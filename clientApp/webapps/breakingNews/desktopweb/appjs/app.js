function addWidgetsForm1() {
    Form1.setDefaultUnit(kony.flex.DP);
    var imgWidget = new kony.ui.Image2({
        "height": "240dp",
        "id": "imgWidget",
        "isVisible": true,
        "left": "178dp",
        "skin": "slImage",
        "src": "imagedrag.png",
        "top": "163dp",
        "width": "260dp",
        "zIndex": 1
    }, {
        "imageScaleMode": constants.IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var btnGetImage = new kony.ui.Button({
        "focusSkin": "defBtnFocus",
        "height": "50dp",
        "id": "btnGetImage",
        "isVisible": true,
        "left": "164dp",
        "onClick": AS_Button_cbbe09bffa5a4efdb12786bcd5ee0c1c,
        "skin": "defBtnNormal",
        "text": "get Image",
        "top": "68dp",
        "width": "300dp",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    Form1.add(imgWidget, btnGetImage);
};

function Form1Globals() {
    Form1 = new kony.ui.Form2({
        "addWidgets": addWidgetsForm1,
        "enabledForIdleTimeout": false,
        "id": "Form1",
        "init": AS_Form_a35f54468796495ebbdefd7b712fb6e2,
        "layoutType": kony.flex.FREE_FORM,
        "needAppMenu": false,
        "skin": "slForm",
        "onBreakpointHandler": onBreakpointHandler,
        "breakpoints": [640, 1024, 1200]
    }, {
        "displayOrientation": constants.FORM_DISPLAY_ORIENTATION_PORTRAIT,
        "layoutType": kony.flex.FREE_FORM,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "retainScrollPosition": false
    });
};
//Type your code here
function FormSubNewsCreatePostShow() {
    FormSubNewsCreate.lstBoxState.masterData = stateNewsListBoxMasterData;
}
function addWidgetsFormSubNewsCreate() {
    FormSubNewsCreate.setDefaultUnit(kony.flex.DP);
    var lblState = new kony.ui.Label({
        "height": "5%",
        "id": "lblState",
        "isVisible": true,
        "left": "30%",
        "skin": "defLabel",
        "text": "Select State",
        "top": "30%",
        "width": "15%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lstBoxState = new kony.ui.ListBox({
        "focusSkin": "defListBoxFocus",
        "height": "5%",
        "id": "lstBoxState",
        "isVisible": true,
        "left": "50%",
        "onSelection": AS_ListBox_jb67fcbba2f3465385d750daecdcafb1,
        "skin": "defListBoxNormal",
        "top": "30%",
        "width": "30%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [3, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "multiSelect": false
    });
    var lblDate = new kony.ui.Label({
        "height": "5%",
        "id": "lblDate",
        "isVisible": true,
        "left": "30%",
        "skin": "defLabel",
        "text": "Select Date",
        "top": "40%",
        "width": "15%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var calBtn = new kony.ui.Calendar({
        "calendarIcon": "calbtn.png",
        "dateComponents": [12, 6, 2019, 0, 0, 0],
        "dateFormat": "dd/MM/yyyy",
        "day": 12,
        "formattedDate": "12/06/2019",
        "height": "5%",
        "hour": 0,
        "id": "calBtn",
        "isVisible": true,
        "left": "50%",
        "minutes": 0,
        "month": 6,
        "seconds": 0,
        "skin": "slCalendar",
        "top": "40%",
        "viewType": constants.CALENDAR_VIEW_TYPE_DEFAULT,
        "width": "30%",
        "year": 2019,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "noOfMonths": 1
    });
    var lblNewsType = new kony.ui.Label({
        "height": "10%",
        "id": "lblNewsType",
        "isVisible": true,
        "left": "30%",
        "skin": "defLabel",
        "text": "Select News Type",
        "top": "50%",
        "width": "15%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lstBoxNewsType = new kony.ui.ListBox({
        "focusSkin": "defListBoxFocus",
        "height": "5%",
        "id": "lstBoxNewsType",
        "isVisible": true,
        "left": "50%",
        "masterData": [
            ["type1", "technolgy"],
            ["type2", "sports"]
        ],
        "selectedKey": "type1",
        "selectedKeyValue": ["type1", "technolgy"],
        "skin": "defListBoxNormal",
        "top": "50%",
        "width": "30%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [3, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "multiSelect": false
    });
    FormSubNewsCreate.add(lblState, lstBoxState, lblDate, calBtn, lblNewsType, lstBoxNewsType);
};

function FormSubNewsCreateGlobals() {
    FormSubNewsCreate = new kony.ui.Form2({
        "addWidgets": addWidgetsFormSubNewsCreate,
        "enabledForIdleTimeout": false,
        "id": "FormSubNewsCreate",
        "layoutType": kony.flex.FREE_FORM,
        "needAppMenu": false,
        "postShow": AS_Form_fba508c029774b02ae682f46b056530c,
        "skin": "slForm",
        "onBreakpointHandler": onBreakpointHandler,
        "breakpoints": [640, 1024, 1200]
    }, {
        "displayOrientation": constants.FORM_DISPLAY_ORIENTATION_PORTRAIT,
        "layoutType": kony.flex.FREE_FORM,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "retainScrollPosition": false
    });
};
// -- SDK File : KonySyncLib.js 
//  --Generated On Mon Jun 03 19:23:30 IST 2019******************* 
//  **************** Start jsonWriter.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
/*
kony.sync.jsonGetType = function(node) {
	sync.log.trace("Entering kony.sync.jsonGetType ");
    if (kony.type(node) === "table") {
        for (var key in node) {
            if ((key === 1)) {
                return 1;
            } else if (key === "1") {
                return 1;
            } else {
                return 2;
            }
        }
        return 1;
    }
    return 0;
};

kony.sync.createJson = function(key, data) {
	sync.log.trace("Entering kony.sync.createJson ");
    kony.sync.jsonBegin();
    kony.sync.jsonWriteKeyValue(key, data);
    kony.sync.jsonEnd();
    return js;
};

kony.sync.jsonWriteKeyValue = function(key, data) {
	sync.log.trace("Entering kony.sync.jsonWriteKeyValue ");
    kony.sync.jsonBeginElement(key);
    kony.sync.jsonWriteValue(data);
};

kony.sync.jsonWriteValue = function(data) {
	sync.log.trace("Entering kony.sync.jsonWriteValue ");
    datatype = kony.sync.jsonGetType(data);
	var len = null;
    if (datatype === 0) {
        kony.sync.jsonString(data);
    } else if (datatype === 1) {
        kony.sync.jsonBeginArray();
        len = kony.sync.jsonwriter_ipairs_length(data);
        var count1 = 0;
		if(!kony.sync.isNullOrUndefined(data)){
			for (var i = 0; i < data.length; i++) {
				var v = data[i];
				count1 = count1 + 1;
				kony.sync.jsonWriteValue(v);
				if ((count1 !== len)) {
					js = js + ",";
				}
			}
		}
        kony.sync.jsonEndArray();
    } else {
        kony.sync.jsonBeginHash();
        len = kony.sync.jsonwriter_pairs_length(data);
        var count2 = 0;
        for (var key in data) {
            var value = data[key];
            count2 = count2 + 1;
            kony.sync.jsonWriteKeyValue(key, value);
            if ((count2 !== len)) {
                js = js + ",";
            }
        }
        kony.sync.jsonEndHash();
    }
};

kony.sync.jsonBegin = function() {
	sync.log.trace("Entering kony.sync.jsonBegin ");
    js = "{";
};

kony.sync.jsonEnd = function() {
	sync.log.trace("Entering kony.sync.jsonEnd ");
    js = js + " }";
};

kony.sync.jsonBeginElement = function(elementName) {
	sync.log.trace("Entering kony.sync.jsonBeginElement ");
    js = js + "\"" + elementName + "\"" + " : ";
};

kony.sync.jsonBeginArray = function() {
	sync.log.trace("Entering kony.sync.jsonBeginArray ");
    js = js + " \[";
};

kony.sync.jsonEndArray = function() {
	sync.log.trace("Entering kony.sync.jsonEndArray ");
    js = js + " \]";
};

kony.sync.jsonBeginHash = function() {
	sync.log.trace("Entering kony.sync.jsonBeginHash ");
    js = js + " \{";
};

kony.sync.jsonEndHash = function() {
	sync.log.trace("Entering kony.sync.jsonEndHash ");
    js = js + " \}";
};

kony.sync.jsonAddValue = function(key, value) {
	sync.log.trace("Entering kony.sync.jsonAddValue ");
    js = js + " \"" + key + "\" : " + "\"" + value + "\"";
};

kony.sync.jsonString = function(value) {
	sync.log.trace("Entering kony.sync.jsonString ");
    if ((value === "null")) {
        js = js + "null";
    } else {
        js = js + "\"" + value + "\"";
    }
};

kony.sync.jsonwriter_pairs_length = function(tab) {
	sync.log.trace("Entering kony.sync.jsonwriter_pairs_length ");
    var count = 0;
    if (!kony.sync.isNullOrUndefined(tab)) {
        for (var key in tab) {
            count = count + 1;
        }
    }
    return count;
};

kony.sync.jsonwriter_ipairs_length = function(tab) {
	sync.log.trace("Entering kony.sync.jsonwriter_ipairs_length ");
    var count = 0;
    if(!kony.sync.isNullOrUndefined(tab)){
        for (var key = 0; key < tab.length; key++) {
            count = count + 1;
        }
    }
    return count;
};
*/
//  **************** End jsonWriter.js*******************
//  **************** Start KonySyncAPI.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
// Device Auto Registration and Validation Starts here --
sync.startSession = function(config) {
    sync.log.trace("Entering sync.startSession ");
    if (kony.sync.validateSyncConfigParams("startSession", config) === false) {
        return;
    }
    if (kony.sync.preProcessSyncConfig("startSession", config, config[kony.sync.onSyncError]) === false) {
        return;
    }
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncStart], kony.sync.currentSyncReturnParams);
    var registerSuccess = true;
    var alreadyRegistered = false;
    var isError = false;
    //assign the currentSyncBinaryStats to lastSyncBinaryStats.
    kony.sync.reinitializeBinaryStats();

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.syncConfigurationColumnDeviceIDName]);
        kony.sync.qb_from(query, kony.sync.syncConfigurationTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params, kony.sync.currentSyncConfigParams[kony.sync.onSyncError]);
        if (resultSet === false) {
            registerSuccess = false;
            isError = true;
            return;
        }
        if (resultSet.rows.length === 0) {
            isError = true;
            return;
        }
        var record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        sync.log.debug("Device Record: ", record);
        sync.log.debug("Device ID: ", record.DeviceID);
        if (record.DeviceID !== kony.sync.getDeviceID()) {
            kony.sync.konyRegisterDevice(registerDeviceCallback);
            sync.log.info("Registering Device...");
        } else {
            alreadyRegistered = true;
            sync.log.info("Device already registered");
        }
    }

    function registerDeviceCallback(serverResponse) {
        sync.log.trace("Entering registerDeviceCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                sync.log.error("Register Device Response : ", serverResponse);
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                    kony.sync.stopSyncSession();
                    return;
                }
                kony.sync.isSessionInProgress = false;
            } else {
                sync.log.error("Register Device Response : ", serverResponse);
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                    kony.sync.stopSyncSession();
                    return;
                }
                kony.sync.isSessionInProgress = false;
            }
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            registerSuccess = false;
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            try {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
            } catch (e) {
                sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
            }
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                kony.sync.stopSyncSession();
                return;
            }
            return;
        }
        if ((serverResponse.d.error === "true")) {
            sync.log.error("Register Device Response : ", serverResponse);
            try {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
            } catch (e) {
                sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync error callback", e);
            }
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped after device registration failed in function registerDeviceCallback");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        }
        sync.log.debug("Register Device Response : ", serverResponse);
        var connection2 = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onSyncError], "Load device id");
        if (connection2 !== null) {
            kony.sync.startTransaction(connection2, single_device_register_callback, single_transaction_success_callback, single_transaction_error_callback, "Load device id");
        }

        function single_device_register_callback(tx) {
            sync.log.trace("Entering single_device_register_callback");
            kony.sync.instanceId = serverResponse.d.__registerdevice.instanceID;
            var insertTab = {};
            insertTab[kony.sync.syncConfigurationColumnInstanceIDName] = kony.sync.instanceId;
            insertTab[kony.sync.syncConfigurationColumnDeviceIDName] = kony.sync.getDeviceID();
            var wcs = {};
            kony.table.insert(wcs, {
                key: kony.sync.syncConfigurationColumnDeviceIDName,
                value: ""
            });
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, kony.sync.syncConfigurationTableName);
            kony.sync.qb_set(query, insertTab);
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
            alreadyRegistered = true;
            sync.log.info("Register Device success");
        }
    }

    function single_transaction_error_callback() {
        sync.log.trace("Entering single_transaction_error_callback");
        sync.log.error("Register Device failed");
        //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getSyncRegisterationFailed());
        kony.sync.isSessionInProgress = false;
        kony.sync.httprequestsinglesession = false;
        kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onSyncError]);
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (registerSuccess && alreadyRegistered && !isError) {
            //Check if schema upgrade is pending
            if (kony.sync.schemaUpgradeNeeded) {
                kony.sync.upgradeSchema(kony.sync.syncStartSession);
            } else {
                kony.sync.isDownloadPendingForSchemaUpgrade(isDownloadPendingForSchemaUpgradeCallback);
            }
        } else if (isError) {
            sync.log.fatal("SynConfigTable is empty. There seems to be problem in sync.init");
            kony.sync.getErrorTable(kony.sync.errorCodeMetatableError, kony.sync.getErrorMessage(kony.sync.errorCodeMetatableError), null);
        }
    }

    function isDownloadPendingForSchemaUpgradeCallback(isError, errorObject, pending) {
        sync.log.trace("Entering isDownloadPendingForSchemaUpgradeCallback");
        if (isError) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], errorObject);
        } else {
            if (pending) {
                kony.sync.omitUpload = true; //only download
                kony.sync.schemaUpgradeDownloadPending = true;
            }
            kony.sync.syncStartSession();
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onSyncError], "Device Registration");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Device Registration");
    }
};
kony.sync.syncStartSession = function() {
    sync.log.trace("Entering kony.sync.syncStartSession ");
    sync.log.info("Calling syncStartSession...");
    kony.sync.isErrorInAnyScope = false;
    kony.sync.syncErrorMessage = {};
    kony.sync.validateScopeSession();
};
kony.sync.validateScopeSession = function(abortSync, syncErrorObject) {
    sync.log.trace("Entering kony.sync.validateScopeSession ");
    //If sync is aborted not because of scope issues
    if (abortSync === true) {
        sync.log.trace("kony.sync.validateScopeSession->abortSync");
        kony.sync.isSessionInProgress = false;
        kony.sync.httprequestsinglesession = false;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], syncErrorObject);
        return;
    }
    kony.sync.resetscopesessionglobals(callback);

    function callback(isSyncComplete) {
        sync.log.trace("Entering callback");
        var isError = false;
        if (isSyncComplete === true) {
            sync.log.trace("is Sync Complete true...");
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined") {
                sync.log.trace("notifying the on demand binary thread. after sync start");
                binary.util.notifyToPrepareJobs();
            }
            //var currentSyncConfig = JSON.stringify(kony.sync.currentSyncConfigParams);
            //store the current sync config so that it can be used later.
            //kony.store.setItem(kony.sync.currentSyncConfigKey, currentSyncConfig);
            //sync.log.trace("resetScopeSessionGlobals callback - "+currentSyncConfig);
            if (kony.sync.forceUpload === true) {
                kony.sync.forceUpload = false;
                kony.sync.omitDownload = false;
                kony.sync.validateScopeSession(true, kony.sync.schemaUpgradeErrorObject);
                return;
            }
            if (kony.sync.forceUploadUpgrade === true) {
                kony.sync.forceUploadUpgrade = false;
                kony.sync.omitDownload = false;
                kony.sync.schemaUpgradeErrorObject();
                return;
            }
            if (!kony.sync.isErrorInAnyScope) {
                if (!kony.sync.performOnlySchemaUpgrade) {
                    //Continue upgrade after upload
                    /*				if(kony.sync.schemaUpgradeNeeded){
                    					kony.sync.upgradeSchema(kony.sync.syncStartSession);
                    					return;
                    				}*/
                    //start normal sync process after downloading changes for schema upgrade
                    if (kony.sync.schemaUpgradeDownloadPending) {
                        kony.sync.schemaUpgradeDownloadPending = false;
                        kony.sync.omitUpload = false;
                        kony.sync.omitDownload = false;
                        kony.sync.resetsyncsessionglobals();
                        kony.sync.syncStartSession();
                        return;
                    }
                }
                kony.sync.omitUpload = false;
                kony.sync.omitDownload = false;
                kony.sync.isSessionInProgress = false;
                kony.sync.performOnlySchemaUpgrade = false;
                sync.log.trace("kony.sync.validateScopeSession->calling onSyncSuccess function");
                kony.sync.schemaUpgradeDownloadPending = false;
                while (kony.sync.pendingBinaryDownloadJobs.length !== 0) {
                    var pendingBinaryJob = kony.sync.pendingBinaryDownloadJobs.pop();
                    kony.sync.getBinary(kony.sync.getDBName(), pendingBinaryJob.tableName, pendingBinaryJob.binaryColumn, pendingBinaryJob.primaryKeyTable, null, function(response) {
                        sync.log.trace("kony.sync.validateScopeSession .. binarySuccessCallback  ", response);
                        kony.sync.incrementCompletedJobs(true);
                        kony.sync.invokeBinaryNotifiers(true);
                    }, function(error) {
                        sync.log.trace("kony.sync.validateScopeSession .. binaryErrorCallback  ", error);
                        kony.sync.incrementFailedJobs(true);
                        kony.sync.invokeBinaryNotifiers(true);
                    });
                }
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncSuccess], kony.sync.currentSyncReturnParams);
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync errpr callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after sync sucess in function validateScopeSession");
                    kony.sync.stopSyncSession();
                    return;
                }
            } else {
                sync.log.error("kony.sync.validateScopeSession->calling onSyncError function");
                kony.sync.isSessionInProgress = false;
                try {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getErrorTable(kony.sync.errorCodeSyncError, kony.sync.getErrorMessage(kony.sync.errorCodeSyncError), kony.sync.syncErrorMessage));
                } catch (e) {
                    sync.log.error("Unknown error occurred during client callbacks in either stop callback or sync errpr callback", e);
                }
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("sync stopped after sync error in function validateScopeSession");
                    kony.sync.stopSyncSession();
                    return;
                }
            }
            kony.sync.httprequestsinglesession = false;
            return; // Sync Completes here.
        }

        function validateTransaction(tx) {
            sync.log.trace("Entering kony.sync.validateScopeSession->validateTransaction");
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, kony.sync.metaTableName);
            kony.sync.qb_where(query, [{
                key: kony.sync.metaTableScopeColumn,
                value: kony.sync.currentScope[kony.sync.scopeName]
            }, {
                key: kony.sync.metaTableFilterValue,
                value: "no filter"
            }]);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return;
            }
            if (resultSet.rows.length !== 1) {
                isError = true;
                return;
            }
            if (kony.sync.schemaUpgradeDownloadPending) {
                //check if download is pending after schema upgrade for this scope
                var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
                if (rowItem[kony.sync.metaTableSchemaUpgradeSyncTimeColumn] === "0,0") {
                    kony.sync.omitDownload = false; //download for this scope
                } else {
                    kony.sync.omitDownload = true; //this scope has already been downloaded
                }
            }
            kony.sync.currentSyncReturnParams.currentScope = kony.sync.currentScope[kony.sync.scopeName];
        }

        function startScopeSession() {
            sync.log.trace("Entering startScopeSession");
            if (isError === true) {
                errorScopeSession();
                return;
            }
            sync.log.trace("Entering kony.sync.validateScopeSession->startScopeSession");
            kony.sync.deleteMapKey(kony.sync.currentSyncReturnParams, kony.sync.serverDetails);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeStart], kony.sync.currentSyncReturnParams);
            kony.sync.startUpload();
        }

        function errorScopeSession() {
            sync.log.trace("Entering kony.sync.validateScopeSession->errorScopeSession");
            var isbreak = kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onScopeError]);
            if (isbreak === true) {
                kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onSyncError]);
                kony.sync.isSessionInProgress = false;
                kony.sync.httprequestsinglesession = false;
                return;
            }
            kony.sync.validateScopeSession();
        }
        var connection = kony.sync.getConnectionOnly(kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.currentScope[kony.sync.scopeDataSource], errorScopeSession, "validate scope session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, validateTransaction, startScopeSession, errorScopeSession, "validate scope session");
        }
    }
};
kony.sync.startUpload = function() {
    sync.log.trace("Entering kony.sync.startUpload ");
    if (kony.sync.omitUpload) {
        kony.sync.uploadCompleted();
        return;
    }
    if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks])) {
        kony.sync.syncUploadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.uploadCompleted);
    } else {
        var scopename = kony.sync.currentScope[kony.sync.scopeName];
        if (kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename] !== null && kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename] !== undefined && kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename][kony.sync.sessionTaskDoUpload]) {
            kony.sync.syncUploadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.uploadCompleted);
        } else {
            sync.log.info("Skipping Upload for Scope : ", kony.sync.currentScope[kony.sync.scopeName]);
            kony.sync.uploadCompleted();
        }
    }
};
kony.sync.uploadCompleted = function(error, msg) {
    sync.log.trace("Entering kony.sync.uploadCompleted ");
    if (kony.sync.isSyncStopped) {
        sync.log.debug("sync stopped in uploadCompleted");
        kony.sync.stopSyncSession();
        return;
    }
    if (error === true) {
        sync.log.error("Error Occurred during upload : ", msg);
        //if schema change error occurred - app is not latest one
        if (msg.errorCode === kony.sync.servercodes.appVersionNotLatest) {
            kony.sync.onSchemaUpgradeErrorFromServer(msg);
            return;
        }
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeError], msg);
        kony.sync.isErrorInAnyScope = true;
        kony.sync.syncErrorMessage[kony.sync.currentScope[kony.sync.scopeName]] = msg;
        kony.sync.validateScopeSession();
    } else {
        if (kony.sync.omitDownload) { //In case download is force disabled
            kony.sync.validateScopeSession();
            return;
        }
        if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) || kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]])) {
            kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.downloadCompletedCallback);
        } else {
            if (kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]][kony.sync.sessionTaskDoDownload]) {
                kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.downloadCompletedCallback);
            } else {
                sync.log.info("Skipping Download for Scope : ", kony.sync.currentScope[kony.sync.scopeName]);
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeSuccess], kony.sync.currentSyncReturnParams);
                //In case of OTA scope and dodownload is false, the records for corresponding ack's will be deleted
                /*if (kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA){
                	kony.sync.deleteRecordsAfterUpload(deleteRecordsAfterUploadCallback);
                }*/
                if (kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
                    if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                        deleteRecordsAfterUploadCallback(0);
                    } else {
                        kony.sync.updateSyncOrderForScope(deleteRecordsAfterUploadCallback);
                    }
                } else {
                    kony.sync.validateScopeSession();
                }
            }
        }
    }

    function deleteRecordsAfterUploadCallback(code) {
        sync.log.trace("Entering deleteRecordsAfterUploadCallback");
        if (code !== 0) {
            kony.sync.isErrorInAnyScope = true;
            var errObject = null;
            //statement error
            if (code === kony.sync.errorCodeSQLStatement) {
                errObject = kony.sync.errorObject;
            }
            //transaction error
            else {
                errObject = kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null);
            }
            kony.sync.syncErrorMessage[kony.sync.currentScope[kony.sync.scopeName]] = errObject;
            sync.log.error("Error occurred in Deleting Records After Upload : ", errObject);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeError], errObject);
        }
        kony.sync.validateScopeSession();
    }
};
kony.sync.downloadCompletedCallback = function(error, msg) {
    sync.log.trace("Entering kony.sync.downloadCompletedCallback ");
    if (kony.sync.isSyncStopped) {
        sync.log.debug("sync stopped in downloadCompletedCallback");
        kony.sync.stopSyncSession();
        return;
    }
    if (error) {
        sync.log.error("Error occurred during download : ", msg);
        //if schema change error occurred - app is not latest one
        if (msg.errorCode === kony.sync.servercodes.appVersionNotLatest) {
            kony.sync.onSchemaUpgradeErrorFromServer(msg);
            return;
        }
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeError], msg);
        kony.sync.isErrorInAnyScope = true;
        kony.sync.syncErrorMessage[kony.sync.currentScope[kony.sync.scopeName]] = msg;
    } else {
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onScopeSuccess], kony.sync.currentSyncReturnParams);
    }
    kony.sync.validateScopeSession();
};
kony.sync.validateSyncConfigParams = function(opName, config) {
    sync.log.trace("Entering kony.sync.validateSyncConfigParams ");
    if (kony.sync.isNullOrUndefined(config)) {
        kony.sync.alert("Argument type mismatch found for operation:sync." + opName + ". Expected 'config object' Actual 'null or undefined'");
        return false;
    }
    if (typeof(config) !== "object") {
        kony.sync.alert("Argument type mismatch found for operation:sync." + opName + ".  Expected 'config object' Actual '" + typeof(config) + "'");
        return false;
    }
    kony.sync.resetSessionVars();
};
kony.sync.preProcessSyncConfig = function(opName, config, errorcallback, sessionRequired) {
    sync.log.trace("Entering kony.sync.preProcessSyncConfig ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return false;
    }
    if (!kony.sync.scopenameExist(config, errorcallback)) {
        return false;
    }
    if (kony.sync.isReconciliationInProgress) {
        sync.log.warn("Reconciliation Session already in progress...");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeReconcileSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeReconcileSessionInProgress), null));
        return false;
    }
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    config.appVersion = kony.sync.configVersion; //konysyncClientSyncConfig.Version;
    kony.sync.currentSyncConfigParams = config;
    kony.sync.uploadClientContext = {};
    kony.sync.downloadClientContext = {};
    if (sessionRequired !== false) {
        if (kony.sync.isSessionInProgress) {
            sync.log.warn("Sync Session already in progress...");
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeSessionInProgress), null));
            return false;
        }
        kony.sync.isSessionInProgress = true;
    }
    sync.log.debug("Starting sync." + opName + " with Current Config Params : ", config);
    kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey]);
    kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey]);
    kony.sync.resetsyncsessionglobals(opName);
};
kony.sync.scopenameExist = function(config, errorcallback) {
    sync.log.trace("Entering kony.sync.scopenameExist");
    if (!kony.sync.isNullOrUndefined(config[kony.sync.sessionTasks])) {
        for (var key in config[kony.sync.sessionTasks]) {
            if (kony.sync.isNullOrUndefined(kony.sync.scopeDict[key])) {
                sync.log.error("Wrong scopename given in SessionTasks");
                kony.sync.alert("Wrong scopename given in SessionTasks");
                kony.sync.verifyAndCallClosure(errorcallback, {});
                return false;
            }
        }
    }
    if (!kony.sync.isNullOrUndefined(config[kony.sync.removeAfterUpload])) {
        for (var key in config[kony.sync.removeAfterUpload]) {
            if (kony.sync.isNullOrUndefined(kony.sync.scopeDict[key])) {
                sync.log.error("Wrong scopename given in RemoveAfterUpload");
                kony.sync.alert("Wrong scopename given in RemoveAfterUpload");
                kony.sync.verifyAndCallClosure(errorcallback, {});
                return false;
            }
        }
    }
    return true;
};
sync.stopSession = function(callback) {
    sync.log.trace("Entering sync.stop");
    kony.sync.isSessionInProgress = false;
    kony.sync.httprequestsinglesession = false;
    kony.sync.isSyncStopped = true;
    kony.sync.onSyncStop = callback;
};
kony.sync.stopSyncSession = function() {
    sync.log.trace("Entering kony.sync.stopSyncSession ");
    kony.sync.isSyncStopped = false;
    kony.sync.globalIsDownloadStarted = true;
    try {
        kony.sync.verifyAndCallClosure(kony.sync.onSyncStop);
    } catch (e) {
        sync.log.error("Unknown error occurred during stop callback", e);
    }
};
//  **************** End KonySyncAPI.js*******************
//  **************** Start KonySyncBinaryDataManager.js*******************
/**
 * Created by Krishna Nikhil Vedurumudi on 21/09/16.
 */
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.isValidChunkSize = function(chunkSize) {
    if (typeof(chunkSize) !== "number") {
        sync.log.error("chunk size is not a number ");
        return false;
    }
    if (chunkSize <= 0) {
        sync.log.error("chunk size should be a non-negative number ");
        return false;
    }
    return true;
};

function validateBinaryOperationParameters(tableName, columnName) {
    sync.log.trace("Entering validateBinaryOperationParameters");
    var error = null;
    if (kony.sync.isNullOrUndefined(tableName) || !kony.sync.validateTableName(tableName) || typeof(tableName) !== "string") {
        //error...
        sync.log.error("invalid table name sent for binary operation ", tableName);
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidTableName, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidTableName, tableName));
    }
    //validate if the columnName passed is a binary column...
    if (error !== null && (kony.sync.isNullOrUndefined(columnName) || !kony.sync.validateBinaryColumn(tableName, columnName) || typeof(tableName) !== "string")) {
        sync.log.error("invalid column name sent for binary operation ", tableName);
        error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadPolicyNotSupported, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadPolicyNotSupported, tableName + "." + columnName));
    }
    if (!kony.sync.isNullOrUndefined(error)) {
        sync.log.error("Error object", error);
    }
    return error;
}
kony.sync.createDownloadTask = function(dbname, tableName, columnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.createDownloadTask ");
    var error = validateBinaryOperationParameters(tableName, columnName);
    if (error != null) {
        kony.sync.verifyAndCallClosure(errorCallback, error);
        return;
    }
    //if config is null.. create empty object!
    if (kony.sync.isNullOrUndefined(config)) {
        config = {};
    }
    var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tableName);
    //validate whether we get all pks in the pk table.
    primaryKeyTable = kony.sync.validatePkTable(primaryKeyColumns, primaryKeyTable);
    sync.log.trace("after validation pks are " + JSON.stringify(primaryKeyTable));
    if (!kony.sync.isNullOrUndefined(primaryKeyTable)) {
        var downloadConfig = {};
        if (!kony.sync.isNullOrUndefined(config)) {
            sync.log.trace("kony.sync.createDownloadTask - config is passed to the download request ", config);
            if (config.hasOwnProperty("ChunkSize")) {
                var chunkSize = config.ChunkSize;
                if (kony.sync.isValidChunkSize(chunkSize)) {
                    downloadConfig.ChunkSize = config.ChunkSize;
                } else {
                    error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidChunkSize, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidChunkSize, chunkSize));
                    kony.sync.verifyAndCallClosure(errorCallback, error);
                    return;
                }
            }
            if (config.hasOwnProperty("NetworkTimeout")) {
                downloadConfig.NetworkTimeout = config.NetworkTimeout;
            }
        }
        var scopeName = kony.sync.scopes.syncTableScopeDic[tableName];
        downloadConfig.URL = kony.sync.getServerURL();
        downloadConfig.ScopeName = scopeName;
        downloadConfig.ResponseType = "Binary";
        downloadConfig.RequestMethod = "GET";
        downloadConfig.ObjectName = tableName;
        downloadConfig.ClientID = kony.sync.getDeviceID();
        sync.log.trace("kony.sync.createDownloadTask -> clientID is ", downloadConfig.ClientID);
        if (!kony.sync.isNullOrUndefined(kony.sync.sessionMap) && !kony.sync.isNullOrUndefined(kony.sync.sessionMap[kony.sync.konySyncSessionID])) {
            downloadConfig.SessionID = kony.sync.sessionMap[kony.sync.konySyncSessionID];
            sync.log.trace("kony.sync.createDownloadTask -> Session ID is ", downloadConfig.SessionID);
        }
        if (!kony.sync.isMbaasEnabled) {
            kony.sync.isMbaasEnabled = true;
        }
        sync.log.trace("Refreshing claims token");

        function claimsRefreshSuccessCallBack() {
            sync.log.trace("Entering kony.sync.createDownloadTask->claimsRefreshSuccessCallBack ");
            var currentClaimToken = kony.sdk.getCurrentInstance().currentClaimToken;
            if (!(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams)) && kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] != currentClaimToken) {
                kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] = currentClaimToken;
            }
            downloadConfig["X-Kony-Authorization"] = currentClaimToken;
            sync.log.trace("creating download task..!!!!");
            if (typeof(binarydata) !== "undefined") {
                binarydata.createDownloadTask(dbname, tableName, columnName, primaryKeyTable, downloadConfig, successCallback, errorCallback);
            } else {
                sync.log.error("FFI is not configured to use Binary Apis");
                error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
                kony.sync.verifyAndCallClosure(errorCallback, error);
            }
        }

        function claimsRefreshFailureCallBack(res) {
            sync.log.error("kony.sync.createDownloadTask->claimsRefreshFailureCallBack " + JSON.stringify(res));
            kony.sync.verifyAndCallClosure(errorCallback, res);
        }
        //claims token.
        kony.sdk.claimsRefresh(claimsRefreshSuccessCallBack, claimsRefreshFailureCallBack);
    } else {
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tableName));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }
};
kony.sync.startDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.startDownload for downloadID " + downloadID);
    var error;
    if (downloadID === null || typeof(downloadID) != "string") {
        sync.log.trace("kony.sync.startDownload -> downloadID is invalid " + downloadID);
        error = kony.sync.getErrorTable(kony.sync.errorCodeNullDownloadID, kony.sync.getErrorMessage(kony.sync.errorCodeNullDownloadID));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        if (typeof(binarydata) !== "undefined") {
            binarydata.startDownload(downloadID, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.pauseDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.pauseDownload for downloadID " + downloadID);
    var error;
    if (downloadID === null || typeof(downloadID) != "string") {
        sync.log.trace("kony.sync.pauseDownload -> downloadID is invalid " + downloadID);
        error = kony.sync.getErrorTable(kony.sync.errorCodeNullDownloadID, kony.sync.getErrorMessage(kony.sync.errorCodeNullDownloadID));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        if (typeof(binarydata) !== "undefined") {
            binarydata.pauseDownload(downloadID, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.resumeDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.resumeDownload for downloadID " + downloadID);
    var error;
    if (downloadID === null || typeof(downloadID) != "string") {
        sync.log.trace("kony.sync.resumeDownload -> downloadID is invalid " + downloadID);
        error = kony.sync.getErrorTable(kony.sync.errorCodeNullDownloadID, kony.sync.getErrorMessage(kony.sync.errorCodeNullDownloadID));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        if (typeof(binarydata) !== "undefined") {
            binarydata.resumeDownload(downloadID, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.getBinaryDataFilePath = function(databaseName, tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.getBinaryDataFilePath ");
    //perform validations..
    var error = validateBinaryOperationParameters(tableName, binaryColumnName);
    if (error !== null) {
        kony.sync.verifyAndCallClosure(errorCallback, error);
        return;
    }
    //validate primary keys.
    var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tableName);
    //validate whether we get all pks in the pk table.
    primaryKeyTable = kony.sync.validatePkTable(primaryKeyColumns, primaryKeyTable);
    sync.log.trace("after validation pks are " + JSON.stringify(primaryKeyTable));
    if (!kony.sync.isNullOrUndefined(primaryKeyTable)) {
        if (typeof(binarydata) !== "undefined") {
            binarydata.getBinaryDataFilePath(databaseName, tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    } else {
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tableName));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }
};
kony.sync.getBinary = function(dbname, tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.getBinary ");

    function createTaskSuccess(downloadResult) {
        sync.log.trace("kony.sync.getBinary .. create task success with downloadID ", downloadResult);
        kony.sync.startDownload(downloadResult.BlobID, successCallback, errorCallback);
    }

    function createTaskFailure(error) {
        sync.log.trace("kony.sync.getBinary.. error in create task ", error);
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }

    function getBinaryFileSuccess(filePath) {
        sync.log.trace("kony.sync.getBinary - filePath received..", filePath);
        kony.sync.verifyAndCallClosure(successCallback, filePath);
    }

    function getBinaryFileFailure(error) {
        if (!kony.sync.isNullOrUndefined(error)) {
            if (error.errorCode == 5001) {
                kony.sync.createDownloadTask(dbname, tableName, binaryColumnName, primaryKeyTable, config, createTaskSuccess, createTaskFailure);
            } else {
                sync.log.error("kony.sync.getBinary - error received from getFilePath ", error);
                kony.sync.verifyAndCallClosure(errorCallback, error);
            }
        } else {
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
    sync.log.trace("kony.sync.getBinary.. checking if file exists..");
    kony.sync.getBinaryDataFilePath(dbname, tableName, binaryColumnName, primaryKeyTable, getBinaryFileSuccess, getBinaryFileFailure);
};
kony.sync.deleteBinaryObject = function(dbname, tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.deleteBinaryObject ");
    //perform validations..
    var error = validateBinaryOperationParameters(tableName, binaryColumnName);
    if (error !== null) {
        kony.sync.verifyAndCallClosure(errorCallback, error);
        return;
    }
    //validate primary keys.
    var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tableName);
    //validate whether we get all pks in the pk table.
    primaryKeyTable = kony.sync.validatePkTable(primaryKeyColumns, primaryKeyTable);
    sync.log.trace("after validation pks are " + JSON.stringify(primaryKeyTable));
    if (kony.sync.isNullOrUndefined(options)) {
        options = {};
    }
    if (!kony.sync.isNullOrUndefined(primaryKeyTable)) {
        if (typeof(binarydata) !== "undefined") {
            binarydata.deleteBinaryObject(dbname, tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback);
        } else {
            sync.log.error("FFI is not configured to use Binary Apis");
            error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDataFFINotConfigured, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDataFFINotConfigured));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
//  **************** End KonySyncBinaryDataManager.js*******************
//  **************** Start KonySyncBlobConstants.js*******************
/**
 * Created by KH9093 on 21-09-2015.
 */
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.BlobType = {
    BASE64: 1,
    FILE: 2
};
kony.sync.currentSyncStats = {};
kony.sync.lastSyncStats = {};
//defining states for blob manager.
kony.sync.blobManager.INSERT_PROCESSING = 1;
kony.sync.blobManager.INSERT_FAILED = 2;
kony.sync.blobManager.UPDATE_PROCESSING = 11;
kony.sync.blobManager.UPDATE_FAILED = 12;
kony.sync.blobManager.DELETE_PROCESSING = 21;
kony.sync.blobManager.DELETE_FAILED = 22;
kony.sync.blobManager.FILE_DOESNOT_EXIST = 31;
kony.sync.blobManager.DOWNLOAD_ACCEPTED = 61;
kony.sync.blobManager.DOWNLOAD_FAILED = 63;
kony.sync.blobManager.DOWNLOAD_IN_PROGRESS = 64;
kony.sync.blobManager.UPLOAD_ACCEPTED = 71;
kony.sync.blobManager.UPLOAD_FAILED = 73;
kony.sync.blobManager.UPLOAD_IN_PROGRESS = 74;
kony.sync.blobManager.NO_OPERATION = 50;
//Binary Chunking states.
kony.sync.blobManager.DOWNLOAD_NOT_STARTED = 101;
kony.sync.blobManager.DOWNLOAD_STARTED = 102;
kony.sync.blobManager.DOWNLOAD_FAIL = 103;
kony.sync.blobManager.DOWNLOAD_PAUSED = 104;
//Delete binary object
kony.sync.blobManager.DELETE_ACCEPTED = 201;
kony.sync.blobManager.DELETE_IN_PROGRESS = 202;
kony.sync.blobManager.ONDEMAND_FETCH_LIMIT = 10;
kony.sync.blobManager.ONDEMAND_FETCH_OFFSET = 0;
//defining state messages..
kony.sync.blobManager.states = {};
kony.sync.blobManager.states[kony.sync.blobManager.INSERT_PROCESSING] = "Insert Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.INSERT_FAILED] = "Insert Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.UPDATE_PROCESSING] = "Update Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.UPDATE_FAILED] = "Update Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_PROCESSING] = "Delete Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_FAILED] = "Delete Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.FILE_DOESNOT_EXIST] = "Blob File doesn't exist.";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_ACCEPTED] = "Download request added to the queue";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_FAILED] = "Download Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_IN_PROGRESS] = "Download Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.NO_OPERATION] = "Blob record available";
kony.sync.blobManager.states[kony.sync.blobManager.UPLOAD_ACCEPTED] = "Upload Request added to the queue";
kony.sync.blobManager.states[kony.sync.blobManager.UPLOAD_IN_PROGRESS] = "Upload Operation In progress";
kony.sync.blobManager.states[kony.sync.blobManager.UPLOAD_FAILED] = "Upload Operation Failed";
//binary chunking state messages
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_NOT_STARTED] = "Download request added to the queue";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_FAIL] = "Download Operation Failed";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_STARTED] = "Download Operation in Process";
kony.sync.blobManager.states[kony.sync.blobManager.DOWNLOAD_PAUSED] = "Download request is paused";
//Delete binary states
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_ACCEPTED] = "Binary object is marked for delete..";
kony.sync.blobManager.states[kony.sync.blobManager.DELETE_IN_PROGRESS] = "Binary object delete at backend data source is in progress";
//  **************** End KonySyncBlobConstants.js*******************
//  **************** Start KonySyncBlobStoreManager.js*******************
//  **************** Start BlobStoreManager.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
/*columns of the BlobStoreManager table are ---
 id, localPath, type, state, status, size, lastUpdatedTimeStamp
 */
kony.sync.blobManager.tableName = "tableName";
kony.sync.blobManager.columnName = "columnName";
kony.sync.blobManager.localPath = "localPath";
kony.sync.blobManager.id = "id";
kony.sync.blobManager.type = "type";
kony.sync.blobManager.state = "state";
kony.sync.blobManager.status = "status";
kony.sync.blobManager.size = "size";
kony.sync.blobManager.lastUpdatedTimeStamp = "lastUpdatedTimeStamp";
kony.sync.blobManager.retry = 'retry';
var dbname = kony.sync.syncConfigurationDBName;
var tbname = "konysyncBLOBSTOREMANAGER";
var resultset = null;
/**
 * Method used to update the blob store manager record for given blobid.
 * @param tx - transaction id
 * @param blobid - id of the blob store manager row.
 * @param valuesTable - values that are updated in the record.
 * @param errorCallback - error callback in case of failures.
 * @returns {*}
 */
kony.sync.blobManager.updateBlobManager = function(tx, blobid, valuesTable, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.updateBlobManager ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_set(query, valuesTable);
    kony.sync.qb_where(query, [{
        key: kony.sync.blobManager.id,
        value: blobid
    }]);
    kony.sync.qb_update(query, kony.sync.blobStoreManagerTable);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    return resultset;
};
/**
 * This method is used to insert a base64 in the konysyncBLOBSTOREMANAGER table.
 * @param base64 the base64 value which has to be inserted in the blob store
 */
kony.sync.blobManager.saveBlob = function(tx, tableName, columnName, base64, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.saveBlob ");
    if (!kony.sync.isNullOrUndefined(base64) && base64.trim().length > 0) {
        var query = kony.sync.qb_createQuery();
        var error;
        kony.sync.qb_set(query, {
            localPath: "",
            size: base64.length,
            status: 100,
            state: kony.sync.blobManager.INSERT_PROCESSING,
            type: kony.sync.blobTypeBase64,
            tableName: tableName,
            columnName: columnName
        });
        kony.sync.qb_insert(query, kony.sync.blobStoreManagerTable);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
        if (resultset === null || resultset === false) return null;
        var blobId = resultset.insertId;
        var blobFileName = binary.util.saveBase64File("" + blobId, base64);
        sync.log.trace("blob filepath returned is " + blobFileName);
        //if file creation is successful.. insert the file path to the blobstoremanager.
        var valuesTable = {};
        if (blobFileName) {
            valuesTable[kony.sync.blobManager.localPath] = blobFileName;
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
            valuesTable[kony.sync.blobManager.status] = 100;
            kony.sync.blobManager.updateBlobManager(tx, blobId, valuesTable, errorCallback);
        } else {
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.INSERT_FAILED;
            valuesTable[kony.sync.blobManager.status] = 0;
            kony.sync.blobManager.updateBlobManager(tx, blobId, valuesTable, errorCallback);
            error = kony.sync.getErrorTable(kony.sync.errorCodeBlobFileNotCreated, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileNotCreated));
            kony.sync.verifyAndCallClosure(errorCallback, error);
            return;
        }
        return blobId;
    } else {
        error = kony.sync.getErrorTable(kony.sync.errorCodeEmptyOrNullBase64, kony.sync.getErrorMessage(kony.sync.errorCodeEmptyOrNullBase64));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    }
};
/**
 * This method is used to delete records from the konysyncBLOBSTOREMANAGER table.
 * @param id array which contains the list of valid ids whose records has to be deleted
 * @return true if deletion is successful else false
 */
kony.sync.blobManager.deleteBlob = function(tx, blobid, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.deleteBlob ");
    sync.log.info("deleteBlobFromTable..");
    if (blobid === undefined || typeof(blobid) !== "number") {
        var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
        //state, status, localPath
        //delete the record only if it is in valid state.
        var state = null;
        if (!kony.sync.isNullOrUndefined(blobMeta)) {
            state = blobMeta[kony.sync.blobManager.state];
        }
        var possibleStates = [kony.sync.blobManager.INSERT_FAILED, kony.sync.blobManager.DELETE_FAILED,
            kony.sync.blobManager.FILE_DOESNOT_EXIST,
            kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPDATE_FAILED,
            kony.sync.blobManager.DOWNLOAD_FAILED, kony.sync.blobManager.DOWNLOAD_IN_PROGRESS,
            kony.sync.blobManager.DOWNLOAD_ACCEPTED,
            kony.sync.blobManager.UPLOAD_IN_PROGRESS,
            kony.sync.blobManager.DELETE_ACCEPTED,
            kony.sync.blobManager.DOWNLOAD_FAIL,
            kony.sync.blobManager.DOWNLOAD_PAUSED,
            kony.sync.blobManager.DOWNLOAD_NOT_STARTED
        ];
        if (!kony.sync.isNullOrUndefined(state) && possibleStates.indexOf(state) !== -1) {
            var valuesTable = {};
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DELETE_PROCESSING;
            kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            var deleteFile = binary.util.deleteBlobFile(blobMeta[kony.sync.blobManager.localPath]);
            //TODO - add check to deletefile status..
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, kony.sync.blobStoreManagerTable);
            var wcs = [{
                key: kony.sync.blobManager.id,
                value: blobid,
                comptype: 'OR'
            }];
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            resultset = kony.db.executeSql(tx, sql, params, errorCallback);
            if (resultset === null || resultset === false) {
                valuesTable = {};
                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DELETE_FAILED;
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback)
            }
            return resultset;
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidStateForDelete, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidStateForDelete, kony.sync.blobManager.states[state]));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
/**
 * This method is used to update the binary data referred by id.
 * @param id unique id of the base64 value.
 * @param base64 is the binary value to be updated.
 */
kony.sync.blobManager.updateBlob = function(tx, blobid, base64, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.updateBlob ");
    var error;
    if (blobid === undefined || typeof(blobid) !== "number") {
        error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
        kony.sync.verifyAndCallClosure(errorCallback, error);
    } else {
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
        //state, status, localPath
        var state = null;
        if (!kony.sync.isNullOrUndefined(blobMeta)) {
            state = blobMeta[kony.sync.blobManager.state];
        }
        var possibleStates = [kony.sync.blobManager.INSERT_FAILED, kony.sync.blobManager.FILE_DOESNOT_EXIST, kony.sync.blobManager.DELETE_FAILED,
            kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPDATE_FAILED, kony.sync.blobManager.DOWNLOAD_FAILED,
            kony.sync.blobManager.DOWNLOAD_ACCEPTED, kony.sync.blobManager.DOWNLOAD_IN_PROGRESS
        ];
        if (!kony.sync.isNullOrUndefined(state) && possibleStates.indexOf(state) !== -1) {
            var valuesTable = {};
            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPDATE_PROCESSING;
            kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            var isBlobSaved = binary.util.saveBase64File("" + blobid, base64);
            if (isBlobSaved !== null) {
                valuesTable = {};
                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            } else {
                valuesTable = {};
                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPDATE_FAILED;
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
            }
            return blobid;
        } else {
            error = kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidStateForUpdate, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidStateForUpdate, kony.sync.blobManager.states[state]));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
/**
 * This is a utility method used to insert inline policy blobvalues to konysyncBLOBSTOREMANAGER
 * and return corresponding blob ids
 * @param tx transaction id
 * @param tbname tablename
 * @param values table columns
 * @return object containing columns and their blob indices
 */
kony.sync.blobstore_insert = function(tx, tbname, values, errorCallback) {
    sync.log.trace("Entering kony.sync.blobstore_insert ");
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        //TODO - call error callback with apt error.
        return;
    }
    var blobstoreindices = {};
    var j;
    var sql;
    var binaryColumnsList = Object.keys(values);
    var binaryColumnRefs = [];
    for (j = 0; j < binaryColumnsList.length; j++) {
        binaryColumnRefs[j] = kony.sync.binaryMetaColumnPrefix + binaryColumnsList[j]
    }
    for (j = 0; j < binaryColumnsList.length; j++) {
        if (!kony.sync.isNullOrUndefined(values[binaryColumnsList[j]])) {
            var blobIndex = kony.sync.blobManager.saveBlob(tx, tbname, binaryColumnsList[j], values[binaryColumnsList[j]], errorCallback);
            if (!kony.sync.isNullOrUndefined(blobIndex)) {
                blobstoreindices[binaryColumnRefs[j]] = blobIndex;
            }
        }
    }
    return blobstoreindices;
};
/**
 * This is a utility method used to update blobvalues to konysyncBLOBSTOREMANAGER and return
 * corresponding blobids
 * @param tx - transaction id
 * @param tbname - tablename
 * @param values - table columns
 * @param wc - whereclause
 * @param isBatch - indicates whether utility function is used for batch or not
 * @return object containing columns and their blob indices
 */
kony.sync.blobstore_update = function(tx, tbname, values, wc, isBatch, errorCallback) {
    sync.log.trace("Entering kony.sync.blobstore_update ");
    var isUpdateSuccessful = true;
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        //TODO - call error callback with apt error.
        return;
    }
    var blobstoreindices = {};
    var query_compile;
    var sql;
    var binaryColumnsList = Object.keys(values);
    var binaryColumnRefs = [];
    for (var i = 0; i < binaryColumnsList.length; i++) {
        binaryColumnRefs[i] = kony.sync.binaryMetaColumnPrefix + binaryColumnsList[i]
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, binaryColumnRefs);
    kony.sync.qb_from(query, tbname);
    if (isBatch === true) {
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0] + " " + wc;
    } else {
        kony.sync.qb_where(query, wc);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
    }
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset !== false && resultset !== null) {
        if (resultset.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            for (var j = 0; j < binaryColumnRefs.length; j++) {
                var blobIndex;
                if (!kony.sync.isNullOrUndefined(rowItem[binaryColumnRefs[j]])) {
                    if (rowItem[binaryColumnRefs[j]] !== "NULL") blobIndex = kony.sync.blobManager.updateBlob(tx, rowItem[binaryColumnRefs[j]], values[binaryColumnsList[j]], errorCallback);
                    else {
                        blobIndex = kony.sync.blobManager.saveBlob(tx, tbname, binaryColumnsList[j], values[binaryColumnsList[j]], errorCallback);
                    }
                }
                if (!kony.sync.isNullOrUndefined(blobIndex)) {
                    blobstoreindices[binaryColumnRefs[j]] = blobIndex;
                }
            }
        }
        return blobstoreindices;
    }
};
/**
 * This is a utility method used to delete blob from konysyncBLOBSTOREMANAGER
 * @param tx transaction id
 * @param tbname tablename
 * @param isBatch indicates whether utility function is used for batch or not
 * @return
 */
kony.sync.blobstore_delete = function(tx, tbname, wc, isBatch, errorCallback) {
    sync.log.trace("Entering kony.sync.blobstore_delete ");
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        return true;
    }
    var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
    var isDeleteSuccessful = true;
    var query_compile = null;
    var sql = null;
    var binaryColumnRefs = [];
    for (var i = 0; i < binaryColumns.length; i++) {
        binaryColumnRefs[i] = kony.sync.binaryMetaColumnPrefix + binaryColumns[i];
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, binaryColumnRefs);
    kony.sync.qb_from(query, tbname);
    if (isBatch === true) {
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0] + " " + wc;
    } else {
        kony.sync.qb_where(query, wc);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
    }
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset !== false && resultset !== null) {
        if (resultset.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            for (var i = 0; i < binaryColumnRefs.length; i++) {
                var blobIndex;
                if (!kony.sync.isNullOrUndefined(rowItem[binaryColumnRefs[i]])) {
                    blobIndex = rowItem[binaryColumnRefs[i]];
                    if (blobIndex !== "NULL") {
                        var results = kony.sync.blobManager.deleteBlob(tx, blobIndex, errorCallback);
                        if (results === false || results === null) {
                            isDeleteSuccessful = false;
                        }
                    }
                }
            }
        }
        return isDeleteSuccessful;
    }
};
/**
 * Success callback called after successful completion of download.
 * @param response - contains the response from download manager. (blobid, value file/base64).
 */
//expected fields in response.
//blobid,requestState,statusCode, errorResponse
//filePath 
kony.sync.blobManager.onDemandUniversalSuccessCallback = function(response) {
    sync.log.trace(" Entered into kony.sync.blobManager.onDemandUniversalSuccessCallback " + JSON.stringify(response));
    var isDownload = true;
    if (response.hasOwnProperty("blobid")) {
        var successResponse = {};
        var blobId = parseInt(response.blobid);
        //give the response to the user.
        function invokeCallbacks(updateResult, filePath) {
            sync.log.trace("Entering invokeCallbacks");
            if (isDownload) {
                if (updateResult) {
                    var blobType = kony.sync.blobManager.getRegisteredBlobType(blobId);
                    //increment total number of download jobs completed..
                    kony.sync.incrementCompletedJobs(true);
                    if (!kony.sync.isNullOrUndefined(blobType)) {
                        successResponse.pkTable = kony.sync.blobManager.getRegisteredPkTable(blobId);
                        if (blobType === kony.sync.BlobType.FILE) {
                            var decodedFilePath = binary.util.decodeBase64File(filePath);
                            successResponse.filePath = decodedFilePath;
                        } else {
                            var base64String = binary.util.getBase64FromFiles([filePath]);
                            successResponse.base64 = base64String[0];
                        }
                        var successCallback = kony.sync.blobManager.getRegisteredSuccessCallback(blobId);
                        //clean up binarynotifier map..
                        if (!kony.sync.isNullOrUndefined(successCallback)) {
                            kony.sync.verifyAndCallClosure(successCallback, successResponse);
                        }
                    } else {
                        //log download completed..
                        sync.log.info("Download completed for blob id " + blobId);
                    }
                } else {
                    var errorCallback = kony.sync.blobManager.getRegisteredErrorCallback(blobId);
                    //increment total number of download jobs failed..
                    kony.sync.incrementFailedJobs(true);
                    if (!kony.sync.isNullOrUndefined(errorCallback)) {
                        //update status failed after download.
                        var error = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDownloadFailed, kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDownloadFailed));
                        kony.sync.verifyAndCallClosure(errorCallback, error);
                    }
                }
            } else {
                //increment upload completed jobs..
                kony.sync.incrementCompletedJobs(false);
                if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && kony.sync.isValidFunctionType(kony.sync.currentSyncConfigParams["uploadBinarySuccessCallback"])) {
                    var uploadSuccessCallback = kony.sync.currentSyncConfigParams["uploadBinarySuccessCallback"];
                    kony.sync.verifyAndCallClosure(uploadSuccessCallback, response);
                } else {
                    sync.log.info("Upload completed..");
                }
            }
            //invoke the notifier..
            kony.sync.invokeBinaryNotifiers(isDownload);
        }
        //check the type of request.
        var reqState = parseInt(response[kony.sync.requestState]);
        if (reqState != kony.sync.blobManager.DOWNLOAD_IN_PROGRESS) {
            isDownload = false;
        }
        kony.sync.blobManager.updateStatusAfterOndemandJob(response, true, isDownload, invokeCallbacks);
    }
};
/**
 * Failure callback after error in download.
 * @param response - contains the error object and the corresponding blob id.
 */
kony.sync.blobManager.onDemandUniversalErrorCallback = function(response) {
    sync.log.error("universal error callback " + JSON.stringify(response));
    var isDownload = true;
    if (response.hasOwnProperty("blobid")) {
        function invokeCallbacks(updateResult, filePath) {
            sync.log.trace("Entering invokeCallbacks");
            if (isDownload) {
                //increment total number of download jobs failed..
                kony.sync.incrementFailedJobs(true);
                sync.log.trace("invoking error callback for the download request..");
                var errorCallback = kony.sync.blobManager.getRegisteredErrorCallback(response.blobid);
                if (!kony.sync.isNullOrUndefined(errorCallback)) {
                    //create an error object with appropriate details..
                    var errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeBinaryDownloadFailed) + " status " + response.statusCode + " " + response.errorMessage;
                    var errorObject = kony.sync.getErrorTable(kony.sync.errorCodeBinaryDownloadFailed, errorMessage);
                    kony.sync.verifyAndCallClosure(errorCallback, errorObject);
                }
            } else {
                //increment total number of download jobs failed..
                kony.sync.incrementFailedJobs(false);
                sync.log.trace("invoking error callback for the upload request..");
                if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && kony.sync.isValidFunctionType(kony.sync.currentSyncConfigParams["uploadBinaryErrorCallback"])) {
                    var uploadErrorCallback = kony.sync.currentSyncConfigParams["uploadBinaryErrorCallback"];
                    //create an error object with appropriate details..
                    var errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeBinaryUploadFailed) + " status " + response.statusCode + " " + response.errorMessage;
                    var errorObject = kony.sync.getErrorTable(kony.sync.errorCodeBinaryUploadFailed, errorMessage);
                    kony.sync.verifyAndCallClosure(uploadErrorCallback, errorObject);
                } else {
                    //upload failed.
                    sync.log.error("sync binary upload failed for blob id " + response.blobid);
                }
            }
            //invoke the notifier..
            kony.sync.invokeBinaryNotifiers(isDownload);
        }
        //using the request state find out if the request is for upload/ download.
        if (parseInt(response[kony.sync.requestState]) === kony.sync.blobManager.UPLOAD_IN_PROGRESS) {
            isDownload = false;
        }
        kony.sync.blobManager.updateStatusAfterOndemandJob(response, false, isDownload, invokeCallbacks);
    }
};
/** Method used to register success and error callbacks for given blob download.
 * @param blobid - blobid which is under download
 * @param pks - primary key values which uniquely identify the blob in parent table
 * @param successCallback - success callback to be called after successful download
 * @param errorCallback - error callback to be called in case of failure.
 */
kony.sync.blobManager.registerCallbacks = function(blobid, pks, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.registerCallbacks ");
    kony.sync.blobManager.binaryNotifierMap[blobid] = [pks, blobType, successCallback, errorCallback];
};
/**
 * Method returns the registered Success callback for the given blobid download request.
 * @param blobid - blobid which is under download.
 * @returns {*}
 */
kony.sync.blobManager.getRegisteredSuccessCallback = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredSuccessCallback ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][2];
    } else {
        return null;
    }
};
/**
 * Method returns the registered error callback for the given blobid download request.
 * @param blobid - blobid which is under download.
 * @returns {*}
 */
kony.sync.blobManager.getRegisteredErrorCallback = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredErrorCallback ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][3];
    } else {
        return null;
    }
};
/**
 * Method returns the registered pk values for the given blobid download request.
 * @param blobid - blobid which is under download.
 * @returns {*}
 */
kony.sync.blobManager.getRegisteredPkTable = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredPkTable ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][0];
    } else {
        return null;
    }
};
kony.sync.blobManager.getRegisteredBlobType = function(blobid) {
    sync.log.trace("Entering kony.sync.blobManager.getRegisteredBlobType ");
    if (kony.sync.blobManager.binaryNotifierMap.hasOwnProperty(blobid)) {
        return kony.sync.blobManager.binaryNotifierMap[blobid][1];
    } else {
        return null;
    }
};
/**
 * Method used to update status of the blob record to completed after completion of donwload.
 * @param blobid - id for which the status has to be updated.
 * @param success - result of operation (true/ false).
 * @param isDownload - operation type. true for download / false for upload.
 */
kony.sync.blobManager.updateStatusAfterOndemandJob = function(response, success, isDownload, updateResultCallback) {
    sync.log.trace("Entering kony.sync.blobManager.updateStatusAfterOndemandJob ");
    var finalFilePath = "";
    var valuesTable = {};

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var blobid = parseInt(response[kony.sync.blobId]);
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, function(err) {
            sync.log.trace("error in fetching blobMeta --> updateStatusAfterOndemandJob");
        });
        if (isDownload) {
            if (blobMeta[kony.sync.blobManager.state] === parseInt(response[kony.sync.requestState])) {
                //delete the previousFile and rename the temp file.
                if (success) {
                    sync.log.trace(" kony.sync.blobManager.updateStatusAfterOndemandJob: single_transaction_callback ", blobid);
                    var previousFileName = blobMeta[kony.sync.blobManager.localPath];
                    var filePath = response["filePath"];
                    var fileSuccess;
                    if (previousFileName === "") {
                        filePath = filePath.substring(0, filePath.indexOf("_temp"));
                        fileSuccess = binary.util.renameFile(response["filePath"], filePath);
                        finalFilePath = filePath;
                    } else {
                        fileSuccess = binary.util.renameFile(response["filePath"], previousFileName);
                        finalFilePath = previousFileName;
                    }
                    if (fileSuccess) {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
                        valuesTable[kony.sync.blobManager.status] = 100;
                        valuesTable[kony.sync.blobManager.localPath] = finalFilePath;
                    } else {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                        valuesTable[kony.sync.blobManager.status] = 0;
                        success = false;
                    }
                } else {
                    if (response.hasOwnProperty("errorResponse") && !response["errorResponse"] && response["errorResponse"].trim() !== "") {
                        //check if for the errorResponse, we have to retry or not.
                        if (kony.sync.blobManager.isRetryError(response["statusCode"], response["errorResponse"])) {
                            var noOfRetries = blobMeta[kony.sync.blobManager.retry] - 1;
                            if (noOfRetries < 0) {
                                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                                valuesTable[kony.sync.blobManager.status] = 0;
                            } else {
                                valuesTable[kony.sync.blobManager.retry] = noOfRetries;
                                valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_ACCEPTED;
                                valuesTable[kony.sync.blobManager.status] = 0;
                            }
                        } else {
                            sync.log.trace("Not a retry error, so updating status as download failed for blobid:" + blobid);
                            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                            valuesTable[kony.sync.blobManager.status] = 0;
                        }
                    } else {
                        //download failed. no error Response received.
                        sync.log.error("Download failed. Response from server is " + JSON.stringify(response));
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_FAILED;
                        valuesTable[kony.sync.blobManager.status] = 0;
                    }
                }
                kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable);
            } else {
                //user invoked operation after download request. No need to update anything.
                success = false;
                sync.log.trace("some other operation got invoked after download call. So, ignoring downloaded file");
                if (response.hasOwnProperty["filePath"]) {
                    binary.util.deleteBlobFile(response["filePath"]);
                }
            }
        } else {
            //upload response parsing.
            var reqState = parseInt(response[kony.sync.requestState]);
            if (reqState == kony.sync.blobManager.UPLOAD_IN_PROGRESS) {
                if (blobMeta[kony.sync.blobManager.state] === parseInt(response[kony.sync.requestState])) {
                    valuesTable = {};
                    if (success) {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.NO_OPERATION;
                    } else {
                        valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPLOAD_FAILED;
                    }
                    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable);
                } else {
                    //user invoked another operation after upload request.
                    sync.log.trace("some other operation got invoked after upload call");
                    success = false;
                }
            } else {
                //in case of delete..
                //first delete the record from blobStoreManager.
                if (success) {
                    var deleteResult = kony.sync.blobManager.deleteBlob(tx, blobid);
                    if (deleteResult !== null && deleteResult !== false) {
                        //update blob reference in parent as Null.
                        var tableName = blobMeta[kony.sync.blobManager.tableName];
                        var setClause = {};
                        var blobMetaFieldKey = kony.sync.binaryMetaColumnPrefix + blobMeta[kony.sync.blobManager.columnName];
                        setClause[blobMetaFieldKey] = "NULL";
                        var wcs = [{
                            key: blobMetaFieldKey,
                            value: blobid
                        }];
                        var updateResult = kony.sync.blobManager.updateParentWithBlobReference(tx, tableName, setClause, wcs);
                        if (updateResult === false || updateResult === null) {
                            sync.log.trace("making blob ref to NULL in " + tableName + " failed ");
                            success = false;
                        }
                    } else {
                        sync.log.trace("error in deleting blob record for id " + blobid);
                        success = false;
                    }
                } else {
                    sync.log.trace("error in uploading binary delete.. marked as DELETE again.");
                    valuesTable = {};
                    valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.DELETE_ACCEPTED;
                    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable);
                }
            }
        }
    }

    function single_transaction_success_callback() {
        sync.log.trace("updateStatusAfterOndemandJob -> transaction success");
        updateResultCallback(success, finalFilePath);
    }

    function single_transaction_error_callback() {
        sync.log.trace("updateStatusAfterOndemandJob -> transaction failure");
        success = false;
        updateResultCallback(success, finalFilePath);
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
/**
 * Method is used to parse the statusCode and errorResponse that the sdk receives upon DownloadBinary
 * and concludes if the download should be retried or not.
 * @param statusCode - statusCode from http response
 * @param errorResponse - errorResponse fetched from server
 * @returns {boolean} - whether the error leads to retry or not.
 */
kony.sync.blobManager.isRetryError = function(statusCode, errorResponse) {
    sync.log.trace("Entering kony.sync.blobManager.isRetryError ");
    var isRetryError = false;
    sync.log.trace("isRetryError:statusCode: " + statusCode + " errorResponse:", errorResponse);
    statusCode = parseInt(statusCode);
    try {
        errorResponse = JSON.parse(errorResponse);
    } catch (err) {
        sync.log.error("kony.sync.blobManager.isRetryError parsing error response " + errorResponse);
        return isRetryError;
    }
    //depending on the status code and error response, find out if the download should be retried!
    switch (statusCode) {
        case 404:
            isRetryError = false;
            break;
        case 401:
            if (errorResponse.hasOwnProperty("mfcode")) {
                if (errorResponse["mfcode"] === "Auth-9") {
                    sync.log.trace("Got Auth-9 response");
                    isRetryError = true;
                } else if (errorResponse["mfcode"] === "Gateway-5") {
                    sync.log.trace("Got Gateway-5 response");
                    isRetryError = true;
                }
            } else {
                isRetryError = false;
            }
            break;
        case 200:
            if (errorResponse.hasOwnProperty("d") && errorResponse["d"].hasOwnProperty("mfcode")) {
                if (errorResponse["d"]["mfcode"] === "Gateway-5") {
                    isRetryError = true;
                }
            }
            break;
        default:
            isRetryError = false;
    }
    return isRetryError;
};
kony.sync.blobManager.updateParentWithBlobReference = function(tx, tableName, values, wcs, errorCallback) {
    sync.log.trace("kony.sync.blobManager.updateParentWithBlobReference - entered with table " + tableName + " and values ", values);
    sync.log.trace("kony.sync.blobManager.updateParentWithBlobReference - updating parent table with blobref.");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, tableName);
    kony.sync.qb_set(query, values);
    kony.sync.qb_where(query, wcs);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        sync.log.error("Error in updating the parent table with blobId ");
    }
    //update the history table as well..
    sync.log.trace("kony.sync.blobManager.updateParentWithBlobReference - updating history table with blobref.");
    query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, tableName + kony.sync.historyTableName);
    kony.sync.qb_set(query, values);
    kony.sync.qb_where(query, wcs);
    query_compile = kony.sync.qb_compile(query);
    sql = query_compile[0];
    params = query_compile[1];
    resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        sync.log.error("Error in updating the history table with blobId ");
    }
    return resultset;
};
kony.sync.blobManager.createBlobRecord = function(tx, tableName, columnName, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.createBlobRecord ");
    var query = kony.sync.qb_createQuery();
    var state = kony.sync.blobManager.DOWNLOAD_ACCEPTED;
    kony.sync.qb_set(query, {
        localPath: "",
        status: 0,
        state: state,
        type: kony.sync.blobTypeBase64,
        tableName: tableName,
        columnName: columnName,
        retry: kony.sync.maxRetries
    });
    kony.sync.qb_insert(query, kony.sync.blobStoreManagerTable);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === null || resultset === false) {
        sync.log.error("error in creating a entry in blobstore manager");
        return;
    }
    var blobId = resultset.insertId;
    return blobId;
};
/**
 * Method invokes download operation on the given record.
 * @param tx - transaction id
 * @param tableName - parent table name for the blob reocrd
 * @param columnName - column name of the binary field.
 * @param blobType - download response type . (FILE /BASE64).
 * @param pks - pk table which uniquely identifies the record
 * @param successCallback - success callback for download request.
 * @param errorCallback - error callback for download request.
 * @returns {null}
 */
kony.sync.blobManager.triggerDownload = function(tx, tableName, columnName, pks, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.triggerDownload ");
    sync.log.trace("kony.sync.blobManager.triggerDownload - Entered function with tablename and columnname " + tableName + "--" + columnName);
    var blobId = kony.sync.blobManager.createBlobRecord(tx, tableName, columnName, errorCallback);
    if (!blobId) {
        return;
    }
    sync.log.trace("successfully created an entry in blobstore manager");
    var setClause = {};
    var blobMetaFieldKey = kony.sync.binaryMetaColumnPrefix + columnName;
    setClause[blobMetaFieldKey] = blobId;
    var wcs = [];
    for (var key in pks) {
        var wc = {};
        wc.key = key;
        wc.value = pks[key];
        wcs.push(wc);
    }
    resultset = kony.sync.blobManager.updateParentWithBlobReference(tx, tableName, setClause, wcs, errorCallback);
    if (resultset === false || resultset === null) {
        return;
    }
    sync.log.trace("updated parent table with the blod id.");
    binary.util.notifyToPrepareJobs();
    return blobId;
};
/**
 * Method retriggers the download (incase of force-download / failed download.)
 * @param tx - transaction id
 * @param blobid - id which uniquely identifies the blob
 * @param blobType - download response type (FILE/ base64).
 * @param pks - pk table which uniquely identifies the record.
 * @param successCallback - success callback for download request.
 * @param errorCallback - error callback for download request.
 */
kony.sync.blobManager.retryDownload = function(tx, blobid, blobType, pks, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.retryDownload ");
    //reset the state and status to 0% and DOWNLOAD_ACCEPTED
    var state = kony.sync.blobManager.DOWNLOAD_ACCEPTED;
    var valuesTable = {};
    valuesTable[kony.sync.blobManager.state] = state;
    valuesTable[kony.sync.blobManager.status] = 0;
    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
    //increment total number of download jobs..
    kony.sync.incrementTotalJobs(true);
    kony.sync.blobManager.registerCallbacks(blobid, pks, blobType, successCallback, errorCallback);
    binary.util.notifyToPrepareJobs();
};
kony.sync.blobManager.getBlobInline = function(tx, blobid, blobType, tableName, columnName, config, pks, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.getBlobInline ");
    var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
    if (!kony.sync.isNullOrUndefined(blobMeta) && blobMeta !== false) {
        var possibleStates = [kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPLOAD_ACCEPTED,
            kony.sync.blobManager.UPLOAD_IN_PROGRESS, kony.sync.blobManager.UPLOAD_FAILED
        ];
        var state = blobMeta[kony.sync.blobManager.state];
        if (blobMeta[kony.sync.blobManager.status] === 100 && possibleStates.indexOf(state) !== -1) {
            //base64 exists. return back the required details.
            var successResponse = {};
            successResponse.pkTable = pks;
            if (blobType === kony.sync.BlobType.FILE) {
                //return blobMeta[kony.sync.blobManager.localPath];
                var decodedFilePath = binary.util.decodeBase64File(blobMeta[kony.sync.blobManager.localPath]);
                successResponse.filePath = decodedFilePath;
                return successResponse;
            } else {
                var base64String = binary.util.getBase64FromFiles([blobMeta[kony.sync.blobManager.localPath]]);
                if (base64String[0].length > 0) {
                    successResponse.base64 = base64String[0];
                    return successResponse;
                } else {
                    //update the state of the file stating the file doesn't exist.
                    var valuesTable = {};
                    valuesTable.state = kony.sync.blobManager.FILE_DOESNOT_EXIST;
                    kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
                    //throw an error saying file doesn't exist.
                    var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobFileDoesnotExist, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileDoesnotExist));
                    return error;
                }
            }
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidState, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidState));
            return error;
        }
    }
};
/**
 * Method called when download request is invoked.
 * @param tx - transaction id
 * @param blobid - id of the blob store manager record.
 * @param blobType - response type (FILE /  BASE64).
 * @param tableName - name of the parent table.
 * @param columnName - binary column to which the record refers to.
 * @param config - configuration parameters for download ( forceDownload).
 * @param pks - pk table that uniquely identies the record in parent table.
 * @param successCallback - success callback for fetch
 * @param errorCallback - error callback for fetch,
 * @returns {*}
 */
kony.sync.blobManager.getBlobOnDemand = function(tx, blobid, blobType, tableName, columnName, config, pks, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.getBlobOnDemand ");
    if (!kony.sync.isNullOrUndefined(config) && config.hasOwnProperty(kony.sync.binaryOperationNetworkTimeoutKey)) {
        kony.sync.binaryOperationNetworkTimeoutValue = config[kony.sync.binaryOperationNetworkTimeoutKey];
    }
    //no blob id. trigger download
    if (blobid === kony.sync.blobRefNotDefined) {
        sync.log.trace("triggering download --> getBlobOnDemand");
        var generatedBlobId = kony.sync.blobManager.triggerDownload(tx, tableName, columnName, pks, errorCallback);
        if (generatedBlobId) {
            kony.sync.blobManager.registerCallbacks(generatedBlobId, pks, blobType, successCallback, errorCallback);
        }
        //increment total number of download jobs..
        kony.sync.incrementTotalJobs(true);
    } else {
        //check if the file is available.
        sync.log.trace("fetching from blobStoreManager --> getBlobOnDemand");
        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobid, errorCallback);
        if (!kony.sync.isNullOrUndefined(blobMeta) && blobMeta !== false) {
            //possible states of the file to read the base64.
            var possibleStates = [kony.sync.blobManager.NO_OPERATION, kony.sync.blobManager.UPLOAD_ACCEPTED,
                kony.sync.blobManager.UPLOAD_IN_PROGRESS, kony.sync.blobManager.UPLOAD_FAILED
            ];
            var state = blobMeta[kony.sync.blobManager.state];
            var forceDownload = false;
            sync.log.trace("blob meta from blobStoreManager.." + JSON.stringify(blobMeta));
            if (!kony.sync.isNullOrUndefined(config) && config.hasOwnProperty(kony.sync.forceDownload)) {
                forceDownload = config.forceDownload;
            }
            sync.log.trace("forceDownload " + forceDownload + " -> getBlobOnDemand");
            //if state is No_operation and status is 100, file exists. read it and return.
            if (blobMeta[kony.sync.blobManager.status] === kony.sync.maxFilePercent && possibleStates.indexOf(state) !== -1) {
                //base64 exists. return back the required details.
                if (!forceDownload) {
                    var successResponse = {};
                    successResponse.pkTable = pks;
                    //if requested response type is FILE, return the filePath.
                    if (blobType === kony.sync.BlobType.FILE) {
                        var decodedFilePath = binary.util.decodeBase64File(blobMeta[kony.sync.blobManager.localPath]);
                        successResponse.filePath = decodedFilePath;
                        sync.log.trace("response to the user with filepath " + JSON.stringify(successResponse));
                        return successResponse;
                    } else {
                        //else read the base64 string from the file.
                        var base64String = binary.util.getBase64FromFiles([blobMeta[kony.sync.blobManager.localPath]])
                        if (base64String[0].length > 0) {
                            successResponse.base64 = base64String[0];
                            sync.log.trace("response to the user with base64 string " + JSON.stringify(successResponse));
                            return successResponse;
                        } else {
                            var valuesTable = {};
                            valuesTable.state = kony.sync.blobManager.FILE_DOESNOT_EXIST;
                            kony.sync.blobManager.updateBlobManager(tx, blobid, valuesTable, errorCallback);
                            sync.log.error("requested file does not exist -> getBlobOnDemand");
                            //throw an error saying file doesn't exist.
                            var error = kony.sync.getErrorTable(kony.sync.errorCodeBlobFileDoesnotExistOnDemand, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileDoesnotExistOnDemand));
                            return error;
                        }
                    }
                } else {
                    //retrigger download..
                    sync.log.trace("forceDownload is true. ReTriggering download -> getBlobOnDemand");
                    kony.sync.blobManager.retryDownload(tx, blobid, blobType, pks, successCallback, errorCallback);
                }
            }
            //if already download requested on that record, throw an error..
            else if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.DOWNLOAD_ACCEPTED || blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.DOWNLOAD_IN_PROGRESS) {
                //throw an error download already requested...
                sync.log.error("Download request is already in queue -> getBlobOnDemand");
                var error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadAlreadyInQueue, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadAlreadyInQueue));
                return error;
            }
            //if already ony operation is in progress on the blob entry, download is not allowed.
            else if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.UPDATE_PROCESSING || blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.DELETE_PROCESSING) {
                sync.log.error("User performing operation..-> getBlobOnDemand");
                var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidStateForDownload, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidStateForDownload, kony.sync.blobManager.states[blobMeta[kony.sync.blobManager.state]]));
                return error;
            } else {
                //retriger download
                //blob entry exists but not the file.
                sync.log.trace("retriggering download -> getBlobOnDemand");
                kony.sync.blobManager.retryDownload(tx, blobid, blobType, pks, successCallback, errorCallback);
            }
        }
    }
};
/**
 * Method used to read meta info about the record in blobstore manager.
 * @param tx - transaction id.
 * @param blobid - id of the record in blob store manager.
 * @param errorCallback - error callback for unsuccesful transactions.
 * @returns {{}} JSON object with state and status information.
 */
kony.sync.blobManager.getBlobMetaDetails = function(tx, blobid, errorCallback) {
    sync.log.trace("Entering kony.sync.blobManager.getBlobMetaDetails ");
    var wcs = [{
        key: "id",
        value: blobid
    }];
    var requiredColumns = [kony.sync.blobManager.state, kony.sync.blobManager.status,
        kony.sync.blobManager.localPath, kony.sync.blobManager.retry,
        kony.sync.blobManager.tableName, kony.sync.blobManager.columnName
    ];
    var response = {};
    resultset = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, requiredColumns, wcs);
    if (resultset !== null && resultset !== false) {
        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        response.state = rowItem[kony.sync.blobManager.state];
        response.status = rowItem[kony.sync.blobManager.status];
        response.localPath = rowItem[kony.sync.blobManager.localPath];
        response.retry = rowItem[kony.sync.blobManager.retry];
        response.tableName = rowItem[kony.sync.blobManager.tableName];
        response.columnName = rowItem[kony.sync.blobManager.columnName];
    }
    return response;
};
/**
 * This method is used to get the fetch the rows from blob tables and populate the ondemand download request
 * @return
 */
kony.sync.blobManager.prepareJobs = function() {
    sync.log.trace("Entering kony.sync.blobManager.prepareJobs ");
    //incase current sync config params are undefined, retrieve them from local storage.
    var errorcallback = function(err) {
        sync.log.error("Error occured in prepareJobs " + JSON.stringify(err));
    };
    var successcallback = kony.sync.blobManager.onDemandManager.setJobs;
    var payloadList = [];
    var isError = false;
    var errorInfo = {};
    sync.log.trace("Entering kony.sync.blobManager.prepareJobs ");

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->single_select_transaction_success");
        if (isError) {
            sync.log.error("Error occured in single_transaction_success_callback " + JSON.stringify(errorInfo))
            kony.sync.verifyAndCallClosure(errorcallback, errorInfo);
            return;
        }
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.authTokenKey])) {
            if (!kony.sync.isMbaasEnabled) {
                kony.sync.isMbaasEnabled = true;
            }
            sync.log.trace("Refreshing claims token");
            kony.sdk.claimsRefresh(claimsRefreshSuccessCallBack, claimsRefreshFailureCallBack);
        } else {
            sync.log.trace("Calling successcallback with payload list " + JSON.stringify(payloadList));
            kony.sync.verifyAndCallClosure(successcallback, payloadList);
        }
    }

    function claimsRefreshSuccessCallBack() {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->claimsRefreshSuccessCallBack ");
        var currentClaimToken = kony.sdk.getCurrentInstance().currentClaimToken;
        if (kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] != currentClaimToken) {
            kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] = currentClaimToken;
        }
        var payloadListSize = payloadList.length;
        var payload = null;
        for (var i = 0; i < payloadListSize; i++) {
            payload = payloadList[i];
            if (!kony.sync.isNullOrUndefined(payload) && !kony.sync.isNullOrUndefined(payload.httpheaders)) {
                payload.httpheaders["X-Kony-Authorization"] = currentClaimToken;
            }
        }
        sync.log.trace("Calling successcallback with payloadlist " + JSON.stringify(payloadList));
        kony.sync.verifyAndCallClosure(successcallback, payloadList);
    }

    function claimsRefreshFailureCallBack(res) {
        sync.log.error("kony.sync.blobManager.prepareJobs->claimsRefreshFailureCallBack " + JSON.stringify(res));
        kony.sync.verifyAndCallClosure(errorcallback, res);
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.blobManager.prepareJobs->single_select_transaction_failed");
        kony.sync.verifyAndCallClosure(errorcallback);
    }

    function populateOnDemandPayload(tx, rowItemsList, isDownload) {
        sync.log.trace("Entering populateOnDemandPayload");
        try {
            sync.log.trace("Entering kony.sync.blobManager.prepareJobs->populateOnDemandPayload isDOwnload " + isDownload);
            sync.log.trace("populate on demand payload -> rowItemsList " + JSON.stringify(rowItemsList));
            var rowItemsListLength = rowItemsList.length;
            var binaryMetaColumnName = null;
            var binaryColumnName = null;
            var binaryTableName = null;
            var rowItem = null;
            var query = null;
            var query_compile = null;
            var sql = null;
            var params = null;
            var resultSet = null;
            var whereClause = [];
            var queryOpenBrace = true;
            var blobId = null;
            //Iterating over the on demand download/upload rows
            for (var j = 0; j < rowItemsListLength; j++) {
                rowItem = rowItemsList[j];
                blobId = rowItem[kony.sync.blobManager.id];
                binaryColumnName = rowItem[kony.sync.blobManager.columnName];
                binaryTableName = rowItem[kony.sync.blobManager.tableName];
                var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[binaryTableName]];
                var columns = kony.sync.createClone(scope.syncTableDic[binaryTableName].Pk_Columns);
                columns.push(binaryColumnName);
                if (!isDownload) {
                    columns.push(kony.sync.mainTableChangeTypeColumn);
                }
                var blobWhereClause = [];
                binaryMetaColumnName = kony.sync.binaryMetaColumnPrefix + binaryColumnName;
                kony.table.insert(blobWhereClause, {
                    key: binaryMetaColumnName,
                    value: blobId,
                    optype: "EQ"
                });
                resultSet = kony.sync.queryTable(tx, binaryTableName, columns, blobWhereClause);
                if (resultSet === false) {
                    sync.log.error("Error executing query", sql, " params ", JSON.stringify(params));
                    isError = true;
                    return;
                }
                if (resultSet !== null && resultSet.rows.length > 0) {
                    var data = null;
                    for (var k = 0; k < resultSet.rows.length; k++) {
                        data = kony.db.sqlResultsetRowItem(tx, resultSet, k);
                        //check if there is context in the binarycolumn. \
                        if (isDownload) {
                            if (data[binaryColumnName] === kony.sync.blobRefNotDefined) {
                                sync.log.error("NULL found in binary data column. ");
                                isError = true;
                                return;
                            }
                        }
                        //adding state of the binary column.
                        data["state"] = rowItem["state"];
                        var payload = populateOnDemandParams(tx, blobId, binaryColumnName, binaryTableName, data, isDownload);
                        payloadList.push(payload);
                    }
                }
                var mp = {};
                mp[kony.sync.queryKey] = kony.sync.blobManager.id;
                mp[kony.sync.queryValue] = rowItem[kony.sync.blobManager.id];
                mp[kony.sync.optype] = "EQ";
                mp[kony.sync.comptype] = "OR";
                if (j === 0) {
                    mp[kony.sync.openbrace] = true;
                }
                if (j === (rowItemsListLength - 1)) {
                    mp[kony.sync.closebrace] = true;
                }
                whereClause.push(mp);
            }
            //Update blobstoremanager table with DOWNLOAD_INPROGRESS/UPLOAD_INPROGRESS FOR corresponding ids
            //if there are any jobs. 
            if (whereClause.length > 0) {
                query = kony.sync.qb_createQuery();
                kony.sync.qb_update(query, kony.sync.blobStoreManagerTable);
                var setClause = {};
                //TODO - add a check before updating the state. 
                if (isDownload) {
                    setClause[kony.sync.blobManager.state] = kony.sync.blobManager.DOWNLOAD_IN_PROGRESS;
                } else {
                    setClause[kony.sync.blobManager.state] = kony.sync.blobManager.UPLOAD_IN_PROGRESS;
                }
                kony.sync.qb_set(query, setClause);
                kony.sync.qb_where(query, whereClause);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                sync.log.trace("Executing query for updating states ", sql, " params ", JSON.stringify(params));
                resultSet = kony.sync.executeSql(tx, sql, params);
                if (resultSet === false) {
                    isError = true;
                    return;
                }
            }
        } catch (err) {
            isError = true;
            //to avoid the thread to wait in case of exception.
            kony.sync.blobManager.onDemandManager.setJobs(null);
            sync.log.trace("catch block for the error-> populateOnDemandPayload " + JSON.stringify(err));
            errorInfo = err;
        }
    }

    function populateOnDemandParams(tx, blobIndex, binaryColumnName, tableName, data, isDownload) {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->populateOnDemandParams ");
        sync.log.trace("params to the method are blobIdex " + blobIndex + " column " + tableName + "." + binaryColumnName);
        var job = {};
        var params = {};
        var scopeName = kony.sync.scopes.syncTableScopeDic[tableName];
        params.scopename = scopeName;
        params.blobid = blobIndex;
        params.strategy = kony.sync.scopes[scopeName][kony.sync.syncStrategy];
        params.instanceid = kony.sync.getInstanceID();
        params.clientid = kony.sync.getDeviceID();
        params.appVersion = kony.sync.configVersion;
        if (isDownload) {
            params.url = kony.sync.getDownloadBinaryURL();
        } else {
            params.url = kony.sync.getUploadBinaryURL();
        }
        //This will populate userid, password, appid, sessionid, requestnumber
        kony.sync.commonServiceParams(params);
        params.enablebatching = "true";
        var syncContext = getLastSyncContext(tx, scopeName);
        var ondemandrequest = getOnDemandRequest(tx, syncContext, scopeName, tableName, data, isDownload, blobIndex, binaryColumnName);
        sync.log.trace("populate on demand params -synccontext " + ondemandrequest);
        if (isDownload) {
            params.downloadrequest = ondemandrequest;
            job[kony.sync.requestState] = kony.sync.blobManager.DOWNLOAD_IN_PROGRESS;
            job[kony.sync.requestType] = kony.sync.isDownload;
        } else {
            params.uploadrequest = ondemandrequest;
            if (data.state == kony.sync.blobManager.UPLOAD_ACCEPTED) {
                job[kony.sync.requestState] = kony.sync.blobManager.UPLOAD_IN_PROGRESS;
            } else {
                job[kony.sync.requestState] = kony.sync.blobManager.DELETE_IN_PROGRESS;
            }
            job[kony.sync.requestType] = kony.sync.isUpload;
        }
        job[kony.sync.params] = params;
        job[kony.sync.httpHeaders] = kony.sync.createClone(params[kony.sync.httpHeaders]);
        if (isDownload) {
            job[kony.sync.url] = kony.sync.getDownloadBinaryURL();
        } else {
            job[kony.sync.url] = kony.sync.getUploadBinaryURL();
        }
        job[kony.sync.blobId] = blobIndex;
        job[kony.sync.blobName] = binaryColumnName;
        //adding timeout for the binary operation.
        if (!kony.sync.isNullOrUndefined(kony.sync.binaryOperationNetworkTimeoutValue)) {
            sync.log.trace("populateOnDemandParams - using binary operation timeout of " + kony.sync.binaryOperationNetworkTimeoutValue);
            job[kony.sync.networkTimeOutKey] = kony.sync.binaryOperationNetworkTimeoutValue;
        } else if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && !kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
            sync.log.trace("populateOnDemandParams - using sync network timeout of " + kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]);
            job[kony.sync.networkTimeOutKey] = kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey];
        } else {
            sync.log.trace("populateOnDemandParams - using default timeout of 180000 milli seconds");
            job[kony.sync.networkTimeOutKey] = 180000; //default timeout used by frameworks..
        }
        delete params[kony.sync.httpHeaders];
        sync.log.info("job details are " + JSON.stringify(job));
        return job;
    }

    function getOnDemandRequest(tx, downloadContext, scopename, tableName, binaryColumnData, isDownload, blobIndex, binaryColumnName) {
        sync.log.trace("Entering getOnDemandRequest");
        var resultSet = [];
        var result = {};
        var metaData = {};
        metaData[kony.sync.type] = tableName;
        var isDelete = false;
        //add the changetype for upload/delete request.
        if (!isDownload) {
            if (binaryColumnData.state == kony.sync.blobManager.UPLOAD_ACCEPTED) {
                metaData[kony.sync.syncStatusColumn] = "update";
            } else if (binaryColumnData.state == kony.sync.blobManager.DELETE_ACCEPTED) {
                sync.log.trace("getOnDemandRequest - Received Delete binary request!");
                isDelete = true;
                metaData[kony.sync.syncStatusColumn] = "delete";
            }
        }
        result[kony.sync.metadata] = metaData;
        result[kony.sync.konySyncReplaySequence] = 1;
        if (!isDownload) {
            delete binaryColumnData[kony.sync.mainTableChangeTypeColumn];
        }
        for (var column in binaryColumnData) {
            if (column === "state") {
                continue;
            }
            if (column === binaryColumnName) {
                if (isDownload) {
                    result[column] = binaryColumnData[column];
                } else {
                    //read the filepath.
                    if (!isDelete) {
                        sync.log.trace("getOnDemandRequest - Received Upload request!");
                        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobIndex, function(err) {
                            sync.log.trace("Entering 						var blobMeta ");
                        });
                        //if the blobMeta has filePath.
                        //from the native, we read base64 content and add it to payload.
                        if (!kony.sync.isNullOrUndefined(blobMeta[kony.sync.blobManager.localPath])) {
                            result["filePath"] = blobMeta[kony.sync.blobManager.localPath];
                        }
                    }
                }
            } else {
                result[column] = binaryColumnData[column];
            }
        }
        resultSet.push(result);
        //creating the d object.
        var d = {};
        d[kony.sync.syncobjects] = resultSet;
        d[kony.sync.sync] = "not implemented";
        d[kony.sync.blobSyncScope] = scopename;
        d[kony.sync.serverBlob] = downloadContext[kony.sync.metaTableSyncTimeColumn];
        d[kony.sync.clientId] = kony.sync.getDeviceID();
        d[kony.sync.moreChangesAvailable] = false;
        d[kony.sync.SequenceNumber] = 0;
        var request = {};
        request["d"] = d;
        sync.log.trace("request object in getOnDemandRequest --> " + JSON.stringify(request));
        return request;
    }

    function getLastSyncContext(tx, scopename) {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->getLastSyncContext");
        var scope = kony.sync.scopes[scopename];
        var datasource = scope[kony.sync.scopeDataSource];
        var whereClause = [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }, {
            key: kony.sync.metaTableFilterValue,
            value: "no filter"
        }];
        var resultSet = kony.sync.queryTable(tx, kony.sync.metaTableName, null, whereClause);
        if (resultSet === false) {
            sync.log.error("Error executing query on table " + kony.sync.metaTableName);
            isError = true;
            return;
        }
        var rowItem = null;
        if (resultSet !== null && resultSet.rows.length > 0) {
            rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        }
        return rowItem;
    }

    function getNextOnDemandRows(tx, isDownload) {
        sync.log.trace("Entering kony.sync.blobManager.prepareJobs->getNextOnDemandRows");
        //Select id, tablename, columnname from blobstoremanager table with status as 0% and state as DOWNLOAD_ACCEPTED
        var selectClause = [kony.sync.blobManager.id, kony.sync.blobManager.tableName, kony.sync.blobManager.columnName,
            kony.sync.blobManager.state
        ];
        var wcs = [];
        if (isDownload) {
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.status,
                value: 0,
                optype: "EQ",
                comptype: "AND"
            });
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.state,
                value: kony.sync.blobManager.DOWNLOAD_ACCEPTED,
                optype: "EQ"
            });
        } else {
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.state,
                value: kony.sync.blobManager.UPLOAD_ACCEPTED,
                optype: "EQ",
                comptype: "OR"
            });
            kony.table.insert(wcs, {
                key: kony.sync.blobManager.state,
                value: kony.sync.blobManager.DELETE_ACCEPTED,
                optype: "EQ",
                comptype: "OR"
            });
        }
        return kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, wcs, kony.sync.blobManager.ONDEMAND_FETCH_LIMIT);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        try {
            sync.log.trace("Entering kony.sync.blobManager.prepareJobs->single_transaction_callback");
            //First check for ondemand rows to be downloaded
            var download = true;
            var resultSet = getNextOnDemandRows(tx, download);
            var rowItemsList = [];
            var rowItem = null;
            var resultSetLength = null;
            if (resultSet === false) {
                sync.log.error("Error executing query ");
                isError = true;
                return;
            }
            if ((resultSet !== null) && (resultSet.rows.length === 0)) {
                //If there are no records to download, fetch the records to be uploaded
                sync.log.trace(" No records to download, get next records to upload ");
                download = false;
                resultSet = getNextOnDemandRows(tx, download);
                if (resultSet === false) {
                    sync.log.error("Error executing query ");
                    isError = true;
                    return;
                }
            }
            if (resultSet !== null) {
                resultSetLength = resultSet.rows.length;
                for (var i = 0; i < resultSetLength; i++) {
                    rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, i);
                    if (!kony.sync.isNullOrUndefined(rowItem)) {
                        rowItemsList.push(rowItem);
                    }
                }
                if (rowItemsList.length > 0) {
                    sync.log.trace("jobs retrieved from database.. " + JSON.stringify(rowItemsList));
                    populateOnDemandPayload(tx, rowItemsList, download);
                } else {
                    return;
                }
            }
        } catch (err) {
            sync.log.error("kony.sync.blobManager.prepareJobs->exception occured " + JSON.stringify(err));
            //errorcallback(err);
            isError = true;
            errorInfo = err;
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, errorcallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
kony.sync.blobManager.onDemandManager = function() {
    sync.log.trace("Entering kony.sync.blobManager.onDemandManager ");
};
kony.sync.blobManager.onDemandManager.jobs = null;
kony.sync.blobManager.onDemandManager.setJobs = function(jobs) {
    sync.log.trace("Entering kony.sync.blobManager.onDemandManager.setJobs ");
    kony.sync.blobManager.onDemandManager.jobs = null;
    kony.sync.blobManager.onDemandManager.jobs = jobs;
    binary.util.notifyToProcessJobs();
};
kony.sync.blobManager.getPreparedJobs = function() {
    sync.log.trace("Entering kony.sync.blobManager.getPreparedJobs ");
    //var map = {'key':kony.sync.blobManager.onDemandManager.jobs};
    //return map;
    return kony.sync.blobManager.onDemandManager.jobs;
};
kony.sync.blobManager.onDemandManager.getJobs = function() {
    sync.log.trace("Entering kony.sync.blobManager.onDemandManager.getJobs ");
    return kony.sync.blobManager.onDemandManager.jobs;
};
kony.sync.blobManager.performCleanUp = function(cleanUpCallback) {
    sync.log.trace("Entering kony.sync.performCleanUp");
    var isError = false;
    //once clean up is completed
    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.performCleanUp - single_transaction_callback");
        //parse through the konysyncBlobStoreManager and remove unwanted rows.
        //Delete the rows in case of following states.
        var deleteRecordStates = [kony.sync.blobManager.INSERT_PROCESSING, kony.sync.blobManager.INSERT_FAILED,
            kony.sync.blobManager.DOWNLOAD_FAILED, kony.sync.blobManager.DOWNLOAD_IN_PROGRESS, kony.sync.blobManager.DOWNLOAD_ACCEPTED,
            kony.sync.blobManager.UPDATE_FAILED, kony.sync.blobManager.UPDATE_PROCESSING,
            kony.sync.blobManager.FILE_DOESNOT_EXIST
        ];
        var whereClause = [];
        for (var i = 0; i < deleteRecordStates.length; i++) {
            var wc = {};
            wc.key = kony.sync.blobManager.state;
            wc.value = deleteRecordStates[i];
            wc.comptype = "OR";
            whereClause.push(wc);
        }
        var selectClause = [kony.sync.blobManager.id, kony.sync.blobManager.tableName, kony.sync.blobManager.columnName];
        var result_set = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, whereClause);
        var rowItem;
        var valuesTable;
        if (result_set !== null && result_set !== false) {
            if (result_set.rows.length > 0) {
                for (var k = 0; k < result_set.rows.length; k++) {
                    //delete the blob entries with the given where clause.
                    rowItem = kony.db.sqlResultsetRowItem(tx, result_set, k);
                    sync.log.trace("record to be deleted in konysyncBlobStoreManager is " + JSON.stringify(rowItem));
                    var deleteResult = kony.sync.blobManager.deleteBlob(tx, rowItem[kony.sync.blobManager.id], function(err) {
                        kony.sync.errorObject = err;
                        sync.log.error("kony.sync.blobManager.performCleanUp -error in deleteBlob " + JSON.stringify(err));
                        isError = true;
                    });
                    sync.log.trace("after deleting record with id " + rowItem[kony.sync.blobManager.id] + " result is " + JSON.stringify(deleteResult));
                    if (deleteResult !== null && deleteResult !== false) {
                        //tx, tableName, values, wcs, errorCallback
                        var binaryColumnName = kony.sync.binaryMetaColumnPrefix + rowItem[kony.sync.blobManager.columnName];
                        valuesTable = {};
                        var wcs = [{
                            key: binaryColumnName,
                            value: rowItem[kony.sync.blobManager.id]
                        }];
                        valuesTable[binaryColumnName] = kony.sync.blobRefNotDefined;
                        var updateResult = kony.sync.blobManager.updateParentWithBlobReference(tx, rowItem[kony.sync.blobManager.tableName], valuesTable, wcs, function(err) {
                            sync.log.trace("Entering ");
                            kony.sync.errorObject = err;
                            sync.log.error("kony.sync.blobManager.performCleanUp -error in updateParentWithBlobReference " + JSON.stringify(err));
                            isError = true;
                        });
                        sync.log.trace("after updating record's blobref result is " + JSON.stringify(updateResult));
                        if (updateResult === null || updateResult === false) {
                            sync.log.error("kony.sync.blobManager.performCleanUp -error in updateParentWithBlobReference ");
                            isError = true;
                        }
                    } else {
                        sync.log.error("kony.sync.blobManager.performCleanUp -error in deleteBlob");
                        isError = true;
                    }
                }
            }
            if (!isError) {
                //change the state of upload_in_progress to upload_failed.
                whereClause = [{
                    key: kony.sync.blobManager.state,
                    value: kony.sync.blobManager.UPLOAD_IN_PROGRESS
                }];
                result_set = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, whereClause);
                if (result_set !== null && result_set !== false) {
                    if (result_set.rows.length > 0) {
                        for (var k = 0; k < result_set.rows.length; k++) {
                            rowItem = kony.db.sqlResultsetRowItem(tx, result_set, k);
                            valuesTable = {};
                            valuesTable.state = kony.sync.blobManager.UPLOAD_FAILED;
                            kony.sync.blobManager.updateBlobManager(tx, rowItem[kony.sync.blobManager.id], valuesTable, function(err) {
                                sync.log.trace("Entering ");
                                kony.sync.errorObject = err;
                                sync.log.error("kony.sync.blobManager.performCleanUp -error in updateBlobManager " + JSON.stringify(err));
                                isError = true;
                            });
                        }
                    }
                } else {
                    sync.log.error("kony.sync.blobManager.performCleanUp - error in fetchFromBlobStoreManager");
                    isError = true;
                }
            }
        } else {
            sync.log.error("kony.sync.blobManager.performCleanUp - error in fetchFromBlobStoreManager");
            isError = true;
        }
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.performCleanUp - single_transaction_success_callback");
        if (!isError) {
            kony.sync.isCleanUpJobCompleted = true;
        }
        cleanUpCallback(isError);
    }

    function single_transaction_error_callback() {
        sync.log.trace("Entering kony.sync.performCleanUp - single_transaction_error_callback");
        cleanUpCallback(true);
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, cleanUpCallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
//  **************** End KonySyncBlobStoreManager.js*******************
//  **************** Start KonySyncBlobUtils.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
/**
 * Method returns the download policy of the given column in the table if the type of column is binary
 * else returns null
 * @param tableName - tablename
 * @param columnName - column name
 * @returns {*} -downloadPolicy for binary column, null for non binary columns.
 */
kony.sync.getDownloadPolicy = function(tableName, columnName) {
    sync.log.trace("Entering kony.sync.getDownloadPolicy ");
    var downloadPolicy = kony.sync.notSupported;
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes) && kony.sync.scopes.syncTableScopeDic.hasOwnProperty(tableName)) {
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tableName]];
        var tableColumns = scope.syncTableDic[tableName].Columns;
        var isColumn = false;
        for (var i = 0; i < tableColumns.length; i++) {
            if (tableColumns[i].Name === columnName && tableColumns[i].type === "binary") {
                isColumn = true;
                if (tableColumns[i].hasOwnProperty(kony.sync.binaryPolicy)) {
                    downloadPolicy = tableColumns[i][kony.sync.binaryPolicy];
                } else {
                    downloadPolicy = kony.sync.inline;
                }
                break;
            }
        };
    }
    return downloadPolicy;
};
/**
 * Method checks whether the given column in binary column or not.
 * @param tbname - table to which column belongs to.
 * @param columnName - name of the column
 * @returns {number|Number} - returns -1 if the column is not binary.
 */
kony.sync.getBinaryColumnsByPolicy = function(tbname, policy) {
    sync.log.trace("Entering kony.sync.getBinaryColumnsByPolicy ");
    var columnsWithRequestedPolicy = [];
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumnsOfTable = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        for (var j = 0; j < binaryColumnsOfTable.length; j++) {
            var downloadPolicy = kony.sync.getDownloadPolicy(tbname, binaryColumnsOfTable[j]);
            if (downloadPolicy === policy) {
                columnsWithRequestedPolicy.push(binaryColumnsOfTable[j]);
            }
        }
    }
    return columnsWithRequestedPolicy;
};
/**
 * Method checks whether the given column in binary column or not.
 * @param tbname - table to which column belongs to.
 * @param columnName - name of the column
 * @returns {number|Number} - returns -1 if the column is not binary.
 */
kony.sync.isBinaryColumn = function(tbname, columnName) {
    sync.log.trace("Entering kony.sync.isBinaryColumn ");
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumnsOfTable = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        return binaryColumnsOfTable.indexOf(columnName);
    }
    return -1;
};
/**
 * Method used to find Blobref for the given record.
 * @param tx - transaction id
 * @param sql - sql statement
 * @param params - sql params
 * @param column - column name
 * @param errorNotifier - error callback.
 * @returns {{}} - blobref object containing pk values and blobreference.
 */
kony.sync.getBlobRef = function(tx, tableName, columnName, pks, errorNotifier) {
        sync.log.trace("Entering kony.sync.getBlobRef ");
        var wcs = [];
        for (var key in pks) {
            var wc = {};
            wc.key = key;
            wc.value = pks[key];
            wc.comptype = "AND";
            wcs.push(wc);
        }
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_from(query, tableName);
        var blobRefColumn = kony.sync.binaryMetaColumnPrefix + columnName;
        kony.sync.qb_select(query, [blobRefColumn]);
        kony.sync.qb_where(query, wcs);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var blobRef = kony.sync.blobRefNotFound;
        //"NULL"
        var result = kony.db.executeSql(tx, sql, params, function(err) {
            sync.log.error("error in transaction call back " + JSON.stringify(err));
            errorNotifier(err);
            return;
        });
        if (result !== null && result !== false) {
            if (result.rows.length > 0) {
                var rowItem = kony.db.sqlResultsetRowItem(tx, result, 0);
                var rowValue = rowItem[kony.sync.binaryMetaColumnPrefix + columnName];
                if (!kony.sync.isNullOrUndefined(rowValue)) {
                    blobRef = rowValue;
                }
            }
        }
        return blobRef;
    }
    /**
     * Method used to validate pkTable.
     * @param pkColumns - pkColumns related to the table
     * @param pkTable - received pkTable from the user.
     * @returns {*} - updated pkTable after removing non binary keys.
     * returns null incase all the pk keys are not sent.
     */
kony.sync.validatePkTable = function(pkColumns, pkTable) {
    sync.log.trace("Entering kony.sync.validatePkTable ");
    var receivedPkColumns = Object.keys(pkTable);
    //remove non pk columns..
    for (var i = receivedPkColumns.length - 1; i >= 0; i--) {
        if (pkColumns.indexOf(receivedPkColumns[i]) === -1) {
            delete pkTable[receivedPkColumns[i]];
            receivedPkColumns.splice(i, 1);
        }
    }
    //check if info is received for all pks.
    if (receivedPkColumns.length !== pkColumns.length) {
        //throw an error. info about all pks is mandate.
        return null;
    } else {
        return pkTable;
    }
};
kony.sync.removeBinaryMetaColumns = function(tablename, columns) {
    sync.log.trace("Entering kony.sync.removeBinaryMetaColumns ");
    var nonMetaColumns = [];
    for (var j = 0; j < columns.length; j++) {
        if (columns[j].Name.indexOf(kony.sync.binaryMetaColumnPrefix) !== 0) {
            nonMetaColumns.push(columns[j]);
        }
    }
    return nonMetaColumns;
}
kony.sync.getBlobContext = function(tx, tableName, columnName, pks, errorNotifier) {
    sync.log.trace("Entering kony.sync.getBlobContext ");
    var wcs = [];
    for (var key in pks) {
        var wc = {};
        wc.key = key;
        wc.value = pks[key];
        wc.comptype = "AND";
        wcs.push(wc);
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_from(query, tableName);
    kony.sync.qb_select(query, [columnName]);
    kony.sync.qb_where(query, wcs);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var blobContext = kony.sync.blobRefNotFound;
    //"NULL"
    var result = kony.db.executeSql(tx, sql, params, function(err) {
        sync.log.error("error in transaction call back " + JSON.stringify(err));
        errorNotifier(err);
    });
    if (result !== null && result !== false) {
        if (result.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, result, 0);
            blobContext = rowItem[columnName];
        }
    }
    return blobContext;
};
kony.sync.getBinaryColumns = function(tablename) {
    sync.log.trace("Entering kony.sync.getBinaryColumns ");
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename]) || kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns])) {
        return;
    } else {
        return kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
    }
};
kony.sync.getSyncToDeviceField = function(tableName, columnName) {
    sync.log.trace("Entering kony.sync.getSyncToDeviceField for table " + tableName + " and column " + columnName);
    if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncToDeviceMap) && !kony.sync.scopes.syncToDeviceMap.hasOwnProperty(tableName + columnName)) {
        return;
    }
    return kony.sync.scopes.syncToDeviceMap[tableName + columnName];
};
//initialize Binary stats properties
kony.sync.initBinaryStatProperties = function() {
    sync.log.trace("Entering kony.sync.initBinaryStatProperties ");
    //current sync cycle stats
    var uploadBinaryStats = {};
    var downloadBinaryStats = {};
    //initializing upload related stats..
    uploadBinaryStats.totalNumberOfUploads = 0;
    uploadBinaryStats.uploadsCompleted = 0;
    uploadBinaryStats.uploadsFailed = 0;
    //initializing download related stats..
    downloadBinaryStats.totalNumberOfDownloads = 0;
    downloadBinaryStats.downloadsCompleted = 0;
    downloadBinaryStats.downloadsFailed = 0;
    kony.sync.currentSyncStats.uploadBinaryStats = uploadBinaryStats;
    kony.sync.currentSyncStats.downloadBinaryStats = downloadBinaryStats;
};
//initialize stat params
kony.sync.initBinaryStats = function() {
    sync.log.trace("Entered kony.sync.initBinaryStats - initializing binary stats parameters.. ");
    kony.sync.currentSyncStats = {};
    kony.sync.initBinaryStatProperties();
    //last sync cycle stats
    kony.sync.lastSyncStats = {};
};
//assign currentSyncStats to lastSyncStats
kony.sync.reinitializeBinaryStats = function() {
    sync.log.trace("Entering kony.sync.reinitializeBinaryStats ");
    kony.sync.lastSyncStats = kony.sync.currentSyncStats;
    //current sync cycle stats
    kony.sync.currentSyncStats = {};
    kony.sync.initBinaryStatProperties();
};
//increment number of uploads/ downloads..
kony.sync.incrementTotalJobs = function(isDownload) {
    sync.log.trace("Entering kony.sync.incrementTotalJobs ");
    if (isDownload) {
        sync.log.trace("kony.sync.incrementTotalJobs downloads incremented");
        kony.sync.currentSyncStats.downloadBinaryStats.totalNumberOfDownloads = kony.sync.currentSyncStats.downloadBinaryStats.totalNumberOfDownloads + 1;
    } else {
        sync.log.trace("kony.sync.incrementTotalJobs uploads incremented");
        kony.sync.currentSyncStats.uploadBinaryStats.totalNumberOfUploads = kony.sync.currentSyncStats.uploadBinaryStats.totalNumberOfUploads + 1;
    }
};
//increment number of completed uploads / downloads
kony.sync.incrementCompletedJobs = function(isDownload) {
    sync.log.trace("Entering kony.sync.incrementCompletedJobs ");
    if (isDownload) {
        sync.log.trace("kony.sync.incrementCompletedJobs downloads incremented");
        kony.sync.currentSyncStats.downloadBinaryStats.downloadsCompleted = kony.sync.currentSyncStats.downloadBinaryStats.downloadsCompleted + 1;
    } else {
        sync.log.trace("kony.sync.incrementCompletedJobs uploads incremented");
        kony.sync.currentSyncStats.uploadBinaryStats.uploadsCompleted = kony.sync.currentSyncStats.uploadBinaryStats.uploadsCompleted + 1;
    }
};
//increment number of failed uploads / downloads
kony.sync.incrementFailedJobs = function(isDownload) {
    sync.log.trace("Entering kony.sync.incrementFailedJobs ");
    if (isDownload) {
        sync.log.trace("kony.sync.incrementFailedJobs downloads incremented");
        kony.sync.currentSyncStats.downloadBinaryStats.downloadsFailed = kony.sync.currentSyncStats.downloadBinaryStats.downloadsFailed + 1;
    } else {
        sync.log.trace("kony.sync.incrementFailedJobs uploads incremented");
        kony.sync.currentSyncStats.uploadBinaryStats.uploadsFailed = kony.sync.currentSyncStats.uploadBinaryStats.uploadsFailed + 1;
    }
};
kony.sync.invokeBinaryNotifiers = function(isDownload) {
    sync.log.trace("Entering kony.sync.invokeBinaryNotifiers ");
    if (isDownload) {
        if (kony.sync.onBinaryDownload && kony.sync.isValidFunctionType(kony.sync.onBinaryDownload)) {
            kony.sync.onBinaryDownload(kony.sync.currentSyncStats.downloadBinaryStats);
        }
    } else {
        if (kony.sync.onBinaryUpload && kony.sync.isValidFunctionType(kony.sync.onBinaryUpload)) {
            kony.sync.onBinaryUpload(kony.sync.currentSyncStats.uploadBinaryStats);
        }
    }
};
kony.sync.validateTableName = function(tableName) {
    sync.log.trace("Entering kony.sync.validateTableName ");
    var tableinfo = kony.sync.getTableInfo(tableName);
    return !kony.sync.isNullOrUndefined(tableinfo);
};
kony.sync.validateBinaryColumn = function(tableName, columnName) {
    sync.log.trace("Entering kony.sync.validateBinaryColumn ");
    var downloadPolicy = kony.sync.getDownloadPolicy(tableName, columnName);
    if (downloadPolicy === kony.sync.notSupported) {
        return false;
    }
    return true;
};
kony.sync.getPrimaryKeyColumns = function(tableName) {
    sync.log.trace("Entering kony.sync.getPrimaryKeyColumns ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
    var scope = kony.sync.scopes[scopename];
    return scope.syncTableDic[tableName].Pk_Columns;
};
//  **************** End KonySyncBlobUtils.js*******************
//  **************** Start KonySyncChunkingHelper.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
//Checks whether download response is eligible for chunking or not
kony.sync.eligibleForChunking = function(result) {
    sync.log.trace("Entering kony.sync.eligibleForChunking");
    if (!kony.sync.isNull(result.opstatus) && result.opstatus != 0) {
        return false;
    }
    return (!kony.sync.isNull(result.d) && result.d.error === "false" && !kony.sync.isNull(result.d.__sync[kony.sync.payloadIdKey]));
};
//Add chunk info in metatable
kony.sync.startChunking = function(url, serviceParams, result, callback) {
    sync.log.trace("Entering kony.sync.startChunking");
    sync.log.info("storing payload info in konysyncchunkmetainfo");
    var isError = false;
    var payloadId = result.d.__sync[kony.sync.payloadIdKey];
    var chunkCount = result.d.__sync[kony.sync.chunkCountKey];
    var hashSum = result.d.__sync[kony.sync.chunkHashSum];
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.startChunking->transactionCallback");
        //clear meta data from chunking table
        if (kony.sync.clearChunkMetaData(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
            return;
        }
        //store payload info in konysyncchunkmetainfo
        var values = {};
        values[kony.sync.metaTablePayloadId] = payloadId;
        values[kony.sync.metaTableChunkSize] = kony.sync.getChunkSize();
        values[kony.sync.metaTableChunkAck] = kony.sync.chunkNotAcknowledged;
        values[kony.sync.metaTableChunkHashSum] = hashSum;
        values[kony.sync.metaTableChunkDiscarded] = kony.sync.chunkNotDiscarded;
        values[kony.sync.metaTableChunkCount] = chunkCount;
        values[kony.sync.metaTableScopeColumn] = kony.sync.currentScope[kony.sync.scopeName];
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_insert(query, kony.sync.chunkMetaTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
        }
    }
    //call callback with framed error
    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.startChunking->transactionFailedCallback");
        if (isError) {
            sync.log.error("Error occurred while inserting chunk information in metatable");
            callback(kony.sync.frameDownloadError(null, null, 1));
        } else {
            var errMsg = "Error occurred while opening transaction to store chunk information in metatable";
            sync.log.error(errMsg);
            callback(kony.sync.frameDownloadError(null, errMsg, 2));
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.startChunking->transactionSuccessCallback");
        kony.sync.downloadChunks(url, serviceParams, payloadId, chunkCount, hashSum, result, false, null, callback);
    }
};
//Starts Chunking
kony.sync.downloadChunks = function(url, serviceParams, payloadId, chunkCount, hashSum, initialData, isResumed, downloadedChunks, callback) {
    sync.log.trace("Entering kony.sync.downloadChunks ");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
    var serverParams = {};
    serviceParams[kony.sync.payloadIdKey] = payloadId;
    serviceParams[kony.sync.chunkCountKey] = chunkCount.toString();
    sync.log.trace("kony.sync.downloadChunks chunkCount " + chunkCount + " and downloadedChunks ", downloadedChunks);
    var noOfParallelCalls = 1;
    //temporarily disabling parallel calls
    /*if(!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey])){
    	if(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey] > 0){
    		noOfParallelCalls = kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey];
    	}
    }*/
    //sync.log.info("Maximum parallel chunks:" + noOfParallelCalls);
    var chunkingFailed = 0;
    var chunkProcessed = 0;
    var chunkErrorMap = {};
    var utf8data = null;
    var corruptedData = false;
    var callNo = 0;
    var infoObj = {};
    var chunkMap;
    var i = null;
    var areAllChunksDownloaded = true; //flag to check if all the chunks are downloaded,
    //process first chunk if chunking is not resumed from an earlier point
    sync.log.trace("kony.sync.downloadChunks isResumed ", isResumed);
    if (!isResumed) {
        downloadNetworkCallback(initialData, 1);
    }
    /*if(!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey])){
    	//infoObj[kony.sync.numberOfRetriesKey] = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
    }*/
    if (isResumed) {
        //find the remaining ids
        //create map for all the ids
        sync.log.trace("kony.sync.downloadChunks - isResumed true for chunkCount " + chunkCount + " with downloadedChunks ", downloadedChunks);
        var chunkMap = [];
        for (var i = 1; i <= chunkCount; i++) {
            chunkMap[i] = 0; //initially set 0 for all the ids
        }
        for (var i = 0; i < downloadedChunks.length; i++) {
            sync.log.trace("kony.sync.downloadChunks process chunks ", downloadedChunks);
            chunkMap[downloadedChunks[i]] = 1; //set 1 for downloaded ids
            chunkProcessed++; //count processed chunks
        }
        i = 1;
        for (callNo = 1; callNo <= chunkCount; callNo++) {
            if (chunkMap[callNo] === 0) {
                areAllChunksDownloaded = false; //all the chunks are not downloaded. Disabling the flag.
                infoObj[kony.sync.chunkNoKey] = callNo.toString();
                serviceParams[kony.sync.chunkNoKey] = callNo.toString();
                kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
                sync.log.info("Hitting the service with URL :" + url + " with params:" + JSON.stringify(serviceParams));
                retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
                kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
                if (i >= noOfParallelCalls) {
                    callNo++;
                    break;
                }
                i++;
            }
        }
    } else {
        for (callNo = 2; callNo <= chunkCount; callNo++) {
            areAllChunksDownloaded = false; //all the chunks are not downloaded. disabling the flag.
            infoObj[kony.sync.chunkNoKey] = callNo.toString();
            serviceParams[kony.sync.chunkNoKey] = callNo.toString();
            kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
            sync.log.info("Hitting the service with URL :" + url + " with params:" + JSON.stringify(serviceParams));
            retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
            kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
            if (callNo > noOfParallelCalls) {
                callNo++;
                break;
            }
        }
    }
    //All the chunks have been downloaded. Start processing them
    if (areAllChunksDownloaded === true) {
        sync.log.trace("kony.sync.downloadChunks -> All the chunks are downloaded.. Starting the processing");
        kony.sync.getChunksFromDB(payloadId, chunkCount, kony.sync.currentScope[kony.sync.scopeName], chunkDataProcessCallback);
    }

    function downloadNetworkCallbackStatus(status, result, info) {
        sync.log.trace("Entering kony.sync.downloadChunks->downloadNetworkCallbackStatus with status " + status + " result " + JSON.stringify(result) + " info ", info);
        if (status === 400) {
            sync.log.info("Got Response for Chunk No:" + info[kony.sync.chunkNoKey]);
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(url, result, info, retries, downloadNetworkCallback, serviceParams);
            } else {
                kony.sync.setSessionID(result);
                downloadNetworkCallback(result, info[kony.sync.chunkNoKey]);
            }
        } else if (status === 300) {
            sync.log.warn("Got status 300 for Chunk, Network call Cancelled.");
            if (!kony.sync.isNullOrUndefined(retries) && (retries > 0)) {
                retries--;
                if (kony.sync.isNullOrUndefined(info)) {
                    info = {};
                }
                info.retryOnNetworkCancel = true;
                sync.log.debug("Retrying the network call for status 300 ");
                if (kony.sync.isNullOrUndefined(result)) {
                    result = kony.sync.getNetworkCancelError();
                }
                kony.sync.retryServiceCall(url, result, info, retries, downloadNetworkCallback, serviceParams);
            } else {
                downloadNetworkCallback(kony.sync.getNetworkCancelError(), info[kony.sync.chunkNoKey]);
            }
        }
    }

    function isChunkPayloadIdInvalid(result) {
        sync.log.trace("Entering isChunkPayloadIdInvalid");
        if (!kony.sync.isNullOrUndefined(result) && !kony.sync.isNullOrUndefined(result.d)) {
            if ((result.d.error === "true") && (result.d.errcode === kony.sync.servercodes.chunkPayloadIdInvalid)) {
                return true;
            }
        }
        return false;
    }

    function clearChunkMetaDataAndAllChunksSuccessCallback() {
        sync.log.trace("Entering clearChunkMetaDataAndAllChunksSuccessCallback");
        kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.downloadCompletedCallback);
    }

    function clearChunkMetaDataAndAllChunksErrorCallback(error) {
        sync.log.trace("Entering clearChunkMetaDataAndAllChunksErrorCallback");
        kony.sync.downloadFailed(error);
    }

    function downloadNetworkCallback(result, info) {
        sync.log.trace("Entering kony.sync.downloadChunks->downloadNetworkCallback with result " + JSON.stringify(result) + " " + "info -> ", info);
        serverParams[kony.sync.hostName] = kony.sync.getServerDetailsHostName(result);
        serverParams[kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(result);
        var chunkId = info;
        if (kony.sync.isValidJSTable(info)) {
            chunkId = info[kony.sync.chunkNoKey];
        }
        if (isChunkPayloadIdInvalid(result)) {
            sync.log.trace(" Chunk PayloadId is Invalid : " + payloadId);
            chunkingFailed++;
            kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, kony.sync.errorCodeChunkInvalidPayloadId, result.d.msg, serverParams);
            kony.sync.clearChunkMetaDataAndAllChunks(payloadId, kony.sync.currentScope[kony.sync.scopeName], clearChunkMetaDataAndAllChunksSuccessCallback, clearChunkMetaDataAndAllChunksErrorCallback);
        } else {
            if (callNo <= chunkCount) {
                if (!isResumed) {
                    if (callNo !== 0) {
                        infoObj[kony.sync.chunkNoKey] = callNo.toString();
                        serviceParams[kony.sync.chunkNoKey] = callNo.toString();
                        kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
                        sync.log.info("Hitting the service with URL :" + url + " with params:", serviceParams);
                        retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
                        kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
                        callNo++;
                    }
                } else {
                    for (; callNo <= chunkCount; callNo++) {
                        if (chunkMap[callNo] === 0) {
                            infoObj[kony.sync.chunkNoKey] = callNo.toString();
                            serviceParams[kony.sync.chunkNoKey] = callNo.toString();
                            kony.sync.callOnChunkStart(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], callNo, serviceParams);
                            sync.log.info("Hitting the service with URL :" + url + " with params:", serviceParams);
                            retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
                            kony.sync.invokeServiceAsync(url, serviceParams, downloadNetworkCallbackStatus, infoObj);
                            if (callNo >= noOfParallelCalls + 1) {
                                callNo++;
                                break;
                            }
                        }
                    }
                }
            }
            if (!kony.sync.isNull(result.opstatus) && result.opstatus != 0) {
                chunkingFailed++;
                sync.log.error("Error occurred while downloading chunks: Code=" + result.opstatus + ", message=" + result.errmsg);
                chunkErrorMap[chunkId] = result.errmsg;
                kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, result.opstatus, result.errmsg, serverParams);
                if (allChunksProcessed()) {
                    handleError();
                }
            } else if (result.d.error === "true") {
                chunkingFailed++;
                sync.log.error("Error occurred while downloading chunks: message=" + result.d.msg);
                chunkErrorMap[chunkId] = result.d.msg;
                kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, kony.sync.errorCodeUnknownServerError, result.d.msg, serverParams);
                if (allChunksProcessed()) {
                    handleError();
                }
            } else {
                //store in local DB
                kony.sync.storeChunkInDB(payloadId, chunkId, result.d[kony.sync.chunkDataKey], kony.sync.currentScope[kony.sync.scopeName], chunkDataStoredCallback);
                if (allChunksProcessed()) {
                    handleError();
                }
            }
        }
    }

    function allChunksProcessed() {
        sync.log.trace("allChunksProcessed chunkProcessed " + chunkProcessed + " chunkingFailed " + chunkingFailed + " chunkCount " + chunkCount);
        var areAllChunksProcessed = (chunkProcessed + chunkingFailed === chunkCount);
        sync.log.trace("allChunksProcessed result " + areAllChunksProcessed);
        return areAllChunksProcessed;
    }

    function handleError() {
        sync.log.info("All chunking calls for current batch with total of " + chunkCount + " completed.")
        if (chunkProcessed > 0) {
            sync.log.info("Chunks successfully downloaded and stored in DB:" + chunkProcessed);
        }
        //error occurred in one or more chunks
        if (chunkingFailed > 0) {
            sync.log.error("Chunks failed either to downloaded or while storing in DB:" + chunkingFailed);
            //frame error
            var framedErrorResponse = kony.sync.frameDownloadError(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), chunkErrorMap, null, kony.sync.errorCodeChunking);
            sync.log.error(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), chunkErrorMap);
            //call download complete callback with error
            callback(framedErrorResponse);
            return false;
        } else {
            return true;
        }
    }

    function chunkDataStoredCallback(chunkId, errorMap) {
        sync.log.trace("Entering kony.sync.downloadChunks->chunkDataStoredCallback");
        //if error, add to errorMap
        if (!kony.sync.isNull(errorMap)) {
            sync.log.error("chunkDataStoredCallback errorMap incrementing chunkingFailed. ", errorMap);
            chunkingFailed++;
            chunkErrorMap[chunkId] = errorMap.errorCode;
            sync.log.error("Error occurred while storing chunk " + chunkId + " in DB");
            kony.sync.callOnChunkError(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, errorMap.errorCode, errorMap.errorMessage, serverParams, errorMap.errorInfo);
        } else {
            chunkProcessed++;
            sync.log.trace("chunkDataStoredCallback incrementing number of chunks processed.." + chunkProcessed);
            kony.sync.callOnChunkSuccess(chunkCount, payloadId, kony.sync.currentScope[kony.sync.scopeName], chunkId, chunkCount - chunkProcessed, chunkProcessed, serverParams);
        }
        sync.log.trace("chunkDataStoredCallback - calling allChunksProcessed ");
        if (allChunksProcessed() && handleError()) {
            //gather all results from chunkMap
            sync.log.trace("chunkDataStoredCallback allChunksProcessed true and handleError true");
            kony.sync.getChunksFromDB(payloadId, chunkCount, kony.sync.currentScope[kony.sync.scopeName], chunkDataProcessCallback);
        }
        /*else {
			sync.log.error("chunkDataStoredCallback Either allChunksProcessed or handleError is not true..");
			var errorObj = kony.sync.getErrorTable(kony.sync.errorCodeChunking, kony.sync.getErrorMessage(kony.sync.errorCodeChunking));
			sync.log.error("Error in chunking ", errorObj);

			//call download complete callback with error
			callback(errorObj);
		}*/
    }

    function chunkDataProcessCallback(data, isError, errorType) {
        sync.log.trace("Entering kony.sync.downloadChunks->chunkDataProcessCallback");
        //error occurred while retrieving info
        if (isError) {
            //frame error
            sync.log.error(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), data);
            var framedErrorResponse = null;
            if (errorType === 1 || errorType === 2) {
                framedErrorResponse = kony.sync.frameDownloadError(null, null, errorType);
            } else {
                framedErrorResponse = kony.sync.frameDownloadError(kony.sync.getErrorMessage(kony.sync.errorCodeChunking), data, null, kony.sync.errorCodeChunking);
            }
            //call download complete callback with error
            callback(framedErrorResponse);
        }
        //all chunks downloaded successfully
        else {
            utf8data = data;
            //calculate checksum hash of utf8data;
            var checksum = kony.sync.createHash("sha256", utf8data);
            //compare checksum with server sent hashsum;
            if (!kony.string.equalsIgnoreCase(checksum, hashSum)) {
                sync.log.error("Received corrupted chunk data for payloadId= " + payloadId + ", clearing erroneous chunks from db.");
                corruptedData = true;
            }
            //release checksum
            checksum = null;
            //clear the payload from metainfo;
            kony.sync.clearChunkForPayload(payloadId, kony.sync.currentScope[kony.sync.scopeName], corruptedData, chunkDataClearback);
        }
    }

    function chunkDataClearback(data, isError) {
        sync.log.trace("Entering kony.sync.downloadChunks->chunkDataClearback");
        //error occurred while clearing chunkInfo
        if (isError || corruptedData) {
            //create error message
            var errMsg = "Following errors occurred:";
            if (isError) {
                errMsg += "Error occurred while clearing chunk information from DB";
            }
            if (corruptedData) {
                if (isError) {
                    errMsg += ", ";
                }
                errMsg += "Received corrupted chunk data for payloadId= " + payloadId;
            }
            errMsg += ".";
            sync.log.error(errMsg);
            //frame error
            var framedErrorResponse = kony.sync.frameDownloadError(errMsg, data, null, kony.sync.errorCodeChunking);
            //call download complete callback with error
            callback(framedErrorResponse);
        } else {
            //convert json string to json object
            var myJsonObject = null;
            try {
                myJsonObject = JSON.parse(utf8data);
            } catch (e) {
                var errMsg = kony.sync.getErrorMessage(kony.sync.errorCodeParseError, utf8data, e);
                sync.log.error(errMsg);
                myJsonObject = null;
                utf8data = null;
                callback(kony.sync.frameDownloadError(errMsg, e, null, kony.sync.errorCodeParseError));
                return;
            }
            utf8data = null;
            //call the callback with final result			
            callback(myJsonObject);
        }
    }
};
//framing download error
kony.sync.frameDownloadError = function(errorMessage, errorInfo, dbError, errorCode) {
    sync.log.trace("Entering kony.sync.frameDownloadError");
    var result = {};
    result.d = {};
    result.d.error = "true";
    if (dbError === 1) { //statement error
        result.d.opstatus = kony.sync.errorObject.errorCode;
        result.d.msg = kony.sync.errorObject.errorMessage;
        result.d.errorInfo = kony.sync.errorObject.errorInfo;
    } else if (dbError === 2) { //transaction error
        result.d.opstatus = kony.sync.errorCodeTransaction;
        result.d.msg = kony.sync.getErrorMessage(kony.sync.errorCodeTransaction);
        result.d.errorInfo = kony.sync.errorObject.errorInfo;
        sync.log.error(result.d.msg);
    } else {
        result.d.msg = errorMessage;
        result.d.errorInfo = errorInfo;
        result.d.opstatus = errorCode;
    }
    return result;
};
//This method will store chunks in DB
kony.sync.storeChunkInDB = function(payloadId, chunkId, chunkData, scopeName, callback, storedChunkCallback) {
    sync.log.trace("Entering kony.sync.storeChunkInDB for chunkId " + chunkId);
    var isError = false;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.storeChunkInDB->transactionCallback for chunkID " + chunkId);
        sync.log.trace("kony.sync.storeChunkInDB - payloadId -> " + payloadId + " chunkId -> " + chunkId + " chunkData -> ", chunkData);
        //check for dupicate chunks
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        wcs.push({
            key: kony.sync.chunkTableChunkId,
            value: chunkId
        });
        wcs.push({
            key: kony.sync.chunkTablePayloadId,
            value: payloadId
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.chunkTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultset = kony.sync.executeSql(tx, sql, params);
        sync.log.trace("kony.sync.storeChunkInDB - resultset for check duplicate counts ", resultset);
        if (resultset === null || resultset === false) {
            isError = true;
            return;
        }
        if (resultset.rows.length > 0) {
            //ignore the chunk as it is already stored by some earlier call
            return;
        }
        //store chunk into DB
        var values = {};
        values[kony.sync.chunkTableChunkData] = chunkData;
        values[kony.sync.chunkTableChunkId] = chunkId;
        values[kony.sync.chunkTablePayloadId] = payloadId;
        values[kony.sync.metaTableScopeColumn] = scopeName;
        values[kony.sync.chunkTableTimeStamp] = (new Date()).toString();
        query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_insert(query, kony.sync.chunkTableName);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        var storeChunkResultSet = kony.sync.executeSql(tx, sql, params);
        sync.log.trace("kony.sync.storeChunkInDB - resultset storing chunk into db ", storeChunkResultSet);
        if (storeChunkResultSet === false || storeChunkResultSet === null) {
            isError = true;
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.storeChunkInDB->transactionFailedCallback");
        callback(chunkId, kony.sync.getTransactionError(isError));
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.storeChunkInDB->transactionSuccessCallback");
        callback(chunkId);
    }
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        sync.log.trace("kony.sync.storeChunkInDb - dbConnection successful");
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }
};
//This method will retrieve all chunks from DB
kony.sync.getChunksFromDB = function(payloadId, chunkCount, scopeName, callback) {
    sync.log.trace("Entering kony.sync.getChunksFromDB");
    var isError = false;
    var base64 = "";
    var unknownError = "";
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.getChunksFromDB->transactionCallback");
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        wcs.push({
            key: kony.sync.chunkTablePayloadId,
            value: payloadId
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_select(query, null);
        kony.sync.qb_orderBy(query, [{
            key: kony.sync.chunkTableChunkId,
            sortType: "asc"
        }]);
        kony.sync.qb_from(query, kony.sync.chunkTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultset = kony.sync.executeSql(tx, sql, params);
        if (resultset === false) {
            isError = true;
            return;
        }
        if (resultset.rows.length !== chunkCount) {
            //should never reach here
            unknownError = "Unknown Error: Chunks in DB(" + resultset.rows.length + ") are not equal to chunkcount(" + chunkCount + ")";
            sync.log.error(unknownError);
            isError = true;
            return;
        }
        for (var i = 0; i < resultset.rows.length; i++) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
            base64 = base64 + rowItem[kony.sync.chunkTableChunkData];
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.getChunksFromDB->transactionFailedCallback");
        callback(null, true, isError === true ? 1 : 2);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.getChunksFromDB->transactionSuccessCallback");
        if (isError) {
            callback(unknownError, true);
        } else {
            callback(base64, false);
        }
    }
};
//clear chunking info from DB
kony.sync.clearChunkForPayload = function(payloadId, scopeName, chunkError, callback) {
    sync.log.trace("Entering kony.sync.clearChunkForPayload");
    var isError = false;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.clearChunkForPayload->transactionCallback");
        //set complete flag in metainfo table
        var values = {};
        values[kony.sync.metaTableChunkAck] = kony.sync.chunkCompleteButNotAcknowledged;
        //if problem occurred while chunking, mark discard flag for next download
        if (chunkError === true) {
            values[kony.sync.metaTableChunkDiscarded] = kony.sync.chunkDiscarded;
        }
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_update(query, kony.sync.chunkMetaTableName);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
            return;
        }
        //clearing chunkdata from chunk table
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        wcs.push({
            key: kony.sync.chunkTablePayloadId,
            value: payloadId
        });
        query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_delete(query, kony.sync.chunkTableName);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
            return;
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.clearChunkForPayload->transactionFailedCallback");
        var errMsg = "";
        if (isError) {
            errMsg = "Error occurred while clearing chunk information from " + kony.sync.chunkTableName;
            callback({
                "errorCode": kony.sync.errorCodeSQLStatement,
                "errorMessage": errMsg
            }, true);
        } else {
            errMsg = "Error occurred while opening transaction for clearing chunk information from " + kony.sync.chunkTableName;
            callback({
                "errorCode": kony.sync.errorCodeTransaction,
                "errorMessage": errMsg
            }, true);
        }
        sync.log.error(errMsg);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.clearChunkForPayload->transactionSuccessCallback");
        callback(null, false);
    }
};
kony.sync.getChunkSize = function() {
    sync.log.trace("Entering kony.sync.getChunkSize");
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.chunkSizeKey])) {
        return kony.sync.currentSyncConfigParams[kony.sync.chunkSizeKey].toString();
    }
};
//This API checks whether chunking should be called before download or not
kony.sync.checkForChunkingBeforeDownload = function(serverblob, normalDownloadCallback, downloadNetworkCallback, schemaUpgradeServerblob) {
    sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload");
    var scopeName = kony.sync.currentScope[kony.sync.scopeName];
    var isError = false;
    var chunkingResumed = 0;
    var lastsynctime = serverblob;
    var chunkData = [];
    var chunkMetaData = null;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload->transactionCallback");
        var wcs = [];
        wcs.push({
            key: kony.sync.metaTableScopeColumn,
            value: scopeName
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_where(query, wcs);
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.chunkMetaTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultset = kony.sync.executeSql(tx, sql, params);
        if (resultset === false) {
            isError = true;
            return;
        }
        if (resultset.rows.length > 0) {
            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            var pendingAck = rowItem[kony.sync.metaTableChunkAck];
            var chunkDiscarded = rowItem[kony.sync.metaTableChunkDiscarded];
            if (pendingAck === 0 && chunkDiscarded === 0) {
                chunkingResumed = 1; //resume chunking				
            } else {
                chunkingResumed = 2; //just send payloadid for acknowledgement
            }
            chunkMetaData = rowItem; //get meta data
            if (chunkingResumed === 2 && pendingAck !== kony.sync.chunkCompleteAndWaitingForAck) {
                //updating metadata status as sent for acknowledgement
                var values = {};
                values[kony.sync.metaTableChunkAck] = kony.sync.chunkCompleteAndWaitingForAck;
                query = kony.sync.qb_createQuery();
                kony.sync.qb_where(query, wcs);
                kony.sync.qb_set(query, values);
                kony.sync.qb_update(query, kony.sync.chunkMetaTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                resultset = kony.sync.executeSql(tx, sql, params);
                if (resultset === false) {
                    isError = true;
                    return;
                }
            }
            //get chunk ids for that payloadid
            wcs = [];
            wcs.push({
                key: kony.sync.metaTableScopeColumn,
                value: scopeName
            });
            wcs.push({
                key: kony.sync.chunkTablePayloadId,
                value: rowItem[kony.sync.metaTablePayloadId]
            });
            query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, [kony.sync.chunkTableChunkId]);
            kony.sync.qb_where(query, wcs);
            kony.sync.qb_from(query, kony.sync.chunkTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            resultset = kony.sync.executeSql(tx, sql, params);
            if (resultset === false) {
                isError = true;
                return;
            }
            for (var i = 0; i < resultset.rows.length; i++) {
                rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
                chunkData[i] = rowItem[kony.sync.chunkTableChunkId];
            }
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload->transactionSuccessCallback");
        if (chunkingResumed === 1) {
            //continue chunking from last point
            var params = kony.sync.getChunkingParams(lastsynctime, schemaUpgradeServerblob);
            var hashSum = chunkMetaData[kony.sync.metaTableChunkHashSum];
            var chunkCount = chunkMetaData[kony.sync.metaTableChunkCount];
            var payloadId = chunkMetaData[kony.sync.metaTablePayloadId];
            kony.sync.globalIsDownloadStarted = false;
            kony.sync.isChunkingResumedPostSyncError = true;
            kony.sync.downloadChunks(kony.sync.getChunkDownloadURL(), params, payloadId, chunkCount, hashSum, null, true, chunkData, downloadNetworkCallback);
        } else if (chunkingResumed === 2) {
            normalDownloadCallback(chunkMetaData[kony.sync.metaTablePayloadId]);
        } else {
            //proceed with normal download
            normalDownloadCallback();
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.checkForChunkingBeforeDownload->transactionFailedCallback");
        var errMsg = "";
        if (isError) {
            errMsg = "Error occurred while inserting chunk information in metatable";
            downloadNetworkCallback(kony.sync.frameDownloadError(null, errMsg, 1));
        } else {
            errMsg = "Error occurred while opening transaction to store chunk information in metatable";
            downloadNetworkCallback(kony.sync.frameDownloadError(null, errMsg, 2));
        }
        sync.log.error(errMsg);
    }
};
kony.sync.getChunkingParams = function(serverblob, schemaUpgradeServerblob) {
    sync.log.trace("Entering kony.sync.getChunkingParams");
    //create params
    if (kony.sync.isNullOrUndefined(serverblob)) {
        serverblob = "";
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    if (kony.sync.schemaUpgradeDownloadPending) {
        params.tickcount = schemaUpgradeServerblob;
        params.uppertickcount = serverblob;
        if (!kony.sync.isNullOrUndefined(kony.sync.schemaUpgradeContext)) {
            params.upgradecontext = kony.sync.schemaUpgradeContext;
        }
    } else {
        params.tickcount = serverblob;
    }
    params.clientid = kony.sync.getDeviceID();
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    return params;
};
//API to abort all pending chunk requests
sync.cancelPendingChunkRequests = function(successcallback, errorcallback) {
    sync.log.trace("Entering kony.sync.cancelPendingChunkRequests");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    var isError = false;
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, transactionFailedCallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, transactionCallback, transactionFailedCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.cancelPendingChunkRequests->transactionCallback");
        //change status in metatable to discarded
        var values = {};
        values[kony.sync.metaTableChunkDiscarded] = kony.sync.chunkDiscarded;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_set(query, values);
        kony.sync.qb_update(query, kony.sync.chunkMetaTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
        }
        //delete pending chunks from chunk table
        query = kony.sync.qb_createQuery();
        kony.sync.qb_delete(query, kony.sync.chunkTableName);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isError = true;
            return;
        }
    }

    function transactionFailedCallback() {
        sync.log.trace("Entering kony.sync.cancelPendingChunkRequests->transactionFailedCallback");
        kony.sync.callTransactionError(errorcallback, isError);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.cancelPendingChunkRequests->transactionSuccessCallback");
        kony.sync.verifyAndCallClosure(successcallback);
    }
};
//This will delete chunk data from metatable after receiving acknowledgement
kony.sync.clearChunkMetaData = function(tx, scopeName) {
    sync.log.trace("Entering kony.sync.clearChunkMetaData");
    var wcs = [];
    wcs.push({
        key: kony.sync.metaTableScopeColumn,
        value: scopeName
    });
    wcs.push({
        key: kony.sync.metaTableChunkAck,
        value: kony.sync.chunkCompleteAndWaitingForAck
    });
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_where(query, wcs);
    kony.sync.qb_delete(query, kony.sync.chunkMetaTableName);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.callOnChunkStart = function(chunkCount, payloadId, scope, chunkid, chunkRequest) {
    sync.log.trace("Entering kony.sync.callOnChunkStart");
    var params = {};
    params[kony.sync.chunkCountKey] = chunkCount.toString();
    params[kony.sync.payloadIdKey] = payloadId;
    params[kony.sync.metaTableScopeColumn] = scope;
    params[kony.sync.chunkTableChunkId] = chunkid;
    params[kony.sync.chunkRequestKey] = chunkRequest;
    return kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onChunkStart], params);
};
kony.sync.callOnChunkSuccess = function(chunkCount, payloadId, scope, chunkid, pendingChunks, chunksDownloaded, serverParams) {
    sync.log.trace("Entering kony.sync.callOnChunkSuccess");
    var params = {};
    params[kony.sync.chunkCountKey] = chunkCount.toString();
    params[kony.sync.payloadIdKey] = payloadId;
    params[kony.sync.metaTableScopeColumn] = scope;
    params[kony.sync.chunkTableChunkId] = chunkid;
    params[kony.sync.pendingChunksKey] = pendingChunks;
    params[kony.sync.chunksDownloadedKey] = chunksDownloaded;
    params[kony.sync.serverDetails] = serverParams;
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onChunkSuccess], params);
};
kony.sync.callOnChunkError = function(chunkCount, payloadId, scope, chunkid, pendingChunks, chunksDownloaded, errorCode, errorMsg, serverParams, errorInfo) {
    sync.log.trace("Entering kony.sync.callOnChunkError");
    var params = {};
    params[kony.sync.chunkCountKey] = chunkCount.toString();
    params[kony.sync.payloadIdKey] = payloadId;
    params[kony.sync.metaTableScopeColumn] = scope;
    params[kony.sync.chunkTableChunkId] = chunkid;
    params[kony.sync.pendingChunksKey] = pendingChunks;
    params[kony.sync.chunksDownloadedKey] = chunksDownloaded;
    params.errorCode = errorCode;
    params.errorMessage = errorMsg;
    params[kony.sync.serverDetails] = serverParams;
    params.errorInfo = errorInfo;
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onChunkError], params);
};
kony.sync.clearChunkMetaDataAndAllChunks = function(payloadId, scopeName, successCallback, errorCallback) {
        sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData");
        var isError = false;
        var dbName = kony.sync.currentScope[kony.sync.scopeDataSource];
        var dbConnection = kony.sync.getConnectionOnly(dbName, dbName, transactionErrorCallback);
        if (dbConnection !== null) {
            kony.db.transaction(dbConnection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
        }

        function transactionCallback(tx) {
            //clearing metadata from konysyncCHUNKMETAINFO table for particular payloadId
            sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData->transactionCallback");
            var wcs = [];
            wcs.push({
                key: kony.sync.metaTableScopeColumn,
                value: scopeName
            });
            wcs.push({
                key: kony.sync.chunkTablePayloadId,
                value: payloadId
            });
            query = kony.sync.qb_createQuery();
            kony.sync.qb_where(query, wcs);
            kony.sync.qb_delete(query, kony.sync.chunkMetaTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
            //clearing all chunks from konysyncCHUNKDATA table for particular payloadId
            query = kony.sync.qb_createQuery();
            kony.sync.qb_where(query, wcs);
            kony.sync.qb_delete(query, kony.sync.chunkTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
        }

        function transactionErrorCallback() {
            sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData->transactionErrorCallback");
            if (isError) {
                sync.log.trace("Error occurred while deleting chunk data for invalid payloadid from konysyncCHUNKMETAINFO/konysyncCHUNKDATA");
            } else {
                sync.log.trace("Transaction occurred when deleting chunk data from konysyncCHUNKMETAINFO/konysyncCHUNKDATA");
            }
            errorCallback(isError);
        }

        function transactionSuccessCallback() {
            sync.log.trace("Entering kony.sync.clearAllChunksAndChunkMetaData->transactionSuccessCallback");
            successCallback();
        }
    }
    //  **************** End KonySyncChunkingHelper.js*******************
    //  **************** Start KonySyncDataReconciliation.js*******************
    //  **************** Start KonySyncDataReconciliation.js*******************
kony.sync.tempTableKey = "_tempReconciliation";
kony.sync.reconcileCacheKey = "_cacheReconciliation";
kony.sync.currentReconcileScopeIndex = null;
kony.sync.lastProcessedTables = {};
kony.sync.ReconcileErrorMessage = {};
kony.sync.reconcileBatchingBlobContext = {};
kony.sync.currentReconcileReturnParams = {};
kony.sync.reconcileObjectLevelInfoMap = {};
kony.sync.isReconciliationInProgress = false;
kony.sync.reconcileTotalDownloaded = 0;
kony.sync.reconcileTotalInserts = 0;
kony.sync.reconcileTotalDeletes = 0;
kony.sync.reconcilePendingScopes = {};
kony.sync.reconcilePendingRecords = [];
kony.sync.preProcessReconcileConfig = function(opname, config, errorcallback) {
    sync.log.trace("Entering kony.sync.preProcessReconcileConfig ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return false;
    }
    if (!kony.sync.scopenameExist(config, errorcallback)) {
        return false;
    }
    if (kony.sync.isReconciliationInProgress) {
        sync.log.warn("Reconciliation Session already in progress...");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeReconcileSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeReconcileSessionInProgress), null));
        return false;
    }
    if (kony.sync.isSessionInProgress) {
        sync.log.warn("Sync Session already in progress...");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeSessionInProgress), null));
        return false;
    }
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    config.appVersion = kony.sync.configVersion; //konysyncClientSyncConfig.Version;
    kony.sync.currentSyncConfigParams = config;
    kony.sync.uploadClientContext = {};
    kony.sync.downloadClientContext = {};
    kony.sync.downloadReconcileClientContext = {};
    kony.sync.bulkGetDownloadReconcileClientContext = {};
    kony.sync.isReconciliationInProgress = true;
    sync.log.debug("Starting reconcile. " + opname + " with Current Config Params : ", config);
    kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey]);
    kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey] = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.maxParallelChunksKey]);
    kony.sync.resetsyncsessionglobals(opname);
};
//kony.sync.reconcile
sync.startReconciliation = function(config) {
    sync.log.trace("Entering sync.startReconciliation");
    if (kony.sync.validateSyncConfigParams("startReconciliation", config) === false) {
        return;
    }
    if (kony.sync.preProcessReconcileConfig("startReconciliation", config, config[kony.sync.onReconciliationError]) === false) {
        return;
    }

    function initReconcileMetaInfo(reconcileScopes) {
        sync.log.trace("Entering initReconcileMetaInfo");

        function initReconcileDictionaryForScope(scopeName) {
            sync.log.trace("Entering  initReconcileDictionaryForScope");
            if (kony.sync.isNullOrUndefined(kony.sync.reconcileScopes[scopeName])) {
                kony.sync.reconcileScopes[scopeName] = {};
            }
            if (kony.sync.isNullOrUndefined(kony.sync.reconcileScopes[scopeName].ReconcileTables)) {
                kony.sync.reconcileScopes[scopeName].ReconcileTables = [];
            }
        }
        //storing  reconcilation metadata for data reconciliation
        sync.log.trace("Entering function initReconcileMetaInfo")
        kony.sync.reconcileScopes = {};
        //array to store list of scopes to be iterated
        kony.sync.reconcileScopes.scopeList = [];
        if (!kony.sync.isEmptyObject(reconcileScopes)) {
            for (var scopeName in reconcileScopes) {
                //checking if the scope is undefined
                if (kony.sync.isNullOrUndefined(kony.sync.scopeDict[scopeName])) {
                    sync.log.error("scope:" + scopeName + " doesnot exists...");
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeScopeDoesNotExist, kony.sync.getErrorMessage(kony.sync.errorCodeScopeDoesNotExist, scopeName), null));
                    return false;
                }
                var scopeTablesArray = reconcileScopes[scopeName];
                if (scopeTablesArray instanceof Array === false) {
                    sync.log.error("value of scope " + scopeName + " Array required ");
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeInvalidReconcileConfig, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidReconcileConfig, scopeName), null));
                    return false;
                }
                var currentScope = kony.sync.scopeDict[scopeName];
                initReconcileDictionaryForScope(scopeName);
                if (scopeTablesArray.length == 0) {
                    for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                        var syncTable = currentScope.ScopeTables[i];
                        var tablename = syncTable.name;
                        kony.sync.reconcileScopes[scopeName].ReconcileTables.push(syncTable.Name);
                    }
                } else {
                    for (var i = 0; i < scopeTablesArray.length; i++) {
                        var tableMap = scopeTablesArray[i];
                        if (tableMap instanceof Object === false) {
                            sync.log.error("value of table for " + scopeName + " for index" + i + " Object required ");
                            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeInvalidReconcileConfig, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidReconcileConfig, scopeName), null));
                            return false;
                        }
                        for (tablename in tableMap) {
                            //checkiing if the table is undefined
                            if (kony.sync.isNullOrUndefined(kony.sync.scopes.syncTableScopeDic[tablename])) {
                                sync.log.error("table:" + tablename + " doesnot exists... in scope " + scopeName);
                                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorCodeTableDoesNotExist, kony.sync.getErrorMessage(kony.sync.errorCodeTableDoesNotExist, tablename, scopeName), null));
                                return false;
                            }
                            kony.sync.reconcileScopes[scopeName].ReconcileTables.push(tablename);
                        }
                    }
                }
                kony.sync.reconcileScopes.scopeList.push(scopeName);
            }
        } else {
            //reconcilescopes parameters is empty so reconciliation is done for all the scopes
            var syncscopes = kony.sync.scopes;
            for (var i = 0; i < kony.sync.scopes.length; i++) {
                var scopeName = syncscopes[i].ScopeName;
                initReconcileDictionaryForScope(scopeName);
                var currentScope = kony.sync.scopeDict[scopeName];
                if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
                    for (var k = 0; k < currentScope.ScopeTables.length; k++) {
                        var syncTable = currentScope.ScopeTables[k];
                        var tablename = syncTable.Name;
                        kony.sync.reconcileScopes[scopeName].ReconcileTables.push(tablename);
                    }
                }
                kony.sync.reconcileScopes.scopeList.push(scopeName);
            }
        }
        return true; //successfully initialised
    }

    function validateReconcileConfig() {
        sync.log.trace("Entering validateReconcileConfig");
        if (config.hasOwnProperty("reconciliation") === true) {
            var reconcileScopes = config.reconciliation;
            var isError = initReconcileMetaInfo(reconcileScopes);
            if (isError === false) {
                kony.sync.isReconciliationInProgress = false;
                return;
            }
        } else {
            kony.sync.isReconciliationInProgress = false;
            sync.log.error("No reconciliation data is defined in the config");
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getErrorTable(kony.sync.errorReconcileKeyUndefined, kony.sync.getErrorMessage(kony.sync.errorReconcileKeyUndefined), null));
            return;
        }
        //After validations calling reconcilationstart callback
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationStart], config);
        var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, startReconcileErrorCallBack, "reconcile sync session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, startReconcileTransactionCallBack, startReconcileSuccessCallBack, startReconcileErrorCallBack, "reconcile sync session");
        }
    }

    function startReconcileTransactionCallBack(tx) {
        sync.log.trace("Entering startReconcileTransactionCallBack");

        function createTempTables() {
            sync.log.trace("Entering function createTempTables ");
            //creating temp tables to store the downloaded data
            var scopeNames = kony.sync.reconcileScopes.scopeList;
            for (var i = 0; i < scopeNames.length; i++) {
                var scopeName = scopeNames[i];
                var reconcileTables = kony.sync.reconcileScopes[scopeName].ReconcileTables;
                for (var j = 0; j < reconcileTables.length; j++) {
                    var tableName = reconcileTables[j];
                    var sql = "create table " + tableName + "" + kony.sync.tempTableKey + " ( "
                    var scope = kony.sync.scopeDict[scopeName];
                    var syncTable = scope.syncTableDic[tableName];
                    var columns = syncTable.Columns;
                    var pkColumns = syncTable.Pk_Columns;
                    var pkCount = pkColumns.length;
                    for (var k = 0, pks = 0; k < columns.length; k++) {
                        var syncColumn = columns[k];
                        if (syncColumn.IsPrimaryKey === true) {
                            if (syncColumn.type === "string") {
                                var stringSize = syncColumn.Length;
                                if (kony.sync.isNullOrUndefined(stringSize)) {
                                    stringSize = 4000;
                                }
                                sql += syncColumn.Name + " nvarchar( " + stringSize + " ) not null ";
                            } else sql += syncColumn.Name + " " + syncColumn.type + " not null ";
                            if (pks != pkCount - 1) {
                                sql += ",";
                            } else {
                                sql += " )";
                            }
                            pks++;
                        }
                    }
                    if (kony.sync.executeSql(tx, sql) === false) {
                        sync.log.error("failure in creating temptable for table " + tableName)
                        isError = true;
                        return;
                    }
                }
            }
        }
        kony.sync.deleteReconcileTempTables(tx);
        createTempTables();
        kony.sync.resetReconcileGlobals();
    }

    function startReconcileSuccessCallBack() {
        sync.log.trace("Entering sync.startReconciliation SuccessCallBack : startReconcileSuccessCallBack ")
            //change scope settings
        kony.sync.currentReconcileScopeIndex = null; //null indicates starting scope
        kony.sync.validateReconcileSession(false);
        //kony.sync.syncDownloadReconcileScopes(null);
    }

    function startReconcileErrorCallBack() {
        sync.log.trace("Entering sync.startReconciliation ErrorCallBack : startReconcileErrorCallBack")
        kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
        kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError]);
        //call reconcileErrorCallBack with apt error
    }
    kony.sync.checkForRegisterDevice(registerDeviceCallback);

    function registerDeviceCallback() {
        sync.log.trace("Entering registerDeviceCallback");
        //check if upgrade is required
        kony.sync.areSyncConfigVersionDifferent(areSyncConfigVersionDifferentCallback);

        function areSyncConfigVersionDifferentCallback(isError, errorObject, isDifferent) {
            sync.log.trace("Entering areSyncConfigVersionDifferentCallback");
            if (isError) {
                kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
                kony.sync.verifyAndCallClosure(config[kony.sync.onReconciliationError], errorObject);
            } else {
                if (isDifferent) {
                    kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
                    kony.sync.verifyAndCallClosure(config[kony.sync.onReconciliationError], {
                        upgradeRequired: true
                    });
                } else {
                    validateReconcileConfig();
                }
            }
        }
    }
}
kony.sync.checkForRegisterDevice = function(onRegisterSuccessCallback) {
    sync.log.trace("Entering kony.sync.checkForRegisterDevice ");
    var registerSuccess = true;
    var alreadyRegistered = false;
    var isError = false;

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.checkForRegisterDevice single_transaction_callback");
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.syncConfigurationColumnDeviceIDName]);
        kony.sync.qb_from(query, kony.sync.syncConfigurationTableName);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError]);
        if (resultSet === false) {
            registerSuccess = false;
            isError = true;
            return;
        }
        if (resultSet.rows.length === 0) {
            isError = true;
            return;
        }
        var record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        sync.log.debug("Device Record: ", record);
        sync.log.debug("Device ID: ", record.DeviceID);
        if (record.DeviceID !== kony.sync.getDeviceID()) {
            kony.sync.konyRegisterDevice(registerDeviceCallback);
            sync.log.info("Registering Device...");
        } else {
            alreadyRegistered = true;
            sync.log.info("Device already registered");
        }
    }

    function registerDeviceCallback(serverResponse) {
        sync.log.trace("Entering registerDeviceCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                sync.log.error("Register Device Response : ", serverResponse);
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse.d));
                kony.sync.isSessionInProgress = false;
            } else {
                sync.log.error("Register Device Response : ", serverResponse);
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse));
                kony.sync.isSessionInProgress = false;
            }
            kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            registerSuccess = false;
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse));
            return;
        }
        if ((serverResponse.d.error === "true")) {
            sync.log.error("Register Device Response : ", serverResponse);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], kony.sync.getServerError(serverResponse.d));
            kony.sync.isSessionInProgress = false;
            kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
            kony.sync.httprequestsinglesession = false;
            registerSuccess = false;
            return;
        }
        sync.log.debug("Register Device Response : ", serverResponse);
        var connection2 = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], "Load device id");
        if (connection2 !== null) {
            kony.sync.startTransaction(connection2, single_device_register_callback, single_transaction_success_callback, single_transaction_error_callback, "Load device id");
        }

        function single_device_register_callback(tx) {
            sync.log.trace("Entering single_device_register_callback");
            kony.sync.instanceId = serverResponse.d.__registerdevice.instanceID;
            var insertTab = {};
            insertTab[kony.sync.syncConfigurationColumnInstanceIDName] = kony.sync.instanceId;
            insertTab[kony.sync.syncConfigurationColumnDeviceIDName] = kony.sync.getDeviceID();
            var wcs = {};
            kony.table.insert(wcs, {
                key: kony.sync.syncConfigurationColumnDeviceIDName,
                value: ""
            });
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, kony.sync.syncConfigurationTableName);
            kony.sync.qb_set(query, insertTab);
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
            alreadyRegistered = true;
            sync.log.info("Register Device success");
        }
    }

    function single_transaction_error_callback() {
        sync.log.trace("Entering single_transaction_error_callback");
        sync.log.error("Register Device failed");
        //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getSyncRegisterationFailed());
        kony.sync.isSessionInProgress = false;
        kony.sync.httprequestsinglesession = false;
        kony.sync.isReconciliationInProgress = false; //resetting the reconcile session flag
        kony.sync.callTransactionError(isError, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError]);
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (registerSuccess && alreadyRegistered && !isError) {
            onRegisterSuccessCallback();
        } else if (isError) {
            sync.log.fatal("SynConfigTable is empty. There seems to be problem in sync.init");
            kony.sync.getErrorTable(kony.sync.errorCodeMetatableError, kony.sync.getErrorMessage(kony.sync.errorCodeMetatableError), null);
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], "Device Registration");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Device Registration");
    }
}
kony.sync.syncDownloadReconcileScopes = function(serverblob) {
        sync.log.trace("Entering kony.sync.syncDownloadReconcileScopes ");

        function populateChangeSet(newserverblob, scopeName) {
            sync.log.trace("Entering populateChangeSet");
            var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
            var scope = kony.sync.scopeDict[scopeName];
            var dataSourceURI = scope[kony.sync.scopeDataSource];
            var changeset = {
                clientid: kony.sync.getDeviceID(),
                serverblob: newserverblob,
                scopeName: scopeName,
                uri: dataSourceURI,
                tables: []
            };
            return changeset;
        }
        var serverChanges = null;
        var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        var changeset = populateChangeSet(serverblob, scopeName);
        var isError = false;
        kony.sync.konyReconcileChanges(scopeName, changeset, serverblob, downloadcallback);
        var readyToComputeTables = [];
        var newserverblob = null;
        var morechanges = false;
        var pendingbatches = null;
        var serverChangesCount = 0;
        var clientDownloadCount = 0;

        function downloadNextBatch(tx) {
            sync.log.trace("Entering downloadNextBatch");
            morechanges = serverChanges.d.__sync.moreChangesAvailable;
            newserverblob = serverChanges.d.__sync.serverblob;
            //kony.sync.reconcilePendingBatches = serverChanges.d.__sync.pendingBatches;
            //kony.sync.currentReconcileReturnParams[kony.sync.lastSyncTimestamp] = serverblob;
            processChanges(tx, serverChanges);
        }

        function computeLeftOverChanges(postProcessingChanges) {
            sync.log.trace("Entering computeLeftOverChanges");
            for (var tablename in kony.sync.lastProcessedTables) {
                readyToComputeTables.push(tablename);
            }
            kony.sync.computeDifference(readyToComputeTables, postProcessingChanges);
        }
        //populate batch statistics
        function getBatchContext() {
            sync.log.trace("Entering  getBatchContext");
            var batchcontext = {};
            batchcontext[kony.sync.reconcileBatchDownloads] = kony.sync.reconcileTotalBatchDownloads;
            batchcontext[kony.sync.reconcileBatchInsertions] = kony.sync.reconcileTotalBatchInserts;
            batchcontext[kony.sync.reconcileBatchDeletions] = kony.sync.reconcileTotalBatchDeletes;
            kony.sync.reconcileTotalDownloaded = kony.sync.reconcileTotalDownloaded + kony.sync.reconcileTotalBatchDownloads;
            kony.sync.reconcileTotalInserts = kony.sync.reconcileTotalInserts + kony.sync.reconcileTotalBatchInserts;
            kony.sync.reconcileTotalDeletes = kony.sync.reconcileTotalDeletes + kony.sync.reconcileTotalBatchDeletes;
            //batchcontext[kony.sync.pendingBatches] = kony.sync.tonumber(kony.sync.reconcilePendingBatches);
            //kony.sync.currentReconcileReturnParams[kony.sync.batchContext] = batchcontext;
            return batchcontext;
        }

        function downloadCompleted() {
            sync.log.trace("Entering datareconciliation downloadCompleted");
            if (readyToComputeTables.length != 0) {
                kony.sync.reconcileBatchingBlobContext["serverblob"] = newserverblob;
                kony.sync.reconcileBatchingBlobContext["morechanges"] = morechanges;
                kony.sync.reconcileBatchingBlobContext["pendingbatches"] = pendingbatches;
                kony.sync.computeDifference(readyToComputeTables, postProcessingChanges);
            } else {
                //morechangesavailable for this scope
                if (morechanges) {
                    //calling successcallback for currentbatch before making a call for next batch
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                    kony.sync.resetReconcileBatchSessionGlobals();
                    kony.sync.syncDownloadReconcileScopes(newserverblob);
                } else {
                    //when there are no changes and no readytocompute tables are available
                    //but there are some last processed table present
                    //so add all lastprocessedtables to readytocomputetables
                    if (kony.sync.isEmptyObject(kony.sync.lastProcessedTables) === false) computeLeftOverChanges(postProcessingChanges);
                    else {
                        //all the changes all are successfully processed
                        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                        kony.sync.resetReconcileBatchSessionGlobals();
                        kony.sync.reconcileCompletedCallback(false, {}); //TODO change to getscopecontext
                    }
                }
            }

            function postProcessingChanges() {
                sync.log.trace("Entering postProcessingChanges");
                //Not called by computeLeftOverChanges
                if (kony.sync.isEmptyObject(kony.sync.reconcileBatchingBlobContext) === false) {
                    var savedBlobContext = kony.sync.reconcileBatchingBlobContext;
                    var _moreChanges = savedBlobContext.morechanges;
                    var _serverblob = savedBlobContext.serverblob;
                    kony.sync.reconcileBatchingBlobContext = {}; //resetting it to empty
                    if (_moreChanges) {
                        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                        kony.sync.resetReconcileBatchSessionGlobals();
                        kony.sync.syncDownloadReconcileScopes(_serverblob);
                    } else {
                        //this case happens when there are some lastprocessedtables left which are yet to be processed
                        if (kony.sync.isEmptyObject(kony.sync.lastProcessedTables) === false) computeLeftOverChanges(postProcessingChanges);
                        sync.log.debug("Reconciliation is completed successfully ");
                    }
                } else {
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingSuccess], getBatchContext());
                    kony.sync.resetReconcileBatchSessionGlobals();
                    //all the changes for current scope are successfully processed
                    kony.sync.reconcileCompletedCallback(false, {}); //TODO change to getscopecontext
                }
            }
        }

        function downloadNextBatchFailed(error) {
            sync.log.trace("Entering downloadNextBatchFailed");
            //alert("error in batch download " +JSON.stringify(error));
            sync.log.error("error in batch download " + JSON.stringify(error));
            if (isError) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
            } else {
                kony.sync.reconcileCompletedCallback(true, kony.sync.errorObject);
                kony.sync.errorObject = null;
            }
        }

        function downloadcallback(serverChangesResult) {
            sync.log.trace("Entering downloadcallback");
            serverChanges = serverChangesResult;
            sync.log.info("ServerChanges:", serverChanges);
            if (!kony.sync.isNullOrUndefined(serverChanges.opstatus) && serverChanges.opstatus != 0) {
                if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
                    kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges.d, "download"));
                } else {
                    kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
                }
                return;
            } else if (kony.sync.isNullOrUndefined(serverChanges.d)) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
                return;
            }
            kony.sync.currentReconcileReturnParams[kony.sync.serverDetails] = {};
            kony.sync.currentReconcileReturnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(serverChanges);
            kony.sync.currentReconcileReturnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(serverChanges);
            if ((serverChanges.d.error === "true")) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
                return;
            }
            var dbname = kony.sync.syncConfigurationDBName;
            var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncFailed);
            if (dbconnection === null) {
                return;
            }
            kony.db.transaction(dbconnection, downloadNextBatch, downloadNextBatchFailed, downloadCompleted);
        }

        function processChanges(tx, serverChanges) {
            sync.log.trace("Entering processChanges");
            //insert pk data into tempReconciliationtables
            sync.log.info("Entering data reconciliation processChanges ");
            var results = serverChanges.d.results;
            var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
            var reconcileList = kony.sync.reconcileScopes[scopeName].ReconcileTables;
            var processedTableNames = {};
            for (var i = 0; i < results.length; i++) {
                var row = results[i];
                var tableName = row.__metadata.type;
                //initialising object level info map
                kony.sync.initReconcileObjectLevelInfoMap(tableName);
                var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
                var scope = kony.sync.scopeDict[scopename];
                var changeType = row.__metadata.changeType; //not required
                //add into processedTableNames
                processedTableNames[tableName] = "true";
                var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
                var length = pkColumns.length;
                var record = [];
                for (var j = length - 1; j >= 0; j--) {
                    if (!kony.sync.isNullOrUndefined(row[pkColumns[j]])) {
                        record[pkColumns[j]] = row[pkColumns[j]];
                    }
                }
                var query = kony.sync.qb_createQuery();
                kony.sync.qb_set(query, record);
                kony.sync.qb_insert(query, tableName + kony.sync.tempTableKey);
                query_compile = kony.sync.qb_compile(query);
                var sql = query_compile[0];
                var params = query_compile[1];
                var result = kony.sync.executeSql(tx, sql, params);
                //exit incase of SQL error
                if (result === false) {
                    sync.log.error("row insertion failed" + JSON.stringify(result));
                    isError = true;
                    return false;
                }
                kony.sync.reconcileTotalBatchDownloads = kony.sync.reconcileTotalBatchDownloads + 1;
                kony.sync.reconcileObjectLevelInfoMap[tableName][kony.sync.reconcileTotalDownloads] += 1;
            }
            for (var currentTableName in processedTableNames) {
                if (!kony.sync.isNullOrUndefined(kony.sync.lastProcessedTables[currentTableName])) {
                    delete kony.sync.lastProcessedTables[currentTableName];
                }
            }
            for (var tablename in kony.sync.lastProcessedTables) {
                readyToComputeTables.push(tablename);
            }
            kony.sync.lastProcessedTables = {};
            for (var currentTableName in processedTableNames) {
                kony.sync.lastProcessedTables[currentTableName] = "true";
            }
        };
    }
    //getAllPks call
kony.sync.konyReconcileChanges = function(scopeName, changeset, serverblob, downloadNetworkCallback) {
    sync.log.trace("Entering kony.sync.konyReconcileChanges ");
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function fetchGetAllPKSContext() {
        sync.log.trace("Entering fetchGetAllPKSContext");
        var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        var scope = kony.sync.scopeDict[scopeName];
        var FilterContext = {};
        var scopeReconcileTables = kony.sync.reconcileScopes[scopeName].ReconcileTables;
        for (var k = 0; k < scopeReconcileTables.length; k++) {
            var syncTableName = scopeReconcileTables[k];
            var syncTable = scope.syncTableDic[syncTableName];
            if (kony.sync.isNullOrUndefined(FilterContext[syncTableName])) FilterContext[syncTableName] = {};
            if (!kony.sync.isNullOrUndefined(syncTable.Pk_Columns)) {
                var fields = [];
                var pkColumns = syncTable.Pk_Columns;
                for (j = 0; j < pkColumns.length; j++) {
                    fields.push(pkColumns[j]);
                }
                FilterContext[syncTableName].fields = fields;
            }
        }
        //filterparams
        if (kony.sync.isValidJSTable(kony.sync.currentSyncConfigParams[kony.sync.filterParams])) {
            kony.sync.currentSyncScopeFilter = kony.sync.currentSyncConfigParams[kony.sync.filterParams][scopeName];
        }
        return FilterContext;
    }

    function downloadNetworkCallbackStatus(status, result) {
        sync.log.trace("Entering downloadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyReconcileChanges->downloadNetworkCallbackStatus");
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, null, retries, downloadNetworkCallback, params);
            } else {
                kony.sync.setSessionID(result);
                downloadNetworkCallback(result);
            }
        } else if (status === 300) {
            downloadNetworkCallback(kony.sync.getNetworkCancelError());
        }
    }
    if (kony.sync.isNullOrUndefined(serverblob)) {
        serverblob = "";
    }
    var params = {};
    var filterparams = fetchGetAllPKSContext();
    var reconcileScopefilter = {
        "d": filterparams
    };
    var jsonContext = null;
    var filterParams = null;
    jsonContext = JSON.stringify(reconcileScopefilter);
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
        var scopejsonfilter = {
            "d": {
                Filters: kony.sync.currentSyncScopeFilter
            }
        };
        filterParams = JSON.stringify(scopejsonfilter);
    }
    kony.sync.commonServiceParams(params);
    params.filterContext = jsonContext;
    params.context = filterParams;
    params.enablebatching = "true";
    params.batchsize = kony.sync.getReconcileDownloadBatchSize();
    params.tickcount = serverblob;
    params.scopename = scopeName;
    var scope = kony.sync.scopeDict[scopeName];
    params.strategy = scope[kony.sync.syncStrategy];
    params.instanceid = kony.sync.getInstanceID();
    params.clientid = kony.sync.getDeviceID();
    params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    var paramsToSend = null;
    var currentReconcileReturnParamsTemp = kony.sync.currentReconcileReturnParams;
    currentReconcileReturnParamsTemp.downloadRequest = params;
    kony.sync.deleteMapKey(currentReconcileReturnParamsTemp, kony.sync.serverDetails);
    if (kony.sync.isFirstReconcileDownload) {
        paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationDownloadStart], currentReconcileReturnParamsTemp);
        kony.sync.isFirstReconcileDownload = false;
        if (!kony.sync.isNullOrUndefined(paramsToSend)) {
            params = paramsToSend;
            kony.sync.downloadReconcileClientContext = params.clientcontext;
        }
    }
    currentReconcileReturnParamsTemp.downloadRequest = params;
    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBatchprocessingStart], kony.sync.currentReconcileReturnParams);
    if (paramsToSend != null) {
        params = paramsToSend;
        kony.sync.downloadReconcileClientContext = params.clientcontext;
    }
    currentReconcileReturnParamsTemp = null;
    paramsToSend = null;
    params.clientcontext = JSON.stringify(kony.sync.downloadReconcileClientContext);
    sync.log.info("Hitting the service with URL " + kony.sync.getDownloadURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getDownloadURL(), params, downloadNetworkCallbackStatus, null);
};
kony.sync.computeDifference = function(tablenames, postProcessingChangesCallBack) {
    sync.log.trace("Entering kony.sync.computeDifference ");

    function delete_api(tx, tableName, pkColumns) {
        sync.log.trace("Entering delete_api");
        sync.log.info("calling delete_api in kony.sync.computeDifference transaction callback");
        var deleteBatchLimit = kony.sync.reconcileMaxDeleteLimit;
        var offSet = 0;
        var deleteBatchLimitString = deleteBatchLimit.toString();
        while (1) {
            var deleteDeltaRecordsQuery = "SELECT * FROM " + tableName + "" + kony.sync.reconcileCacheKey + " LIMIT " + deleteBatchLimitString + " OFFSET " + offSet;
            var resultset = kony.sync.executeSql(tx, deleteDeltaRecordsQuery); //need to handle error callback if required
            if (resultset != false) {
                var resultset_length = resultset.rows.length;
                //need to delete records one by one hierarchially based on the cascade information
                if (resultset_length >= 1) {
                    var whereClause = "";
                    for (var i = 0; i < resultset_length; i++) {
                        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
                        //check in cascade information provided and delete if and only if the record in not present
                        //in the history table
                        kony.sync.deleteHierarchialChildRecords(tx, rowItem, tableName, computeDifferenceErrorCallBack);
                    }
                }
            } else {
                sync.log.error("Error in delete_api in kony.sync.computeDifference transaction callback while executing query " + deleteDeltaRecordsQuery)
            }
            if (resultset_length < 1000) {
                //rows obtained are less than 1000 ,so all rows are processed for the given table
                break;
            }
            offSet += deleteBatchLimit;
        }
    }
    var recordPKValues = [];
    var isError = false;

    function computeDifferenceTransaction(tx) {
        sync.log.trace("Entering kony.sync.computeDifference transactioncallback ");
        //delete delta A-B
        for (var i = 0; i < tablenames.length; i++) {
            var tableName = tablenames[i];
            var scopeName = kony.sync.scopes.syncTableScopeDic[tableName];
            var scope = kony.sync.scopeDict[scopeName];
            var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
            var length = pkColumns.length;
            var selectClause = "";
            var whereClause = "";
            for (var j = 0; j < length; j++) {
                selectClause += tableName + "." + pkColumns[j];
                whereClause += tableName + "." + pkColumns[j] + " = " + tableName + "" + kony.sync.tempTableKey + "." + pkColumns[j];
                if (j != length - 1) {
                    selectClause += ",";
                    whereClause += " and ";
                }
            }
            //creating the cache table with left join ,here left join is formed between maintable and temptable
            //here the records which are to be deleted will be present in the cache table
            var createTempTable = "create table " + tableName + "" + kony.sync.reconcileCacheKey + " as select " + selectClause + " from " + tableName + " where NOT EXISTS (select 1 from " + tableName + "" + kony.sync.tempTableKey + " where " + whereClause + " )";
            if (kony.sync.executeSql(tx, createTempTable) === false) {
                sync.log.error("Error in creating cache table in executing query" + createTempTable + "in kony.sync.computeDifference computeDifference");
                isError = true;
                return;
            }
            delete_api(tx, tableName, pkColumns);
            //deleting the cache table as the A-B delta calculation is successfully completed
            var dropCacheTable = "drop table if exists " + tableName + "" + kony.sync.reconcileCacheKey;
            if (kony.sync.executeSql(tx, dropCacheTable) === false) {
                sync.log.error("error in executing query  " + dropCacheTable + " in kony.sync.computeDifference computeDifference");
                isError = true;
                return;
            }
            sync.log.debug("successful in executing query  " + dropCacheTable + " in kony.sync.computeDifference computeDifference");
        }
    }

    function computeDifferenceSuccessCallBack() {
        sync.log.trace("Entering kony.sync.computeDifference SuccessCallBack : computeDifferenceSuccessCallBack");
        var tableIndex = 0;
        var Offset = 0;
        kony.sync.downloadReconcileChanges(null, tablenames, tableIndex, Offset, postProcessingChangesCallBack);
    }

    function computeDifferenceErrorCallBack(isError) {
        sync.log.trace("Entering kony.sync.computeDifference ErrorCallBack : computeDifferenceErrorCallBack")
        if (!kony.sync.isNullOrUndefined(isError) && isError === true) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.reconcileCompletedCallback(true, isError);
            kony.sync.errorObject = null;
        }
    }
    var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, computeDifferenceErrorCallBack, "compute  difference");
    if (connection !== null) {
        kony.sync.startTransaction(connection, computeDifferenceTransaction, computeDifferenceSuccessCallBack, computeDifferenceErrorCallBack, "validate scope session");
    }
}
kony.sync.deleteRow = function(tx, parentTableName, rowItem, errorCallBack) {
    sync.log.trace("Entering kony.sync.deleteRow ");

    function delete_row(wcs, tablename) {
        sync.log.trace("Entering delete_row");
        var deleteParentQuery = kony.sync.qb_createQuery();
        kony.sync.qb_delete(deleteParentQuery, tablename);
        kony.sync.qb_where(deleteParentQuery, wcs);
        var query_compile = kony.sync.qb_compile(deleteParentQuery);
        var sql = query_compile[0];
        var params = query_compile[1];
        resultset = kony.db.executeSql(tx, sql, params, errorCallBack);
        if (resultset === false) {
            sync.log.error("Error in kony.sync.deleteHierarchialChildRecordsForRow for parentTable " + tablename + " with query " + sql + " params :" + params);
            return;
        }
    }
    var scopename = kony.sync.scopes.syncTableScopeDic[parentTableName];
    var pkColumns = kony.sync.scopes[scopename].syncTableDic[parentTableName].Pk_Columns;
    var wcs = [];
    for (var i = 0; i < pkColumns.length; i++) {
        wcs.push({
            key: pkColumns[i],
            value: rowItem[pkColumns[i]]
        });
    }
    delete_row(wcs, parentTableName); //delete in main table
    delete_row(wcs, parentTableName + kony.sync.originalTableName); //delete in original table
    kony.sync.reconcileTotalBatchDeletes = kony.sync.reconcileTotalBatchDeletes + 1;
    kony.sync.initReconcileObjectLevelInfoMap(parentTableName);
    kony.sync.reconcileObjectLevelInfoMap[parentTableName][kony.sync.reconcileTotalDeletions] += 1;
}
kony.sync.deleteHierarchialChildRecords = function(tx, rowItem, parentTableName, errorCallBack) {
    sync.log.trace("Entering kony.sync.deleteHierarchialChildRecords-> for parent table " + parentTableName);
    var scopename = kony.sync.scopes.syncTableScopeDic[parentTableName];
    var scope = kony.sync.scopes[scopename];
    var OTM = scope.syncTableDic[parentTableName].Relationships.OneToMany;
    var isDeleteOTM = kony.sync.deleteHierarchialChildRecordsForRow(tx, rowItem, parentTableName, OTM, errorCallBack);
    var MTO = scope.reverseRelationships[parentTableName];
    var isDeleteMTO = kony.sync.deleteHierarchialChildRecordsForRow(tx, rowItem, parentTableName, MTO, errorCallBack);
    var OTO = scope.syncTableDic[parentTableName].Relationships.OneToOne;
    var isDeleteOTO = kony.sync.deleteHierarchialChildRecordsForRow(tx, rowItem, parentTableName, OTO, errorCallBack);
    if (isDeleteOTM === true && isDeleteMTO === true && isDeleteOTO === true) {
        kony.sync.deleteRow(tx, parentTableName, rowItem, errorCallBack);
        return true;
    } else {
        return false;
    }
}
kony.sync.deleteHierarchialChildRecordsForRow = function(tx, rowItem, parentTableName, relationshipSet, errorCallBack) {
    sync.log.trace("Entering kony.sync.deleteHierarchialChildRecordsForRow for parenttable " + parentTableName);
    var allChildsDeleted = true; //true means yes ,false means no
    if (!kony.sync.isNullOrUndefined(relationshipSet)) {
        for (var i = 0; i < relationshipSet.length; i++) {
            var childTableName = relationshipSet[i].TargetObject;
            sync.log.trace("processing childtable :  " + childTableName + " for parent:" + parentTableName);
            var isCascade = false;
            var selectChildrenQuery = null;
            var params = null;
            if (kony.sync.isNullOrUndefined(relationshipSet[i].Cascade)) {
                sync.log.warn("no Cascade flag found for relationship for parentable " + parentTableName + " and " + childTableName + " so cascade is considered as false");
            } else isCascade = relationshipSet[i].Cascade;
            var wcs = [];
            if (!kony.sync.isNullOrUndefined(relationshipSet[i].RelationshipAttributes)) {
                var relationshipAttributes = relationshipSet[i].RelationshipAttributes;
                for (var attName in rowItem) {
                    for (var k = 0; k < relationshipAttributes.length; k++) {
                        if (attName === relationshipAttributes[k].SourceObject_Attribute) {
                            wcs.push({
                                key: relationshipAttributes[k].TargetObject_Attribute,
                                value: rowItem[attName]
                            });
                        }
                    }
                }
                var query = kony.sync.qb_createQuery();
                kony.sync.qb_select(query, null);
                kony.sync.qb_from(query, childTableName);
                kony.sync.qb_where(query, wcs);
                var query_compile = kony.sync.qb_compile(query);
                selectChildrenQuery = query_compile[0];
                params = query_compile[1];
            } else {
                //need to remove this logic as this is not required post 7.0
                wcs[0] = {
                    key: relationshipSet[i].TargetObject_Attribute,
                    value: rowItem[relationshipSet[i].SourceObject_Attribute]
                };
                selectChildrenQuery = "select * from " + childTableName + " where " + relationshipSet[i].TargetObject_Attribute + " = '" + rowItem[relationshipSet[i].SourceObject_Attribute] + "'";
            }
            sync.log.debug("kony.sync.deleteHierarchialChildRecordsForRow executing query  " + selectChildrenQuery + " with params " + params);
            var resultset = kony.sync.executeSql(tx, selectChildrenQuery, params); //need to handle error callback if required
            if (resultset != false) {
                var resultset_length = resultset.rows.length;
                //logic to process the resultset
                if (resultset_length >= 1) {
                    if (isCascade === "true" || isCascade === true) {
                        for (var j = 0; j < resultset_length; j++) {
                            var newRowItem = kony.db.sqlResultsetRowItem(tx, resultset, j);
                            if (childTableName === parentTableName) {
                                var matchCount = 0;
                                var relationshipAttributes = relationshipSet[i].RelationshipAttributes;
                                for (var colName in rowItem) {
                                    for (var attributeIndex = 0; attributeIndex < relationshipAttributes.length; attributeIndex++) {
                                        if (colName === relationshipAttributes[attributeIndex].SourceObject_Attribute) {
                                            var parentColumnValue = rowItem[relationshipAttributes[attributeIndex].SourceObject_Attribute];
                                            var ChildColumnValue = newRowItem[relationshipAttributes[attributeIndex].TargetObject_Attribute];
                                            if (parentColumnValue === ChildColumnValue) {
                                                matchCount++;
                                            }
                                        }
                                    }
                                }
                                if (matchCount == relationshipAttributes.length) {
                                    sync.log.warn("Cyclic dependency ignoring the record " + JSON.stringify(rowItem));
                                    continue;
                                }
                            }
                            sync.log.info("calling kony.sync.deleteHierarchialChildRecords for tablename " + childTableName + " with rowItem " + JSON.stringify(newRowItem));
                            var deletedStatus = kony.sync.deleteHierarchialChildRecords(tx, newRowItem, childTableName);
                            if (deletedStatus === false) allChildsDeleted = false;
                        }
                    } else {
                        allChildsDeleted = false;
                    }
                }
            } else {
                sync.log.info("No Corresponding children:" + childTableName + " found for corresponding parent:" + parentTableName + " for query:" + selectChildrenQuery);
                return;
            }
        }
        return allChildsDeleted;
    } else {
        return true;
    }
}
kony.sync.downloadReconcileChanges = function(serverblob, tableNames, tableIndex, offSet, postProcessingChangesCallBack) {
        sync.log.trace("entering kony.sync.downloadreconcilechanges")
        var recordPKValues = {};
        var totalFetchedRowCount = 0;

        function createCacheTable(tx, currentCacheTableName) {
            sync.log.info("calling  createCacheTable on " + currentCacheTableName + " in transactionCallBack of kony.sync.downloadReconcileChanges");
            var scopename = kony.sync.scopes.syncTableScopeDic[currentCacheTableName];
            var scope = kony.sync.scopeDict[scopename];
            var pkColumns = scope.syncTableDic[currentCacheTableName].Pk_Columns;
            var length = pkColumns.length;
            var pkString = "";
            for (var j = length - 1; j >= 0; j--) {
                pkString += pkColumns[j];
                if (j != 0) {
                    pkString += ",";
                }
            }
            //here this cache table contains the pkrecords on which bulkget needs to be called
            var createBulkGetRowsTable = "create table " + currentCacheTableName + "" + kony.sync.reconcileCacheKey + " as select " + pkString + " from " + currentCacheTableName + "" + kony.sync.tempTableKey + " except select " + pkString + " from " + currentCacheTableName;
            if (kony.sync.executeSql(tx, createBulkGetRowsTable) === false) {
                sync.log.error("failure in creating cache table " + currentCacheTableName + " with query " + createBulkGetRowsTable);
                isError = true;
                return;
            }
        }

        function getRecords(tx, numberOfRecords, offSet, currentCacheTableName) {
            sync.log.info("calling getRecords on " + currentCacheTableName + " in transactionCallBack of kony.sync.downloadReconcileChanges");
            if (kony.sync.isNullOrUndefined(recordPKValues[currentCacheTableName])) {
                recordPKValues[currentCacheTableName] = [];
            }
            var bulkGetDataQuery = "select * from " + currentCacheTableName + "" + kony.sync.reconcileCacheKey + " LIMIT " + numberOfRecords + " OFFSET " + offSet;
            var resultset = kony.sync.executeSql(tx, bulkGetDataQuery); //need to handle error callback if required
            if (resultset != false) {
                var fetchedRowCount = resultset.rows.length;
                if (fetchedRowCount >= 1) {
                    for (var i = 0; i < fetchedRowCount; i++) {
                        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, i);
                        recordPKValues[currentCacheTableName].push(rowItem);
                    }
                }
            } else {
                sync.log.error("failed to getRecords for table " + currentCacheTableName + " with query " + bulkGetDataQuery);
                kony.sync.reconcileCompletedCallback(true, "failed to getRecords for table " + currentCacheTableName + " with query " + bulkGetDataQuery);
            }
            return fetchedRowCount;
        }

        function transactionCallBack(tx) {
            sync.log.trace("entering kony.sync.downloadReconcileChanges transactioncallback ");
            var fetchedRecordsCount = 0;
            var batchSize = kony.sync.getReconcileBulkGetBatchSize(); //change to actual batchsize
            var numberOfRecords = batchSize;
            //var Offset = 0;
            while ((fetchedRecordsCount != batchSize) && (tableIndex < tableNames.length)) {
                var currentCacheTableName = tableNames[tableIndex];
                if (offSet === 0) {
                    createCacheTable(tx, currentCacheTableName);
                }
                var obtainedRecordsCount = getRecords(tx, numberOfRecords, offSet, currentCacheTableName);
                if (obtainedRecordsCount != numberOfRecords) {
                    offSet = 0;
                    numberOfRecords -= obtainedRecordsCount;
                    //current table processing finished
                    var dropTempTable = "drop table if exists " + currentCacheTableName + "" + kony.sync.reconcileCacheKey;
                    if (kony.sync.executeSql(tx, dropTempTable) === false) {
                        sync.log.error("failed to drop the cache table " + currentCacheTableName + "in transactionCallBack of kony.sync.downloadReconcileChanges");
                        isError = true;
                        return;
                    }
                    sync.log.debug("successful : drop the cache table " + currentCacheTableName + "in transactionCallBack of kony.sync.downloadReconcileChanges");
                    tableIndex = tableIndex + 1; //go to next table
                } else {
                    offSet += obtainedRecordsCount;
                }
                fetchedRecordsCount += obtainedRecordsCount;
            }
            totalFetchedRowCount = fetchedRecordsCount;
        }

        function getBulkGetParams() {
            sync.log.info("calling getBulkGetParams in  kony.sync.downloadReconcileChanges successCallBack ");
            var filterParamsMap = {};
            for (var tableName in recordPKValues) {
                if (kony.sync.isNullOrUndefined(filterParamsMap[tableName])) {
                    filterParamsMap[tableName] = {};
                }
                if (kony.sync.isNullOrUndefined(filterParamsMap[tableName].keys)) {
                    filterParamsMap[tableName].keys = [];
                    filterParamsMap[tableName].fields = [];
                }
                var records = filterParamsMap[tableName].keys;
                var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
                var scope = kony.sync.scopeDict[scopename];
                var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
                var columns = scope.syncTableDic[tableName].Columns;
                var fields = filterParamsMap[tableName].fields;
                for (var i = 0; i < columns.length; i++) {
                    fields.push(columns[i].Name);
                }
                var tableResultSet = recordPKValues[tableName];
                for (var i = 0; i < tableResultSet.length; i++) {
                    var pkKeys = [];
                    var rowItem = tableResultSet[i];
                    for (var j = 0; j < pkColumns.length; j++) {
                        var pkColumn = pkColumns[j];
                        var pkMap = {};
                        pkMap.Name = pkColumn;
                        pkMap.Value = rowItem[pkColumn];
                        pkKeys.push(pkMap);
                    }
                    records.push(pkKeys);
                }
            }
            return filterParamsMap;
        }

        function successCallBack() {
            sync.log.trace("entering kony.sync.downloadReconcileChanges successCallBack ");
            if (totalFetchedRowCount == 0) {
                //if all the tables processing is finished we get totalFetchedRowCount as 0
                postProcessingChangesCallBack();
            } else {
                //make params
                var filterParams = getBulkGetParams();
                var contextParams = {
                    "tableNames": tableNames,
                    "tableIndex": tableIndex,
                    "offSet": offSet,
                    "callback": postProcessingChangesCallBack
                };
                kony.sync.applyReconcileDownloadChanges(serverblob, filterParams, contextParams);
            }
        }

        function errorCallBack() {
            sync.log.trace("entering kony.sync.downloadReconcileChanges errorCallBack ");
        }
        var connection = kony.sync.getConnectionOnly(kony.sync.syncConfigurationDBName, kony.sync.syncConfigurationDBName, errorCallBack, "reconcile sync session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, transactionCallBack, successCallBack, errorCallBack, "validate scope session");
        }
    }
    //inserting the delta B-A into database
kony.sync.applyReconcileDownloadChanges = function(serverblob, filterParams, contextParams) {
    sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges");
    var serverChanges = null;
    var newserverblob = null;
    var isError = false;
    bulkGetNetworkCall();

    function bulkGetNetworkCall() {
        sync.log.trace("Entering kony.sync.applyReconcileDownloadChanges :bulkGetNetworkCall");
        var scopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        var scope = kony.sync.scopeDict[scopeName];
        var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

        function downloadNetworkCallbackStatus(status, result) {
            sync.log.trace("Entering downloadNetworkCallbackStatus");
            if (status === 400) {
                sync.log.trace("Entering kony.sync.applyReconcileDownloadChanges->downloadNetworkCallbackStatus");
                if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                    retries--;
                    kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, null, retries, downloadNetworkCallback, params);
                } else {
                    kony.sync.setSessionID(result);
                    downloadNetworkCallback(result);
                }
            } else if (status === 300) {
                downloadNetworkCallback(kony.sync.getNetworkCancelError());
            }
        }
        if (kony.sync.isNullOrUndefined(serverblob)) {
            serverblob = "";
        }
        var params = {};
        var jsonContext = null;
        var reconcileScopefilter = {
            "d": filterParams
        };
        var clientFilterParams = null;
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
            var scopejsonfilter = {
                "d": {
                    Filters: kony.sync.currentSyncScopeFilter
                }
            };
            clientFilterParams = JSON.stringify(scopejsonfilter);
        }
        params.context = clientFilterParams;
        jsonContext = JSON.stringify(reconcileScopefilter);
        kony.sync.commonServiceParams(params);
        params.filterContext = jsonContext;
        params.tickcount = serverblob;
        params.scopename = scopeName;
        params.strategy = scope[kony.sync.syncStrategy];
        params.instanceid = kony.sync.getInstanceID();
        params.clientid = kony.sync.getDeviceID();
        params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
        params.batchsize = kony.sync.getReconcileBulkGetBatchSize();
        params.enablebatching = "true"
        if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
            params.httpconfig = {
                timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
            };
        }
        var paramsToSend = null;
        var currentReconcileReturnParamsTemp = {};
        currentReconcileReturnParamsTemp.downloadRequest = params;
        kony.sync.deleteMapKey(currentReconcileReturnParamsTemp, kony.sync.serverDetails);
        if (kony.sync.isFirstBulkGetReconcileDownload) {
            paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBulkGetDownloadStart], currentReconcileReturnParamsTemp);
            kony.sync.isFirstBulkGetReconcileDownload = false;
            if (!kony.sync.isNullOrUndefined(paramsToSend)) {
                params = paramsToSend;
                kony.sync.bulkGetDownloadReconcileClientContext = params.clientcontext;
            }
        }
        currentReconcileReturnParamsTemp.downloadRequest = params;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBulkGetBatchprocessingStart], currentReconcileReturnParamsTemp);
        if (paramsToSend != null) {
            params = paramsToSend;
            kony.sync.bulkGetDownloadReconcileClientContext = params.clientcontext;
        }
        currentReconcileReturnParamsTemp = null;
        paramsToSend = null;
        params.clientcontext = JSON.stringify(kony.sync.bulkGetDownloadReconcileClientContext);
        sync.log.info("Hitting the service with URL " + kony.sync.getDownloadURL(), params);
        kony.sync.invokeServiceAsync(kony.sync.getDownloadURL(), params, downloadNetworkCallbackStatus, null);
    }

    function transactionCallBack(tx) {
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: transactionCallBack");
        var results = serverChanges.d.results;
        newserverblob = serverChanges.d.__sync.serverblob;
        for (var i = 0; i < results.length; i++) {
            var row = results[i];
            var tablename = row.__metadata.type;
            var changeType = row.__metadata.changeType;
            var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
            var scope = kony.sync.scopes[scopename];
            var columns = scope.syncTableDic[tablename].Columns
            var length = columns.length;
            var record = [];
            for (var j = length - 1; j >= 0; j--) {
                if (!kony.sync.isNullOrUndefined(row[columns[j].Name])) {
                    record[columns[j].Name] = row[columns[j].Name];
                }
            }
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, record);
            kony.sync.qb_insert(query, tablename);
            query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var result = kony.sync.executeSql(tx, sql, params);
            //exit incase of SQL error
            if (result === false) {
                sync.log.error("row insertion failed" + JSON.stringify(result));
                isError = true;
                return false;
            }
            kony.sync.reconcileTotalBatchInserts = kony.sync.reconcileTotalBatchInserts + 1;
            kony.sync.initReconcileObjectLevelInfoMap(tablename);
            kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalInsertions] += 1;
        }
    }

    function successCallBack() {
        sync.log.trace("Entering successCallBack");
        var batchcontext = {};
        batchcontext[kony.sync.reconcileBatchInsertions] = kony.sync.reconcileTotalBatchInserts;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationBulkGetBatchprocessingSuccess], batchcontext);
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: successCallBack");
        var tableNames = contextParams.tableNames;
        var tableIndex = contextParams.tableIndex;
        var offSet = contextParams.offSet;
        var postProcessingChangesCallBack = contextParams.callback;
        if (tableIndex != tableNames.length) {
            kony.sync.downloadReconcileChanges(newserverblob, tableNames, tableIndex, offSet, postProcessingChangesCallBack);
        } else {
            postProcessingChangesCallBack();
        }
    }

    function errorCallBack() {
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: errorCallBack");
        if (!isError) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.reconcileCompletedCallback(true, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function downloadNetworkCallback(serverChangesResult) {
        sync.log.trace("Entering function kony.sync.applyReconcileDownloadChanges: downloadNetworkCallback");
        serverChanges = serverChangesResult;
        sync.log.info("ServerChanges:", serverChanges);
        if (!kony.sync.isNullOrUndefined(serverChanges.opstatus) && serverChanges.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges.d, "download"));
            } else {
                kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
            }
            return;
        } else if (kony.sync.isNullOrUndefined(serverChanges.d)) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
            return;
        }
        if ((serverChanges.d.error === "true")) {
            kony.sync.reconcileCompletedCallback(true, kony.sync.getServerError(serverChanges));
            return;
        }
        var dbname = kony.sync.syncConfigurationDBName;
        var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallBack, "reconcile sync session");
        if (connection !== null) {
            kony.sync.startTransaction(connection, transactionCallBack, successCallBack, errorCallBack, "reconcile sync session");
        }
    }
}
kony.sync.resetReconcileGlobals = function() {
    sync.log.trace("Entering kony.sync.resetReconcileGlobals ");
    kony.sync.lastProcessedTables = {};
    kony.sync.currentReconcileScopeIndex = 0;
    kony.sync.reconcileBatchingBlobContext = {};
    kony.sync.currentReconcileReturnParams = {};
    kony.sync.reconcilePendingScopes = {};
    kony.sync.isReconciliationInProgress = false;
    kony.sync.reconcilePendingRecords = [];
    kony.sync.currentSyncScopeFilter = null;
    kony.sync.resetReconcileSessionGlobals();
    kony.sync.resetReconcileBatchSessionGlobals();
}
kony.sync.isEmptyObject = function(object) {
    sync.log.trace("Entering kony.sync.isEmptyObject ");
    for (var key in object) {
        return false;
    }
    return true;
}
kony.sync.checkIfChangesExistInHistoryTable = function(tx, tablename) {
    sync.log.trace("entering function checkIfChangesExistInHistoryTable for tablename" + tablename);
    var sql = "select count(*) as rowcount from " + tablename + "" + kony.sync.historyTableName;
    var resultset = kony.sync.executeSql(tx, sql, null);
    if (resultset === false) {
        return false;
    } else {
        var record = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        var count = record["rowcount"];
        if (count == 0) {
            return "";
        } else {
            return true;
        }
    }
}
kony.sync.checkForPendingUploadInTransaction = function(scopename, successCallBack, errorCallBack) {
    sync.log.trace("entering function kony.sync.checkForPendingUploadInTransaction  for scopename " + scopename);
    var isError = false;
    var pendingObjectsInScope = []; //objects with pending changes
    function checkForPendingUploadTxCallBack(tx) {
        sync.log.trace("Entering checkForPendingUploadTxCallBack");
        var reconcileTables = kony.sync.reconcileScopes[scopename].ReconcileTables;
        for (var i = 0; i < reconcileTables.length; i++) {
            var tablename = reconcileTables[i];
            var resultset = kony.sync.checkIfChangesExistInHistoryTable(tx, tablename);
            if (resultset === false) {
                sync.log.error("checkForPendingUploadInTransaction : error in checkIfChangesExistInHistoryTable for tablename " + tablename);
                isError = true;
                return;
            } else if (resultset === "") {
                sync.log.debug("checkForPendingUploadInTransaction : no pending changes in historytable " + tablename);
            } else {
                sync.log.debug("checkForPendingUploadInTransaction :  pending changes in historytable " + tablename);
                pendingObjectsInScope.push(tablename);
            }
        }
    }

    function checkForPendingUploadSuccCallBack() {
        sync.log.trace("Entering checkForPendingUploadSuccCallBack");
        successCallBack(pendingObjectsInScope);
    }

    function checkForPendingUploadErrCallBack() {
        sync.log.trace("Entering checkForPendingUploadErrCallBack");
        errorCallBack();
    }
    var dbname = kony.sync.syncConfigurationDBName;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, checkForPendingUploadErrCallBack, "check pendingupload for scope");
    if (connection !== null) {
        kony.sync.startTransaction(connection, checkForPendingUploadTxCallBack, checkForPendingUploadSuccCallBack, checkForPendingUploadErrCallBack, "check pendingupload for scope");
    }
}
kony.sync.reconcileCompletedCallback = function(error, msg) {
    sync.log.trace("Entering kony.sync.reconcileCompletedCallback ");
    if (error) {
        sync.log.error("Error occurred during reconcilation : ", msg);
        //kony.sync.deleteReconcileTempTables(tx);
        //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeError], msg);
        //return;
    } else {
        //calling scope scopesucesscallback
        kony.sync.isReconciliationInProgress = false;
        //todo changescopecontext
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeSuccess], {});
    }
    kony.sync.validateReconcileSession(error, msg);
};
kony.sync.resetReconcileSessionGlobals = function() {
    sync.log.trace("Entering kony.sync.resetReconcileSessionGlobals ");
    //delete kony.sync.currentReconcileReturnParams[kony.sync.reconcileContext];
    //reconcile_total_inserts = 0;
    kony.sync.reconcileTotalInserts = 0;
    kony.sync.reconcileTotalDeletes = 0;
    kony.sync.reconcileTotalDownloaded = 0;
    kony.sync.reconcileObjectLevelInfoMap = {};
};
kony.sync.resetReconcileBatchSessionGlobals = function() {
    sync.log.trace("Entering kony.sync.resetReconcileBatchSessionGlobals ");
    delete kony.sync.currentReconcileReturnParams[kony.sync.batchContext];
    //kony.sync.reconcilePendingBatches = 0;
    kony.sync.reconcileTotalBatchDownloads = 0;
    kony.sync.reconcileTotalBatchInserts = 0;
    kony.sync.reconcileTotalBatchDeletes = 0;
};
kony.sync.initReconcileObjectLevelInfoMap = function(tablename) {
    sync.log.trace("Entering kony.sync.initReconcileObjectLevelInfoMap ");
    if (kony.sync.isNullOrUndefined(kony.sync.reconcileObjectLevelInfoMap[tablename])) {
        kony.sync.reconcileObjectLevelInfoMap[tablename] = {};
        kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalDownloads] = 0;
        kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalInsertions] = 0;
        kony.sync.reconcileObjectLevelInfoMap[tablename][kony.sync.reconcileTotalDeletions] = 0;
    }
}
kony.sync.validateReconcileSession = function(error, errorContext, validateReconcileSessionError) {
    sync.log.trace("Entering kony.sync.validateReconcileSession ");

    function validateReconcileSessionSuccess() {
        sync.log.trace("Entering  validateReconcileSessionSuccess");
        kony.sync.isFirstReconcileDownload = true;
        kony.sync.isFirstBulkGetReconcileDownload = true;
        var reconcileContext = kony.sync.getReconcileContext();
        kony.sync.resetReconcileGlobals();
        //todo add reconcilecontext to errorcontext
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationSuccess], reconcileContext);
    }

    function validateReconcileSessionError() {
        sync.log.trace("Entering  validateReconcileSessionError");
        kony.sync.currentSyncScopeFilter = null;
        kony.sync.isFirstReconcileDownload = true;
        kony.sync.isFirstBulkGetReconcileDownload = true;
        kony.sync.resetReconcileGlobals();
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationError], errorContext);
    }
    if (error === true) {
        validateReconcileSessionError();
    } else {
        kony.sync.currentSyncScopeFilter = null;
        if (kony.sync.currentReconcileScopeIndex == null) kony.sync.currentReconcileScopeIndex = 0;
        else kony.sync.currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex + 1;
        if (kony.sync.currentReconcileScopeIndex >= kony.sync.reconcileScopes.scopeList.length) {
            validateReconcileSessionSuccess();
            return;
        }
        var scopename = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
        kony.sync.checkForPendingUploadInTransaction(scopename, successCallBack, validateReconcileSessionError);

        function populatePendingScopes(pendingObjectsInScope) {
            sync.log.trace("Entering populatePendingScopes");
            var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
            var scopename = kony.sync.reconcileScopes.scopeList[currentReconcileScopeIndex];
            if (kony.sync.isNullOrUndefined(kony.sync.reconcilePendingScopes[scopename])) {
                kony.sync.reconcilePendingScopes[scopename] = null;
            }
            kony.sync.reconcilePendingScopes[scopename] = pendingObjectsInScope;
        }

        function successCallBack(pendingObjectsInScope) {
            sync.log.trace("Entering successCallBack");
            if (pendingObjectsInScope.length > 0) {
                populatePendingScopes(pendingObjectsInScope);
                var pendingInfoMap = {};
                var skippedScopeName = kony.sync.reconcileScopes.scopeList[kony.sync.currentReconcileScopeIndex];
                pendingInfoMap[kony.sync.reconcileSkippedScopeName] = skippedScopeName;
                pendingInfoMap[kony.sync.reconcilePendingObjectsInScope] = pendingObjectsInScope;
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeSuccess], pendingInfoMap);
                kony.sync.currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex + 1;
                var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
                if (currentReconcileScopeIndex < kony.sync.reconcileScopes.scopeList.length) {
                    var scopename = kony.sync.reconcileScopes.scopeList[currentReconcileScopeIndex];
                    kony.sync.checkForPendingUploadInTransaction(scopename, successCallBack);
                } else {
                    validateReconcileSessionSuccess();
                }
            } else {
                var currentReconcileScopeIndex = kony.sync.currentReconcileScopeIndex;
                if (currentReconcileScopeIndex < kony.sync.reconcileScopes.scopeList.length) {
                    var scopename = kony.sync.reconcileScopes.scopeList[currentReconcileScopeIndex];
                    var scopeContext = {};
                    scopeContext[scopename] = kony.sync.reconcileScopes[scopename].ReconcileTables;
                    kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onReconciliationScopeStart], scopeContext);
                    kony.sync.syncDownloadReconcileScopes(null);
                } else {
                    validateReconcileSessionSuccess();
                }
            }
        }
    }
}
kony.sync.getReconcileContext = function() {
    sync.log.trace("Entering kony.sync.getReconcileContext ");
    var reconcilecontext = {};
    reconcilecontext[kony.sync.reconcileObjectLevelInfo] = kony.sync.reconcileObjectLevelInfoMap;
    reconcilecontext[kony.sync.reconcileTotalInsertions] = kony.sync.reconcileTotalInserts;
    reconcilecontext[kony.sync.reconcileTotalDeletions] = kony.sync.reconcileTotalDeletes;
    reconcilecontext[kony.sync.reconcileTotalDownloads] = kony.sync.reconcileTotalDownloaded;
    reconcilecontext[kony.sync.pendingReconcileScopesWithHistoryChanges] = kony.sync.reconcilePendingScopes;
    return reconcilecontext;
}
kony.sync.getReconcileBulkGetBatchSize = function() {
    sync.log.trace("Entering kony.sync.getReconcileUploadBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.reconcileBulkGetBatchSize])) {
        return kony.sync.currentSyncConfigParams[kony.sync.reconcileBulkGetBatchSize];
    }
    if (kony.os.deviceInfo().name === "blackberry") {
        return "50";
    } else {
        return "500";
    }
};
kony.sync.getReconcileDownloadBatchSize = function() {
    sync.log.trace("Entering kony.sync.getReconcileDownloadBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.reconcileDownloadBatchSize])) {
        return kony.sync.currentSyncConfigParams[kony.sync.reconcileDownloadBatchSize];
    }
    if (kony.os.deviceInfo().name === "blackberry") {
        return "50";
    } else {
        return "500";
    }
};
kony.sync.deleteReconcileTempTables = function(tx) {
        sync.log.trace("Entering function kony.sync.deleteReconcileTempTables ");
        //deleting temp tables to store the downloaded data
        var scopeNames = kony.sync.reconcileScopes.scopeList;
        var isError = false;
        for (var i = 0; i < scopeNames.length; i++) {
            var scopeName = scopeNames[i];
            var reconcileTables = kony.sync.reconcileScopes[scopeName].ReconcileTables;
            for (var j = 0; j < reconcileTables.length; j++) {
                var tableName = reconcileTables[j];
                var dropCacheTable = "drop table if exists " + tableName + "" + kony.sync.reconcileCacheKey;
                if (kony.sync.executeSql(tx, dropCacheTable) === false) {
                    sync.log.error("failure in dropping cachetable for table " + tableName)
                    isError = true;
                }
                var dropTempTable = "drop table if exists " + tableName + "" + kony.sync.tempTableKey;
                if (kony.sync.executeSql(tx, dropTempTable) === false) {
                    sync.log.error("failure in dropping temptable for table " + tableName)
                    isError = true;
                }
            }
        }
    }
    //  **************** End KonySyncDataReconciliation.js*******************
    //  **************** End KonySyncDataReconciliation.js*******************
    //  **************** Start KonySyncDBOperations.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.insert = function(tx, tablename, values, insert_callback, markForUpload, options) {
    sync.log.trace("Entering kony.sync.insert ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    if (markForUpload === false || markForUpload === "false") {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.insertColStatusDI;
    } else {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.insertColStatus;
    }
    values[kony.sync.mainTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
    var scope = kony.sync.scopes[scopename];
    var generatedPK = kony.sync.replaceautogeneratedPK(scopename, scope.syncTableDic[tablename], values, tx, insert_callback);
    if (generatedPK === false) {
        return false;
    }
    //Check if it is original or save the original state.
    if (markForUpload === false || markForUpload === "false") {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.insertColStatusDI, null, insert_callback) === false) {
            return false;
        }
    } else {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.insertColStatus, null, insert_callback) === false) {
            return false;
        }
    }
    if (kony.sync.insertEx(tx, tablename, values, insert_callback) === false) {
        return false;
    }
    //By default, sync tracking is enabled
    var synctracking = kony.sync.getSyncTracking(options);
    //If sync tracking is off, avoid inserting the record in history table
    if (synctracking === false) {
        return generatedPK;
    }
    var syncorder = kony.sync.getSyncOrder(scopename, tx, insert_callback);
    if (syncorder !== null && syncorder !== false) {
        values[kony.sync.mainTableChangeTypeColumn] = null;
        values[kony.sync.mainTableSyncVersionColumn] = null;
        if (markForUpload === false || markForUpload === "false") {
            values[kony.sync.historyTableChangeTypeColumn] = kony.sync.insertColStatusDI;
        } else {
            values[kony.sync.historyTableChangeTypeColumn] = kony.sync.insertColStatus;
        }
        values[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
        values[kony.sync.historyTableReplaySequenceColumn] = syncorder + 1;
        if (kony.sync.insertEx(tx, tablename + kony.sync.historyTableName, values, insert_callback) === false) {
            return false;
        }
        if (kony.sync.setSyncOrder(scopename, syncorder + 1, tx, insert_callback) === false) {
            return false;
        }
    } else {
        // not expected to come here
        sync.log.fatal("Invalid sync order in insert function");
    }
    return generatedPK;
};
kony.sync.insertEx = function(tx, tablename, values, errorcallback, rollback) {
    sync.log.trace("Entering kony.sync.insertEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_set(query, values);
    kony.sync.qb_insert(query, tablename);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params, errorcallback, rollback);
};
kony.sync.purgeInsertEx = function(tx, tablename, values, rollback) {
    sync.log.trace("Entering kony.sync.purgeInsertEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_purgeInsert(query, tablename, values);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params, null, rollback);
};
kony.sync.error_callbackdb = function(error) {
    sync.log.trace("Entering kony.sync.error_callbackdb ");
    sync.log.error("@@@@@@@@@@@@@ -" + error.message + " @@@ " + error.code);
};
kony.sync.update = function(tx, tablename, values, wc, markForUpload, options) {
    sync.log.trace("Entering kony.sync.update ");
    //Check if it is original or save the original state.
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + "_history");
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var myres = kony.sync.executeSql(tx, sql, params);
    if (myres === false) {
        return false;
    }
    for (var k = 0; k < myres.rows.length; k++) {
        var recordres = kony.db.sqlResultsetRowItem(tx, myres, 0);
        if (recordres === null) {
            return false;
        }
        var prevMarkForupload = recordres.konysyncchangetype;
        if (prevMarkForupload == 90 && (markForUpload === true || markForUpload === "true")) {
            return kony.sync.errorCodeInvalidMarkForUploadValue;
        }
    }
    if (markForUpload === false || markForUpload === "false") {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.updateColStatusDU, wc) === false) {
            return false;
        }
    } else {
        if (kony.sync.addToRollBack(tx, tablename, values, kony.sync.updateColStatus, wc) === false) {
            return false;
        }
    }
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    if (markForUpload === false || markForUpload === "false") {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatusDU;
    } else {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatus;
    }
    values[kony.sync.mainTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
    var resultSet = kony.sync.updateEx(tx, tablename, values, wc);
    var updateResult = {};
    if (resultSet === false) {
        return false;
    } else {
        updateResult[kony.sync.numberOfRowsUpdated] = resultSet.rowsAffected;
    }
    var synctracking = kony.sync.getSyncTracking(options);
    //If sync tracking is off, just return dont insert the record in history table
    if (synctracking === false) {
        return updateResult;
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var syncorder = kony.sync.getSyncOrder(scopename, tx);
    if (syncorder === false) {
        return false;
    }
    resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return false;
    } else if (resultSet.rows.length === 0) {
        sync.log.error("No record found with the given where condition " + JSON.stringify(wc));
        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeRecordDoNotExist, kony.sync.getErrorMessage(kony.sync.errorCodeRecordDoNotExist, JSON.stringify(wc)));
        return false;
    }
    var record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
    if (record === null) {
        return false;
    }
    if (!kony.sync.isNullOrUndefined(syncorder)) {
        record[kony.sync.historyTableReplaySequenceColumn] = syncorder + 1;
        if (markForUpload === false || markForUpload === "false") {
            record[kony.sync.historyTableChangeTypeColumn] = kony.sync.updateColStatusDU;
        } else {
            record[kony.sync.historyTableChangeTypeColumn] = kony.sync.updateColStatus;
        }
        record[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
        if (kony.sync.addUpdateToHistoryTable(tx, tablename + kony.sync.historyTableName, record) === false) {
            return false;
        }
        if (kony.sync.setSyncOrder(scopename, syncorder + 1, tx) === false) {
            return false;
        }
    } else {
        // not expected to come here
        sync.log.fatal("Invalid sync order in insert function");
    }
    return updateResult;
};
kony.sync.updateBatch = function(tx, tablename, values, wc, markForUpload, primaryKey, options) {
    sync.log.trace("Entering kony.sync.updateBatch ");
    //adding original values to rollback tables if exists
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0] + " " + wc;
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params, null, null, "Adding original values to rollback tables if exists");
    var i = 0;
    var record = null;
    if (resultSet === false) {
        return false;
    }
    var num_records = resultSet.rows.length;
    for (i = 0; i < num_records; i++) {
        record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
        if (markForUpload === false || markForUpload === "false") {
            record[kony.sync.originalTableChangeTypeColumn] = kony.sync.updateColStatusDU;
        } else {
            record[kony.sync.originalTableChangeTypeColumn] = kony.sync.updateColStatus;
        }
        record[kony.sync.originalTableSyncVersionColumn] = record[kony.sync.originalTableChangeTypeColumn];
        record[kony.sync.mainTableChangeTypeColumn] = null;
        record[kony.sync.mainTableSyncVersionColumn] = null;
        //record[kony.sync.mainTableHashSumColumn] = null;
        kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, record, null, false);
    }
    //Get Primary Key from where clause
    query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    query_compile = kony.sync.qb_compile(query);
    sql = query_compile[0] + " " + wc;
    params = query_compile[1];
    resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return false;
    }
    num_records = resultSet.rows.length;
    var pkSet = [];
    for (i = 0; i < num_records; i++) {
        record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
        var pkRecord = [];
        for (var j = 0; j < primaryKey.length; j++) {
            pkRecord.push({
                "key": primaryKey[j],
                "value": record[primaryKey[j]]
            });
        }
        pkSet.push(pkRecord);
    }
    //updating main tables
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    if (markForUpload === false || markForUpload === "false") {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatusDU;
    } else {
        values[kony.sync.mainTableChangeTypeColumn] = kony.sync.updateColStatus;
    }
    values[kony.sync.mainTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
    // update the flag only if this record is present on server
    resultSet = kony.sync.updateEx(tx, tablename, values, wc, null, true);
    var updateResult = {};
    if (resultSet === false) {
        return false;
    } else {
        updateResult[kony.sync.numberOfRowsUpdated] = resultSet.rowsAffected;
        //kony.sync.verifyAndCallClosure(update_callback, {kony.sync.numberOfRowsUpdated:resultSet.rowsAffected});
    }
    var synctracking = kony.sync.getSyncTracking(options);
    //Don't insert into history table if sync tracking is off
    if (synctracking === false) {
        return updateResult;
    }
    var syncorder = kony.sync.getSyncOrder(scopename, tx);
    if (syncorder === false) {
        return false;
    }
    for (var i = 0; i < pkSet.length; i++) {
        query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, pkSet[i]);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            return false;
        }
        record = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        syncorder = syncorder + 1;
        record[kony.sync.historyTableReplaySequenceColumn] = syncorder;
        record[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
        if (kony.sync.addUpdateToHistoryTable(tx, tablename + kony.sync.historyTableName, record) === false) {
            return false;
        }
    }
    if (kony.sync.setSyncOrder(scopename, syncorder, tx) === false) {
        return false;
    }
    return updateResult;
};
kony.sync.updateEx = function(tx, tablename, values, wc, update_callback, isBatch) {
    sync.log.trace("Entering kony.sync.updateEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_set(query, values);
    kony.sync.qb_update(query, tablename);
    if (kony.sync.isNullOrUndefined(isBatch)) {
        kony.sync.qb_where(query, wc);
    }
    //local sqlUpdate = "update "..tablename.." set "..updateStr..wc;
    var query_compile = kony.sync.qb_compile(query);
    var sqlUpdate = "";
    if (isBatch === true) {
        sqlUpdate = query_compile[0] + " " + wc;
    } else {
        sqlUpdate = query_compile[0];
    }
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sqlUpdate, params);
};
kony.sync.upsertEx = function(tx, tablename, values, wc, callback) {
    sync.log.trace("Entering kony.sync.upsertEx ");
    var result = kony.sync.purgeInsertEx(tx, tablename, values, callback);
    if (result !== false && result.rowsAffected === 0) {
        kony.sync.serverUpdateCount = kony.sync.serverUpdateCount + 1;
        // update if the user hasn't changed the record
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + 1;
        kony.sync.updateEx(tx, tablename, values, wc);
    } else {
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + 1;
        kony.sync.serverInsertCount = kony.sync.serverInsertCount + 1;
    }
};
kony.sync.isrowexists = function(tx, tablename, wc, errorCallback) {
    sync.log.trace("Entering kony.sync.isrowexists ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, wc);
    //local sql = "select * from "..tablename..wc;
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        return false;
    }
    if (resultset.rows.length === 1) {
        return true;
    } else {
        return null; //if row doesn't exists, we should add it to rollback table
    }
};
//Function to delete one(batch)change
kony.sync.remove = function(tx, tablename, wc, isLocal, markForUpload, errorCallback, options) {
    sync.log.trace("Entering kony.sync.remove ");
    //Check if it is original or save the original state.
    if (isLocal !== true) {
        if (markForUpload === false || markForUpload === "false") {
            if (kony.sync.addToRollBack(tx, tablename, null, kony.sync.deleteColStatusDD, wc, errorCallback) === false) {
                return false;
            }
        } else {
            if (kony.sync.addToRollBack(tx, tablename, null, kony.sync.deleteColStatus, wc, errorCallback) === false) {
                return false;
            }
        }
    }
    //Getting the records with the where clause
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    var scope = kony.sync.scopes[scopename];
    var syncTable = scope.syncTableDic[tablename];
    var record = null;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultSet === false) {
        return false;
    }
    var num_records = resultSet.rows.length;
    var rowsDeleted = 0;
    var synctracking = kony.sync.getSyncTracking(options);
    for (var i = 0; i < num_records; i++) {
        //adding changes to history table
        if (isLocal !== true) {
            if (synctracking === true) {
                record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
                var values = {};
                values[kony.sync.historyTableHashSumColumn] = record[kony.sync.mainTableHashSumColumn];
                if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                    for (var j = 0; j < syncTable.Columns.length; j++) {
                        var column = syncTable.Columns[j];
                        values[column.Name] = record[column.Name];
                    }
                }
                var syncorder = kony.sync.getSyncOrder(scopename, tx, errorCallback);
                if (syncorder === false) {
                    return false;
                }
                if (syncorder !== null) {
                    values[kony.sync.historyTableReplaySequenceColumn] = syncorder + 1;
                    if (markForUpload === false || markForUpload === "false") {
                        values[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatusDD;
                    } else {
                        values[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatus;
                    }
                    values[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
                    if (kony.sync.insertEx(tx, tablename + kony.sync.historyTableName, values, null, errorCallback) === false) {
                        return false;
                    }
                    if (kony.sync.setSyncOrder(scopename, syncorder + 1, tx, errorCallback) === false) {
                        return false;
                    }
                } else {
                    // not expected to come here
                    sync.log.fatal("Invalid sync order in insert function");
                }
            }
        } else {
            //deleting all local changes from history
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            sync.log.debug("Removing Local Changes: ", record);
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, null);
            kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_where(query, wc);
            query_compile = kony.sync.qb_compile(query);
            params = query_compile[1];
            sql = query_compile[0];
            if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                return false;
            }
            //deleting all local changes from original
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            sync.log.debug("Removing Local Changes from original: ", record);
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, null);
            kony.sync.qb_from(query, tablename + kony.sync.originalTableName);
            kony.sync.qb_where(query, wc);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                return false;
            }
        }
        //deleting from main table
        var resultSet1 = kony.sync.removeEx(tx, tablename, wc, null, errorCallback);
        if (resultSet1 === false) {
            return false;
        }
        rowsDeleted = rowsDeleted + resultSet1.rowsAffected;
    }
    var deleteResult = {};
    deleteResult[kony.sync.numberOfRowsDeleted] = rowsDeleted;
    return deleteResult;
};
//Function to delete more than one(batch)changes
kony.sync.deleteBatch = function(tx, tablename, wc, isLocal, markForUpload, errorCallback, options) {
    sync.log.trace("Entering kony.sync.deleteBatch ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    var i = null;
    var record = null;
    //adding original values to rollback tables if exists
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0] + " " + wc;
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultSet === false) {
        return false;
    }
    var num_records = resultSet.rows.length;
    if (isLocal === false) {
        for (i = 0; i <= num_records - 1; i++) {
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            record[kony.sync.originalTableChangeTypeColumn] = kony.sync.deleteColStatus;
            record[kony.sync.originalTableSyncVersionColumn] = record[kony.sync.originalTableChangeTypeColumn];
            record[kony.sync.mainTableChangeTypeColumn] = null;
            record[kony.sync.mainTableSyncVersionColumn] = null;
            //record[kony.sync.mainTableHashSumColumn] = null;
            kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, record, null, false);
        }
    }
    query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename);
    query_compile = kony.sync.qb_compile(query);
    sql = query_compile[0] + " " + wc;
    params = query_compile[1];
    var syncorder = kony.sync.getSyncOrder(scopename, tx, errorCallback);
    if (syncorder === false) {
        return false;
    }
    resultSet = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultSet === false) {
        return false;
    }
    num_records = resultSet.rows.length;
    var synctracking = kony.sync.getSyncTracking(options);
    if ((syncorder !== null)) {
        for (i = 0; i < num_records; i++) {
            record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            //adding change replay to history tables
            if (isLocal === false) {
                if (synctracking === true) {
                    syncorder = syncorder + 1;
                    record[kony.sync.historyTableReplaySequenceColumn] = syncorder;
                    if (markForUpload === false || markForUpload === "false") {
                        record[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatusDD;
                    } else {
                        record[kony.sync.historyTableChangeTypeColumn] = kony.sync.deleteColStatus;
                    }
                    record[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[scopename];
                    if (kony.sync.insertEx(tx, tablename + kony.sync.historyTableName, record, errorCallback) === false) {
                        return false;
                    }
                }
            }
            //deleting local changes from history table
            else {
                sync.log.debug("Removing Local Changes: ", record);
                query = kony.sync.qb_createQuery();
                kony.sync.qb_delete(query, null);
                kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0] + " " + wc;
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                    return false;
                }
                sync.log.debug("Removing Local Changes from original: ", record);
                query = kony.sync.qb_createQuery();
                kony.sync.qb_delete(query, null);
                kony.sync.qb_from(query, tablename + kony.sync.originalTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0] + " " + wc;
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params, errorCallback) === false) {
                    return false;
                }
            }
        }
        if (kony.sync.setSyncOrder(scopename, syncorder, tx, errorCallback) === false) {
            return false;
        }
    } else {
        // not expected to come here
        sync.log.fatal("Invalid sync order in insert function");
    }
    //deleting main tables
    resultSet = kony.sync.removeEx(tx, tablename, wc, true, errorCallback);
    if (resultSet === false) {
        return false;
    }
    var deleteResult = {};
    deleteResult[kony.sync.numberOfRowsDeleted] = resultSet.rowsAffected;
    return deleteResult;
};
kony.sync.removeEx = function(tx, tablename, wc, isBatch, errorcallback) {
    sync.log.trace("Entering kony.sync.removeEx ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, tablename);
    if (kony.sync.isNullOrUndefined(isBatch)) {
        kony.sync.qb_where(query, wc);
    }
    //local sql = "delete from "..tablename.." "..wc;
    var query_compile = kony.sync.qb_compile(query);
    var sql = "";
    if (isBatch === true) {
        sql = query_compile[0] + " " + wc;
    } else {
        sql = query_compile[0];
    }
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params, errorcallback);
};
kony.sync.addToRollBack = function(tx, tablename, values, changetype, wcs, errorCallback) {
    sync.log.trace("Entering kony.sync.addToRollBack ");
    var originalwcs = kony.sync.createClone(wcs);
    var originalvalues = kony.sync.createClone(values);
    var rowExists = null;
    if (changetype === kony.sync.insertColStatus || changetype === kony.sync.insertColStatusDI) {
        originalvalues[kony.sync.originalTableChangeTypeColumn] = changetype;
        originalvalues[kony.sync.originalTableSyncVersionColumn] = null;
        originalvalues[kony.sync.mainTableChangeTypeColumn] = null;
        originalvalues[kony.sync.mainTableSyncVersionColumn] = null;
        originalvalues[kony.sync.mainTableHashSumColumn] = null;
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var pkColumns = scope.syncTableDic[tablename].Pk_Columns;
        var pkRecord = [];
        for (var j = 0; j < pkColumns.length; j++) {
            pkRecord.push({
                "key": pkColumns[j],
                "value": originalvalues[pkColumns[j]]
            });
        }
        rowExists = kony.sync.isrowexists(tx, tablename + kony.sync.originalTableName, pkRecord);
        if (rowExists === true) {
            //Original State is already saved, no need to save again
            return true;
        } else if (rowExists === false) {
            return false;
        } else {
            if (kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, originalvalues) === false) {
                return false;
            } else {
                return true;
            }
        }
    }
    rowExists = kony.sync.isrowexists(tx, tablename + kony.sync.originalTableName, wcs);
    if (rowExists === true) {
        //Original State is already saved, no need to save again
        return true;
    } else if (rowExists === false) {
        return false;
    } else if (rowExists === null) {
        kony.table.insert(originalwcs, {
            key: kony.sync.mainTableChangeTypeColumn,
            value: "nil",
            comptype: "OR",
            openbrace: true
        });
        kony.table.insert(originalwcs, {
            key: kony.sync.mainTableChangeTypeColumn,
            value: "-1",
            comptype: "OR",
            closebrace: true
        });
        //table.insert(originalwcs,{key = kony.sync.mainTableChangeTypeColumn, value = "-1"})
        var record = kony.sync.getOriginalRow(tx, tablename, originalwcs, errorCallback);
        if (record === false) {
            return false;
        }
        /* This logic is not needed as when row is not already present in rollback table and 
        	waiting for acknowledgement,it should not be backed up in original table because 
        	rollbacking it would lead to inconsistency
        	Note: This case generally occurs in persistent strategy when record waits for acknowledgement
        if (record === null) {
        	//means record got changed but pending for acknowledgement
        	kony.table.remove(originalwcs);
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : "-1",
        		optype : "EQ",
        		comptype : "OR",
        		openbrace : true
        	});
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : changetype,
        		optype : "EQ",
        		comptype : "OR"
        	});
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : "90",
        		optype : "EQ",
        		comptype : "OR"
        	});
        	kony.table.insert(originalwcs, {
        		key : kony.sync.mainTableChangeTypeColumn,
        		value : "91",
        		optype : "EQ",
        		closebrace : true
        	});
        	record = kony.sync.getOriginalRow(tx, tablename, originalwcs, errorCallback);
        	if (record === false) {
        		return false;
        	}
        }
        */
        if (record !== null) {
            //Records not equal to nil means that it is not pending to be uploaded/acknowledged. So original state has to saved.
            record[kony.sync.originalTableChangeTypeColumn] = changetype;
            record[kony.sync.originalTableSyncVersionColumn] = record[kony.sync.mainTableSyncVersionColumn];
            record[kony.sync.mainTableChangeTypeColumn] = null;
            record[kony.sync.mainTableSyncVersionColumn] = null;
            //record[kony.sync.mainTableHashSumColumn] = null;
            record[kony.sync.mainTableHashSumColumn] = record[kony.sync.originalTableHashSumColumn];
            return kony.sync.insertEx(tx, tablename + kony.sync.originalTableName, record);
        }
    }
};
kony.sync.getOriginalRow = function(tx, tablename, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.getOriginalRow ");
    var sql = "";
    var params = "";
    if (typeof(wcs) == "string" || typeof(wcs) == "String") {
        sql = "select * from " + tablename + " " + wcs + " ;";
        params = null;
    } else {
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, wcs);
        var query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
    }
    var resultset = kony.sync.executeSql(tx, sql, params, errorcallback);
    if (!resultset) {
        return false;
    }
    if (resultset.rows.length === 1) {
        return kony.db.sqlResultsetRowItem(tx, resultset, 0);
    } else {
        return null;
    }
};
kony.sync.syncDropDatabase = function(dbList, successcallback, errorcallback) {
    sync.log.trace("Entering kony.sync.syncDropDatabase ");
    sync.log.info("Dropping database list: ", dbList);
    var isError = false;

    function single_transaction_success_callback(res) {
        sync.log.trace("Entering single_transaction_success_callback");
        sync.log.debug("Single Select callback result: ", res);
        if (!kony.sync.isNullOrUndefined(dbList) && !kony.sync.isNullOrUndefined(dbList[0]) && !kony.sync.isNullOrUndefined(dbList[0].dbname)) {
            dbname = dbList[0].dbname;
            //var connection1 = kony.db.openDatabaseSync(dbname, "1.0", dbname, 5 * 1024 * 1024);
            //kony.db.transaction(connection1, single_transaction_callback, single_transaction_error_callback, single_transaction_success_callback);
            var connection1 = kony.sync.getConnectionOnly(dbname, dbname);
            kony.sync.startTransaction(connection1, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
        } else {
            sync.log.info("Deleting all binary files ");
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined") {
                binary.util.deleteAllBinaryFiles();
            }
            sync.log.info("Reinitializing...");
            sync.init(successcallback, errorcallback);
        }
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        sync.log.info("Dropping database: ", dbList[0].dbname);
        for (var i = 0; i < dbList[0].tableList.length; i++) {
            var v = dbList[0].tableList[i];
            if (kony.sync.dropTable(tx, v) === false) {
                isError = true;
                return;
            }
        }
        dbList = dbList.slice(1);
    }

    function single_transaction_error_callback(res) {
        sync.log.trace("Entering single_transaction_error_callback");
        sync.log.error("Sync Reset failed ", res);
        //kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getSyncResetFailed());
        kony.sync.isResetInProgress = false;
        kony.sync.callTransactionError(isError, errorcallback);
    }
    var dbname = dbList[0].dbname;
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
};
kony.sync.dropTable = function(tx, tablename) {
    sync.log.trace("Entering kony.sync.dropTable ");
    sync.log.info("Dropping tablename ", tablename);
    var query = null;
    if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
        query = "Drop Table " + tablename;
    } else if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
        query = "Drop Table if exists " + tablename;
    }
    return kony.sync.executeSql(tx, query, null);
};
kony.sync.addUpdateToHistoryTable = function(tx, tablename, values) {
    sync.log.trace("Entering kony.sync.addUpdateToHistoryTable ");
    var toUpdate = false;
    if (!kony.sync.trackIntermediateUpdates) {
        //frame primary key
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var pkColumns = scope.syncTableDic[tablename].Pk_Columns;
        var wc = [];
        if (!kony.sync.isNullOrUndefined(pkColumns)) {
            for (var j = 0; j < pkColumns.length; j++) {
                if (!kony.sync.isNullOrUndefined(values[pkColumns[j]])) {
                    kony.table.insert(wc, {
                        key: pkColumns[j],
                        value: values[pkColumns[j]]
                    });
                }
            }
        }
        //Get the row and check its changetype
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, wc);
        kony.sync.qb_orderBy(query, [{
            key: kony.sync.historyTableReplaySequenceColumn,
            sortType: "desc"
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        var lastRecord = null;
        var lastChangeType = null;
        if (resultSet === false) {
            return false;
        }
        if (resultSet.rows.length > 0) {
            lastRecord = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
            lastChangeType = "" + lastRecord[kony.sync.historyTableChangeTypeColumn];
            if (lastChangeType === kony.sync.updateColStatus || lastChangeType === kony.sync.updateColStatusDU) {
                toUpdate = true;
                //update the last row
                query = kony.sync.qb_createQuery();
                kony.sync.qb_set(query, values);
                kony.sync.qb_update(query, tablename);
                kony.table.insert(wc, {
                    key: kony.sync.historyTableReplaySequenceColumn,
                    value: lastRecord[kony.sync.historyTableReplaySequenceColumn]
                });
                kony.sync.qb_where(query, wc);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                return kony.sync.executeSql(tx, sql, params);
            }
        }
    }
    if (!toUpdate) {
        var query1 = kony.sync.qb_createQuery();
        kony.sync.qb_set(query1, values);
        kony.sync.qb_insert(query1, tablename);
        var query_compile1 = kony.sync.qb_compile(query1);
        var sql1 = query_compile1[0];
        var params1 = query_compile1[1];
        return kony.sync.executeSql(tx, sql1, params1);
    }
};
//  **************** End KonySyncDBOperations.js*******************
//  **************** Start KonySyncDownload.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.pendingBinaryDownloadJobs = [];
kony.sync.syncDownloadChanges = function(sname, dbname, onCompletion) {
    sync.log.trace("Entering kony.sync.syncDownloadChanges ");
    kony.sync.onDownloadCompletion = onCompletion;
    kony.sync.resetbatchsessionglobals();
    kony.sync.PersisChangestobeDeleted = []; //Used for upload after delete in persistence strategey 
    sync.log.info("Download started for scope : ", sname);
    kony.sync.currentSyncScopeFilter = null;
    if (kony.sync.isValidJSTable(kony.sync.currentSyncConfigParams[kony.sync.filterParams])) {
        var scopeFilter = kony.sync.currentSyncConfigParams[kony.sync.filterParams][kony.sync.currentScope[kony.sync.scopeName]];
        sync.log.info("scope Filter for " + kony.sync.currentScope[kony.sync.scopeName] + " is :" + scopeFilter);
        if (kony.sync.isNullOrUndefined(scopeFilter)) {
            kony.sync.getLastSynctime(sname, dbname, kony.sync.syncDownloadchangesGetLastSynctime);
        } else {
            //current_sync_scopefilter_index = 0;
            //kony.sync.syncDownloadbyFilter(current_sync_scopefilter_index);
            kony.sync.syncDownloadbyFilter();
        }
    } else {
        kony.sync.getLastSynctime(sname, dbname, kony.sync.syncDownloadchangesGetLastSynctime);
    }
};
//kony.sync.syncDownloadbyFilter = function (index) {
kony.sync.syncDownloadbyFilter = function() {
    sync.log.trace("Entering kony.sync.syncDownloadbyFilter ");
    var scopeFilter = kony.sync.currentSyncConfigParams[kony.sync.filterParams][kony.sync.currentScope[kony.sync.scopeName]];
    //if (index < scopeFilter.length) {
    var scopejsonfilter = {
        //"d" : scopeFilter[index]
        "d": scopeFilter
    };
    var filtervaluejson = JSON.stringify(scopejsonfilter);
    sync.log.debug(filtervaluejson);
    kony.sync.currentSyncScopeFilter = scopeFilter; //scopeFilter[index];
    kony.sync.getLastSynctimeFilter(kony.sync.currentScope[kony.sync.scopeName], filtervaluejson, kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.syncDownloadchangesGetLastSynctime);
    /*} else {
    	kony.sync.globalIsDownloadStarted = true;
    	kony.sync.onDownloadCompletion(false, null);
    }*/
};
kony.sync.syncDownloadchangesGetLastSynctime = function(rowItem) {
    sync.log.trace("Entering kony.sync.syncDownloadchangesGetLastSynctime ");
    var lastsynctime = rowItem[0][kony.sync.metaTableSyncTimeColumn];
    sync.log.info("Last Sync Time with Server : " + lastsynctime);
    var upgradeSchemaLastSyncTime = rowItem[0][kony.sync.metaTableSchemaUpgradeSyncTimeColumn];
    var serverChanges = null;
    var startTime = new Date();
    var isError = false;
    if (kony.sync.schemaUpgradeDownloadPending && kony.sync.isSchemaUpgradeTimeStampEmpty(lastsynctime)) {
        sync.log.trace("Skipping download for schema upgrade as no data available");
        kony.sync.onDownloadCompletion(false);
        return;
    }

    function downloadNextBatch(tx) {
        sync.log.trace("Entering downloadNextBatch");
        var morechanges = serverChanges.d.__sync.moreChangesAvailable;
        var serverblob = serverChanges.d.__sync.serverblob;
        var pendingbatches = serverChanges.d.__sync.pendingBatches;
        kony.sync.currentSyncReturnParams[kony.sync.lastSyncTimestamp] = serverblob;
        if (kony.sync.isApplyChangesSync()) {
            if (kony.sync.applyChanges(tx, kony.sync.currentScope, serverChanges) === false) {
                isError = true;
                return;
            }
            if (kony.sync.postApplyChanges(tx, serverblob, morechanges, pendingbatches) === false) {
                isError = true;
                return;
            }
        } else {
            kony.sync.applyChangesAsync(tx, kony.sync.currentScope, serverChanges, serverblob, morechanges);
        }
    }

    function downloadCompleted() {
        sync.log.trace("Entering downloadCompleted");
        if (kony.sync.globalIsDownloadStarted) {
            //This means that download has failed and variable is reset;
            return;
        }
        var endTime = new Date();
        var diff = endTime.getTime() - startTime.getTime();
        sync.log.debug("Time Taken for Batch Insertion Download : " + diff);
        kony.sync.batchInsertionTimer = kony.sync.batchInsertionTimer + diff;
        var params = {};
        params.pending_batches = kony.sync.tonumber(kony.sync.syncPendingBatchesNo);
        params.serverinsertcount = "Server Insert Count :" + kony.sync.serverInsertCount;
        params.serverupdatecount = "Server Update Count :" + kony.sync.serverUpdateCount;
        params.serverinsertackcount = "Server Insert Ack Count :" + kony.sync.serverInsertAckCount;
        params.serverupdateackcount = "Server Update Ack Count :" + kony.sync.serverUpdateAckCount;
        sync.log.debug("@@@@@@" + params);
        kony.table.insert(kony.sync.currentSyncLog, params);
        sync.log.debug(kony.sync.serverInsertCount);
        if (kony.sync.isSyncStopped) {
            sync.log.debug("sync stopped in downloadCompleted");
            kony.sync.stopSyncSession();
            return;
        }
        var batchcontext = {};
        batchcontext[kony.sync.numberOfRowsDownloaded] = kony.sync.serverInsertCount + kony.sync.serverUpdateCount + kony.sync.serverDeleteCount;
        batchcontext[kony.sync.numberOfRowsInserted] = kony.sync.serverInsertCount;
        batchcontext[kony.sync.numberOfRowsUpdated] = kony.sync.serverUpdateCount;
        batchcontext[kony.sync.numberOfRowsDeleted] = kony.sync.serverDeleteCount;
        batchcontext[kony.sync.numberOfRowsFailedtoUpload] = kony.sync.serverFailedCount;
        batchcontext[kony.sync.failedRowInfo] = kony.sync.uploadSummary;
        batchcontext[kony.sync.objectLevelInfo] = kony.sync.objectLevelInfoMap;
        kony.sync.objectLevelInfoMap = {};
        if ((kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA)) {
            batchcontext[kony.sync.numberOfRowsAcknowledged] = kony.sync.serverInsertAckCount + kony.sync.serverUpdateAckCount + kony.sync.serverDeleteAckCount;
            batchcontext[kony.sync.numberOfRowsInsertedAck] = kony.sync.serverInsertAckCount;
            batchcontext[kony.sync.numberOfRowsUpdatedAck] = kony.sync.serverUpdateAckCount;
            batchcontext[kony.sync.numberOfRowsDeletedAck] = kony.sync.serverDeleteAckCount;
        }
        batchcontext[kony.sync.pendingBatches] = kony.sync.tonumber(kony.sync.syncPendingBatchesNo);
        kony.sync.currentSyncReturnParams[kony.sync.batchContext] = batchcontext;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onBatchProcessingSuccess], kony.sync.currentSyncReturnParams);
        if ((kony.sync.moreChangesAvailable)) {
            kony.sync.syncDownloadChanges(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.onDownloadCompletion);
        } else {
            kony.sync.printScopeLog(kony.sync.currentSyncLog);
            delete kony.sync.currentSyncReturnParams[kony.sync.batchContext];
            //clearing sync order and then deleting records after upload
            if (kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
                if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                    removeAfterUpload(0);
                } else {
                    kony.sync.updateSyncOrderForScope(removeAfterUpload);
                }
            } else {
                removeAfterUpload(0);
            }
        }
    }
    //wrapper for removeafterupload
    function removeAfterUpload(code) {
        sync.log.trace("Entering removeAfterUpload");
        if (code === 0) {
            kony.sync.deleteRecordsAfterUpload(postDownloadProcessing);
        } else {
            //statement error
            if (code === kony.sync.errorCodeSQLStatement) {
                kony.sync.downloadFailed(true);
            }
            //transaction error
            else {
                kony.sync.downloadFailed(false);
            }
        }
    }
    //This function should be called after finishing all post download tasks like removeafterupload
    function postDownloadProcessing(code) {
        sync.log.trace("Entering postDownloadProcessing");
        if (kony.sync.isSyncStopped) {
            sync.log.debug("Stopped in  postDownloadProcessing");
            kony.sync.stopSyncSession();
            return;
        }
        if (code === 0) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onDownloadSuccess], kony.sync.currentSyncReturnParams);
            /*if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
            	kony.sync.syncDownloadbyFilter(kony.sync.currentSyncScopeFilterIndex + 1);
            } else {*/
            kony.sync.globalIsDownloadStarted = true;
            kony.sync.onDownloadCompletion(false, null);
            //}
        } else {
            //statement error
            if (code === kony.sync.errorCodeSQLStatement) {
                kony.sync.downloadFailed(true);
            }
            //transaction error
            else {
                kony.sync.downloadFailed(false);
            }
        }
    }
    //Used for upload after delete in persistence strategey , Adding all the merged records in delete queue
    function recsToBeDeletedAfterUploadForPersistentStrategy(serverChanges) {
        sync.log.trace("Entering recsToBeDeletedAfterUploadForPersistentStrategy");
        var scopename = kony.sync.currentScope[kony.sync.scopeName];
        if (!kony.sync.isNullOrUndefined(serverChanges.d) && !kony.sync.isNullOrUndefined(serverChanges.d.results)) {
            for (var i = 0; i < serverChanges.d.results.length; i++) {
                var tablename = serverChanges.d.results[i].__metadata.type;
                if (kony.sync.checkForDeleteAfterUpload(tablename, scopename) === true && !kony.sync.isNullOrUndefined(serverChanges.d.results[i][kony.sync.mergedWithEIS]) && serverChanges.d.results[i][kony.sync.mergedWithEIS] === "1") {
                    kony.sync.PersisChangestobeDeleted.push(serverChanges.d.results[i]);
                }
            }
            sync.log.info("Changes to be deleted after upload", kony.sync.PersisChangestobeDeleted);
        }
    }

    function downloadcallback(serverChangesResult) {
        sync.log.trace("Entering downloadcallback");
        var endTime = new Date();
        var diff = endTime.getTime() - startTime.getTime();
        sync.log.debug("Time Taken for Network Batch Download : " + diff);
        kony.sync.batchDownloadTimer = kony.sync.batchDownloadTimer + diff;
        serverChanges = serverChangesResult;
        sync.log.info("ServerChanges:", serverChanges);
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.removeAfterUpload]) && kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
            recsToBeDeletedAfterUploadForPersistentStrategy(serverChanges);
        }
        if (!kony.sync.isNullOrUndefined(serverChanges.opstatus) && serverChanges.opstatus != 0) {
            kony.sync.globalIsDownloadStarted = true;
            if (kony.sync.isSyncStopped) {
                sync.log.debug("Sync stopped in downloadcallback in opstatus check");
                kony.sync.stopSyncSession();
                return;
            }
            if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
                kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges.d, "download"));
            } else {
                kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges));
            }
            return;
        } else if (kony.sync.isNullOrUndefined(serverChanges.d)) {
            if (kony.sync.isSyncStopped) {
                sync.log.debug("Sync stopped in downloadcallback in serverchanges.d check");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.globalIsDownloadStarted = true;
            kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges));
            return;
        }
        kony.sync.currentSyncReturnParams[kony.sync.serverDetails] = {};
        kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(serverChanges);
        kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(serverChanges);
        if ((serverChanges.d.error === "true")) {
            kony.sync.globalIsDownloadStarted = true;
            var hasResults = serverChanges.d.hasOwnProperty("results");
            if (hasResults && (serverChanges.d["results"].length > 0)) {
                applyDownloadBatchChangesToDBonError();
            } else {
                if (kony.sync.isSyncStopped) {
                    sync.log.debug("Sync stopped in downloadcallback in serverchanges.d.error true");
                    kony.sync.stopSyncSession();
                    return;
                }
                kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges.d, "download"));
            }
            return;
        }
        //If has uploadErrors for persistentSync incase of AbortOnError Sync Strategy
        if (hasUploadErrors(serverChanges)) {
            kony.sync.globalIsDownloadStarted = true;
            var hasResults = serverChanges.d.hasOwnProperty("results");
            if (hasResults && (serverChanges.d["results"].length > 0)) {
                applyDownloadBatchChangesToDBonError();
                //Update Sync Order for failed records
                updateVersionNumberOnPersistentDownload();
            } else {
                var uploadErrorsInfoMap = getUploadErrorsInfoMap(serverChanges);
                //Update Sync Order for failed records
                updateVersionNumberOnPersistentDownload();
                kony.sync.onDownloadCompletion(true, uploadErrorsInfoMap);
            }
            return;
        }
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncFailed);
        if (dbconnection === null) {
            return;
        }
        if (kony.sync.isApplyChangesSync()) {
            kony.db.transaction(dbconnection, downloadNextBatch, downloadNextBatchFailed, downloadCompleted);
        } else {
            kony.db.transaction(dbconnection, downloadNextBatch, downloadNextBatchFailed, downloadCompleted, {
                isCommitTransaction: false
            });
        }
    }

    function hasUploadErrors(serverChanges) {
        sync.log.trace("Entering hasUploadErrors");
        if (!kony.sync.isNullOrUndefined(serverChanges) && !kony.sync.isNullOrUndefined(serverChanges.d) && (serverChanges.d.error === "false") && !kony.sync.isNullOrUndefined(serverChanges.d.__sync) && !kony.sync.isNullOrUndefined(serverChanges.d.__sync.UploadErrors)) {
            return true;
        }
        return false;
    }

    function getUploadErrorsInfoMap(serverChanges) {
        sync.log.trace("Entering getUploadErrorsInfoMap");
        var failedRowsInfoMap = {};
        if (kony.sync.isNullOrUndefined(serverChanges) || kony.sync.isNullOrUndefined(serverChanges.d) || kony.sync.isNullOrUndefined(serverChanges.d.__sync) || kony.sync.isNullOrUndefined(serverChanges.d.__sync.UploadErrors)) {
            return failedRowsInfoMap;
        }
        var errors = serverChanges.d.__sync.UploadErrors;
        var failedRowsInfo = {};
        var errorMap = null;
        var serverDetails = {};
        for (var i = 0; i < errors.length; i++) {
            errorMap = errors[i];
            for (var key in errorMap) {
                var contextMap = errorMap[key];
                failedRowsInfo.push({
                    key: contextMap.primaryKeys,
                    type: contextMap.type,
                    errorMessage: contextMap.errorMessage
                });
            }
        }
        failedRowsInfoMap[kony.sync.failedRowInfo] = failedRowsInfo;
        if (!kony.sync.isNullOrUndefined(serverChanges.d.server)) {
            serverDetails[kony.sync.hostName] = serverChanges.d.server.hostName;
            serverDetails[kony.sync.ipAddress] = serverChanges.d.server.ipAddress;
        }
        failedRowsInfoMap[kony.sync.serverDetails] = serverDetails;
        return failedRowsInfoMap;
    }

    function updateVersionNumberOnPersistentDownload() {
        sync.log.trace("Entering updateVersionNumberOnPersistentDownload ");
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var scopename = kony.sync.currentScope[kony.sync.scopeName];
        var sql = null;
        var params = null;
        var query = null;
        var query_compile = null;
        kony.sync.getConnection(dbname, dbname, transactionCallback, successCallback, failureCallback);

        function transactionCallback(tx) {
            sync.log.trace("Entering transactionCallback");
            var versionNo = kony.sync.getseqnumber(tx, scopename);
            if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
                for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
                    var syncTable = kony.sync.currentScope.ScopeTables[i];
                    if (kony.sync.isNullOrUndefined(syncTable)) {
                        continue;
                    }
                    var tbname = syncTable.Name;
                    query = kony.sync.qb_createQuery();
                    kony.sync.qb_select(query, null);
                    kony.sync.qb_from(query, tbname + kony.sync.historyTableName);
                    query_compile = kony.sync.qb_compile(query);
                    sql = query_compile[0];
                    params = query_compile[1];
                    var resultSet = kony.sync.executeSql(tx, sql, params);
                    if (resultSet !== false) {
                        var num_records = resultSet.rows.length;
                        if (num_records > 0) {
                            var versionMap = {};
                            versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo.versionnumber;
                            var whereClause = [];
                            kony.table.insert(whereClause, {
                                key: kony.sync.historyTableChangeTypeColumn,
                                value: "9%",
                                optype: "NOT LIKE"
                            });
                            query = kony.sync.qb_createQuery();
                            kony.sync.qb_update(query, tbname + kony.sync.historyTableName);
                            kony.sync.qb_set(query, versionMap);
                            kony.sync.qb_where(query, whereClause);
                            query_compile = kony.sync.qb_compile(query);
                            sql = query_compile[0];
                            params = query_compile[1];
                            if (kony.sync.executeSql(tx, sql, params) === false) {
                                return;
                            }
                        }
                    } else {
                        return;
                    }
                }
            }
        }

        function failureCallback() {
            sync.log.error(" Failed to update version number for failed rows on persistent download ");
        }

        function successCallback() {
            sync.log.trace(" Updated version number for failed rows on persistent download ");
        }
    }

    function ondownloadComplete() {
        if (hasUploadErrors(serverChanges)) {
            kony.sync.onDownloadCompletion(true, getUploadErrorsInfoMap(serverChanges));
        } else {
            kony.sync.onDownloadCompletion(true, kony.sync.getServerError(serverChanges.d, "download"));
        }
    }

    function applyDownloadBatchChangesToDBonError() {
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncFailed);
        if (dbconnection === null) {
            return;
        }
        if (kony.sync.globalIsDownloadStarted) {
            if (kony.sync.isApplyChangesSync()) {
                kony.db.transaction(dbconnection, downloadNextBatch, currentBatchDownloadError, ondownloadComplete);
            } else {
                kony.db.transaction(dbconnection, downloadNextBatch, currentBatchDownloadError, ondownloadComplete, {
                    isCommitTransaction: false
                });
            }
        }
    }

    function currentBatchDownloadError() {
        sync.log.trace("Entering currentBatchDownloadError");
        var serverError = null;
        if (!kony.sync.isNullOrUndefined(serverChanges.d)) {
            serverError = kony.sync.getServerError(serverChanges.d, "download");
        }
        var errorTable = kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null);
        if (serverError === null) {
            kony.sync.onDownloadCompletion(true, errorTable);
            return;
        }
        if (serverError && serverError.errorMessage && errorTable && errorTable.errorMessage) {
            serverError.errorMessage = serverError.errorMessage + " and " + errorTable.errorMessage;
        }
        kony.sync.onDownloadCompletion(true, serverError);
    }

    function downloadNextBatchFailed() {
        sync.log.trace("Entering downloadNextBatchFailed");
        kony.sync.downloadFailed(isError);
    }

    function scopeSettingsCallback(isInitialized) {
        sync.log.trace("Entering scopeSettingsCallback");
        kony.sync.konyDownloadChanges(lastsynctime, null, downloadcallback, isInitialized, upgradeSchemaLastSyncTime);
    }
    kony.sync.isScopeInitialized(kony.sync.currentScope[kony.sync.scopeName], kony.sync.currentScope[kony.sync.scopeDataSource], scopeSettingsCallback);
};
kony.sync.downloadFailed = function(dbError) {
    sync.log.trace("Entering kony.sync.downloadFailed ");
    kony.sync.gSyncFailed = true;
    kony.sync.globalIsDownloadStarted = true;
    //kony.sync.onDownloadCompletion(true, JSON.stringify(connection));
    sync.log.error("Scope Download Failed");
    if (!dbError) {
        kony.sync.onDownloadCompletion(true, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
    } else {
        kony.sync.onDownloadCompletion(true, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }
};
kony.sync.applyChanges = function(tx, currentScope, serverChanges) {
    sync.log.trace("Entering kony.sync.applyChanges ");
    sync.log.info("Applying Changes from Server................... ----------->");
    var results = serverChanges.d.results;
    if (!kony.sync.isNullOrUndefined(results)) {
        return kony.sync.applyChangesToDB({
            "tx": tx,
            "currentScope": currentScope,
            "results": results,
            "startposition": 0,
            "endposition": results.length
        });
    }
};
kony.sync.postApplyChanges = function(tx, serverblob, moreChangesAvailable, pendingBatches) {
    sync.log.trace("Entering kony.sync.postApplyChanges ");
    if (kony.sync.clearChunkMetaData(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
        return false;
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
        var scopejsonfilter = {
            "d": kony.sync.currentSyncScopeFilter
        };
        var filtervaluejson = JSON.stringify(scopejsonfilter);
        if (kony.sync.setLastSyncTimeFilter(tx, kony.sync.currentScope[kony.sync.scopeName], filtervaluejson, null, serverblob) === false) {
            return false;
        }
    } else {
        if (kony.sync.setLastSyncTime(tx, kony.sync.currentScope[kony.sync.scopeName], null, serverblob) === false) {
            return false;
        }
    }
    //shrink memory execution
    kony.db.executeSql(tx, "PRAGMA shrink_memory");
    if (!kony.sync.isNullOrUndefined(moreChangesAvailable)) {
        var temp = moreChangesAvailable;
        temp = temp + "";
        temp = temp.toLowerCase();
        if ((temp === "true")) {
            //Enable below code if PendingBatches is implemented.
            if (!kony.sync.isNullOrUndefined(pendingBatches)) {
                kony.sync.syncPendingBatchesNo = pendingBatches;
            }
            kony.sync.moreChangesAvailable = true;
        } else {
            kony.sync.moreChangesAvailable = false;
            kony.sync.syncPendingBatchesNo = 0;
        }
    } else {
        kony.sync.moreChangesAvailable = false;
    }
    sync.log.info("more changes available " + kony.sync.moreChangesAvailable);
    if (!kony.sync.moreChangesAvailable) {
        //After Every successful Scope download completion we will check and update the Scope Settings to make that scope Initialized;
        if (kony.sync.updateScopeSettings(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            return false;
        }
        //After Every successful Scope download completion we will check if this download was for schema upgrade and mark it complete
        if (kony.sync.setSchemaUpgradeDownloadComplete(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            return false;
        }
    }
};
kony.sync.applyChangesAsync = function(tx, currentScope, serverChanges, serverblob, morechanges) {
    sync.log.trace("Entering kony.sync.applyChangesAsync ");
    sync.log.info("Applying Changes from Server................... ----------->");
    var results = serverChanges.d.results;
    var bbBatchSize = kony.sync.getAsyncDownloadBatchSize();
    var lastbatch = results.length % bbBatchSize;
    var noofloops = (results.length - lastbatch) / bbBatchSize;
    var context = {
        "tx": tx,
        counter: 0,
        "currentScope": currentScope,
        "results": results,
        "noofloops": noofloops,
        "lastbatch": lastbatch,
        "serverblob": serverblob,
        "morechanges": morechanges
    };
    sync.log.debug("sending context");
    kony.api.executeAsync(kony.sync.applyChangesToDBAsync, context);
};
kony.sync.applyChangesToDBAsync = function(context) {
    sync.log.trace("Entering kony.sync.applyChangesToDBAsync ");
    sync.log.debug("point ******b : ", context);
    if (context.counter >= context.noofloops) {
        if (context.lastbatch > 0) {
            context.startposition = context.counter * kony.sync.getAsyncDownloadBatchSize();
            context.endposition = context.startposition + context.lastbatch;
            kony.sync.applyChangesToDB(context);
            context.counter = context.counter + 1;
            context.lastbatch = 0;
            kony.api.executeAsync(kony.sync.applyChangesToDBAsync, context);
        } else {
            kony.sync.postApplyChanges(context.tx, context.serverblob, context.morechanges);
            kony.db.commitTransaction(context.tx);
        }
    } else {
        context.startposition = context.counter * kony.sync.getAsyncDownloadBatchSize();
        context.endposition = context.startposition + kony.sync.getAsyncDownloadBatchSize();
        kony.sync.applyChangesToDB(context);
        context.counter = context.counter + 1;
        sync.log.debug("point ******c : ", context);
        kony.api.executeAsync(kony.sync.applyChangesToDBAsync, context);
    }
};
kony.sync.updateSyncVerisonNumberForFailedRow = function(tx, tablename, pkKey, pkValue) {
    sync.log.trace("Entering kony.sync.updateSyncVerisonNumberForFailedRow ");
    var versionNo = kony.sync.getseqnumber(tx, kony.sync.currentScope[kony.sync.scopeName]);
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet !== false) {
        if (resultSet.rows.length > 0) {
            var versionMap = {};
            versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo.versionnumber;
            var whereClause = [];
            kony.table.insert(whereClause, {
                key: kony.sync.historyTableChangeTypeColumn,
                value: "9%",
                optype: "NOT LIKE"
            });
            kony.table.insert(whereClause, {
                key: pkKey,
                value: pkValue
            });
            query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, versionMap);
            kony.sync.qb_where(query, whereClause);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return;
            }
        }
    }
};
kony.sync.addBinaryRecordsToDownload = function(tx, tablename, pkColumns) {
    sync.log.trace("Entering kony.sync.addBinaryRecordsToDownload ");

    function errorCallback(err) {
        sync.log.trace("Entering errorCallback");
        kony.sync.errorObject = err;
        kony.sync.downloadFailed(false);
    }
    //from the table fetch all the records having NULL for blobref columns with "always" policy.
    var alwaysColumns = kony.sync.getBinaryColumnsByPolicy(tablename, kony.sync.always);
    //var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
    var resultSet;
    for (var k = 0; k < alwaysColumns.length; k++) {
        sync.log.trace("kony.sync.addBinaryRecordsToDownload - alwaysColumn is " + alwaysColumns[k]);
        var konysyncBinaryMetaColumn = kony.sync.binaryMetaColumnPrefix + alwaysColumns[k];
        var whereClause = [{
            key: konysyncBinaryMetaColumn,
            value: kony.sync.blobRefNotDefined
        }, {
            key: alwaysColumns[k],
            value: kony.sync.blobRefNotDefined,
            optype: "NOT_EQ"
        }];
        resultSet = kony.sync.queryTable(tx, tablename, pkColumns, whereClause);
        //parse through the result set, create blob record for each record and update its reference at parent table.
        if (resultSet) {
            sync.log.trace("kony.sync.addBinaryRecordsToDownload - Number of always records to be added to the download queue " + resultSet.rows.length);
            for (var l = 0; l < resultSet.rows.length; l++) {
                var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, l);
                //create a record in blobStoreManager.
                kony.sync.blobManager.triggerDownload(tx, tablename, alwaysColumns[k], rowItem, errorCallback);
                //increment total number of download jobs..
                kony.sync.incrementTotalJobs(true);
            }
        } else {
            sync.log.error("Error in querying table " + tablename);
            return;
        }
    }
    //for ifRecordValue columns...
    var ifRecordValueColumns = kony.sync.getBinaryColumnsByPolicy(tablename, kony.sync.ifRecordValue);
    for (var k = 0; k < ifRecordValueColumns.length; k++) {
        //fetch the synctodevicefield for the column.
        var syncToDeviceColumn = kony.sync.getSyncToDeviceField(tablename, ifRecordValueColumns[k]);
        if (syncToDeviceColumn) {
            sync.log.trace("kony.sync.addBinaryRecordsToDownload - alwaysColumn is " + ifRecordValueColumns[k]);
            var konysyncBinaryMetaColumn = kony.sync.binaryMetaColumnPrefix + ifRecordValueColumns[k];
            var whereClause = [{
                key: konysyncBinaryMetaColumn,
                value: kony.sync.blobRefNotDefined
            }, {
                key: ifRecordValueColumns[k],
                value: kony.sync.blobRefNotDefined,
                optype: "NOT_EQ"
            }, {
                key: syncToDeviceColumn,
                value: "true"
            }];
            resultSet = kony.sync.queryTable(tx, tablename, pkColumns, whereClause);
            if (resultSet) {
                sync.log.trace("kony.sync.addBinaryRecordsToDownload - Number of ifrecordvalue records to be added to the download queue " + resultSet.rows.length);
                for (var l = 0; l < resultSet.rows.length; l++) {
                    var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, l);
                    //create a record in blobStoreManager.
                    kony.sync.blobManager.triggerDownload(tx, tablename, ifRecordValueColumns[k], rowItem, errorCallback);
                    //increment total number of download jobs..
                    kony.sync.incrementTotalJobs(true);
                }
            } else {
                sync.log.error("Error in querying table " + tablename);
                return;
            }
        }
    }
    return true;
};
kony.sync.applyChangesToBlobStoreDB = function(tx, tablename, row, blobMap, changeType, pks) {
    sync.log.trace("Entering kony.sync.applyChangesToBlobStoreDB ");

    function errorCallback(err) {
        sync.log.trace("Entering errorCallback");
        kony.sync.errorObject = err;
        kony.sync.downloadFailed(false);
    }

    function binarySuccessCallback(response) {
        sync.log.trace("kony.sync.applyChangesToBlobStoreDB .. binarySuccessCallback  ", response);
        kony.sync.incrementCompletedJobs(true);
        kony.sync.invokeBinaryNotifiers(true);
    }

    function binaryErrorCallback(error) {
        sync.log.trace("kony.sync.applyChangesToBlobStoreDB .. binaryErrorCallback  ", error);
        kony.sync.incrementFailedJobs(true);
        kony.sync.invokeBinaryNotifiers(true);
    }
    var blobStoreIndices = {};
    var dbname = kony.sync.getDBName();
    //adding the always, ifrecordvalue policy binaries to download queue..
    var binaryColumns = kony.sync.getBinaryColumns(tablename);
    if (binaryColumns) {
        for (var k = 0; k < binaryColumns.length; k++) {
            //create primaryKey Map.
            var primaryKeyTable = {};
            var primaryKeyColumns = kony.sync.getPrimaryKeyColumns(tablename);
            for (var index in primaryKeyColumns) {
                primaryKeyTable[primaryKeyColumns[index]] = row[primaryKeyColumns[index]];
            }
            switch (kony.sync.getDownloadPolicy(tablename, binaryColumns[k])) {
                case kony.sync.always:
                    var pendingJob = {
                        "tableName": tablename,
                        "binaryColumn": binaryColumns[k],
                        "primaryKeyTable": primaryKeyTable
                    };
                    kony.sync.pendingBinaryDownloadJobs.push(pendingJob);
                    break;
                case kony.sync.ifRecordValue:
                    var syncToDeviceField = kony.sync.getSyncToDeviceField(tablename, binaryColumns[k]);
                    if (syncToDeviceField && row[syncToDeviceField] === "true") {
                        var pendingJob = {
                            "tableName": tablename,
                            "binaryColumn": binaryColumns[k],
                            "primaryKeyTable": primaryKeyTable
                        };
                        kony.sync.pendingBinaryDownloadJobs.push(pendingJob);
                    }
                    break;
            }
        }
    }
    sync.log.trace("inserting inline base64 data in kony blobstoremanager..");
    if (changeType === "insert") {
        if (Object.keys(blobMap).length > 0) {
            var inlineBlobStoreIndices = kony.sync.blobstore_insert(tx, tablename, blobMap, errorCallback);
            if (inlineBlobStoreIndices) {
                for (var blobKey in inlineBlobStoreIndices) {
                    blobStoreIndices[blobKey] = inlineBlobStoreIndices[blobKey];
                }
            } else {
                sync.log.error("applyChangesToDb - error in inserting inline base64 data for table " + tablename);
                return false;
            }
        }
    } else if (changeType === "update") {
        if (Object.keys(blobMap).length > 0) {
            var inlineBlobStoreIndices = kony.sync.blobstore_update(tx, tablename, blobMap, pks, false, errorCallback);
            if (inlineBlobStoreIndices) {
                for (var blobKey in inlineBlobStoreIndices) {
                    blobStoreIndices[blobKey] = inlineBlobStoreIndices[blobKey];
                }
            } else {
                sync.log.error("applyChangesToDb - error in updating inline base64 data for table " + tablename);
                return false;
            }
        }
    }
    if (Object.keys(blobStoreIndices).length > 0) {
        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
        sync.log.trace("updating blobref values in parent table.. " + JSON.stringify(blobStoreIndices));
        //update the parent table with blob references.
        var wcs = [];
        for (var key = 0; key < pkColumns.length; key++) {
            var wc = {};
            wc.key = pkColumns[key];
            wc.value = row[pkColumns[key]];
            wcs.push(wc);
        }
        var resultset = kony.sync.blobManager.updateParentWithBlobReference(tx, tablename, blobStoreIndices, wcs, errorCallback);
        if (resultset === false || kony.sync.isNullOrUndefined(resultset)) {
            return false;
        }
    }
    //invoke the status update notifier..
    kony.sync.invokeBinaryNotifiers(true);
};
kony.sync.applyChangesToDB = function(context) {
    sync.log.trace("Entering kony.sync.applyChangesToDB ");
    var tx = context.tx;
    var results = context.results;
    var startposition = context.startposition;
    var endposition = context.endposition;
    var newVersion = kony.sync.getseqnumber(tx, kony.sync.currentScope.ScopeName);
    var newVersionNo = newVersion.versionnumber;
    var j = null;
    var pk = null;
    var query_compile = null;
    var query = null;
    var sql = null;
    var params = null;
    var resultset = null;
    var prevTable = '';
    var internalBatchSize = 53;
    var currentSqlQuery = "";
    var insertUpdateCounter = 0;
    var currentScope = context.currentScope;
    var columnsInScopeTable = {};
    //populate columns for tables.
    for (var tableCount = 0; tableCount < currentScope.ScopeTables.length; tableCount++) {
        var syncTable = currentScope.ScopeTables[tableCount];
        var tableName = syncTable.Name;
        if (tableName) {
            var columns = syncTable["Columns"];
            var columnList = [kony.sync.mainTableHashSumColumn, kony.sync.mainTableSyncVersionColumn];
            for (var columnCount = 0; columnCount < columns.length; columnCount++) {
                kony.table.insert(columnList, columns[columnCount]["Name"]);
            }
        }
        columnsInScopeTable[tableName] = columnList;
    }

    function getColumnsForInsertORReplaceQuery(tableName) {
        var columnNamesForInsertQuery = "(";
        var columnList = columnsInScopeTable[tableName];
        for (var colIndex = 0; colIndex < columnList.length - 1; colIndex++) {
            columnNamesForInsertQuery += columnList[colIndex] + ",";
        }
        return columnNamesForInsertQuery + columnList[columnList.length - 1] + ")";
    }

    function getInsertORReplaceQueryStringForTable(tableName) {
        var sqlQuery = "INSERT" + " OR REPLACE " + "INTO " + tableName + " " + getColumnsForInsertORReplaceQuery(tableName) + " VALUES ";
        return sqlQuery;
    }

    function getColumnsValuesForInsertORReplaceQuery(tableName, tableDataFromResponse) {
        var columnsValuesForInsertQuery = "(";
        var columns = columnsInScopeTable[tableName];
        /* 
        	Changes done for [MFSDK-3879]
        	As we are creating raw queries for bulk insert, we are replacing " character with "" characters
        	to avoid malformed query. SQL reads "" as " in a raw query, and inserts it accordingly. 
        */
        for (var colIndex = 0; colIndex < columns.length - 1; colIndex++) {
            var value = tableDataFromResponse[columns[colIndex]];
            if ((typeof value) == "Undefined" || value == null) {
                value = "NULL";
            }
            value = value.replace(/"/gi, "\"\"");
            columnsValuesForInsertQuery = columnsValuesForInsertQuery + "\"" + value + "\",";
        }
        var value = tableDataFromResponse[columns[columns.length - 1]];
        if ((typeof value) == "Undefined" || value == null) {
            value = "NULL";
        }
        value = value.replace(/"/gi, "\"\"");
        columnsValuesForInsertQuery = columnsValuesForInsertQuery + "\"" + value + "\"" + ")";
        return columnsValuesForInsertQuery;
    }

    function bulkInsert(tableName, tableDataFromResponse) {
        if (currentSqlQuery !== "") {
            currentSqlQuery += "," + getColumnsValuesForInsertORReplaceQuery(tableName, tableDataFromResponse);
        } else {
            currentSqlQuery = getInsertORReplaceQueryStringForTable(tableName) + getColumnsValuesForInsertORReplaceQuery(tableName, tableDataFromResponse);
        }
        return currentSqlQuery;
    }

    function executeBulkInsert(sqlQuery) {
        return kony.sync.executeSql(tx, sqlQuery, null, null);
    }
    if (kony.sync.isNullOrUndefined(results)) {
        return;
    }
    var insertNull = kony.sync.getInsertNullForFieldsMissingInPayload();
    //before updating changes to db, addBinaryRecordsToDownload.
    sync.log.trace("kony.sync.applyChangesToDb - addBinaryRecordsToDownload.");
    var syncscopes = konysyncClientSyncConfig.ArrayOfSyncScope;
    if (!kony.sync.isNullOrUndefined(syncscopes)) {
        for (var scopeCount = 0; scopeCount < syncscopes.length; scopeCount++) {
            var scope = syncscopes[scopeCount];
            sync.log.trace("kony.sync.applyChangesToDb - current scope " + scope.ScopeName);
            if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
                for (var tableCount = 0; tableCount < scope.ScopeTables.length; tableCount++) {
                    var syncTable = scope.ScopeTables[tableCount];
                    var tablename = syncTable.Name;
                    sync.log.trace("kony.sync.applyChangesToDb - addBinaryRecordsToDownload for " + tablename);
                    if (tablename) {
                        var addingPendingBinariesForDownload = kony.sync.addBinaryRecordsToDownload(tx, tablename, syncTable.Pk_Columns);
                        if (!addingPendingBinariesForDownload) {
                            sync.log.trace("kony.sync.applyChangesToDb - addBinaryRecordsToDownload failed..");
                            return false;
                        }
                    }
                }
            }
        }
    }
    var _upgradeContextForBulkInsert = kony.sync.schemaUpgradeContext;
    var _upgradeContextJSONForBulkInsert = null;
    if (!kony.sync.isNullOrUndefined(_upgradeContextForBulkInsert)) {
        _upgradeContextJSONForBulkInsert = JSON.parse(_upgradeContextForBulkInsert);
    }
    for (var i = startposition; i < endposition; i++) {
        var row = results[i];
        var tablename = row.__metadata.type;
        if (kony.sync.isNullOrUndefined(kony.sync.objectLevelInfoMap[tablename])) {
            kony.sync.objectLevelInfoMap[tablename] = {};
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDownloaded] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsAcknowledged] = 0;
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] = 0;
        }
        if (kony.sync.objectLevelInfoMap[tablename][kony.sync.reconciledKeysKey] == null) {
            kony.sync.objectLevelInfoMap[tablename][kony.sync.reconciledKeysKey] = [];
        }
        var changeType = row.__metadata.changeType;
        var values = [];
        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
        var pkwcs = [];
        var pkset = null;
        var pksetwcs = [];
        var blobMap = {};
        //var currentversion = kony.sync.getCurrentVersionNumber(tablename);
        var MergedWithEIS = row[kony.sync.mergedWithEIS];
        var versionNumber = row[kony.sync.mainTableSyncVersionColumn];
        versionNumber = kony.sync.tonumber(versionNumber);
        sync.log.trace("row is are " + JSON.stringify(row));
        if (MergedWithEIS !== "1" && MergedWithEIS !== "0") {
            if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename])) {
                var binaryDataColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                sync.log.trace("values are " + JSON.stringify(values));
                var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                for (var j = 0; j < binaryColumns.length; j++) {
                    //getDownloadPolicy of the column
                    var downloadPolicy = kony.sync.getDownloadPolicy(tablename, binaryColumns[j]);
                    if (downloadPolicy == kony.sync.inline) {
                        if (!kony.sync.isNullOrUndefined(row[binaryColumns[j]]) && row[binaryColumns[j]].trim().length > 0) blobMap[binaryColumns[j]] = row[binaryColumns[j]];
                        delete row[binaryColumns[j]];
                    }
                }
            }
        }
        sync.log.trace("after applyDB blobstore " + JSON.stringify(row));
        values = kony.sync.removeprovisioncolumns(row, kony.sync.currentScope.syncTableDic[tablename].Columns, true, insertNull);
        if (MergedWithEIS !== "1" && MergedWithEIS !== "0") {
            var hasInstanceInMainTable = false;
            var binaryColumns;
            if (kony.sync.enableBulkInsert && changeType === "update" && (kony.sync.isNullOrUndefined(_upgradeContextJSONForBulkInsert) || kony.sync.isNullOrUndefined(_upgradeContextJSONForBulkInsert[tableName]))) {
                //This case takes care of insert/update during sync and no schema upgrade for table.
                var result = null;
                //execute query in case of different table name or query batch limit is reached.
                if (prevTable !== tablename || insertUpdateCounter % internalBatchSize == 0) {
                    prevTable = tablename;
                    //checks whether record already exist or not.
                    binaryColumns = kony.sync.getBinaryColumns(tablename);
                    if (currentSqlQuery != "") {
                        result = executeBulkInsert(currentSqlQuery);
                        currentSqlQuery = "";
                        insertUpdateCounter = 0;
                        sync.log.trace("result is " + JSON.stringify(result));
                        if (result === false) {
                            sync.log.error("Bulk insert in download failed");
                            return false;
                        }
                    }
                }
                //add the null columns update scenario
                var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
                values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, insertNull);
                if (!kony.sync.isNullOrUndefined(pkColumns)) {
                    for (j = 0; j < pkColumns.length; j++) {
                        pk = pkColumns[j];
                        if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                            //pkset = pkset.." "..pk.."='"..row[pk].."'";
                            if (kony.sync.isNullOrUndefined(pkset)) {
                                pkset = {};
                            }
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[kony.sync.clientPKPrefix + pk]
                            });
                            pkset[pk] = row[pk];
                            kony.table.insert(pksetwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        } else {
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[pk]
                            });
                            kony.table.insert(pksetwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        }
                    }
                }
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: "nil",
                    optype: "EQ",
                    comptype: "OR",
                    openbrace: true
                });
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: -1,
                    optype: "EQ",
                    comptype: "OR",
                    closebrace: true
                });
                var originalwcs = kony.sync.CreateCopy(pksetwcs);
                var hasInstanceInHistoryTable = false;
                if (!kony.sync.enableOverride) {
                    hasInstanceInHistoryTable = kony.sync.checkForHistoryInstance(tx, tablename, values, originalwcs);
                }
                if (hasInstanceInHistoryTable === 0) {
                    return false;
                }
                if (hasInstanceInHistoryTable === false) {
                    //Adds current row to query.
                    bulkInsert(tablename, row);
                    insertUpdateCounter++;
                }
                if (binaryColumns) {
                    hasInstanceInMainTable = kony.sync.checkForInstance(tx, tablename, values, originalwcs);
                }
                if (hasInstanceInMainTable) {
                    //update the blob store manager..
                    function updateBlobStoreManager(pks) {
                        kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "update", pks);
                    }
                    //for binary columns, delete the existing entries.
                    function deleteOnDemandBinaryEntries() {
                        sync.log.trace("entering deleteOnDemandBinaryEntries..");

                        function updateBlobErrorCallback(err) {
                            kony.sync.errorObject = err;
                            kony.sync.downloadFailed(false);
                        }
                        if (binaryColumns) {
                            sync.log.trace("onDemandColumns for " + tablename + " are " + JSON.stringify(binaryColumns));
                            for (var j = 0; j < binaryColumns.length; j++) {
                                if (kony.sync.getDownloadPolicy(tablename, binaryColumns[j]) !== kony.sync.inline) {
                                    var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
                                    var pkTable = {};
                                    for (var pk = 0; pk < pkColumns.length; pk++) {
                                        pkTable[pkColumns[pk]] = row[pkColumns[pk]];
                                    }
                                    //get the blobrefs of ondemand columns and delete that entries in blob store manager.
                                    var blobRef = kony.sync.getBlobRef(tx, tablename, binaryColumns[j], pkTable, updateBlobErrorCallback);
                                    sync.log.trace("blobRef for the data is " + blobRef + "for pkTable " + JSON.stringify(pkTable) + "in tablename " + tablename);
                                    if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                                        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, updateBlobErrorCallback);
                                        //delete the record only if it is not in queue for upload.
                                        if (blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_ACCEPTED && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_IN_PROGRESS && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_FAILED) {
                                            //TODO - open item. delete the image after upload.
                                            var isDeleteSuccessful = kony.sync.blobManager.deleteBlob(tx, blobRef, updateBlobErrorCallback);
                                            sync.log.trace("isDeleteSuccessful uploadBlobStoreManager " + isDeleteSuccessful);
                                            if (!isDeleteSuccessful) return false;
                                            //update NULL in the parent table.
                                            sync.log.trace("deleteOnDemandEntries - updating blobref column for " + binaryColumns[j] + " with NULL");
                                            values[kony.sync.binaryMetaColumnPrefix + binaryColumns[j]] = kony.sync.blobRefNotDefined;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (hasInstanceInHistoryTable === 0) {
                        return false;
                    }
                    if (hasInstanceInHistoryTable === false) {
                        //first delete the blob entries for the respective column.
                        deleteOnDemandBinaryEntries();
                        if (!kony.sync.isNullOrUndefined(pkset)) {
                            //update blobstore manager ?
                            updateBlobStoreManager(pksetwcs);
                        } else {
                            //update blobstore manager ?
                            updateBlobStoreManager(pkwcs);
                        }
                    }
                    kony.sync.serverUpdateCount = kony.sync.serverUpdateCount + 1;
                    // update if the user hasn't changed the record
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + 1;
                } else {
                    kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "insert");
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + 1;
                    kony.sync.serverInsertCount = kony.sync.serverInsertCount + 1;
                }
            } else if ((changeType === "update")) {
                //do purge logic here.
                var result = null;
                result = kony.sync.insertEx(tx, tablename, values, null, true);
                if (result === false) {
                    return false;
                }
                if (result !== false && result.rowsAffected === 0) {
                    sync.log.trace("Change type is update in sync session- insert failed.. ");
                    var _upgradeContext = kony.sync.schemaUpgradeContext;
                    var _upgradeContextJSON = null;
                    if (!kony.sync.isNullOrUndefined(_upgradeContext)) {
                        _upgradeContextJSON = JSON.parse(_upgradeContext);
                    }
                    //add the null columns update scenario
                    if (kony.sync.isNullOrUndefined(_upgradeContextJSON) || kony.sync.isNullOrUndefined(_upgradeContextJSON[tablename])) {
                        var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
                        values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, insertNull);
                    } else {
                        //DSC scenario
                        var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
                        values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, false);
                    }
                    if (!kony.sync.isNullOrUndefined(pkColumns)) {
                        for (j = 0; j < pkColumns.length; j++) {
                            pk = pkColumns[j];
                            if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                                //pkset = pkset.." "..pk.."='"..row[pk].."'";
                                if (kony.sync.isNullOrUndefined(pkset)) {
                                    pkset = {};
                                }
                                kony.table.insert(pkwcs, {
                                    key: pk,
                                    value: row[kony.sync.clientPKPrefix + pk]
                                });
                                pkset[pk] = row[pk];
                                kony.table.insert(pksetwcs, {
                                    key: pk,
                                    value: row[pk]
                                });
                            } else {
                                kony.table.insert(pkwcs, {
                                    key: pk,
                                    value: row[pk]
                                });
                                kony.table.insert(pksetwcs, {
                                    key: pk,
                                    value: row[pk]
                                });
                            }
                        }
                    }
                    kony.table.insert(pkwcs, {
                        key: kony.sync.mainTableChangeTypeColumn,
                        value: "nil",
                        optype: "EQ",
                        comptype: "OR",
                        openbrace: true
                    });
                    kony.table.insert(pkwcs, {
                        key: kony.sync.mainTableChangeTypeColumn,
                        value: -1,
                        optype: "EQ",
                        comptype: "OR",
                        closebrace: true
                    });
                    /* kony.table.insert(pkwcs, {
                     key: kony.sync.mainTableSyncVersionColumn,
                     value: currentversion,
                     optype : "EQ"
                     });*/
                    var originalwcs = kony.sync.CreateCopy(pksetwcs);
                    var hasInstanceInHistoryTable = kony.sync.checkForHistoryInstance(tx, tablename, values, originalwcs);
                    //update the blob store manager..
                    function updateBlobStoreManager(pks) {
                        sync.log.trace("Entering updateBlobStoreManager");
                        kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "update", pks);
                    }
                    //for binary columns, delete the existing entries.
                    function deleteOnDemandBinaryEntries() {
                        sync.log.trace("entering deleteOnDemandBinaryEntries..");

                        function updateBlobErrorCallback(err) {
                            sync.log.trace("Entering updateBlobErrorCallback");
                            kony.sync.errorObject = err;
                            kony.sync.downloadFailed(false);
                        }
                        var binaryColumns = kony.sync.getBinaryColumns(tablename);
                        if (binaryColumns) {
                            sync.log.trace("onDemandColumns for " + tablename + " are " + JSON.stringify(binaryColumns));
                            for (var j = 0; j < binaryColumns.length; j++) {
                                if (kony.sync.getDownloadPolicy(tablename, binaryColumns[j]) !== kony.sync.inline) {
                                    var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
                                    var pkTable = {};
                                    for (var pk = 0; pk < pkColumns.length; pk++) {
                                        pkTable[pkColumns[pk]] = row[pkColumns[pk]];
                                    }
                                    //get the blobrefs of ondemand columns and delete that entries in blob store manager.
                                    var blobRef = kony.sync.getBlobRef(tx, tablename, binaryColumns[j], pkTable, updateBlobErrorCallback);
                                    sync.log.trace("blobRef for the data is " + blobRef + "for pkTable " + JSON.stringify(pkTable) + "in tablename " + tablename);
                                    if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                                        var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, updateBlobErrorCallback);
                                        //delete the record only if it is not in queue for upload.
                                        if (blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_ACCEPTED && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_IN_PROGRESS && blobMeta[kony.sync.blobManager.state] !== kony.sync.blobManager.UPLOAD_FAILED) {
                                            //TODO - open item. delete the image after upload.
                                            var isDeleteSuccessful = kony.sync.blobManager.deleteBlob(tx, blobRef, updateBlobErrorCallback);
                                            sync.log.trace("isDeleteSuccessful uploadBlobStoreManager " + isDeleteSuccessful);
                                            if (!isDeleteSuccessful) return false;
                                            //update NULL in the parent table.
                                            sync.log.trace("deleteOnDemandEntries - updating blobref column for " + binaryColumns[j] + " with NULL");
                                            values[kony.sync.binaryMetaColumnPrefix + binaryColumns[j]] = kony.sync.blobRefNotDefined;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (hasInstanceInHistoryTable === 0) {
                        return false;
                    }
                    if (hasInstanceInHistoryTable === false) {
                        //first delete the blob entries for the respective column.
                        deleteOnDemandBinaryEntries();
                        if (!kony.sync.isNullOrUndefined(pkset)) {
                            if (kony.sync.updateEx(tx, tablename, values, pksetwcs) === false) {
                                return false;
                            } else {
                                //update blobstore manager ?
                                updateBlobStoreManager(pksetwcs);
                            }
                        } else {
                            if (kony.sync.updateEx(tx, tablename, values, pkwcs) === false) {
                                return false;
                            } else {
                                //update blobstore manager ?
                                updateBlobStoreManager(pkwcs);
                            }
                        }
                    }
                    kony.sync.serverUpdateCount = kony.sync.serverUpdateCount + 1;
                    // update if the user hasn't changed the record
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + 1;
                    //					if(kony.sync.updateEx(tx, tablename, values, pkwcs)===false){
                    //						return false;
                    //					}
                } else {
                    kony.sync.applyChangesToBlobStoreDB(tx, tablename, row, blobMap, "insert");
                    kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + 1;
                    kony.sync.serverInsertCount = kony.sync.serverInsertCount + 1;
                }
            } else if ((changeType === "delete")) {
                values = kony.sync.removeprovisioncolumns(row, kony.sync.currentScope.syncTableDic[tablename].Columns, true, insertNull);
                // delete the record if it hasn't been changed by the user
                if (!kony.sync.isNullOrUndefined(pkColumns)) {
                    for (j = 0; j < pkColumns.length; j++) {
                        pk = pkColumns[j];
                        if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                            //pkwc = pkwc.." "..pk.."='"..row["Client_"..pk].."'";
                            //pkset = pkset.." "..pk.."='"..row[pk].."'";
                            if (kony.sync.isNullOrUndefined(pkset)) {
                                pkset = {};
                            }
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[kony.sync.clientPKPrefix + pk]
                            });
                            pkset[pk] = row[pk];
                            kony.table.insert(pksetwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        } else {
                            kony.table.insert(pkwcs, {
                                key: pk,
                                value: row[pk]
                            });
                        }
                    }
                }
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: "nil",
                    optype: "EQ",
                    comptype: "OR",
                    openbrace: true
                });
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableChangeTypeColumn,
                    value: -1,
                    optype: "EQ",
                    closebrace: true
                });
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted] + 1;
                kony.sync.serverDeleteCount = kony.sync.serverDeleteCount + 1;
                /*WARNING: Undefined method call for kony.sync.deleteEx*/
                function blobDeleteErrorCallback(err) {
                    sync.log.trace("Entering blobDeleteErrorCallback");
                    kony.sync.errorObject = err;
                    kony.sync.downloadFailed(false);
                }
                //delete the blob record first.
                if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns])) {
                    var binaryDataColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                    //get the blobRef for the column and delete the blobrecord.
                    for (var blobColumn = 0; blobColumn < binaryDataColumns.length; blobColumn++) {
                        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
                        var pks = {};
                        for (var pk = 0; pk < pkColumns.length; pk++) {
                            pks[pkColumns[pk]] = row[pkColumns[pk]];
                        }
                        var blobRef = kony.sync.getBlobRef(tx, tablename, binaryDataColumns[blobColumn], pks, blobDeleteErrorCallback);
                        if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                            var isDeleteSuccessful = kony.sync.blobManager.deleteBlob(tx, blobRef, blobDeleteErrorCallback);
                            if (!isDeleteSuccessful) return false;
                        }
                    }
                }
                if (kony.sync.removeEx(tx, tablename, pkwcs) === false) {
                    return false;
                }
            }
            kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDownloaded] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInserted] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdated] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeleted];
        } else {
            //deleting data of binary columns. but only in case of inline.
            if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns])) {
                var binaryDataColumns = kony.sync.scopes.syncScopeBlobInfoMap[tablename][kony.sync.columns];
                var binaryColumn = null;
                for (var k = 0; k < binaryDataColumns.length; k++) {
                    binaryColumn = binaryDataColumns[k];
                    var downloadPolicy = kony.sync.getDownloadPolicy(tablename, binaryColumn);
                    if (downloadPolicy === kony.sync.inline) {
                        delete row[binaryColumn];
                    }
                }
            }
            var pkTable = {};
            var originalChangeType = row[kony.sync.mainTableChangeTypeColumn];
            if (kony.sync.isNullOrUndefined(originalChangeType)) {
                originalChangeType = 1;
            }
            //ignore the blobref columns in removeprovisioncolumns method.
            var columnsDefinedForTable = kony.sync.removeBinaryMetaColumns(tablename, kony.sync.currentScope.syncTableDic[tablename].Columns);
            values = kony.sync.removeprovisioncolumns(row, columnsDefinedForTable, true, insertNull);
            //creating a map of reconciled primary keys
            var keyMap = {};
            var isAutoGenPkPresent = false;
            if (!kony.sync.isNullOrUndefined(pkColumns)) {
                for (j = 0; j < pkColumns.length; j++) {
                    pk = pkColumns[j];
                    pkTable[pk] = row[pk]; //creating pk for uploadcontext
                    if (!kony.sync.isNullOrUndefined(row[kony.sync.clientPKPrefix + pk])) {
                        if (kony.sync.isNullOrUndefined(pkset)) {
                            pkset = {};
                        }
                        kony.table.insert(pkwcs, {
                            key: pk,
                            value: row[kony.sync.clientPKPrefix + pk]
                        });
                        pkset[pk] = row[pk];
                        kony.table.insert(pksetwcs, {
                            key: pk,
                            value: row[pk]
                        });
                        isAutoGenPkPresent = true;
                        keyMap[pk] = {
                            newpk: row[pk],
                            oldpk: row[kony.sync.clientPKPrefix + pk]
                        };
                    } else {
                        kony.table.insert(pkwcs, {
                            key: pk,
                            value: row[pk]
                        });
                        kony.table.insert(pksetwcs, {
                            key: pk,
                            value: row[pk]
                        });
                    }
                }
            }
            var originalwcs = kony.sync.CreateCopy(pksetwcs);
            if (isAutoGenPkPresent) {
                kony.sync.objectLevelInfoMap[tablename][kony.sync.reconciledKeysKey].push(keyMap);
            }
            sync.log.debug("Inside MergedWithEis");
            var isError = false;
            var prevErrors = 0;
            if (!kony.sync.isNullOrUndefined(row.__metadata.intermediateErrors)) {
                prevErrors = row.__metadata.intermediateErrors.length;
            }
            //checking for error on continueonerror upload policy
            if (!kony.sync.isNullOrUndefined(row.__metadata.errorMessage)) {
                kony.sync.serverFailedCount = kony.sync.serverFailedCount + 1 + prevErrors;
                kony.sync.uploadSummary.push({
                    key: pkTable,
                    type: row.__metadata.type,
                    errorMessage: row.__metadata.errorMessage,
                    errorRootCause: row.__metadata.errorRootCause,
                    intermediateErrors: row.__metadata.intermediateErrors
                });
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] + 1 + prevErrors;
                isError = true;
                if ((kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) && kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
                    //Increase the version number of the failed row
                    kony.sync.updateSyncVerisonNumberForFailedRow(tx, tablename, pk, row[pk]);
                }
            }
            //checking for previous errors
            else if (prevErrors !== 0) {
                kony.sync.uploadSummary.push({
                    key: pkTable,
                    type: row.__metadata.type,
                    errorMessage: null,
                    errorRootCause: null,
                    intermediateErrors: row.__metadata.intermediateErrors
                });
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsFailedtoUpload] + prevErrors;
                kony.sync.serverFailedCount = kony.sync.serverFailedCount + prevErrors;
            }
            var settable = {};
            //before updating the pk
            //remove row from history, original and main(in case of removeafterupload) tables for COE error upload policy if success
            var isRemoved = false;
            isRemoved = kony.sync.clearDataForCOE(tx, kony.sync.currentScope.ScopeName, tablename, pkwcs, pksetwcs, changeType, pkset, row[kony.sync.historyTableReplaySequenceColumn], values, isError);
            if (isRemoved === 0) {
                return false;
            }
            if (!kony.sync.isNullOrUndefined(pkset)) {
                /*update related tables foreign keys*/
                //reconciliation starts here .....
                //row implies record here,i inplies index of the record
                var _isError = kony.sync.reconcileForeignKeyForChildren(tx, pkset, pkwcs, tablename, row, i, endposition, results);
                if (_isError === 0) return false;
            }
            if (isError === false) {
                kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsAcknowledged] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] + kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck];
                //continue if removed to skip updates for same record
                if (isRemoved === true) {
                    continue;
                }
                //if no error, change changetype to null in main table
                settable[kony.sync.mainTableChangeTypeColumn] = "nil";
            } else {
                //checking for error on continueonerror upload policy and making the reconciled values consistent in child tables
                if (!kony.sync.isNullOrUndefined(row.__metadata.errorMessage)) {
                    //querying the foreignkey values from from child table and replacing in setclause to maintain reconciled values properly in child table
                    selectClause = [];
                    parentRelationshipMap = kony.sync.currentScope.syncTableDic[tablename + kony.sync.parentRelationshipMap];
                    //onetomany relationships from parent table
                    for (var tname in parentRelationshipMap) {
                        var relationshipAttributes = parentRelationshipMap[tname];
                        var relationshipAttributes_length = relationshipAttributes.length;
                        for (var k = 0; k < relationshipAttributes_length; k++) {
                            relationshipAttribute = relationshipAttributes[k];
                            var columnName = relationshipAttribute["ChildObject_Attribute"];
                            selectClause.push(columnName);
                        }
                    }
                    synctable = kony.sync.currentScope.syncTableDic[tablename];
                    ManyToOne = synctable.Relationships.ManyToOne; //manytone relationships
                    //manytoone relationships in childtable
                    if (!kony.sync.isNullOrUndefined(ManyToOne)) {
                        ManyToOne_length = ManyToOne.length;
                        for (var k = 0; k < ManyToOne_length; k++) {
                            if (!kony.sync.isNullOrUndefined(ManyToOne[k].RelationshipAttributes)) {
                                var relationshipAttributes = ManyToOne[k].RelationshipAttributes;
                                for (var j = 0; j < relationshipAttributes.length; j++) {
                                    var columnName = relationshipAttributes[j].SourceObject_Attribute;
                                    selectClause.push(columnName);
                                };
                            }
                        }
                    }
                    //reverse relationships in childtable
                    reverseRelationships = kony.sync.currentScope.reverseRelationships[tablename];
                    if (!(kony.sync.isNullOrUndefined(reverseRelationships))) {
                        for (var k = 0; k < reverseRelationships.length; k++) {
                            relationshipAttributes = reverseRelationships[k].RelationshipAttributes;
                            for (var j = 0; j < relationshipAttributes.length; j++) {
                                var columnName = relationshipAttributes[j].SourceObject_Attribute;
                                selectClause.push(columnName);
                            }
                        }
                    }
                    if (selectClause.length != 0) {
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_select(query, selectClause);
                        kony.sync.qb_from(query, tablename);
                        kony.sync.qb_where(query, pkwcs); //using the whereClause already generated
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        resultset = kony.sync.executeSql(tx, sql, params); //need to handle error callback if required
                        //logic to process the resultset
                        if (resultset.rows.length >= 1) {
                            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                            for (var j = 0; j < selectClause.length; j++) {
                                var columnName = selectClause[j];
                                values[columnName] = rowItem[columnName];
                            }
                        }
                    }
                }
                //updating history table to make relationship data consistent
                var whereClause = kony.sync.CreateCopy(pkwcs);
                //versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo[ "versionnumber"];
                kony.table.insert(whereClause, {
                    key: kony.sync.historyTableReplaySequenceColumn,
                    value: row[kony.sync.historyTableReplaySequenceColumn]
                });
                if (kony.sync.updateEx(tx, tablename + kony.sync.historyTableName, values, whereClause) === false) {
                    return false;
                }
                //there is possibility that record is deleted by an earlier successful record, so insert it
                if (changeType !== "delete") {
                    if (!kony.sync.isNullOrUndefined(pkset)) {
                        whereClause = pksetwcs;
                    } else {
                        whereClause = pkwcs;
                    }
                    values[kony.sync.mainTableChangeTypeColumn] = originalChangeType;
                    values[kony.sync.mainTableSyncVersionColumn] = newVersionNo + 1;
                    query = kony.sync.qb_createQuery();
                    kony.sync.qb_select(query, null);
                    kony.sync.qb_from(query, tablename);
                    kony.sync.qb_where(query, whereClause);
                    query_compile = kony.sync.qb_compile(query);
                    sql = query_compile[0];
                    params = query_compile[1];
                    resultset = kony.sync.executeSql(tx, sql, params);
                    if (resultset !== false) {
                        var num_records = resultset.rows.length;
                        //updated if not deleted
                        if (num_records > 0) {
                            kony.sync.updateEx(tx, tablename, values, whereClause);
                        } else {
                            query = kony.sync.qb_createQuery();
                            kony.sync.qb_set(query, values);
                            kony.sync.qb_insert(query, tablename);
                            query_compile = kony.sync.qb_compile(query);
                            sql = query_compile[0];
                            params = query_compile[1];
                            if (kony.sync.executeSql(tx, sql, params) === false) {
                                //exit incase of SQL error
                                return false;
                            }
                        }
                    } else {
                        //exit incase of SQL error
                        return false;
                    }
                }
                continue;
            }
            if (!kony.sync.isNullOrUndefined(pkset)) {
                /* clear dirty flag if not updated again*/
                kony.table.insert(pksetwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: versionNumber,
                    optype: "LT_EQ",
                    openbrace: true,
                    comptype: "OR"
                });
                kony.table.insert(pksetwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: "nil",
                    closebrace: true
                });
                query = kony.sync.qb_createQuery();
                kony.sync.qb_update(query, tablename);
                kony.sync.qb_set(query, settable);
                kony.sync.qb_where(query, pksetwcs);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params) === false) {
                    return false;
                }
            } else {
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: versionNumber,
                    optype: "LT_EQ",
                    openbrace: true,
                    comptype: "OR"
                });
                kony.table.insert(pkwcs, {
                    key: kony.sync.mainTableSyncVersionColumn,
                    value: "nil",
                    closebrace: true
                });
                query = kony.sync.qb_createQuery();
                kony.sync.qb_update(query, tablename);
                kony.sync.qb_set(query, settable);
                kony.sync.qb_where(query, pkwcs);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params) === false) {
                    return false;
                }
            }
            if (changeType === "update") {
                // clear the dirty flag
                values[kony.sync.mainTableChangeTypeColumn] = "nil";
                values[kony.sync.mainTableSyncVersionColumn] = "nil";
                var hasInstanceInHistoryTable = kony.sync.checkForHistoryInstance(tx, tablename, values, originalwcs);
                if (hasInstanceInHistoryTable === 0) {
                    return false;
                }
                if (hasInstanceInHistoryTable === false) {
                    if (!kony.sync.isNullOrUndefined(pkset)) {
                        if (kony.sync.updateEx(tx, tablename, values, pksetwcs) === false) {
                            return false;
                        }
                    } else {
                        if (kony.sync.updateEx(tx, tablename, values, pkwcs) === false) {
                            return false;
                        }
                    }
                }
            } else if (changeType === "delete") {
                if (!kony.sync.isNullOrUndefined(pkset)) {
                    kony.table.insert(pksetwcs, {
                        key: kony.sync.mainTableSyncVersionColumn,
                        value: versionNumber
                    });
                    if (kony.sync.removeEx(tx, tablename, pksetwcs) === false) {
                        return false;
                    }
                } else {
                    kony.table.insert(pkwcs, {
                        key: kony.sync.mainTableSyncVersionColumn,
                        value: versionNumber
                    });
                    if (kony.sync.removeEx(tx, tablename, pkwcs) === false) {
                        return false;
                    }
                }
            }
        }
    }
    if (kony.sync.enableBulkInsert && !MergedWithEIS && insertUpdateCounter > 0) {
        if (currentSqlQuery != "") {
            result = executeBulkInsert(currentSqlQuery);
            currentSqlQuery = "";
            insertUpdateCounter = 0;
            sync.log.trace("result is " + JSON.stringify(result));
            if (result === false) {
                sync.log.error("Bulk insert in download failed");
                return false;
            }
        }
    }
};
kony.sync.reconcileForeignKeyForChildren = function(tx, pksetwcs, pkwcs, tablename, parentRow, currentIndex, endposition, results) {
    sync.log.trace("Entering kony.sync.reconcileForeignKeyForChildren ");
    //populate setClause and whereClause for the child tables
    function populateMetaDataForReconciliation(_pkColumns, _row, _pkset, _pkwcs) {
        sync.log.trace("Entering populateMetaDataForReconciliation");
        if (!kony.sync.isNullOrUndefined(_pkColumns)) {
            for (var j = 0; j < _pkColumns.length; j++) {
                var pk = _pkColumns[j];
                if (!kony.sync.isNullOrUndefined(_row[kony.sync.clientPKPrefix + pk])) {
                    kony.table.insert(_pkwcs, {
                        key: pk,
                        value: _row[kony.sync.clientPKPrefix + pk]
                    });
                    _pkset[pk] = _row[pk];
                }
            }
        }
    }
    //get the childrow 
    var childRowFound = false;
    for (var j = currentIndex + 1; j < endposition; j++) {
        var childPkwcs = [];
        var childPkset = {};
        var childRow = results[j];
        var childMetaData = childRow.__metadata;
        var childTablename = childMetaData.type;
        var childPkColumns = kony.sync.currentScope.syncTableDic[childTablename].Pk_Columns;
        var parentAttributes = [];
        var childAttributes = [];
        //Forward Relationships(OneToMany) reconcilation
        var OneToMany = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToMany;
        if (!kony.sync.isNullOrUndefined(OneToMany)) {
            for (var k = 0; k < OneToMany.length; k++) {
                if (OneToMany[k].TargetObject === childTablename) {
                    var currentRelation = OneToMany[k];
                    //relation found add the SourceObject_Attributes and TargetObject_Attributes to corresponding arrays
                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                    for (var l = 0; l < relationshipAttributes.length; l++) {
                        parentAttributes.push(relationshipAttributes[l].SourceObject_Attribute);
                        childAttributes.push(relationshipAttributes[l].TargetObject_Attribute);
                    }
                    break;
                }
            }
        }
        //Forward Relationships(OneToOne) reconcilation
        var OneToOne = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToOne;
        if (!kony.sync.isNullOrUndefined(OneToOne)) {
            for (var k = 0; k < OneToOne.length; k++) {
                if (OneToOne[k].TargetObject === childTablename) {
                    var currentRelation = OneToOne[k];
                    //relation found add the SourceObject_Attributes and TargetObject_Attributes to corresponding arrays
                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                    for (var l = 0; l < relationshipAttributes.length; l++) {
                        parentAttributes.push(relationshipAttributes[l].SourceObject_Attribute);
                        childAttributes.push(relationshipAttributes[l].TargetObject_Attribute);
                    }
                    break;
                }
            }
        }
        //Reverse Relationships(ManyToOne) reconcilation
        var ManyToOne = kony.sync.currentScope.reverseRelationships[tablename];
        if (!kony.sync.isNullOrUndefined(ManyToOne)) {
            for (var k = 0; k < ManyToOne.length; k++) {
                if (ManyToOne[k].TargetObject === childTablename) {
                    var currentRelation = ManyToOne[k];
                    //relation found add the SourceObject_Attributes and TargetObject_Attributes to corresponding arrays
                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                    for (var l = 0; l < relationshipAttributes.length; l++) {
                        parentAttributes.push(relationshipAttributes[l].SourceObject_Attribute);
                        childAttributes.push(relationshipAttributes[l].TargetObject_Attribute);
                    }
                    break;
                }
            }
        }
        if (parentAttributes.length === 0) continue;
        else {
            var matchCount = 0;
            //identifying if the record is child of the parent record
            for (var k = 0; k < parentAttributes.length; k++) {
                var parentAttribute = parentAttributes[k];
                var childAttribute = childAttributes[k];
                //modifying the parent reconciled values in child record's non-reconciled field to make relationship data consistent
                if (childRow[kony.sync.clientPKPrefix + childAttribute] != undefined) {
                    if (childRow[kony.sync.clientPKPrefix + childAttribute] === parentRow[kony.sync.clientPKPrefix + parentAttribute]) matchCount++;
                    else break;
                }
            }
            //childrow found
            if (matchCount === parentAttributes.length) {
                childRowFound = true;
                populateMetaDataForReconciliation(childPkColumns, childRow, childPkset, childPkwcs);
                //tx,pkset,pkwcs,tablename,parentRow,currentIndex
                kony.sync.reconcileForeignKeyForChildren(tx, childPkset, childPkwcs, childTablename, childRow, j, endposition, results); //childrowindex			
                if (kony.sync.reconcileForeignKey(tx, pksetwcs, pkwcs, tablename) === false) {
                    return false;
                }
                //reconcilation of child rows which are not part of changeset but exist in history table
                //it should be done after because we should not do disturb changeset records in history table
                reconcileChildrenInHistoryTable(tablename, pkwcs, pksetwcs);
                //modifying the parent reconciled values in child record's non-reconciled field to make relationship data consistent
                for (var k = 0; k < parentAttributes.length; k++) {
                    var parentAttribute = parentAttributes[k];
                    var childAttribute = childAttributes[k];
                    if (childRow[kony.sync.clientPKPrefix + childAttribute] != undefined) childRow[kony.sync.clientPKPrefix + childAttribute] = parentRow[parentAttribute];
                }
            }
        }
    }
    if (childRowFound === false) {
        var _isError = reconcileChildrenInHistoryTable(tablename, pkwcs, pksetwcs);
        if (_isError === 0) {
            sync.log.error("error in reconciliation of records of history table not in changeset with parent " + tablename + " with setclause " + JSON.stringify(pksetwcs) + " and whereClause " + JSON.stringify(pkwcs));
            return 0;
        }
        if (kony.sync.reconcileForeignKey(tx, pksetwcs, pkwcs, tablename) === false) {
            sync.log.error("error in reconciliation of records with parent " + tablename + " with setclause " + JSON.stringify(pksetwcs) + " and whereClause " + JSON.stringify(pkwcs));
            return 0;
        }
    }
    //reconcileChildrenInHistoryTable(tablename,pkwcs,pksetwcs);
    // no need to check if this is a error record because as this call is made by non-error records
    //reconcile records that are not part of server response inside device db ( history table records)
    function reconcileChildrenInHistoryTable(parentTableName, parentwcs, parentSetClause) {
        sync.log.trace("Entering  reconcileChildrenInHistoryTable");

        function reconcileUpdateHelper(childTablename, childSetClause, childwcs) {
            sync.log.trace("Entering reconcileUpdateHelper");
            if (kony.sync.isEmpty(childSetClause)) {
                return;
            }
            //update history table 
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, childTablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, childSetClause);
            kony.sync.qb_where(query, childwcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                sync.log.error("reconcilation: error in updating records of " + childTablename + "" + kony.sync.historyTableName + " with whereClause " + JSON.stringify(childwcs) + " and setclause " + childSetClause);
                return 0;
            }
            //update main table
            kony.sync.qb_update(query, childTablename);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                sync.log.error("reconcilation: error in updating records of " + childTablename + " with whereClause " + JSON.stringify(childwcs) + " and setclause " + childSetClause);
                return 0;
            }
        }

        function fetchChildHistoryTableRows(childTablename, childwcs) {
            sync.log.trace("Entering fetchChildHistoryTableRows");
            //select the records
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, childTablename + kony.sync.historyTableName);
            kony.sync.qb_where(query, childwcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultset = kony.sync.executeSql(tx, sql, params);
            return resultset;
        }
        //fill the current child whereClause and childSetClause
        function populateChildQueryParams(relationshipAttributes, childwcs, childSetClause, childTablename, parentTableName) {
            sync.log.trace("Entering populateChildQueryParams");
            for (var i = 0; i < relationshipAttributes.length; i++) {
                var parentPk = relationshipAttributes[i].SourceObject_Attribute;
                var childPk = relationshipAttributes[i].TargetObject_Attribute;
                var whereClauseValue = null;
                //need to set only the parentSetClause Columns not all the columns in relationshipattributes set
                if (parentSetClause[parentPk] != undefined) {
                    childSetClause[childPk] = parentSetClause[parentPk];
                }
                for (var j = 0; j < parentwcs.length; j++) {
                    var currentObject = parentwcs[j];
                    if (currentObject.key == parentPk) {
                        whereClauseValue = currentObject.value;
                        break;
                    }
                }
                if (whereClauseValue === null) {
                    sync.log.error("reconcilation:error in forming whereClause for " + childTablename + " having foreign key " + childPk + " with parent table " + parentTableName + " primary key " + parentPk);
                    return 0;
                }
                kony.table.insert(childwcs, {
                    key: childPk,
                    value: whereClauseValue
                });
            }
        }
        //make new whereClause to go recursive
        function populateChildWCSParams(rowItem, childPkColumns, newWhereClause, childTablename) {
            sync.log.trace("Entering populateChildWCSParams");
            for (var i = 0; i < childPkColumns.length; i++) {
                var columnName = childPkColumns[i];
                var columnValue = rowItem[columnName];
                if (columnName === undefined) {
                    sync.log.error("reconcilation:error in creating where clause for " + childTablename + " with childrow " + JSON.stringify(rowItem));
                    return 0;
                }
                kony.table.insert(newWhereClause, {
                    key: columnName,
                    value: columnValue
                });
            }
        }

        function checkIfParentColumnsArePrimaryKeys(parentRelationshipAttributes, childPkColumns) {
            sync.log.trace("Entering checkIfParentColumnsArePrimaryKeys");
            var columnCount = 0;
            for (var i = 0; i < parentRelationshipAttributes.length; i++) {
                for (var j = 0; j < childPkColumns.length; j++) {
                    if (parentRelationshipAttributes[i].TargetObject_Attribute === childPkColumns[j]) {
                        columnCount++;
                        break;
                    }
                }
            }
            return columnCount;
        }
        //entry here
        function reconcileForRelation(RelationShipSet, parentTableName) {
            sync.log.trace("Entering reconcileForRelation");
            if (!kony.sync.isNullOrUndefined(RelationShipSet)) {
                for (var k = 0; k < RelationShipSet.length; k++) {
                    var currentRelation = RelationShipSet[k];
                    var childTablename = currentRelation.TargetObject;
                    var childwcs = []; // all foreign key columns
                    var childSetClause = {};
                    var parentRelationshipAttributes = currentRelation.RelationshipAttributes;
                    var childPkColumns = kony.sync.currentScope.syncTableDic[childTablename].Pk_Columns;
                    var _isError = populateChildQueryParams(parentRelationshipAttributes, childwcs, childSetClause, childTablename, parentTableName); //child tablename and parent tablename are passed only for error handling
                    if (_isError === 0) return _isError;
                    //call child only if parent columns are part of primary key set
                    var columnCount = checkIfParentColumnsArePrimaryKeys(parentRelationshipAttributes, childPkColumns);
                    if (columnCount === parentRelationshipAttributes.length) {
                        // newWhereClause to goto parent grand child
                        var newWhereClause = [];
                        //fetch rows from child history table
                        var childresultset = fetchChildHistoryTableRows(childTablename, childwcs);
                        if (childresultset === false) {
                            sync.log.error("Reconciliation:error in fetching records from " + childTablename + " history table with parent " + parentTableName);
                            return 0;
                        } else {
                            for (var m = 0; m < childresultset.rows.length; m++) {
                                var rowItem = kony.db.sqlResultsetRowItem(tx, childresultset, 0);
                                var _isError = populateChildWCSParams(rowItem, childPkColumns, newWhereClause, childTablename);
                                if (_isError === 0) return _isError;
                                //make recursive call
                                _isError = reconcileChildrenInHistoryTable(childTablename, newWhereClause, childSetClause);
                                if (_isError === 0) return _isError;
                            }
                        }
                    }
                    var _isError = reconcileUpdateHelper(childTablename, childSetClause, childwcs);
                    if (_isError === 0) return _isError;
                }
            }
        }
        //Forward Relationships(OneToMany) reconcilation
        var OneToMany = kony.sync.currentScope.syncTableDic[parentTableName].Relationships.OneToMany;
        var _isError = reconcileForRelation(OneToMany, parentTableName);
        if (_isError === 0) return _isError;
        //Forward Relationships(OneToOne) reconcilation
        var OneToOne = kony.sync.currentScope.syncTableDic[parentTableName].Relationships.OneToOne;
        var _isError = reconcileForRelation(OneToOne, parentTableName);
        if (_isError === 0) return _isError;
        //Reverse Relationships(ManyToOne) reconcilation
        var ManyToOne = kony.sync.currentScope.reverseRelationships[parentTableName];
        var _isError = reconcileForRelation(ManyToOne, parentTableName);
        if (_isError === 0) return _isError;
    }
}
kony.sync.checkForHistoryInstance = function(tx, tablename, values, whereClause) {
    sync.log.trace("Entering kony.sync.checkForHistoryInstance ");
    //var sql = "select count(*) from " + tablename + kony.sync.historyTableName + " " + wcs;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return 0;
    }
    if (resultSet.rows.length === 0) {
        return false;
    }
    return true;
}
kony.sync.checkForInstance = function(tx, tablename, values, whereClause) {
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, tablename);
        kony.sync.qb_where(query, whereClause);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            return 0;
        }
        if (resultSet.rows.length === 0) {
            return false;
        }
        return true;
    }
    //This function removes successful uploads mostly in case of dummy updates
kony.sync.deleteRecordsAfterUpload = function(callback) {
    sync.log.trace("Entering kony.sync.deleteRecordsAfterUpload ");
    var isError = false;
    if ((kony.sync.OTAChangestobeDeleted.length === 0 && kony.sync.PersisChangestobeDeleted.length === 0) || kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.removeAfterUpload])) {
        callback(0);
        return;
    }
    //Concatinating both OTA uploadqueue and persistent delete queue
    var results = kony.sync.OTAChangestobeDeleted.concat(kony.sync.PersisChangestobeDeleted);
    var length = results.length;
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var scopename = kony.sync.currentScope[kony.sync.scopeName];
    kony.sync.getConnection(dbname, dbname, myTransactionCallBack, mySucessCallBack, myErrorCallBack);

    function myTransactionCallBack(tx) {
        sync.log.trace("Entering myTransactionCallBack");
        for (var i = 0; i < length; i++) {
            var row = results[i];
            var tablename = row.__metadata.type;
            //checking for removeafteruploadpolicy
            if (kony.sync.checkForDeleteAfterUpload(tablename, scopename) !== true) {
                continue;
            }
            //skipping if error
            if (!kony.sync.isNullOrUndefined(row.__metadata.errorMessage)) {
                continue;
            }
            var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
            var pkwcs = [];
            for (var j = 0; j < pkColumns.length; j++) {
                kony.table.insert(pkwcs, {
                    key: pkColumns[j],
                    value: row[pkColumns[j]],
                    optype: "EQ"
                });
            }
            //Get records to be deleted from history table;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_where(query, pkwcs);
            kony.sync.qb_distinct(query);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultSet = kony.sync.executeSql(tx, sql, params);
            //do not delete from main table if there is some instance in history table
            if (resultSet === false) {
                isError = true;
                return;
            }
            if (resultSet.rows.length !== 0) {
                continue;
            }
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, tablename);
            kony.sync.qb_where(query, pkwcs);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                isError = true;
                return;
            }
        }
    }

    function myErrorCallBack() {
        sync.log.trace("Entering deleteRecordsAfterUpload myErrorCallBack");
        kony.sync.OTAChangestobeDeleted = [];
        kony.sync.PersisChangestobeDeleted = [];
        if (isError) {
            callback(kony.sync.errorCodeSQLStatement);
        } else {
            callback(kony.sync.errorCodeTransaction);
        }
    }

    function mySucessCallBack() {
        sync.log.trace("Entering deleteRecordsAfterUpload mySucessCallBack");
        kony.sync.OTAChangestobeDeleted = [];
        kony.sync.PersisChangestobeDeleted = [];
        callback(0);
    }
};
//  **************** End KonySyncDownload.js*******************
//  **************** Start KonySyncErrors.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//error codes
kony.sync.errorCodeInvalidDataType = 7001;
kony.sync.errorCodeMandatoryAttribute = 7002;
kony.sync.errorCodePrimaryKeyNotSpecified = 7003; //Primary Key CategoryID not specified in updating an item in Categories
kony.sync.errorCodeScopeLoading = 7004; //"Scopes loading failed",
kony.sync.errorCodeSyncReset = 7005; //"Sync Reset failed",
kony.sync.errorCodeRegisterDevice = 7006; //"Register device failed",
kony.sync.errorCodeSessionBreak = 7007; //"Session breaks since user scope failure",
kony.sync.errorCodeSessionInProgress = 7008; //"Session in progress",
kony.sync.errorCodeNoDataWithPrimaryKey = 7009; //No data with specified primary key found in SyncObject Categories
kony.sync.errorCodeTransaction = 7010; //"Transaction failed"
kony.sync.errorCodeDbConnection = 7011; //"Database connection closed"
kony.sync.errorCodeMarkForUpload = 7012; // "ERROR: [KONYSYNC] Record does not exist on server, mark it for upload before updating/deleting it"
kony.sync.errorCodeDeferredUpload = 7013; // "Error during Deferred Upload Transaction"
kony.sync.errorCodeReferentialIntegrity = 7014; //"Error because of referential integrity failure"
kony.sync.errorCodeLengthValidationFailed = 7015; //Length exceeds than specified limit
kony.sync.errorCodeDuplicatePrimaryKey = 7016;
kony.sync.errorCodeInputTableNotDefined = 7017;
kony.sync.errorCodeMaliciousType = 7018;
kony.sync.errorCodeSQLStatement = 7019;
kony.sync.errorCodeUploadFailed = 7020;
kony.sync.errorCodeDownloadFailed = 7021;
kony.sync.errorCodeSyncError = 7022;
kony.sync.errorCodeParseError = 7023;
kony.sync.errorCodeChunking = 7024;
kony.sync.errorCodeNetworkCallCancelled = 7025;
kony.sync.errorCodeMetatableError = 7026;
kony.sync.errorCodeNullValue = 7027;
kony.sync.errorCodeInvalidMarkForUploadValue = 7028;
kony.sync.errorCodeDuplicateUniqueKey = 7029;
kony.sync.errorCodeScopeDoesNotExist = 7030;
kony.sync.errorCodeTableDoesNotExist = 7031;
kony.sync.errorCodeInvalidReconcileConfig = 7032;
kony.sync.errorReconcileKeyUndefined = 7033;
kony.sync.errorCodeReconcileSessionInProgress = 7034; //"Reconcile Session in progress",
kony.sync.errorCodeBackendTokenExpiredForOfflineAuth = 7035;
kony.sync.errorUnknown = 7777;
kony.sync.errorCodeUnknownServerError = 8888;
kony.sync.errorCodeChunkInvalidPayloadId = 9999;
kony.sync.errorCodeBlobFileNotCreated = 9000;
kony.sync.errorCodeInvalidColumnType = 9001;
kony.sync.errorCodeEmptyOrNullBase64 = 9002;
kony.sync.errorCodeBlobFileDoesnotExist = 9003;
kony.sync.errorCodeBlobInvalidState = 9004;
kony.sync.errorCodeDownloadAlreadyInQueue = 9005;
kony.sync.errorCodeBlobInvalidStateForDelete = 9006;
kony.sync.errorCodeBlobInvalidStateForUpdate = 9007;
kony.sync.errorCodeInvalidPksGiven = 9008;
kony.sync.errorCodeInvalidColumnParams = 9009;
kony.sync.errorCodeDownloadPolicyNotSupported = 9010;
kony.sync.errorCodeInvalidStateForDownload = 9011;
kony.sync.errorCodeBinaryDownloadFailed = 9012;
kony.sync.errorCodeBlobFileDoesnotExistOnDemand = 9013;
kony.sync.errorCodeParentMappingAttributeNotFound = 9014;
kony.sync.errorCodeChildObjectShouldBeArray = 9015;
kony.sync.errorCodeNullPrimaryKeyValue = 9016;
kony.sync.errorCodeInvalidTableName = 9017;
kony.sync.errorCodeRecordDoNotExist = 9018;
kony.sync.errorCodeBinaryUploadFailed = 9019;
kony.sync.errorCodeBinaryDataFFINotConfigured = 9020;
kony.sync.errorCodeNullDownloadID = 9021;
kony.sync.errorCodeInvalidChunkSize = 9022;
kony.sync.retryErrors = {};
//Server ErrorCodes
kony.sync.servercodes = {};
kony.sync.servercodes.appVersionNotLatest = "SY3001E";
kony.sync.servercodes.chunkPayloadIdInvalid = "SY3008E";
kony.sync.getSessionInProgressError = function() {
    sync.log.trace("Entering kony.sync.getSessionInProgressError ");
    return kony.sync.getErrorTable(kony.sync.errorCodeSessionInProgress, kony.sync.getErrorMessage(kony.sync.errorCodeSessionInProgress), null);
};
kony.sync.getScopeLoadingFailed = function() {
    sync.log.trace("Entering kony.sync.getScopeLoadingFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeScopeLoading, kony.sync.getErrorMessage(kony.sync.errorCodeScopeLoading), null);
};
kony.sync.getSyncResetFailed = function() {
    sync.log.trace("Entering kony.sync.getSyncResetFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeSyncReset, kony.sync.getErrorMessage(kony.sync.errorCodeSyncReset), null);
};
kony.sync.getSyncRegisterationFailed = function() {
    sync.log.trace("Entering kony.sync.getSyncRegisterationFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeRegisterDevice, kony.sync.getErrorMessage(kony.sync.errorCodeRegisterDevice), null);
};
kony.sync.getScopeFailed = function() {
    sync.log.trace("Entering kony.sync.getScopeFailed ");
    return kony.sync.getErrorTable(kony.sync.errorCodeSessionBreak, kony.sync.getErrorMessage(kony.sync.errorCodeSessionBreak), null);
};
kony.sync.getServerError = function(ServerReport, moduleType) {
    sync.log.trace("Entering kony.sync.getServerError ");
    var serverDetails = {};
    if (!kony.sync.isNullOrUndefined(ServerReport)) {
        if (!kony.sync.isNullOrUndefined(ServerReport.server)) {
            serverDetails[kony.sync.hostName] = ServerReport.server.hostName;
            serverDetails[kony.sync.ipAddress] = ServerReport.server.ipAddress;
        }
        //error occurred at application layer
        if (!kony.sync.isNullOrUndefined(ServerReport.msg)) {
            var errorCode = ServerReport.errcode;
            if (kony.sync.isNullOrUndefined(ServerReport.errcode)) { //should not hit this ideally
                if (moduleType === "upload") {
                    errorCode = kony.sync.errorCodeUploadFailed;
                } else if (moduleType === "download") {
                    errorCode = kony.sync.errorCodeDownloadFailed;
                } else {
                    errorCode = kony.sync.errorCodeUnknownServerError;
                }
            }
            var otherParams = {};
            if (errorCode === kony.sync.servercodes.appVersionNotLatest) {
                otherParams.newApplicationVersion = ServerReport.newapplicationversion;
                otherParams.oldApplicationVersion = ServerReport.oldapplicationversion;
            }
            if (kony.sync.isMbaasEnabled && !kony.sync.isNullOrUndefined(ServerReport.mfcode)) {
                if (kony.sdk.offline.isOfflineEnabled) {
                    errorCode = kony.sync.errorCodeBackendTokenExpiredForOfflineAuth;
                    otherParams.mfcode = ServerReport.mfcode;
                    ServerReport.msg = kony.sync.getErrorMessage(errorCode);
                } else {
                    otherParams.mfcode = ServerReport.mfcode;
                    ServerReport.msg = getAuthErrorMessage(ServerReport.mfcode);
                }
            }
            return kony.sync.getErrorTable(errorCode, ServerReport.msg, ServerReport.stacktrace, serverDetails, otherParams);
        }
        //error occurred at network layer
        if (!kony.sync.isNullOrUndefined(ServerReport.errmsg)) {
            return kony.sync.getErrorTable(ServerReport.opstatus, ServerReport.errmsg, null, serverDetails);
        }
    }
    return kony.sync.getErrorTable(kony.sync.errorCodeUnknownServerError, "Unknown Error from the server", ServerReport, serverDetails);
};
kony.sync.getErrorTable = function(errorCode, errorMessage, errorInfo, serverDetails, otherParams) {
    sync.log.trace("Entering kony.sync.getErrorTable ");
    var errorTable = {};
    errorTable.errorCode = errorCode;
    errorTable.errorMessage = errorMessage;
    errorTable.errorInfo = errorInfo;
    errorTable[kony.sync.serverDetails] = serverDetails;
    if (!kony.sync.isNullOrUndefined(otherParams)) {
        for (var i in otherParams) {
            errorTable[i] = otherParams[i];
        }
    }
    if (!kony.sync.isNullOrUndefined(errorInfo)) {
        if (!kony.sync.isNullOrUndefined(errorInfo[kony.sync.errorInfoDatabaseError])) {
            if (!kony.sync.isEmptyString(errorInfo[kony.sync.errorInfoDatabaseError])) {
                errorTable.errorMessage = errorMessage + ". \n" + "System Error:" + errorInfo[kony.sync.errorInfoDatabaseError].message;
            }
        }
    }
    return errorTable;
};
kony.sync.getErrorMessage = function(errorCode, objectName, attributeName) {
    sync.log.trace("Entering kony.sync.getErrorMessage ");
    var errorMap = {};
    errorMap[kony.sync.errorCodeMandatoryAttribute] = "Mandatory attribute " + attributeName + " is missing for the SyncObject " + objectName + ".";
    errorMap[kony.sync.errorCodeScopeLoading] = "Scopes loading failed.";
    errorMap[kony.sync.errorCodeSyncReset] = "Sync Reset failed.";
    errorMap[kony.sync.errorCodeRegisterDevice] = "Register device failed.";
    errorMap[kony.sync.errorCodeSessionBreak] = "Session breaks since user scope failure.";
    errorMap[kony.sync.errorCodeSessionInProgress] = "Session in progress.";
    errorMap[kony.sync.errorCodeTransaction] = "Transaction failed.";
    errorMap[kony.sync.errorCodeDbConnection] = "Error occurred while establishing a Database connection.";
    errorMap[kony.sync.errorCodeMarkForUpload] = "Record does not exist on server, mark it for upload before updating/deleting it.";
    errorMap[kony.sync.errorCodeDeferredUpload] = "Error during Deferred Upload Transaction.";
    errorMap[kony.sync.errorCodeNoDataWithPrimaryKey] = "No data with specified primary key found in SyncObject " + objectName + ".";
    errorMap[kony.sync.errorCodeDuplicatePrimaryKey] = "Primary Key " + attributeName + " already exists in table " + objectName + ". Please give different value of primary key.";
    errorMap[kony.sync.errorCodeDuplicateUniqueKey] = "Unique Key " + attributeName + " already exists in table " + objectName + ". Please give different value of unique key.";
    errorMap[kony.sync.errorCodeInputTableNotDefined] = "Input Table not defined";
    errorMap[kony.sync.errorCodeMaliciousType] = "Malicious value '" + attributeName + "' given for attribute " + objectName + ".";
    errorMap[kony.sync.errorCodeSQLStatement] = "Some error occurred in executing SQL statement";
    errorMap[kony.sync.errorCodeSyncError] = "Error occurred while syncing one or more scopes";
    errorMap[kony.sync.errorCodeDownloadFailed] = "Error occurred in Downloading changes from Sever";
    errorMap[kony.sync.errorCodeUploadFailed] = "Error occurred in Uploading changes to Server";
    errorMap[kony.sync.errorUnknown] = "The following error occurred while performing " + objectName + " : \"" + attributeName + "\"." + " Possible reasons can be sync.init may not have been invoked.";
    errorMap[kony.sync.errorCodeParseError] = "Following error occurred while parsing " + JSON.stringify(objectName) + " : \"" + attributeName + "\"";
    errorMap[kony.sync.errorCodeChunking] = "Error occurred while downloading one or more chunks.";
    errorMap[kony.sync.errorCodeMetatableError] = "Meta tables did not get created successfully because of some unknown problem in sync.init, please invoke sync.reset";
    errorMap[kony.sync.errorCodeNullValue] = "Null values passed in input array";
    errorMap[kony.sync.errorCodeBlobFileNotCreated] = "Error occurred when creating a file";
    errorMap[kony.sync.errorCodeInvalidColumnType] = "Expecting an array and got type " + objectName + "instead for columns";
    errorMap[kony.sync.errorCodeEmptyOrNullBase64] = "Empty or Null value should not be passed for Base64";
    errorMap[kony.sync.errorCodeBlobFileDoesnotExistOnDemand] = "Request file doesn't exist. Please retrigger the download of the binary";
    errorMap[kony.sync.errorCodeBlobFileDoesnotExist] = "Request file doesn't exist.";
    errorMap[kony.sync.errorCodeBlobInvalidState] = "BlobFile in invalid state. Could not upload.";
    errorMap[kony.sync.errorCodeDownloadAlreadyInQueue] = "Binary download already requested";
    errorMap[kony.sync.errorCodeBlobInvalidStateForDelete] = "Blob cannot be deleted in " + objectName + " state";
    errorMap[kony.sync.errorCodeBlobInvalidStateForUpdate] = "Blob cannot be updated in " + objectName + " state";
    errorMap[kony.sync.errorCodeInvalidPksGiven] = "Invalid primary keys given for table " + objectName;
    errorMap[kony.sync.errorCodeInvalidColumnParams] = "Invalid column params ";
    errorMap[kony.sync.errorCodeDownloadPolicyNotSupported] = "Download policy not supported for " + objectName;
    errorMap[kony.sync.errorCodeInvalidStateForDownload] = "Blob cannot be downloaded in " + objectName + " state";
    errorMap[kony.sync.errorCodeBinaryDownloadFailed] = "Binary Download operation failed ";
    errorMap[kony.sync.errorCodeParentMappingAttributeNotFound] = "Parent Mapping Attribute not found for given child " + objectName;
    errorMap[kony.sync.errorCodeChildObjectShouldBeArray] = "Child objects should be of Array type for complex object CUD";
    errorMap[kony.sync.errorCodeNullPrimaryKeyValue] = "Null value passed for primary key " + objectName;
    errorMap[kony.sync.errorCodeInvalidTableName] = "Invalid table name sent for DB Operation " + objectName;
    errorMap[kony.sync.errorCodeRecordDoNotExist] = "Record doesn't exists with given conditions " + objectName;
    errorMap[kony.sync.errorCodeInvalidMarkForUploadValue] = "MarkforUpload value can not be made true if the object is created with mark for upload as false";
    errorMap[kony.sync.errorCodeBinaryUploadFailed] = "Binary Upload operation failed ";
    errorMap[kony.sync.errorReconcileKeyUndefined] = "No reconciliation field defined in reconciliation config";
    errorMap[kony.sync.errorCodeReconcileSessionInProgress] = "Reconcile session in progress";
    errorMap[kony.sync.errorCodeScopeDoesNotExist] = "Scope:" + objectName + " Doesnot exists ";
    errorMap[kony.sync.errorCodeTableDoesNotExist] = "table:" + objectName + " doesnot exists in scope: " + attributeName;
    errorMap[kony.sync.errorCodeInvalidReconcileConfig] = "invalid reconcile config found for scope: " + objectName;
    errorMap[kony.sync.errorCodeBackendTokenExpiredForOfflineAuth] = "Backend token has expired. Please login with network before invoking online services";
    errorMap[kony.sync.errorCodeBinaryDataFFINotConfigured] = "binary data ffi is not configured to use the Binary APIs.";
    errorMap[kony.sync.errorCodeNullDownloadID] = "Download ID for a download operation cannot be null";
    errorMap[kony.sync.errorCodeInvalidChunkSize] = "ChunkSize value given is invalid " + objectName;
    if (errorMap[errorCode] === null) {
        return "Some unknown client error";
    } else {
        return errorMap[errorCode];
    }
};
kony.sync.getInvalidDataTypeMsg = function(objectName, attributeName, expectedType, actualType) {
    sync.log.trace("Entering kony.sync.getInvalidDataTypeMsg ");
    return "Invalid data type for the attribute " + attributeName + " in " + objectName + ".\nExpected:\"" + expectedType + "\"\nActual:\"" + actualType + "\"";
};
kony.sync.getPrimaryKeyNotSpecifiedMsg = function(primaryKey, operation, table) {
    sync.log.trace("Entering kony.sync.getPrimaryKeyNotSpecifiedMsg ");
    return "Primary Key " + primaryKey + " not specified in " + operation + " an item in " + table + ".";
};
kony.sync.getReferetialIntegrityerrMessg = function(sourceAttribute, TargetAttributes, TargetValues) {
    sync.log.trace("Entering kony.sync.getReferetialIntegrityerrMessg ");
    //return  "Referential Integrity Constraints Violation: " + TargetAttribute+" = " + TargetValue + " does not exists in " + sourceAttribute + ".";
    var integrityMessage = "";
    for (var i = 0; i < TargetAttributes.length; i++) {
        integrityMessage = integrityMessage + TargetAttributes[i] + " = " + TargetValues[i];
        if (i != TargetAttributes.length - 1) {
            integrityMessage = integrityMessage + " AND ";
        }
    };
    integrityMessage = integrityMessage + " does not exists in " + sourceAttribute + ".";
    //return  "Referential Integrity Constraints Violation: " + TargetAttribute+" = " + TargetValue + " does not exists in " + sourceAttribute + ".";
    return "Referential Integrity Constraints Violation: " + integrityMessage;
};
kony.sync.getReferetialIntegrityDeleteErrMessg = function(sourceAttribute, TargetAttribute, targetValue, srcValue) {
    sync.log.trace("Entering kony.sync.getReferetialIntegrityDeleteErrMessg ");
    return "Referential Integrity Constraints Violation: " + "Delete dependent records from " + targetValue + " before deleting record(s) in " + srcValue + ".";
};
kony.sync.getValidateLengthErrMsg = function(tablename, colname, expectedLength, actualLength) {
    sync.log.trace("Entering kony.sync.getValidateLengthErrMsg ");
    return "Length exceeds the limit for the attribute " + colname + " in " + tablename + ".\nExpected:\'" + expectedLength + "\'\nActual:\'" + actualLength + "\'";
};
kony.sync.getSchemaUpgradeNeededError = function() {
    sync.log.trace("Entering kony.sync.getSchemaUpgradeNeededError");
    //TODO:needs to be replaced with actual schema error
    return kony.sync.getErrorTable(kony.sync.errorCodeSessionBreak, kony.sync.getErrorMessage(kony.sync.errorCodeSessionBreak), null);
};
kony.sync.getNetworkCancelError = function() {
        sync.log.trace("Entering kony.sync.getNetworkCancelError ");
        var errCreate = {};
        errCreate.opstatus = 7025;
        errCreate.errmsg = "Error occurred, Network Call Cancelled";
        return errCreate;
    }
    //  **************** End KonySyncErrors.js*******************
    //  **************** Start KonySyncGlobals.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//This enables the Print Statements in the Sync Library
kony.sync.syncLibPrint = true;
kony.sync.downloadNextBatchServerblob = null; //not used
kony.sync.scopes = [];
kony.sync.gMoreChanges = true; //not used
kony.sync.gSyncFailed = false;
kony.sync.gPolicy = 0;
kony.sync.isMbaasEnabled = false;
//Sync Config
kony.sync.currentSyncConfigParams = null;
kony.sync.currentSyncLog = [];
//Binary Config.
kony.sync.binaryOperationNetworkTimeoutKey = "binaryOperationNetworkTimeout";
kony.sync.binaryOperationNetworkTimeoutValue = null;
//Sync Call Backs Constants
kony.sync.sessionTasks = "sessiontasks";
kony.sync.sessionTaskDoUpload = "doupload";
kony.sync.sessionTaskDoDownload = "dodownload";
kony.sync.blobStoreManagerTable = "konysyncBLOBSTOREMANAGER";
kony.sync.filterParams = "filterparams";
kony.sync.onSyncStart = "onsyncstart";
kony.sync.onScopeStart = "onscopestart";
kony.sync.onScopeError = "onscopeerror";
kony.sync.onScopeSuccess = "onscopesuccess";
kony.sync.onAuthenticationSuccess = "onauthenticationsuccess";
kony.sync.onUploadStart = "onuploadstart";
kony.sync.onUploadSuccess = "onuploadsuccess";
kony.sync.onUploadBatchStart = "onuploadbatchstart";
kony.sync.onUploadBatchSuccess = "onuploadbatchsuccess";
kony.sync.onDownloadStart = "ondownloadstart";
kony.sync.onDownloadSuccess = "ondownloadsuccess";
kony.sync.onBatchStored = "onbatchstored";
kony.sync.onBatchProcessingStart = "onbatchprocessingstart";
kony.sync.onBatchProcessingSuccess = "onbatchprocessingsuccess";
kony.sync.onSyncSuccess = "onsyncsuccess";
kony.sync.onSyncError = "onsyncerror";
kony.sync.removeAfterUpload = "removeafterupload";
kony.sync.passwordHashingAlgo = "passwordhashalgo";
//Reconciliation CallBacks
kony.sync.onReconciliationStart = "onreconciliationstart"
kony.sync.onReconciliationScopeStart = "onreconciliationscopestart";
kony.sync.onReconciliationScopeSuccess = "onreconciliationscopesuccess";
kony.sync.onReconciliationScopeError = "onreconciliationscopeerror";
kony.sync.onReconciliationBatchprocessingStart = "onreconciliationbatchprocessingstart";
kony.sync.onReconciliationDownloadStart = "onreconciliationdownloadstart";
kony.sync.onReconciliationBulkGetDownloadStart = "onreconciliationbulkgetdownloadstart";
kony.sync.onReconciliationBulkGetBatchprocessingStart = "onreconciliationbulkgetbatchprocessingstart";
kony.sync.onReconciliationBulkGetBatchprocessingSuccess = "onreconciliationbulkgetbatchprocessingsuccess";
kony.sync.onReconciliationBatchprocessingSuccess = "onreconciliationbatchprocessingsuccess";
kony.sync.onReconciliationSuccess = "onreconciliationsuccess";
kony.sync.onReconciliationError = "onreconciliationerror";
//Sync Context Params
kony.sync.reconcileObjectLevelInfo = "reconcileobjectlevelinfo";
kony.sync.objectLevelInfo = "objectlevelinfo";
kony.sync.authenticateURL = "authenticateurl";
kony.sync.uploadURL = "uploadurl";
kony.sync.downloadURL = "downloadurl";
kony.sync.uploadContext = "uploadcontext";
kony.sync.uploadBatchContext = "uploadbatchcontext";
kony.sync.failedRowInfo = "failedrowinfo";
kony.sync.uploadSummary = [];
kony.sync.numberOfRowsUploaded = "rowsuploaded";
kony.sync.numberOfRowsInserted = "rowsinserted";
kony.sync.numberOfRowsUpdated = "rowsupdated";
kony.sync.numberOfRowsDeleted = "rowsdeleted";
kony.sync.numberOfRowsInsertedAck = "ackinsertedrows";
kony.sync.numberOfRowsUpdatedAck = "ackupdatedrows";
kony.sync.numberOfRowsDeletedAck = "ackdeletedrows";
kony.sync.numberOfRowsAcknowledged = "acktotalrows";
kony.sync.numberOfRowsFailedtoUpload = "rowsfailedtoupload";
kony.sync.pendingBatches = "pendingbatches";
kony.sync.numberOfRowsDownloaded = "batchrowsdownloaded";
kony.sync.batchContext = "batchcontext";
kony.sync.lastSyncTimestamp = "lastsynctimestamp";
kony.sync.uploadSequenceNumber = "uploadsequencenumber";
kony.sync.currentScope = "currentscope";
kony.sync.dataSource = "DataSource";
kony.sync.scopeDataSource = "ScopeDatabaseName";
kony.sync.scopeName = "ScopeName";
kony.sync.syncStrategy = "Strategy";
kony.sync.syncStrategy_OTA = "OTA_SYNC";
kony.sync.versionNumber = "1.0";
kony.sync.dbSize = 5 * 1024 * 1024;
//Pending Batchs
kony.sync.syncPendingBatchesNo = 0;
kony.sync.syncStatusColumn = "changetype";
kony.sync.syncConfigurationDBName = "SyncConfig";
kony.sync.syncConfigurationTableName = "SyncConfigTable";
kony.sync.syncConfigurationColumnDeviceIDName = "DeviceID";
kony.sync.syncConfigurationColumnInstanceIDName = "InstanceID";
kony.sync.syncConfigurationColumnVersion = "SyncVersion";
kony.sync.syncConfigurationColumnSchemaUpgradeContext = "schemaupgradecontext";
kony.sync.configVersion = "";
kony.sync.metaTableName = "konysyncMETAINFO";
kony.sync.metaTableScopeColumn = "scopename";
kony.sync.metaTableSyncTimeColumn = "lastserversynccontext";
kony.sync.metaTableUploadSyncTimeColumn = "lastserveruploadsynccontext";
kony.sync.metaTableSchemaUpgradeSyncTimeColumn = "lastschemaupgradesynccontext";
kony.sync.metaTableSyncVersionCloumn = "versionnumber";
kony.sync.metaTableSyncOrderCloumn = "replaysequencenumber";
kony.sync.metaTableLastGeneratedId = "lastgeneratedid";
kony.sync.metaTableFilterValue = "filtervalue";
kony.sync.historyTableName = "_history";
kony.sync.changeTypeColumn = "changetype";
kony.sync.dbConnection = null;
kony.sync.mainTableSyncVersionColumn = "konysyncversionnumber";
kony.sync.mainTableChangeTypeColumn = "konysyncchangetype";
kony.sync.mainTableHashSumColumn = "konysynchashsum";
kony.sync.historyTableSyncVersionColumn = "konysyncversionnumber";
kony.sync.historyTableChangeTypeColumn = "konysyncchangetype";
kony.sync.historyTableReplaySequenceColumn = "konysyncreplaysequence";
kony.sync.historyTableChangeTimeColumn = "konysyncchangetime"; // Not used as of now.
kony.sync.historyTableHashSumColumn = "konysynchashsum";
kony.sync.originalTableName = "_original";
kony.sync.originalTableChangeTypeColumn = "konysyncoriginalchangetype";
kony.sync.originalTableSyncVersionColumn = "konysyncoriginalversionnumber";
kony.sync.originalTableHashSumColumn = "konysynchashsum";
kony.sync.mergedWithEIS = "konysyncMergedWithEIS";
kony.sync.clientPKPrefix = "konysyncClient";
kony.sync.parentRelationshipMap = "_parentrelationships";
//Global SyncSession Configurations
kony.sync.isSessionInProgress = false;
kony.sync.currentScope = null;
kony.sync.deviceId = null;
kony.sync.instanceId = null;
kony.sync.originalDeviceId = null;
//Global changetype columns
kony.sync.insertColStatus = "0";
kony.sync.updateColStatus = "1";
kony.sync.deleteColStatus = "2";
kony.sync.insertColStatusDI = "90";
kony.sync.updateColStatusDU = "91";
kony.sync.deleteColStatusDD = "92";
//storeid_callback_scope = null; Not used.
kony.sync.currentSyncScopesState = {};
kony.sync.isParameter = true;
kony.sync.dbTypeSQLLite = "sqllite";
kony.sync.dbTypeSQLCE = "sqlce";
kony.sync.platformName = null;
kony.sync.hashTypeSHA256 = "SHA256";
kony.sync.pendingAckIndex = 1;
kony.sync.pendingAckResult = {};
kony.sync.pendingAckCount = 0;
kony.sync.pendingUploadIndex = 1;
kony.sync.pendingUploadResult = {};
kony.sync.pendingUploadCount = 0;
kony.sync.deferredUploadIndex = 1;
kony.sync.deferredUploadResult = {};
kony.sync.deferredUploadCount = 0;
kony.sync.rollbackCurrentScope = null;
kony.sync.onDownloadCompletion = null;
kony.sync.globalIsDownloadStarted = true;
kony.sync.globalIsUploadStarted = true;
kony.sync.globalIsUploadFailed = true;
kony.sync.isChunkingResumedPostSyncError = false;
kony.sync.onUploadCompletion = null;
kony.sync.enableBulkInsert = false;
kony.sync.enableOverride = true;
kony.sync.currentSyncReturnParams = {};
kony.sync.syncTotalBatchInserts = 0;
kony.sync.syncTotalBatchUpdates = 0;
kony.sync.syncTotalBatchDeletes = 0;
kony.sync.syncTotalInserts = 0;
kony.sync.syncTotalUpdates = 0;
kony.sync.syncTotalDeletes = 0;
kony.sync.serverInsertCount = 0;
kony.sync.serverUpdateCount = 0;
kony.sync.serverDeleteCount = 0;
kony.sync.serverInsertAckCount = 0;
kony.sync.serverUpdateAckCount = 0;
kony.sync.serverDeleteAckCount = 0;
kony.sync.serverFailedCount = 0;
kony.sync.objectLevelInfoMap = {};
//reconcile
kony.sync.reconcileBatchDeletions = "reconcilebatchdeletions";
kony.sync.reconcileBatchInsertions = "reconcilebatchinsertions";
kony.sync.reconcileBatchDownloads = "reconcilebatchdownloads";
kony.sync.reconcileTotalInsertions = "reconciletotalinsertions";
kony.sync.reconcileTotalDeletions = "reconciletotaldeletions";
kony.sync.reconcileTotalDownloads = "reconciletotaldownloads";
kony.sync.reconcileBulkGetBatchSize = "reconcilebulkgetbatchsize";
kony.sync.reconcileDownloadBatchSize = "reconciledownloadbatchsize";
kony.sync.pendingReconcileScopesWithHistoryChanges = "pendingreconcilescopeswithhistorychanges";
//reconcileglobals
kony.sync.reconcileTotalBatchDownloads = 0;
kony.sync.reconcileTotalBatchInserts = 0;
kony.sync.reconcileTotalBatchDeletes = 0;
kony.sync.reconcileTotalInserts = 0;
kony.sync.reconcileTotalDeletes = 0;
kony.sync.reconcileTotalDownloaded = 0;
kony.sync.isFirstReconcileDownload = true;
kony.sync.isFirstBulkGetReconcileDownload = true;
kony.sync.downloadReconcileClientContext = {};
kony.sync.bulkGetDownloadReconcileClientContext = {};
kony.sync.queryStore = {};
kony.sync.batchDownloadTimer = 0;
kony.sync.batchInsertionTimer = 0;
kony.sync.reconcileMaxDeleteLimit = 1000;
kony.sync.reconcileSkippedScopeName = "reconcileskippedscopename";
kony.sync.reconcilePendingObjectsInScope = "reconcilependingobjectsinscope";
kony.sync.OTAChangestobeDeleted = [];
kony.sync.PersisChangestobeDeleted = [];
kony.sync.sessionTaskUploadErrorPolicy = "uploaderrorpolicy";
kony.sync.sessionTaskUploadErrorPolicyCOE = "continueonerror";
kony.sync.sessionTaskUploadErrorPolicyAOE = "abortonerror";
//global variable to check whether reset already started or not
kony.sync.isResetInProgress = false;
kony.sync.errorInfoTransactionID = "transactionID";
kony.sync.errorInfoDatabaseError = "dbError";
//global variable to check whether sync for any scope got succeeded or not.
//If sync is not faled for any scope, then only call onsyncsuccess else onsyncerror
kony.sync.isErrorInAnyScope = false;
kony.sync.syncErrorMessage = {};
//This variable will save download request from first batch for subsequent batches
kony.sync.downloadRequest = null;
kony.sync.errorObject = null;
kony.sync.schemaUpgradeErrorObject = null;
kony.sync.enableORMValidations = true;
kony.sync.numberOfRetriesKey = "numberofretryattempts";
kony.sync.onRetry = "onretry";
kony.sync.networkTimeOutKey = "networktimeout";
kony.sync.retryErrorCodes = "retryerrorcodes";
kony.sync.retryWaitKey = "retrywaittime";
//kony.sync.numberOfRetries = 0;
kony.sync.numberOfRetriesMap = {};
kony.sync.maxParallelChunksKey = "maxparallelchunks";
kony.sync.payloadIdKey = "payloadid";
kony.sync.chunkCountKey = "chunkcount";
kony.sync.chunkNoKey = "chunknumber";
kony.sync.chunkDataKey = "chunkdata";
kony.sync.chunkSizeKey = "chunksize";
kony.sync.chunkHashSum = "checksum";
kony.sync.chunkMetaTableName = "konysyncCHUNKMETAINFO";
kony.sync.metaTablePayloadId = "payloadid";
kony.sync.metaTableChunkAck = "chunkacknowledged";
kony.sync.metaTableChunkSize = "chunksize";
kony.sync.metaTableChunkHashSum = "chunkhashsum";
kony.sync.metaTableChunkDiscarded = "chunkdiscarded";
kony.sync.metaTableChunkCount = "chunkcount";
kony.sync.chunkTableName = "konysyncCHUNKDATA";
kony.sync.chunkTableChunkData = "chunkdata";
kony.sync.chunkTableChunkId = "chunkid";
kony.sync.chunkTablePayloadId = "payloadid";
kony.sync.chunkTableTimeStamp = "timestamp";
kony.sync.chunkRequestKey = "chunkrequest";
kony.sync.pendingChunksKey = "pendingchunks";
kony.sync.chunksDownloadedKey = "chunksdownloaded";
kony.sync.onChunkStart = "onchunkstart";
kony.sync.onChunkSuccess = "onchunksuccess";
kony.sync.onChunkError = "onchunkerror";
kony.sync.chunkNotAcknowledged = 0;
kony.sync.chunkCompleteButNotAcknowledged = 1;
kony.sync.chunkCompleteAndWaitingForAck = 2;
kony.sync.chunkDiscarded = 1;
kony.sync.chunkNotDiscarded = 0;
kony.sync.trackIntermediateUpdates = true;
kony.sync.uploadcontextMap = {};
kony.sync.serverDetails = "serverDetails";
kony.sync.hostName = "hostName";
kony.sync.ipAddress = "ipAddress";
/*meta info about konysyncPENDINGUPLOADREQUESTINFO table */
kony.sync.pendingUploadTableName = "konysyncPENDINGUPLOADREQUESTINFO";
kony.sync.pendingUploadTableInsertCount = "insertcount";
kony.sync.pendingUploadTableUpdateCount = "updatecount";
kony.sync.pendingUploadTableDeleteCount = "deletecount";
kony.sync.pendingUploadTableBatchInsertCount = "batchinsertcount";
kony.sync.pendingUploadTableBatchUpdateCount = "batchupdatecount";
kony.sync.pendingUploadTableBatchDeleteCount = "batchdeletecount";
kony.sync.pendingUploadTableObjectLevelInfo = "objectlevelinfo";
kony.sync.pendingUploadTableUploadRequest = "uploadrequest";
kony.sync.pendingUploadTableUploadLimit = "uploadlimit";
kony.sync.deviceDBEncryptionKey = null;
kony.sync.deviceDBEncryptionKeyParam = "devicedbencryptionkey";
kony.sync.onSyncInitSuccessParam = "oninitsuccess";
kony.sync.onSyncInitErrorParam = "oniniterror";
kony.sync.onSyncResetSuccessParam = "onresetsuccess";
kony.sync.onSyncResetErrorParam = "onreseterror";
kony.sync.currentSyncScopeFilter = null;
kony.sync.currentSyncScopeFilterIndex = 1;
kony.sync.uploadClientContext = {};
kony.sync.downloadClientContext = {};
kony.sync.reconciledKeysKey = "reconciledprimarykeys";
kony.sync.schemaUpgradeNeeded = false;
kony.sync.schemaUpgradeContext = null;
kony.sync.schemaUpgradeDownloadPending = false;
kony.sync.omitUpload = false;
kony.sync.omitDownload = false;
kony.sync.onUpgradeQueriesDownloadStartKey = "onupgradescriptsdownloadstart";
kony.sync.onUpgradeQueriesDownloadSuccessKey = "onupgradescriptsdownloadsuccess";
kony.sync.onUpgradeQueriesDownloadErrorKey = "onupgradescriptsdownloaderror";
kony.sync.onUpgradeQueriesExecutionStartKey = "onupgradescriptsexecutionstart";
kony.sync.onUpgradeQueriesExecutionSuccessKey = "onupgradescriptsexecutionsuccess";
kony.sync.onUpgradeQueriesExecutionErrorKey = "onupgradescriptsexecutionerror";
kony.sync.onUpgradeRequiredKey = "onupgraderequired";
//Schema Upgrade Policies
kony.sync.onUpgradeActionAbort = "ABORT";
kony.sync.onUpgradeActionContinue = "CONTINUE"; //Not Implemented
kony.sync.onUpgradeActionContinueOnlyUpload = "CONTINUE_ONLY_UPLOAD"; //Not Implemented
kony.sync.onUpgradeActionUploadAbort = "UPLOAD_AND_ABORT";
kony.sync.onUpgradeActionUpgrade = "UPGRADE";
kony.sync.onUpgradeActionUploadUpgrade = "UPLOAD_AND_UPGRADE";
kony.sync.performOnlySchemaUpgrade = false;
kony.sync.onIsUpgradeRequiredSuccessKey = "isupgraderequiredsuccess";
kony.sync.onIsUpgradeRequiredErrorKey = "isupgraderequirederror";
kony.sync.onIsUpgradeRequiredStartKey = "isupgraderequiredstart";
kony.sync.onPerformUpgradeStartKey = "onperformupgradestart";
kony.sync.onPerformUpgradeSuccessKey = "onperformupgradesuccess";
kony.sync.onPerformUpgradeErrorKey = "onperformupgradeerror";
kony.sync.forceUpload = false;
kony.sync.forceUploadUpgrade = false;
kony.sync.uploadLimit = 0;
kony.sync.deviceIdentifierIOS7Key = "deviceidentifierios7";
kony.sync.isAlertEnabled = true;
kony.sync.invokeServiceFunctionKey = "invokeservicefunction";
kony.sync.authTokenKey = "authtoken";
kony.sync.sessionMap = {};
kony.sync.konySyncSessionID = "konysyncsessionid";
kony.sync.konySyncRequestNumber = "konysyncrequestnumber";
kony.sync.isSyncStopped = false;
kony.sync.onSyncStop = null;
kony.sync.httprequestsession = null;
kony.sync.DDL556to559Update = [];
kony.sync.DDL559to560Update = [];
kony.sync.DDL6xto70Update = [];
kony.sync.scopeDict = {};
kony.sync.isAppInBackground = false;
kony.sync.isPhonegap = false;
//upload cache changes
kony.sync.scope = "scope";
kony.sync.offset = "offset";
kony.sync.limit = "limit";
kony.sync.lastSequenceNumber = "lastSeqNo";
kony.sync.batchSize = "batchsize";
kony.sync.changeSet = "changeset";
kony.sync.uploadChangesLimit = "uploadLimit";
kony.sync.lastBatch = "lastBatch";
kony.sync.columns = "binarycolumns";
kony.sync.binaryMetaColumnPrefix = "blobref_";
kony.sync.blob = "binary";
kony.sync.onDemand = "ondemand";
kony.sync.always = "always";
kony.sync.ifRecordValue = "ifrecordvalue";
kony.sync.syncToDeviceField = "downloadToDeviceField";
kony.sync.inline = "Inline";
kony.sync.notSupported = "NotSupported";
kony.sync.blobRefNotFound = -1;
kony.sync.blobRefNotDefined = "NULL";
kony.sync.binaryPolicy = "downloadToDevice";
kony.sync.blobTypeBase64 = "base64";
kony.sync.blobTypeStream = "stream";
kony.sync.forceDownload = "forceDownload";
kony.sync.maxFilePercent = 100;
kony.sync.minFilePercent = 0;
kony.sync.maxRetries = 3;
kony.sync.optype = "optype";
kony.sync.comptype = "comptype";
kony.sync.openbrace = "openbrace";
kony.sync.closebrace = "closebrace";
kony.sync.queryKey = "key";
kony.sync.queryValue = "value";
kony.sync.params = "params";
kony.sync.httpHeaders = "httpheaders";
kony.sync.url = "url";
kony.sync.blobId = "blobid";
kony.sync.blobName = "blobname";
kony.sync.type = "type";
kony.sync.metadata = "metadata";
kony.sync.changetype = "changetype";
kony.sync.syncobjects = "syncobjects";
kony.sync.serverBlob = "serverBlob";
kony.sync.blobSyncScope = "scopeName";
kony.sync.clientId = "clientid";
kony.sync.moreChangesAvailable = "moreChangesAvailable";
kony.sync.requestState = "requestState";
kony.sync.currentSyncConfigKey = "currentSyncConfigParams";
kony.sync.requestType = "requestType";
kony.sync.isUpload = false;
kony.sync.isDownload = true;
kony.sync.konySyncReplaySequence = "konysyncreplaysequence";
kony.sync.SequenceNumber = "SequenceNumber";
kony.sync.sync = "sync";
kony.sync.oneToMany = "OneToMany";
kony.sync.targetObject = "TargetObject";
kony.sync.sourceAttribute = "ParentObject_Attribute";
kony.sync.targetAttribute = "ChildObject_Attribute";
kony.sync.isCleanUpJobCompleted = false;
kony.sync.onBinaryDownloadFunction = "onBinaryDownload";
kony.sync.onBinaryUploadFunction = "onBinaryUpload";
kony.sync.tracking = "syncTracking";
kony.sync.shouldDeleteBeforeSyncSession = "shouldDeleteBeforeSyncSession";
//  **************** End KonySyncGlobals.js*******************
//  **************** Start KonySyncHelper.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//This function is used inside sync library to handle prints
kony.sync.syncPrint = function(param) {
    sync.log.trace("Entering kony.sync.syncPrint ");
    if (kony.sync.syncLibPrint) {
        kony.print(param);
    }
};
/*
--This function formats the sqllite resultset. This is temporary and should be done at platform level.
--function format_row(rowItem)
kony.sync.format_row = function(rowItem)
local rowtemp = {}
if(rowItem ~= nil)then
for key,value in pairs(rowItem) do
value = ""..value;
if(string.isnumeric(value))then
string.replace(value,".0","");
end
rowtemp[key] = string.replace(value, "'", "");
end
if ( value ~= nil ) then
string.replace(value, "'", "");
end
else
return nil;
end
return rowtemp;
end
--*/
kony.sync.getTableInfo = function(tablename) {
    sync.log.trace("Entering kony.sync.getTableInfo ");
    for (var i = 0; i < kony.sync.scopes.length; i++) {
        var scope = kony.sync.scopes[i];
        if (!kony.sync.isNullOrUndefined(scope.syncTableDic[tablename])) {
            return scope.syncTableDic[tablename];
        }
    }
    return null;
};
kony.sync.is_SQL_select = function(sql) {
    sync.log.trace("Entering kony.sync.is_SQL_select ");
    sql = kony.string.trim(sql);
    return kony.string.startsWith(sql, "select", true);
};
kony.sync.dummyerror = function(tid, err) {
    sync.log.trace("Entering kony.sync.dummyerror ");
    if (kony.sync.isNullOrUndefined(err)) {
        sync.log.debug("dummyerror");
    } else {
        sync.log.debug("dummy error --->", err);
    }
};
kony.sync.verifyAndCallClosure = function(closure, params) {
    sync.log.trace("Entering kony.sync.verifyAndCallClosure ");
    if (kony.sync.isValidFunctionType(closure)) {
        return closure(params);
    } else {
        sync.log.warn("Invalid callback type : ", closure);
    }
};
kony.sync.getArrayCount = function(tab) {
    sync.log.trace("Entering kony.sync.getArrayCount ");
    var count = 0;
    if (!kony.sync.isNullOrUndefined(tab)) {
        return tab.length;
    }
    return count;
};
kony.sync.getDeviceID = function() {
    sync.log.trace("Entering kony.sync.getDeviceID");
    if (kony.sync.deviceId !== "") {
        return kony.sync.deviceId;
    }
    var deviceInfo = kony.os.deviceInfo();
    return deviceInfo.deviceid;
};
kony.sync.getInstanceID = function() {
    sync.log.trace("Entering kony.sync.getInstanceID ");
    return kony.sync.instanceId;
};
kony.sync.getOriginalDeviceID = function() {
    sync.log.trace("Entering kony.sync.getOriginalDeviceID ");
    if (kony.sync.isNullOrUndefined(kony.sync.originalDeviceId)) {
        kony.sync.originalDeviceId = kony.os.deviceInfo().deviceid;
        return kony.os.deviceInfo().deviceid;
    } else {
        return kony.sync.originalDeviceId;
    }
};
kony.sync.removeprovisioncolumns = function(row, columns, isArray, insertNull) {
    sync.log.trace("Entering kony.sync.removeprovisioncolumns ");
    //remove the blobref_columns from the columns.
    var length = columns.length;
    var record = [];
    var i = null;
    if (!isArray) {
        record = [];
        for (i = length - 1; i >= 0; i--) {
            if (!kony.sync.isNullOrUndefined(row[columns[i].Name])) {
                record.push(row[columns[i].Name]);
            } else if (insertNull === true) {
                record.push("NULL");
            }
        }
        if (!kony.sync.isNullOrUndefined(row.konysynchashsum)) {
            record.push(row.konysynchashsum);
        }
        return record;
    } else {
        record = {};
        for (i = length - 1; i >= 0; i--) {
            if (!kony.sync.isNullOrUndefined(row[columns[i].Name])) {
                record[columns[i].Name] = row[columns[i].Name];
            } else if (insertNull === true) {
                record[columns[i].Name] = "NULL";
            }
        }
        if (!kony.sync.isNullOrUndefined(row.konysynchashsum)) {
            record.konysynchashsum = row.konysynchashsum;
        }
        return record;
    }
};
kony.sync.replaceautogeneratedPK = function(sname, synctable, values, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.replaceautogeneratedPK ");
    var id = null;
    var pkTab = {};
    if (!kony.sync.isNullOrUndefined(synctable.Pk_Columns)) {
        for (var i = 0; i < synctable.Pk_Columns.length; i++) {
            var pk = synctable.Pk_Columns[i];
            if (synctable.ColumnsDic[pk].Autogenerated === "true") {
                id = kony.sync.getLastGeneratedID(sname, tx, errorCallback);
                if (id === false) {
                    return false;
                }
                id = id - 1;
                if (synctable.ColumnsDic[pk].type === "string") {
                    id = id.toString();
                }
                values[pk] = id;
                pkTab[pk] = id;
                if (!kony.sync.setLastGeneratedID(sname, id, tx, errorCallback)) {
                    return false;
                }
            } else {
                pkTab[pk] = values[pk];
            }
        }
    }
    //implemented for composite primary key
    return pkTab;
};
kony.sync.CreateCopy = function(obj) {
    sync.log.trace("Entering kony.sync.CreateCopy ");
    var copy;
    if (null == obj || "object" != typeof obj) return obj;
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = kony.sync.CreateCopy(obj[i]);
        }
        return copy;
    }
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = kony.sync.CreateCopy(obj[attr]);
        }
        return copy;
    }
};
kony.sync.getautogeneratePK = function(sname, synctable) {
    sync.log.trace("Entering kony.sync.getautogeneratePK ");
    var agPKs = [];
    if (!kony.sync.isNullOrUndefined(synctable.Pk_Columns)) {
        for (var i = 0; i < synctable.Pk_Columns.length; i++) {
            var pk = synctable.Pk_Columns[i];
            if ((synctable.ColumnsDic[pk].Autogenerated === "true")) {
                kony.table.insert(agPKs, pk);
            }
        }
    }
    return agPKs;
};
kony.sync.getDBNamefromDataSource = function(dsname) {
    sync.log.trace("Entering kony.sync.getDBNamefromDataSource ");
    sync.log.debug("validatint dsname : ", dsname);
    for (var i = 0; i < konysyncClientSyncConfig.ArrayOfDataSource.length; i++) {
        var datasource = konysyncClientSyncConfig.ArrayOfDataSource[i];
        sync.log.debug("datasource.type:" + datasource.type + ":datasource.ID:" + datasource.ID);
        if ((datasource.type === "database" && datasource.ID === dsname)) {
            return datasource.Database.DatabaseName;
        }
    }
    return null;
};
kony.sync.getAppId = function() {
    sync.log.trace("Entering kony.sync.getAppId ");
    return kony.sync.currentSyncConfigParams.appid;
};
kony.sync.getBatchSize = function() {
    sync.log.trace("Entering kony.sync.getBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.batchsize)) {
        return kony.sync.currentSyncConfigParams.batchsize;
    }
    if (kony.os.deviceInfo().name === "blackberry") {
        return "50";
    } else {
        return "500";
    }
};
kony.sync.resetsyncsessionglobals = function(opName) {
    sync.log.trace("Entering kony.sync.resetsyncsessionglobals ");
    kony.sync.currentScope = null;
    kony.sync.currentSyncReturnParams = {};
    kony.sync.isSyncStopped = false;
    if (opName === "startSession") {
        kony.sync.currentSyncReturnParams[kony.sync.uploadURL] = kony.sync.getUploadURL();
        kony.sync.currentSyncReturnParams[kony.sync.downloadURL] = kony.sync.getDownloadURL();
    }
    kony.sync.currentSyncLog = [];
};
kony.sync.resetscopesessionglobals = function(CallBack) {
    sync.log.trace("Entering kony.sync.resetscopesessionglobals ");
    var isError = false;

    function clearSchemaUpgradeContext(tx) {
        sync.log.trace("Entering clearSchemaUpgradeContext");
        //resetting the schemaupgrade flag   once the download of the columns is done in memory and in db
        kony.sync.schemaUpgradeContext = null;
        var sql = "update " + kony.sync.syncConfigurationTableName + " set " + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " = null";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            isError = true;
            return; //error
        }
        sync.log.info("schemaupgrade context cleared successfully in memory and db");
    }

    function clearSchemaSuccessCallBack() {
        sync.log.trace("Entering clearSchemaSuccessCallBack");
        CallBack(true);
    }

    function dbErrorCallBack(errInfo) {
        sync.log.error("error in opening db connection " + JSON.stringify(errInfo));
        clearSchemaErrorCallBack(errInfo);
    }

    function clearSchemaErrorCallBack(errInfo) {
        sync.log.error("failed to clear schemaupgradeinfo in synconfigtable after dsc " + JSON.stringify(errInfo));
        kony.sync.isErrorInAnyScope = true;
        CallBack(true);
    }
    sync.log.trace("Entering kony.sync.resetscopesessionglobals ");
    kony.sync.syncPendingBatchesNo = 0;
    delete kony.sync.currentSyncReturnParams[kony.sync.batchContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadContext];
    if (kony.sync.currentScope === null) {
        kony.sync.currentScope = kony.sync.scopes[0]; //- Start 1st Scope Sync
        CallBack(false);
    } else {
        sync.log.debug("Scope index: ", kony.sync.currentScope.Index);
        sync.log.debug("Scope count: ", kony.sync.scopes.scopecount);
        if (kony.sync.currentScope.Index === kony.sync.scopes.scopecount - 1) {
            if (!kony.sync.isNullOrUndefined(kony.sync.schemaUpgradeContext)) {
                var dbName = kony.sync.currentScope[kony.sync.scopeDataSource];
                var conn = kony.sync.getConnectionOnly(dbName, dbName, dbErrorCallBack);
                if (conn !== null) {
                    kony.db.transaction(conn, clearSchemaUpgradeContext, clearSchemaErrorCallBack, clearSchemaSuccessCallBack);
                }
            } else CallBack(true); //Sync Complete
        } else {
            kony.sync.currentScope = kony.sync.scopes[kony.sync.currentScope.Index + 1]; //Get Next Scope
            CallBack(false);
        }
    }
};
kony.sync.resetuploadsessioglobals = function() {
    sync.log.trace("Entering kony.sync.resetuploadsessioglobals ");
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.lastSyncTimestamp];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadSequenceNumber];
    //sync_total_inserts = 0;
    kony.sync.syncTotalInserts = 0;
    kony.sync.syncTotalUpdates = 0;
    kony.sync.syncTotalDeletes = 0;
    kony.sync.serverInsertCount = 0;
    kony.sync.serverUpdateCount = 0;
    kony.sync.serverDeleteCount = 0;
    kony.sync.serverInsertAckCount = 0;
    kony.sync.serverUpdateAckCount = 0;
    kony.sync.serverDeleteAckCount = 0;
    kony.sync.serverFailedCount = 0;
    kony.sync.uploadSummary = [];
};
kony.sync.resetbatchsessionglobals = function() {
    sync.log.trace("Entering kony.sync.resetbatchsessionglobals ");
    delete kony.sync.currentSyncReturnParams[kony.sync.batchContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadContext];
    delete kony.sync.currentSyncReturnParams[kony.sync.uploadSequenceNumber];
    kony.sync.serverInsertCount = 0;
    kony.sync.serverUpdateCount = 0;
    kony.sync.serverDeleteCount = 0;
    kony.sync.serverInsertAckCount = 0;
    kony.sync.serverUpdateAckCount = 0;
    kony.sync.serverDeleteAckCount = 0;
    kony.sync.serverFailedCount = 0;
    kony.sync.uploadSummary = [];
    kony.sync.objectLevelInfoMap = {};
};
kony.sync.getSyncTable = function(tablename) {
    sync.log.trace("Entering kony.sync.getSyncTable ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    return kony.sync.scopes[scopename].syncTableDic[tablename];
};
kony.sync.getCurrentVersionNumber = function(tbname) {
    sync.log.trace("Entering kony.sync.getCurrentVersionNumber ");
    var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
    return kony.sync.currentSyncScopesState[scopename];
};
kony.sync.getBackEndDBType = function() {
    sync.log.trace("Entering kony.sync.getBackEndDBType ");
    if (kony.sync.platformName === null) {
        kony.sync.platformName = kony.os.deviceInfo().name;
    }
    if (kony.sync.platformName === "winmobile") {
        return kony.sync.dbTypeSQLCE;
    }
    return kony.sync.dbTypeSQLLite;
};
kony.sync.printScopeLog = function() {
    sync.log.trace("Entering kony.sync.printScopeLog ");
    sync.log.info("Sync complete");
    sync.log.info("----------------------------------------------------");
    for (var i = 0; i < kony.sync.currentSyncLog.length; i++) {
        var batch = kony.sync.currentSyncLog[i];
        sync.log.info("Batch No: ", i);
        sync.log.info("Batch log: ", batch);
    }
    sync.log.info("----------------------------------------------------");
};
//To generate hash
kony.sync.genHash = function(hashType, plaintext) {
    sync.log.trace("Entering kony.sync.genHash ");
    //return same in case of null/undefined plaintext
    if (kony.sync.isNull(plaintext)) {
        return plaintext;
    }
    //if hashType is callback, get the value from it
    if (kony.sync.isValidFunctionType(hashType)) {
        return hashType(plaintext);
    }
    //convert plaintext to string if not already
    plaintext = plaintext.toString();
    //apply default value in case of invalid/null/undefined hashtype
    if (kony.sync.isNull(hashType) || kony.string.equalsIgnoreCase(kony.type(hashType), "string") === false) {
        return kony.crypto.createHash("sha256", plaintext);
    }
    //return same if hashtype is none
    else if (kony.string.equalsIgnoreCase(hashType, "none") === true) {
        return plaintext;
    }
    //apply the desired hash algo
    else {
        return kony.crypto.createHash(hashType, plaintext);
    }
};
kony.sync.tonumber = function(arg) {
    sync.log.trace("Entering kony.sync.tonumber ");
    if (kony.sync.isNullOrUndefined(arg)) {
        return null;
    }
    //duplicating kony.os.toNumber in order to avoid Android platform dependency issues
    if (arguments.length !== 1) {
        throw new Error("Invalid argument to os.toNumber");
    }
    if (typeof(arg) === "number") {
        return arg;
    } else if (typeof(arg) === "string") {
        var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
        if (str === '') {
            return null;
        } else {
            var num = str - 0;
            return (isNaN(num) ? null : num);
        }
    } else {
        return null;
    }
};
kony.sync.filterNullsFromSelectResult = function(res) {
    sync.log.trace("Entering kony.sync.filterNullsFromSelectResult ");
    if (kony.sync.enableORMValidations) {
        var tableToMap = [];
        for (var j = 0; j < res.length; j++) {
            var u = res[j];
            var rowToMap = {};
            for (var k in u) {
                var v = u[k];
                if (!kony.sync.isNull(v)) {
                    rowToMap[k] = v;
                }
            }
            kony.table.insert(tableToMap, rowToMap);
        }
        return tableToMap;
    } else {
        return res;
    }
};
kony.sync.getAsyncDownloadBatchSize = function() {
    sync.log.trace("Entering kony.sync.getAsyncDownloadBatchSize ");
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.asyncbatchsize)) {
        return kony.sync.currentSyncConfigParams.asyncbatchsize;
    }
    return 50;
};
kony.sync.isApplyChangesSync = function() {
    sync.log.trace("Entering kony.sync.isApplyChangesSync ");
    var returnVal;
    returnVal = true;
    return returnVal;
};
kony.sync.getChangeTypeForUploadTrue = function(type) {
    sync.log.debug("ValueSentForChange: ", type);
    if (typeof(type) === "number") {
        type = type.toString();
    }
    if (type === "90") {
        return "0";
    }
    if (type === "91") {
        return "1";
    }
    if (type === "92") {
        return "2";
    }
    return type;
};
//Checking whether table is defined for delete after upload or not
kony.sync.checkForDeleteAfterUpload = function(tablename, scopename) {
    sync.log.trace("Entering kony.sync.checkForDeleteAfterUpload ");
    var i = null;
    var myTab = kony.sync.currentSyncConfigParams[kony.sync.removeAfterUpload];
    if (kony.sync.isNullOrUndefined(myTab)) {
        return false;
    }
    if (!kony.sync.isNullOrUndefined(scopename)) {
        if (kony.sync.isNullOrUndefined(myTab[scopename])) {
            return false;
        }
        if (myTab[scopename].length === 0) {
            return true;
        }
        for (i in myTab[scopename]) {
            if (myTab[scopename][i] === tablename) {
                return true;
            }
        }
    } else {
        for (i in myTab) {
            for (var j in myTab[i]) {
                if (myTab[i][j] === tablename) {
                    return true;
                }
            }
        }
    }
    return false;
};
//checking for false updates
kony.sync.checkForFalseUpdate = function(dbname, tbname, twcs, markForUpload, errorcallback, successcallback) {
    sync.log.trace("Entering kony.sync.checkForFalseUpdate ");
    var uploadstatus = true;
    var isError = false;
    if (markForUpload === false || markForUpload === "false") {
        return true;
    } else {
        kony.table.insert(twcs, {
            key: kony.sync.historyTableChangeTypeColumn,
            value: "90",
            optype: "EQ",
            comptype: "AND"
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.historyTableChangeTypeColumn]);
        kony.sync.qb_from(query, tbname + "_history");
        kony.sync.qb_where(query, twcs);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var connection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback, "check for false update");
        if (connection !== null) {
            kony.sync.startTransaction(connection, transaction_callback, update_successcallback, single_transaction_error_callback, "check for false update");
        }
    }

    function transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.checkForFalseUpdate transaction_callback");
        var resultSet = kony.sync.executeSql(tx, sql, params, errorcallback);
        if (resultSet !== false) {
            var num_records = resultSet.rows.length;
            if (num_records !== 0) {
                sync.log.error("Record does not exist on server, mark it for upload before updating/deleting it");
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMarkForUpload, kony.sync.getErrorMessage(kony.sync.errorCodeMarkForUpload), null));
                uploadstatus = false;
            } else {
                uploadstatus = true;
            }
        } else {
            //return;
            isError = true;
        }
    }

    function update_successcallback() {
        sync.log.trace("Entering kony.sync.checkForFalseUpdate update_successcallback");
        if (!isError && uploadstatus === true) {
            successcallback();
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.checkForFalseUpdate single_transaction_error_callback");
        if (!isError) {
            sync.log.error("Transaction error occurred", "check for false update");
            kony.sync.showTransactionError(errorcallback, "check for false update");
        } else {
            sync.log.error("Transaction error occurred", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.checkForFalseUpdateWCS = function(dbname, tbname, twcs, markForUpload, errorcallback, successcallback) {
    sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS ");
    var uploadstatus = true;
    var isError = false;
    if (markForUpload === false || markForUpload === "false") {
        return true;
    }
    if (twcs !== "" && !kony.sync.isNull(twcs)) {
        twcs = twcs + " AND " + kony.sync.historyTableChangeTypeColumn + " = 90";
    } else {
        twcs = " where " + kony.sync.historyTableChangeTypeColumn + " = 90";
    }
    var sql = "select " + kony.sync.historyTableChangeTypeColumn + " from " + tbname + "_history " + twcs;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback, "check for false update WCS");
    if (connection !== null) {
        kony.sync.startTransaction(connection, transaction_callback, update_successcallback, update_failurecallback, "check for false update WCS");
    }

    function transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS transaction_callback");
        var resultSet = kony.sync.executeSql(tx, sql, null, errorcallback);
        if (resultSet !== false) {
            var num_records = resultSet.rows.length;
            if (num_records !== 0) {
                sync.log.error("Record does not exist on server, mark it for upload before updating/deleting it");
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMarkForUpload, kony.sync.getErrorMessage(kony.sync.errorCodeMarkForUpload), null));
                uploadstatus = false;
            } else {
                uploadstatus = true;
            }
        } else {
            isError = true;
        }
    }

    function update_successcallback() {
        sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS update_successcallback");
        if (!isError && uploadstatus === true) {
            successcallback();
        }
    }

    function update_failurecallback() {
        sync.log.trace("Entering kony.sync.checkForFalseUpdateWCS update_failurecallback");
        if (!isError && uploadstatus === true) {
            sync.log.error("Transaction error occurred : ", "check for false update WCS");
            kony.sync.showTransactionError(errorcallback, "check for false update WCS");
        } else {
            sync.log.error("Transaction error occurred : ", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.getConnection = function(dbName, displayName, transactionCallBack, successCallBack, errorCallBack) {
    sync.log.trace("Entering kony.sync.getConnection ");
    var connection = kony.sync.getConnectionOnly(dbName, displayName, errorCallBack);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallBack, errorCallBack, successCallBack);
    }
};
//This function starts a transaction given a connection
kony.sync.startTransaction = function(connection, transactionCallBack, successCallBack, errorCallBack) {
    sync.log.trace("Entering kony.sync.startTransaction ");
    kony.db.transaction(connection, transactionCallBack, errorCallBack, successCallBack);
};
kony.sync.showTransactionError = function(errorCallBack, moduleName) {
    sync.log.trace("Entering kony.sync.showTransactionError ");
    if (kony.sync.isNullOrUndefined(moduleName)) {
        moduleName = "";
    }
    sync.log.fatal(moduleName + ":" + " Db connection is null");
    kony.sync.verifyAndCallClosure(errorCallBack, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
};
kony.sync.checkIntegrity = function(dbname, rMap, successCallback, errorCallBack) {
    sync.log.trace("Entering kony.sync.checkIntegrity ");
    if (!kony.sync.enableORMValidations) {
        kony.sync.verifyAndCallClosure(successCallback);
        return;
    }
    var status = true;
    var isError = false;
    var integrityFailedMap = null;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallBack, "Checking integrity");
    if (connection !== null) {
        kony.sync.startTransaction(connection, integrityTransaction, integritySuccess, integrityFailure, "Checking Referential Integrity Constraints");
    }

    function integrityTransaction(tx) {
        sync.log.trace("Entering integrityTransaction");
        integrityFailedMap = kony.sync.checkIntegrityinTransaction(tx, rMap);
    }

    function integritySuccess() {
        sync.log.trace("Entering integritySuccess");
        var error = "";
        if (integrityFailedMap === true) {
            kony.sync.verifyAndCallClosure(successCallback);
        } else {
            for (var key in integrityFailedMap) {
                error = error + integrityFailedMap[key];
            }
            kony.sync.verifyAndCallClosure(errorCallBack, kony.sync.getErrorTable(kony.sync.errorCodeReferentialIntegrity, error));
        }
    }

    function integrityFailure() {
        sync.log.trace("Entering integrityFailure");
        if (!integrityFailedMap) {
            kony.sync.showTransactionError(errorCallBack, "Checking integrity");
        } else {
            kony.sync.verifyAndCallClosure(errorCallBack, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.checkIntegrityinTransaction_old = function(tx, rMap) {
    sync.log.trace("Entering kony.sync.checkIntegrityinTransaction ");
    var integrityFailedMap = {};
    if (!kony.sync.enableORMValidations) {
        return true;
    }
    for (var obj in rMap) {
        for (var key in rMap[obj]) {
            if (kony.sync.isNull(rMap[obj][key].targetAttributeValue)) {
                continue;
            }
            if (integrityFailedMap[rMap[obj][key].foreignKeyAttribute] === false) {
                continue;
            }
            if (rMap[obj][key].targetAttributeValue === "") {
                rMap[obj][key].targetAttributeValue = "''";
            }
            var sql = "select * from " + obj + " where " + rMap[obj][key].sourceAttribute[0] + " = " + rMap[obj][key].targetAttributeValue[0] + "";
            var resultSet = kony.sync.executeSql(tx, sql, null);
            if (resultSet !== false) {
                if (resultSet.rows.length === 0) {
                    sync.log.error("Referential Integrity Check Failed", kony.sync.getErrorTable(kony.sync.errorCodeReferentialIntegrity, kony.sync.getReferetialIntegrityerrMessg(obj, rMap[obj][key].sourceAttribute, rMap[obj][key].targetAttributeValue)));
                    if (kony.sync.isNullOrUndefined(integrityFailedMap[rMap[obj][key].foreignKeyAttribute])) {
                        integrityFailedMap[rMap[obj][key].foreignKeyAttribute] = kony.sync.getReferetialIntegrityerrMessg(obj, rMap[obj][key].sourceAttribute, rMap[obj][key].targetAttributeValue);
                    } else {
                        integrityFailedMap[rMap[obj][key].foreignKeyAttribute] = integrityFailedMap[rMap[obj][key].foreignKeyAttribute] + kony.sync.getReferetialIntegrityerrMessg(obj, rMap[obj][key].sourceAttribute, rMap[obj][key].targetAttributeValue);
                    }
                } else {
                    integrityFailedMap[rMap[obj][key].foreignKeyAttribute] = false;
                }
            } else {
                return false;
            }
        }
    }
    var logicalBreak = false;
    for (var key in integrityFailedMap) {
        if (integrityFailedMap[key] !== false) {
            logicalBreak = true;
        }
    }
    return logicalBreak === false ? true : integrityFailedMap;
};
kony.sync.checkIntegrityinTransaction = function(tx, rMap) {
    sync.log.trace("Entering kony.sync.checkIntegrityinTransactionFK ");
    var integrityFailedMap = {};
    if (!kony.sync.enableORMValidations) {
        return true;
    }
    for (var obj in rMap) {
        for (var key = 0; key < rMap[obj].length; key++) {
            var relationShipMap = rMap[obj][key];
            var whereClause = " where ";
            for (var i = 0; i < relationShipMap.targetAttributeValue.length; i++) {
                if (kony.sync.isNull(relationShipMap.targetAttributeValue[i])) {
                    continue;
                }
                if (integrityFailedMap[relationShipMap.foreignKeyAttribute[i]] === false) {
                    continue;
                }
                if (relationShipMap.targetAttributeValue[i] === "") {
                    relationShipMap.targetAttributeValue[i] = "''";
                }
                whereClause = whereClause + relationShipMap.sourceAttribute[i] + " = " + relationShipMap.targetAttributeValue[i];
                if (i != relationShipMap.targetAttributeValue.length - 1) {
                    whereClause = whereClause + " AND ";
                }
            };
            var sql = "select * from " + obj + whereClause + "";
            var resultSet = kony.sync.executeSql(tx, sql, null);
            if (resultSet !== false) {
                if (resultSet.rows.length === 0) {
                    sync.log.error("Referential Integrity Check Failed", kony.sync.getErrorTable(kony.sync.errorCodeReferentialIntegrity, kony.sync.getReferetialIntegrityerrMessg(obj, relationShipMap.sourceAttribute, relationShipMap.targetAttributeValue)));
                    integrityFailedMap[relationShipMap.foreignKeyAttribute[0]] = kony.sync.getReferetialIntegrityerrMessg(obj, relationShipMap.sourceAttribute, relationShipMap.targetAttributeValue);
                } else {
                    integrityFailedMap[relationShipMap.foreignKeyAttribute[0]] = false;
                }
            } else {
                return false;
            }
        }
    }
    var logicalBreak = false;
    for (var key in integrityFailedMap) {
        if (integrityFailedMap[key] !== false) {
            logicalBreak = true;
        }
    }
    return logicalBreak === false ? true : integrityFailedMap;
};
kony.sync.convertOrderByMapToValuesTable = function(orderByMap) {
    sync.log.trace("Entering kony.sync.convertOrderByMapToValuesTable ");
    var valuesTable = {};
    for (var i in orderByMap) {
        valuesTable[orderByMap[i].key] = orderByMap[i].key;
    }
    return valuesTable;
};
kony.sync.convertToValuesTableOrderByMap = function(orderByMap, valuesTable) {
    sync.log.trace("Entering kony.sync.convertToValuesTableOrderByMap ");
    var orderByMapFiltered = [];
    var j = 0;
    for (var i in orderByMap) {
        if (valuesTable[orderByMap[i].key] === orderByMap[i].key) {
            orderByMapFiltered[j] = orderByMap[i];
            j++;
        }
    }
    return orderByMapFiltered;
};
kony.sync.isValidFunctionType = function(closure) {
    sync.log.trace("Entering kony.sync.isValidFunctionType ");
    return kony.type(closure) === "function";
};
kony.sync.initializeScopeSettings = function(tx) {
    sync.log.trace("Entering kony.sync.initializeScopeSettings ");
    var query = kony.sync.qb_createQuery();
    var json = "{\"scopeSettings\" : {}}";
    kony.sync.qb_set(query, {
        "id": 1,
        "action": "",
        "details": json
    });
    kony.sync.qb_insert(query, "konysyncDIAGNOSTICS");
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.updateScopeSettings = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.updateScopeSettings ");
    var resultset = kony.sync.executeSql(tx, "select * from konysyncDIAGNOSTICS");
    if (resultset === false) {
        return false;
    }
    var settings = "";
    var rowItem = null;
    if (resultset.rows.length > 0) {
        rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        settings = rowItem.details;
    } else {
        sync.log.error("Updation of Scope Settings Failed");
    }
    var table = JSON.parse(settings);
    if (kony.sync.isNullOrUndefined(table.scopeSettings[scopename])) {
        table.scopeSettings[scopename] = {
            "initialize": true
        };
    } else if (kony.sync.isNullOrUndefined(table.scopeSettings[scopename].initialize)) {
        table.scopeSettings[scopename].initialize = true;
    }
    var query = kony.sync.qb_createQuery();
    var json = JSON.stringify(table);
    kony.sync.qb_set(query, {
        "details": json
    });
    kony.sync.qb_update(query, "konysyncDIAGNOSTICS");
    kony.sync.qb_where(query, [{
        "key": "id",
        "value": 1
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.getScopeSettings = function(scopename, dbname, callback, errorcallback) {
    sync.log.trace("Entering kony.sync.getScopeSettings ");
    var settings = null;
    var isError = false;

    function getSettingsTransaction(tx) {
        sync.log.trace("Entering getSettingsTransaction");
        var resultset = kony.sync.executeSql(tx, "select * from konysyncDIAGNOSTICS");
        var set = "";
        var rowItem = null;
        if (resultset !== false) {
            if (resultset.rows.length > 0) {
                rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                set = rowItem.details;
            } else {
                sync.log.error("Updation of Scope Settings Failed");
            }
        } else {
            sync.log.error("Updation of Scope Settings Failed");
            isError = true;
            return;
        }
        var table = JSON.parse(set);
        if (!kony.sync.isNullOrUndefined(table.scopeSettings[scopename])) {
            settings = table.scopeSettings[scopename];
        }
    }

    function getSettingsCompleted() {
        sync.log.trace("Entering getSettingsCompleted");
        callback(settings);
    }

    function getSettingsFailed() {
        sync.log.trace("Entering getSettingsFailed");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, getSettingsFailed, "getScopeSettings");
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, getSettingsTransaction, getSettingsCompleted, getSettingsFailed);
    }
};
kony.sync.isScopeInitialized = function(scopename, dbname, callback) {
    sync.log.trace("Entering kony.sync.isScopeInitialized ");

    function localcallback(settings) {
        sync.log.trace("Entering localcallback");
        if (settings !== null) {
            if (settings.initialize === true) {
                callback(true);
            } else {
                callback(false);
            }
        } else {
            callback(false);
        }
    }

    function errorCallback(res) {
        sync.log.trace("Entering errorCallback");
        kony.sync.onDownloadCompletion(true, res);
    }
    var settings = kony.sync.getScopeSettings(scopename, dbname, localcallback, errorCallback);
};
kony.sync.setPragmaSize = function(tx) {
    sync.log.trace("Entering kony.sync.setPragmaSize ");
    return kony.sync.executeSql(tx, "PRAGMA CACHE_SIZE=50");
};
/*
The same function is present below with same  functionalities and more validations for camel cases
kony.sync.isValidJSTable = function(inputTable) {
	if (kony.sync.isNullOrUndefined(inputTable)) {
		return false;
	}
	return kony.type(inputTable) === "object" || kony.type(inputTable) === "Object" || kony.type(inputTable) === "Array";
};
*/
kony.sync.isNull = function(val) {
    sync.log.trace("Entering kony.sync.isNull ");
    if (kony.sync.isNullOrUndefined(val)) {
        return true;
    }
    val = val + "";
    return (kony.string.equalsIgnoreCase(val, "null"));
};
//returns whether a error upload policy is continueonerror or not
kony.sync.isUploadErrorPolicyCOE = function(currentScope) {
    sync.log.trace("Entering kony.sync.isUploadErrorPolicyCOE ");
    var scopename = currentScope.ScopeName;
    //Added these redundant checks to check for OTA or Persistent Sync. As proper checks 
    //have not made in earlier implementation, we are doing this to avoid any backward compatibility issues.
    if (currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA) {
        if (currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename]) && kony.string.equalsIgnoreCase(kony.sync.getString(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename][kony.sync.sessionTaskUploadErrorPolicy]), kony.sync.sessionTaskUploadErrorPolicyCOE)) {
            return true;
        }
        return false;
    } else {
        if (currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename]) && kony.string.equalsIgnoreCase(kony.sync.getString(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][scopename][kony.sync.sessionTaskUploadErrorPolicy]), kony.sync.sessionTaskUploadErrorPolicyCOE)) {
            return true;
        }
        return false;
    }
};
kony.sync.isEmptyString = function(val) {
    sync.log.trace("Entering kony.sync.isEmptyString ");
    if (!kony.sync.isNullOrUndefined(val) && typeof(val) === "string" && val.trim() === "") {
        return true;
    } else {
        return false;
    }
};
kony.sync.isValidNumberType = function(val) {
    sync.log.trace("Entering kony.sync.isValidNumberType ");
    if (kony.string.equalsIgnoreCase(kony.type(val), "number")) {
        return true;
    } else if (kony.string.equalsIgnoreCase(kony.type(val), "string") && null !== kony.sync.tonumber(val)) {
        return true;
    } else {
        return false;
    }
};
kony.sync.isValidBooleanType = function(val) {
    sync.log.trace("Entering kony.sync.isValidBooleanType ");
    if (kony.string.equalsIgnoreCase(kony.type(val), "boolean")) {
        return true;
    } else if (kony.string.equalsIgnoreCase(kony.type(val), "string")) {
        if (kony.string.equalsIgnoreCase(val, "false") || kony.string.equalsIgnoreCase(val, "true") || kony.string.equalsIgnoreCase(val, "0") || kony.string.equalsIgnoreCase(val, "1")) {
            return true;
        }
    } else if (kony.string.equalsIgnoreCase(kony.type(val), "number")) {
        if (val === 0 || val === 1) {
            return true;
        }
    }
    return false;
};
kony.sync.isMaliciousType = function(val) {
    sync.log.trace("Entering kony.sync.isMaliciousType ");
    if (kony.sync.isValidNumberType(val) && isNaN(val)) {
        return "NaN";
    }
    if (val === Number.POSITIVE_INFINITY || val === Number.NEGATIVE_INFINITY) {
        return "infinity";
    }
    return false;
};
kony.sync.genMaliciousTypeCheck = function(obj, errorcallback) {
    sync.log.trace("Entering kony.sync.genMaliciousTypeCheck ");
    if (!kony.sync.enableORMValidations) {
        return false;
    }
    var errorMessage = null;
    var maliciousType = null;
    if (kony.string.equalsIgnoreCase(kony.type(obj), "object") || kony.string.equalsIgnoreCase(kony.type(obj), "table")) {
        for (var i in obj) {
            maliciousType = kony.sync.isMaliciousType(obj[i]);
            if (maliciousType !== false) {
                errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeMaliciousType, i, maliciousType);
                sync.log.error("Malicious object detected", kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                return true;
            } else {
                if (obj[i] === undefined) {
                    obj[i] = "null";
                }
            }
        }
    } else {
        maliciousType = kony.sync.isMaliciousType(obj);
        if (maliciousType !== false) {
            errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeMaliciousType, "", maliciousType);
            sync.log.error("Malicious object detected", kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
            return true;
        }
    }
    return false;
};
kony.sync.getBoolean = function(val) {
    sync.log.trace("Entering kony.sync.getBoolean ");
    if (kony.sync.isValidBooleanType(val)) {
        val = val + "";
        if (kony.string.equalsIgnoreCase(val, "true") || kony.string.equalsIgnoreCase(val, "1") || val === 1) {
            return true;
        } else {
            return false;
        }
    } else {
        return val;
    }
};
kony.sync.getString = function(val) {
    sync.log.trace("Entering kony.sync.getString ");
    if (kony.sync.isNull(val)) {
        return "";
    }
    return val.toString();
};
kony.sync.getUploadStatus = function(markForUpload) {
    sync.log.trace("Entering kony.sync.getUploadStatus ");
    if (markForUpload === false || markForUpload === "false") {
        return false;
    } else {
        return true;
    }
};
kony.sync.getDBName = function() {
    sync.log.trace("Entering kony.sync.getDBName ");
    var syncscopes = konysyncClientSyncConfig.ArrayOfSyncScope;
    if (syncscopes === null) {
        return null;
    }
    for (var i = 0; i < syncscopes.length; i++) {
        var scope = syncscopes[i];
        //This logic needs to be changed when we have separate DB for each scope
        if (scope[kony.sync.scopeDataSource] !== null) {
            return scope[kony.sync.scopeDataSource];
        }
    }
    return null;
};
kony.sync.mergeTable = function(toObj, frmObj) {
    sync.log.trace("Entering kony.sync.mergeTable ");
    if (!kony.sync.isValidJSTable(frmObj)) {
        return toObj;
    }
    if (!kony.sync.isValidJSTable(toObj)) {
        return frmObj;
    }
    for (var k in frmObj) {
        toObj[k] = frmObj[k];
    }
    return toObj;
};
kony.sync.pkNotFoundErrCallback = function(errorcallback, objName) {
    sync.log.trace("Entering kony.sync.pkNotFoundErrCallback ");
    sync.log.error("No data with specified primary key found in SyncObject " + objName + ".");
    errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeNoDataWithPrimaryKey, kony.sync.getErrorMessage(kony.sync.errorCodeNoDataWithPrimaryKey, objName)));
};
kony.sync.skyEventObserver = function(event, args, eventFinishCallback, errorcallback, isCascade) {
    sync.log.trace("Entering kony.sync.skyEventObserver ");
    if (event !== "START") {
        if (event === "ERROR") {
            if (!kony.sync.isNull(args)) {
                if (isCascade) {
                    sky.rollbackTransaction(kony.sky.skyEmptyFunction);
                }
                var errorCode = args.ERRORCODE;
                var errorMsg = args.ERRORDESC;
                kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(errorCode, errorMsg));
            }
        }
        if (event === "FINISH") {
            kony.sync.verifyAndCallClosure(eventFinishCallback, args);
        }
    }
};
kony.sync.removeCascadeHelper_old = function(tx, srcAttribute, targetAttribute, tbname, wcs, targetObjectRemoveCascade, targetObjectName, isCascade, errorcallback, markForUpload, pkRecord, isLocal) {
    sync.log.trace("Entering kony.sync.removeCascadeHelper_old ");
    var wcsCascade = null;
    if (pkRecord === null) {
        var sqlTarget = "select " + srcAttribute + " from " + tbname + wcs;
        var resultSet = kony.sync.executeSql(tx, sqlTarget, null);
        if (resultSet === false) {
            return false;
        }
        var num_records = resultSet.rows.length;
        if (num_records === 0) {
            return true;
        }
        if (isCascade) {
            sync.log.debug("No of Records to be deleted in " + targetObjectName + " for cascade delete=" + num_records);
        }
        for (var i = 0; i <= num_records - 1; i++) {
            var record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            wcsCascade = " where " + targetAttribute + " = '" + record[srcAttribute] + "'";
            if (targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal) === false) {
                return false;
            }
        }
    } else {
        wcsCascade = " where " + targetAttribute + " = '" + pkRecord[srcAttribute] + "'";
        return targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal);
    }
    return true;
};
kony.sync.removeCascadeHelper = function(tx, srcAttributes, targetAttributes, tbname, wcs, targetObjectRemoveCascade, targetObjectName, isCascade, errorcallback, markForUpload, pkRecord, isLocal) {
    sync.log.trace("Entering kony.sync.removeCascadeHelper ");
    var wcsCascade = null;
    if (pkRecord === null) {
        var sqlTarget = "select ";
        var sourceAttribute = "";
        for (var i = 0; i < srcAttributes.length; i++) {
            sourceAttribute = sourceAttribute + srcAttributes[i];
            if (i != srcAttributes.length - 1) {
                sourceAttribute = sourceAttribute + ","
            }
        };
        sqlTarget = sqlTarget + sourceAttribute + " from " + tbname + wcs;
        var resultSet = kony.sync.executeSql(tx, sqlTarget, null);
        if (resultSet === false) {
            return false;
        }
        var num_records = resultSet.rows.length;
        if (num_records === 0) {
            return true;
        }
        if (isCascade) {
            sync.log.debug("No of Records to be deleted in " + targetObjectName + " for cascade delete=" + num_records);
        }
        wcsCascade = " where ";
        for (var i = 0; i <= num_records - 1; i++) {
            var record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            var srcAttributesLen = srcAttributes.length;
            for (var j = 0; j < srcAttributesLen; ++j) {
                wcsCascade = wcsCascade + targetAttributes[j] + " = '" + record[srcAttributes[j]] + "'"
                if (j != srcAttributesLen - 1) {
                    wcsCascade = wcsCascade + " and "
                }
            }
            if (i != num_records - 1) {
                wcsCascade = wcsCascade + " or ";
            }
        }
        if (targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal) === false) {
            return false;
        }
    } else {
        wcsCascade = " where ";
        var srcAttributesLen = srcAttributes.length;
        for (var j = 0; j < srcAttributesLen; j++) {
            wcsCascade = wcsCascade + targetAttributes[j] + " = '" + pkRecord[srcAttributes[j]] + "'"
            if (j != srcAttributesLen - 1) {
                wcsCascade = wcsCascade + " and "
            }
        }
        return targetObjectRemoveCascade(tx, wcsCascade, errorcallback, markForUpload, isCascade, tbname, isLocal);
    }
    return true;
};
kony.sync.rollbackTransaction = function(tx) {
    sync.log.trace("Entering kony.sync.rollbackTransaction ");

    function dummyError() {
        sync.log.trace("Entering dummyError");
        //rollback the transaction
        return true;
    }
    //dummy statement
    kony.db.executeSql(tx, "dummy", null, dummyError);
};
//Wrapper for kony.db.executeSql
kony.sync.executeSql = function(tx, sql, params, errorCallback, rollback, opMsg) {
    // method to get table name from sql query
    function getObjectNameAndPKColName(sqlStmt) {
        var insertIgnoreCommand = "insert or ignore into";
        var deleteFromCommand = "delete from";
        var insertCommand = "insert into";
        var deleteCommand = "delete";
        var updateCommand = "update";
        var originalTable = "_original";
        var historyTable = "_history";
        var pkColumn = "";
        var tableName = "";
        var retVal = [];
        var words = sqlStmt.split(' ');
        if (sqlStmt.startsWith(insertIgnoreCommand)) {
            tableName = words[4];
        } else if (sqlStmt.startsWith(insertCommand) || sqlStmt.startsWith(deleteFromCommand)) {
            tableName = words[2];
        } else if (sqlStmt.startsWith(updateCommand)) {
            tableName = words[1];
            pkColumn = words[3];
        } else if (sqlStmt.startsWith(deleteCommand)) {
            tableName = words[1];
        }
        if (tableName.endsWith(originalTable)) {
            tableName = tableName.slice(0, tableName.lastIndexOf(originalTable));
        }
        retVal.push(tableName);
        retVal.push(pkColumn.replace(/\'/g, '').replace(/\"/g, '').replace(/=/g, '').replace(/\?/g, '').trim());
        return retVal;
    }
    // method to get reconciliation error if occured for update
    function getReconcilitaionError(sqlStatement, errorResult) {
        var sqlStmt = sqlStatement.toLowerCase().replace(/\s+/g, ' ').trim();
        if (sqlStmt.startsWith("update") && errorResult.message.toLowerCase().indexOf("unique constraint failed") >= 0) {
            var tabAndPk = getObjectNameAndPKColName(sqlStmt);
            return {
                "tableName": (tabAndPk[0]).toUpperCase(),
                "pkColumn": (tabAndPk[1]).toUpperCase(),
                "createdPK": params[1],
                "existingPK": params[0],
                "recievedPK": params[0],
            };
        } else {
            return null;
        }
    }
    sync.log.trace("Entering kony.sync.executeSql ");
    kony.sync.errorObject = null;
    if (!kony.sync.isNullOrUndefined(opMsg)) {
        sync.log.debug(opMsg);
    }
    sync.log.debug("SQL Query : ", sql);
    sync.log.debug("SQL Params : ", params);
    var result = kony.db.executeSql(tx, sql, params, localErrorCallback);
    if (result === null) {
        sync.log.error("Query execution failed: " + sql + " with params : ", params);
        return false;
    } else {
        sync.log.debug("Query execution success: " + sql + " with params : ", params);
        sync.log.debug("Result of query execution is: ", result);
        return result;
    }

    function localErrorCallback(tx, res) {
        var errorInfo = {};
        errorInfo[kony.sync.errorInfoTransactionID] = tx;
        errorInfo[kony.sync.errorInfoDatabaseError] = res;
        var recocileError = getReconcilitaionError(sql, res);
        if (recocileError) {
            errorInfo["duplicatePKError"] = recocileError;
            kony.sync.reconciliationErrorObject.push(recocileError);
        }
        sync.log.error("SQLite Error : ", res);
        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeSQLStatement, kony.sync.getErrorMessage(kony.sync.errorCodeSQLStatement), errorInfo);
        if (rollback === false) {
            return false;
        } else {
            return true;
        }
    }
};
kony.sync.callTransactionError = function(isError, errorcallback) {
    sync.log.trace("Entering kony.sync.callTransactionError ");
    kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getTransactionError(isError));
};
kony.sync.validateWhereClause = function(wcs) {
    sync.log.trace("Entering kony.sync.validateWhereClause ");
    if (!kony.sync.enableORMValidations) {
        return wcs;
    }
    if (kony.sync.isNull(wcs)) {
        return "";
    }
    wcs = kony.sync.getString(wcs);
    wcs = kony.string.trim(wcs);
    var twcs = kony.string.lower(wcs);
    if (twcs !== "") {
        // check if the where clause starts with a reserved keyword, else append "where" keyword
        if (!kony.sync.startsWithKeyword(twcs)) {
            wcs = " where " + wcs;
        }
    }
    return wcs;
};
//check whether the given data contains the key 
kony.sync.contains = function(data, key) {
    sync.log.trace("Entering kony.sync.contains ");
    //currently implementing for array only
    for (var i = 0; i < data.length; i++) {
        if (data[i] === key) {
            return true;
        }
    }
    return false;
};
kony.sync.createHash = function(hash, plaintext) {
    sync.log.trace("Entering kony.sync.createHash ");
    return kony.crypto.createHash(hash, plaintext);
};
kony.sync.getChunkDownloadURL = function() {
    sync.log.trace("Entering kony.sync.getChunkDownloadURL ");
    var server = kony.sync.getServerURL();
    return server + "downloadchunk";
};
kony.sync.getUploadBatchSize = function() {
    sync.log.trace("Entering kony.sync.getUploadBatchSize ");
    if (kony.sync.isValidNumberType(kony.sync.currentSyncConfigParams.uploadbatchsize)) {
        return kony.sync.tonumber(kony.sync.currentSyncConfigParams.uploadbatchsize);
    }
    return 50; //default batch size
};
kony.sync.isValidJSTable = function(inputTable) {
    if (kony.sync.isNullOrUndefined(inputTable)) {
        return false;
    }
    if (kony.type(inputTable) === "object" || kony.type(inputTable) === "Object" || kony.type(inputTable) === "Array" || kony.type(inputTable) === "array") {
        return true;
    } else {
        return false;
    }
};
kony.sync.deleteMapKey = function(map, key) {
    sync.log.trace("Entering kony.sync.deleteMapKey ");
    if (!kony.sync.isNull(map) && !kony.sync.isNull(key)) {
        delete map[key];
    }
};
kony.sync.getServerDetailsHostName = function(response) {
    sync.log.trace("Entering kony.sync.getServerDetailsHostName ");
    if (!kony.sync.isNullOrUndefined(response) && !kony.sync.isNullOrUndefined(response.d) && !kony.sync.isNullOrUndefined(response.d.server)) {
        return response.d.server.hostName;
    } else {
        return null;
    }
};
kony.sync.getServerDetailsIpAddress = function(response) {
    sync.log.trace("Entering kony.sync.getServerDetailsIpAddress ");
    if (!kony.sync.isNullOrUndefined(response) && !kony.sync.isNullOrUndefined(response.d) && !kony.sync.isNullOrUndefined(response.d.server)) {
        return response.d.server.ipAddress;
    } else {
        return null;
    }
};
kony.sync.addServerDetails = function(returnParams, serverResponse) {
    sync.log.trace("Entering kony.sync.addServerDetails ");
    if (!kony.sync.isNullOrUndefined(returnParams)) {
        returnParams[kony.sync.serverDetails] = {};
        returnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(serverResponse);
        returnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(serverResponse);
    }
};
//This function gets connection
kony.sync.getConnectionOnly = function(dbName, displayName, errorCallback, moduleName) {
    sync.log.trace("Entering kony.sync.getConnectionOnly ");
    var estimatedDBSize = 5 * 1024 * 1024;
    var connection = null;
    var version = "1.0";
    var exceptionObject = null;

    function makeEncryptedConnection() {
        sync.log.trace("Entering makeEncryptedConnection");
        if (kony.sync.deviceDBEncryptionKey === null) {
            connection = kony.db.openDatabaseSync(dbName, version, displayName, estimatedDBSize);
        } else {
            sync.log.info("Opening encrypted connection", kony.sync.deviceDBEncryptionKey);
            connection = kony.db.openDatabaseSync(dbName, version, displayName, estimatedDBSize, kony.sync.deviceDBEncryptionKey);
        }
    }
    try {
        makeEncryptedConnection();
    } catch (e) {
        connection = null;
        exceptionObject = e;
    }
    if (connection === null) {
        if (kony.sync.isNullOrUndefined(moduleName)) {
            moduleName = "";
        } else {
            moduleName += ": ";
        }
        sync.log.fatal(moduleName + "Error in getting connection");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.getErrorTable(kony.sync.errorCodeDbConnection, kony.sync.getErrorMessage(kony.sync.errorCodeDbConnection), exceptionObject));
    }
    return connection;
};
kony.sync.createDBEncryptionKey = function(passPhrase) {
    sync.log.trace("Entering kony.sync.createDBEncryptionKey ");
    if (kony.sync.deviceDBEncryptionKey === null && passPhrase !== null && passPhrase !== undefined && !kony.sync.isEmptyString(passPhrase)) {
        kony.sync.deviceDBEncryptionKey = passPhrase;
    }
};
kony.sync.isValidFunctionType = function(closure) {
    sync.log.trace("Entering kony.sync.isValidFunctionType ");
    return kony.type(closure) === "function";
};
kony.sync.getTransactionError = function(isError) {
    sync.log.trace("Entering kony.sync.getTransactionError ");
    if (!isError) {
        sync.log.error("Transaction error occurred : ", kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        return kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null);
    } else {
        sync.log.error("Statement error occurred : ", kony.sync.errorObject);
        return kony.sync.errorObject;
    }
};
kony.sync.isNullOrUndefined = function(val) {
    if (val === null || val === undefined) {
        return true;
    } else {
        return false;
    }
};
kony.sync.formOrderByClause = function(tablename, map) {
    sync.log.trace("Entering kony.sync.formOrderByClause function");
    if (map !== null && map !== undefined) {
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var columns = scope.syncTableDic[tablename].ColumnsDic;
        for (var k = 0; k < map.length; k++) {
            var v = map[k];
            if (!kony.sync.isValidJSTable(v)) {
                sync.log.warn("Ignoring the orderby entry " + v + " as it is not a valid js object");
                delete map[k];
                continue;
            }
            if (kony.sync.isNull(columns[v.key])) {
                sync.log.warn("Ignoring the orderby entry " + v.key + " for the SyncObject " + tablename + ". " + v.key + " is not defined as an attribute in SyncConfiguration.");
                delete map[k];
            }
        }
        //var valuestable = kony.sync.convertOrderByMapToValuesTable(map);
        //return kony.sync.convertToValuesTableOrderByMap(map,valuestable);
        return map;
    }
};
//function to check if where clause starts with a SQLite reserved keyword
kony.sync.startsWithKeyword = function(wcs) {
    sync.log.trace("Entering kony.sync.startsWithKeyword ");
    var keywordTable = ["where ", "limit ", "group ", "order ", "join "];
    for (var i = 0; i < keywordTable.length; i++) {
        if (kony.string.startsWith(wcs, keywordTable[i])) {
            return true;
        }
    }
    return false;
};
kony.sync.getChannelName = function() {
    sync.log.trace("Entering kony.sync.getChannelName ");
    var returnVal = "";
    returnVal = "desktop";
    return returnVal;
};
kony.sync.getPlatformName = function() {
    sync.log.trace("Entering kony.sync.getPlatformName ");
    var returnVal = "";
    returnVal = "windows";
    return returnVal;
};
kony.sync.getRelationshipsForTable = function(tablename) {
    sync.log.trace("Entering kony.sync.getRelationshipsForTable for table " + tablename);
    var scopename = kony.sync.scopes.syncTableScopeDic[tablename];
    var scope = kony.sync.scopes[scopename];
    var relationShips = scope.syncTableDic[tablename].Relationships;
    return relationShips;
};
kony.sync.getChildRecords = function(tablename, valuesTable) {
    sync.log.trace("Entering kony.sync.getChildRecords for table " + tablename);
    var childRecords = [];
    var relationShips = kony.sync.getRelationshipsForTable(tablename);
    if (!kony.sync.isNullOrUndefined(relationShips) && relationShips.hasOwnProperty(kony.sync.oneToMany)) {
        //remove the child record from the values and add it to child records.
        for (var j = 0; j < relationShips[kony.sync.oneToMany].length; j++) {
            var childRecord = {};
            var relationshipTargetObject = relationShips[kony.sync.oneToMany][j][kony.sync.targetObject];
            //if there exists relationship target object, and values has child object which is not a null value.
            if (!kony.sync.isNullOrUndefined(relationshipTargetObject) && valuesTable.hasOwnProperty(relationshipTargetObject) && !kony.sync.isNullOrUndefined(valuesTable[relationshipTargetObject])) {
                childRecord[relationshipTargetObject] = valuesTable[relationshipTargetObject];
                childRecords.push(childRecord);
                delete valuesTable[relationshipTargetObject];
            }
        }
    }
    return childRecords;
};
kony.sync.getParentRelationshipAttributes = function(childTable, parentTable) {
    sync.log.trace("Enterting kony.sync.getParentRelationshipAttributes for child " + childTable + " and parent " + parentTable);
    if (childTable && parentTable) {
        var scopename = kony.sync.scopes.syncTableScopeDic[childTable];
        var scope = kony.sync.scopes[scopename];
        var relationShipMap = scope.syncTableDic[parentTable + kony.sync.parentRelationshipMap];
        //if there exists relationship and there are relationship attributes, return them. else return null
        if (!kony.sync.isNullOrUndefined(relationShipMap) && relationShipMap.hasOwnProperty(childTable)) {
            return relationShipMap[childTable];
        }
    }
    return null;
};
kony.sync.getPkTableFromJSON = function(valuesTable, tableName) {
    sync.log.trace("Entering kony.sync.getPkTableFromJSON for valuesTbale " + JSON.stringify(valuesTable) + " and table " + tableName);
    var pkTable = {};
    if (valuesTable && tableName) {
        var scopename = kony.sync.scopes.syncTableScopeDic[tableName];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tableName].Pk_Columns;
        for (var pkCount = 0; pkCount < pkColumns.length; pkCount++) {
            if (valuesTable.hasOwnProperty(pkColumns[pkCount])) {
                pkTable[pkColumns[pkCount]] = valuesTable[pkColumns[pkCount]];
                delete valuesTable[pkColumns[pkCount]];
            } else {
                //pkColumn field not found. error.
                sync.log.error("pkcolumn field " + pkColumns[pkCount] + " not found in " + JSON.stringify(valuesTable));
                return false;
            }
        }
    }
    return pkTable;
};
kony.sync.queryTable = function(tx, tablename, selectClause, whereClause, limitOffset) {
    sync.log.trace("Entering kony.sync.queryTable for table " + tablename + " and select clause " + JSON.stringify(selectClause) + " with where clause " + JSON.stringify(whereClause));
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, selectClause);
    kony.sync.qb_from(query, tablename);
    kony.sync.qb_where(query, whereClause);
    if (!kony.sync.isNullOrUndefined(limitOffset)) {
        kony.sync.qb_limitOffset(query, limitOffset, kony.sync.blobManager.ONDEMAND_FETCH_OFFSET);
    }
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.trace("Executing query ", query, " with params ", JSON.stringify(params));
    var result_set = kony.sync.executeSql(tx, sql, params);
    return result_set;
};
kony.sync.isEmpty = function(obj) {
    sync.log.trace("Entering kony.sync.isEmpty ");
    // null and undefined are "empty"
    if (obj == null) return true;
    // Assume if it has a length property with a non-zero value
    // that that property is correct.
    if (obj.length > 0) return false;
    if (obj.length === 0) return true;
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) return false;
    }
    return true;
};
kony.sync.getSyncTracking = function(options) {
    sync.log.trace("Entering kony.sync.getSyncTracking ");
    var synctracking = true;
    if (!kony.sync.isNullOrUndefined(options) && (typeof(options) == "object")) {
        if (!kony.sync.isNullOrUndefined(options[kony.sync.tracking])) {
            synctracking = options[kony.sync.tracking]
        }
    }
    return synctracking;
}
kony.sync.getInsertNullForFieldsMissingInPayload = function() {
        sync.log.trace("Entering kony.sync.getInsertNullForFieldsMissingInPayload ");
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.insertNullForFieldsMissingInPayload) && (typeof(kony.sync.currentSyncConfigParams.insertNullForFieldsMissingInPayload) === "boolean")) {
            return kony.sync.currentSyncConfigParams.insertNullForFieldsMissingInPayload;
        }
        //by default, null values should be inserted
        return true;
    }
    //  **************** End KonySyncHelper.js*******************
    //  **************** Start KonySyncInit.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
//Initializes the DB with Generated Scope
sync.init = function(on_sync_init_success, on_sync_init_error) {
    sync.log.trace("Entering sync.init ");
    if (kony.sync.isValidJSTable(on_sync_init_success) === true) {
        //new style, user called as sync.init(config)
        //upload binary listener..
        if (!kony.sync.isNullOrUndefined(on_sync_init_success[kony.sync.onBinaryUploadFunction]) && kony.sync.isValidFunctionType(on_sync_init_success[kony.sync.onBinaryUploadFunction])) {
            sync.log.trace("sync.init - registering upload binary listener..");
            kony.sync.onBinaryUpload = on_sync_init_success[kony.sync.onBinaryUploadFunction];
        }
        //download binary listener.
        if (!kony.sync.isNullOrUndefined(on_sync_init_success[kony.sync.onBinaryDownloadFunction]) && kony.sync.isValidFunctionType(on_sync_init_success[kony.sync.onBinaryDownloadFunction])) {
            sync.log.trace("sync.init - registering download binary listener..");
            kony.sync.onBinaryDownload = on_sync_init_success[kony.sync.onBinaryDownloadFunction];
        }
        on_sync_init_error = on_sync_init_success[kony.sync.onSyncInitErrorParam];
        kony.sync.createDBEncryptionKey(on_sync_init_success[kony.sync.deviceDBEncryptionKeyParam]);
        on_sync_init_success = on_sync_init_success[kony.sync.onSyncInitSuccessParam];
    }
    // Create the database from xml. It also contains the provisioning commands
    var syncscopes = konysyncClientSyncConfig.ArrayOfSyncScope;
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    var isError = false;
    var dbExists = false;

    function loadDatabase() {
        sync.log.trace("Entering loadDatabase");
        var createDB = false;
        syncscopes.syncTableScopeDic = {};
        syncscopes.syncScopeBlobInfoMap = {};
        syncscopes.syncToDeviceMap = {};
        syncscopes.syncScopeRelationAttributesMap = {};
        var currentscope = null;
        var currenttemptable = null;
        sync.log.info("loading DB");

        function dbValidationCompleted() {
            sync.log.trace("Entering dbValidationCompleted");
            loadSyncScope(0);
        }

        function loadDatabaseTransaction(tx) {
            sync.log.trace("Entering loadDatabaseTransaction");
            // this is to be uncommented when we have db for each scope
            //for i, ddl in ipairs ( DDLCommands[currentscope[kony.sync.scopeName]] ) do 
            var DDLCommands = null;
            if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
                DDLCommands = konysyncSQLCEDDLCommands;
            } else {
                DDLCommands = konysyncSQLLiteDDLCommands;
            }
            if (!kony.sync.isNullOrUndefined(DDLCommands)) {
                for (var i = 0; i < DDLCommands.length; i++) {
                    var ddl = DDLCommands[i];
                    sync.log.debug("ddl :" + ddl);
                    if (kony.sync.executeSql(tx, ddl) === false) {
                        isError = true;
                        return;
                    }
                }
            }
            if (kony.sync.initializeScopeSettings(tx) === false) {
                isError = true;
                return;
            }
            if (kony.sync.setPragmaSize(tx) === false) {
                isError = true;
                return;
            }
        }

        function dbexistsErrorCallback() {
            sync.log.trace("Entering dbexistsErrorCallback");
            //Create DB
            createDB = true;
            sync.log.info("creating DB");
            var conn = kony.sync.getConnectionOnly(currentscope[kony.sync.scopeDataSource], currentscope[kony.sync.scopeDataSource], on_sync_init_error);
            if (conn !== null) {
                kony.sync.startTransaction(conn, loadDatabaseTransaction, dbValidationCompleted, initTransactionError);
            }
        }

        function dbexistsSuccessCallback() {
            sync.log.trace("Entering dbexistsSuccessCallback");
            loadSyncScope(0);
        }
        //for a given table getting the reverseRelationships information
        //for a child table getting the  relationship data from a parent where child is targetobject
        function getParentRelationships(currentscope, synctable) {
            sync.log.trace("Entering getParentRelationships");
            parentRelationshipMap = {};
            scopeTables = currentscope.ScopeTables;
            if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
                tables_length = scopeTables.length;
                for (var i = 0; i < tables_length; i++) {
                    var currentTable = scopeTables[i];
                    var RelationshipAttributes = [];
                    if (!kony.sync.isNullOrUndefined(currentTable.Relationships.OneToMany)) {
                        relationships_OneToMany = currentTable.Relationships.OneToMany;
                        OneToMany_length = relationships_OneToMany.length;
                        for (var j = 0; j < OneToMany_length; j++) {
                            //var attributeMap = {};
                            currentRelationShip = relationships_OneToMany[j];
                            if (currentRelationShip.TargetObject === synctable.Name) {
                                relationshipAttributes = currentRelationShip.RelationshipAttributes;
                                relationshipAttributes_length = relationshipAttributes.length;
                                for (var k = 0; k < relationshipAttributes_length; k++) {
                                    attributes = {}
                                    attributes["ParentObject_Attribute"] = relationshipAttributes[k].SourceObject_Attribute;
                                    attributes["ChildObject_Attribute"] = relationshipAttributes[k].TargetObject_Attribute;
                                    RelationshipAttributes.push(attributes)
                                }
                            }
                        }
                    }
                    if (RelationshipAttributes.length != 0) {
                        parentRelationshipMap[currentTable.Name] = RelationshipAttributes;
                    }
                }
            }
            return parentRelationshipMap;
        }
        var j = 0;
        kony.sync.scopeDict = {};
        if (!kony.sync.isNullOrUndefined(syncscopes)) {
            for (var i = 0; i < syncscopes.length; i++) {
                var scope = syncscopes[i];
                kony.sync.scopeDict[syncscopes[i].ScopeName] = scope;
                currentscope = scope;
                syncscopes[i] = scope;
                scope.Index = i;
                scope.syncTableDic = {};
                scope.reverseRelationships = {};
                // create helper dictionaries
                if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
                    for (var k = 0; k < scope.ScopeTables.length; k++) {
                        var syncTable = scope.ScopeTables[k];
                        scope.syncTableDic[syncTable.Name] = syncTable;
                        scope.syncTableDic[syncTable.Name + kony.sync.historyTableName] = syncTable;
                        scope.syncTableDic[syncTable.Name + kony.sync.parentRelationshipMap] = getParentRelationships(scope, syncTable);
                        //reverse relationship mapping
                        if (!kony.sync.isNullOrUndefined(syncTable.Relationships.ManyToOne)) {
                            for (j = 0; j < syncTable.Relationships.ManyToOne.length; j++) {
                                var rTable = syncTable.Relationships.ManyToOne[j].TargetObject;
                                if (kony.sync.isNullOrUndefined(scope.reverseRelationships[rTable])) {
                                    scope.reverseRelationships[rTable] = [];
                                }
                                if (!kony.sync.isNullOrUndefined(syncTable.Relationships.ManyToOne[j].RelationshipAttributes)) {
                                    var relationshipAttributes = syncTable.Relationships.ManyToOne[j].RelationshipAttributes;
                                    var attributeMap = {};
                                    attributeMap.RelationshipAttributes = [];
                                    attributeMap.TargetObject = syncTable.Name;
                                    for (var iter = 0; iter < relationshipAttributes.length; iter++) {
                                        var attributes = {};
                                        attributes["SourceObject_Attribute"] = relationshipAttributes[iter].TargetObject_Attribute;
                                        attributes["TargetObject_Attribute"] = relationshipAttributes[iter].SourceObject_Attribute;
                                        attributeMap.RelationshipAttributes.push(attributes);
                                    };
                                    scope.reverseRelationships[rTable].push(attributeMap);
                                } else {
                                    var cascade = false;
                                    if (!kony.sync.isNullOrUndefined(syncTable.Relationships.ManyToOne[j].Cascade)) cascade = syncTable.Relationships.ManyToOne[j].Cascade;
                                    scope.reverseRelationships[rTable].push({
                                        SourceObject_Attribute: syncTable.Relationships.ManyToOne[j].TargetObject_Attribute,
                                        TargetObject: syncTable.Name,
                                        TargetObject_Attribute: syncTable.Relationships.ManyToOne[j].SourceObject_Attribute,
                                        Cascade: cascade
                                    });
                                }
                            }
                        }
                        syncscopes.syncTableScopeDic[syncTable.Name] = scope.ScopeName;
                        syncscopes.syncTableScopeDic[syncTable.Name + kony.sync.historyTableName] = scope.ScopeName;
                        syncTable.ColumnsDic = {};
                        if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                            for (j = 0; j < syncTable.Columns.length; j++) {
                                var syncColumn = syncTable.Columns[j];
                                syncTable.ColumnsDic[syncColumn.Name] = syncColumn;
                                if (syncColumn.type === kony.sync.blob) {
                                    if (kony.sync.isNullOrUndefined(syncscopes.syncScopeBlobInfoMap[syncTable.Name])) {
                                        syncscopes.syncScopeBlobInfoMap[syncTable.Name] = {};
                                        syncscopes.syncScopeBlobInfoMap[syncTable.Name][kony.sync.columns] = [];
                                    }
                                    syncscopes.syncScopeBlobInfoMap[syncTable.Name][kony.sync.columns].push(syncColumn.Name);
                                    //in case of ifrecordvalue type, map the synctodevicefield.
                                    if (syncColumn.hasOwnProperty(kony.sync.binaryPolicy) && syncColumn[kony.sync.binaryPolicy] === kony.sync.ifRecordValue) {
                                        syncscopes.syncToDeviceMap[syncTable.Name + syncColumn.Name] = syncColumn[kony.sync.syncToDeviceField];
                                    }
                                }
                            }
                        }
                        currenttemptable = syncTable.Name;
                    }
                }
                //Note This change will be undone once we have 1 DB for each scope.
                sync.log.info("*************" + "\n", scope);
                sync.log.info("\n" + "*************");
            }
        }
        kony.sync.scopes = syncscopes;
        kony.sync.scopes.scopecount = syncscopes.length;
        /*removing check for existence of 1st table as 1st table may change for dynamic schema changes
		kony.sync.single_execute_sql(currentscope[kony.sync.scopeDataSource], sqlcheckfordb + " LIMIT 1", null, dbexistsSuccessCallback, dbexistsErrorCallback);*/
        if (dbExists) {
            dbexistsSuccessCallback();
        } else {
            dbexistsErrorCallback();
        }
    }
    //Check If DB is created or not		
    function loadSyncScope(scopeindex) {
        sync.log.trace("Entering loadSyncScope");
        var addmetainfo = false;
        var scope = kony.sync.scopes[scopeindex];
        //Add scopes to MetaInfo table if not created and Initialize kony.sync.currentSyncScopesState table.	
        function loadSyncScopeTransaction(tx) {
            sync.log.trace("Entering loadSyncScopeTransaction");
            var query = null;
            var query_compile = null;
            var sql = null;
            var params = null;
            // check whether scope exists in metainfo after schema upgrade
            sql = "select * from " + kony.sync.metaTableName + " where scopename = '" + scope.ScopeName + "'";
            var resultSet = kony.sync.executeSql(tx, sql, null);
            if (resultSet === false) {
                isError = true;
                return;
            }
            if (resultSet.rows.length === 0) {
                //the scope does not exist in the metainfo table and so has to be added
                addmetainfo = true;
            }
            if (addmetainfo) {
                //Querying the database for last inserted index
                sql = "select max(id) as 'max' from " + kony.sync.metaTableName;
                var resultSet = kony.sync.executeSql(tx, sql, null);
                var metaIndex = 0;
                if (resultSet !== false) {
                    if (resultSet.rows.length > 0) {
                        var rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
                        if (!kony.sync.isNullOrUndefined(rowItem["max"])) {
                            metaIndex = rowItem["max"] + 1;
                        } else {
                            metaIndex = 0;
                        }
                    }
                }
                query = kony.sync.qb_createQuery();
                kony.sync.qb_set(query, {
                    id: "" + metaIndex,
                    filtervalue: "no filter",
                    scopename: scope.ScopeName,
                    versionnumber: 0,
                    lastserversynccontext: "",
                    lastserveruploadsynccontext: "",
                    replaysequencenumber: 0,
                    lastgeneratedid: -1
                });
                kony.sync.qb_insert(query, kony.sync.metaTableName);
                //local sql = "insert into "..kony.sync.metaTableName.." (id,scopename,versionnumber,lastserversynccontext,replaysequencenumber,lastgeneratedid) values ('"..id.."','"..scope.ScopeName.."','0','','0','-1')"
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                if (kony.sync.executeSql(tx, sql, params) === false) {
                    isError = true;
                }
                kony.sync.currentSyncScopesState[scope.ScopeName] = 0;
            } else {
                query = kony.sync.qb_createQuery();
                kony.sync.qb_select(query, [kony.sync.metaTableSyncVersionCloumn]);
                kony.sync.qb_from(query, kony.sync.metaTableName);
                kony.sync.qb_where(query, [{
                    key: kony.sync.metaTableScopeColumn,
                    value: scope.ScopeName
                }]);
                //local sql = "select "..kony.sync.metaTableSyncVersionCloumn.." from "..kony.sync.metaTableName.." where "..kony.sync.metaTableScopeColumn.."='"..scope.ScopeName.."'";
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                var resultset = kony.sync.executeSql(tx, sql, params);
                if (resultset !== false && resultset.rows.length > 0) {
                    var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                    if (!kony.sync.isNullOrUndefined(rowItem[kony.sync.metaTableSyncVersionCloumn])) {
                        kony.sync.currentSyncScopesState[scope.ScopeName] = rowItem[kony.sync.metaTableSyncVersionCloumn];
                    } else {
                        kony.sync.isResetInProgress = false;
                        isError = true;
                    }
                } else {
                    kony.sync.isResetInProgress = false;
                    isError = true;
                }
            }
            //Check for Sync Version 5.5.6
            if (kony.sync.checkForUpdate556to559Schema(tx) === false) {
                isError = true;
            }
            //Check for Sync Version 5.5.9
            if (kony.sync.checkForUpdate559to560Schema(tx) === false) {
                isError = true;
            }
            //Check for Sync Version 6.x
            if (kony.sync.checkForUpdate6xto70Schema(tx) === false) {
                isError = true;
            }
        }

        function loadSyncScopeSuccess() {
            sync.log.trace("Entering loadSyncScopeSuccess");
            //schema changed
            if (kony.sync.configVersion !== konysyncClientSyncConfig.Version) {
                kony.sync.schemaUpgradeNeeded = true;
                //kony.sync.verifyAndCallClosure(on_sync_init_error, kony.sync.getSchemaUpgradeNeededError());
                //return;
            }
            if (isError === true) {
                kony.sync.verifyAndCallClosure(on_sync_init_error, kony.sync.getScopeLoadingFailed());
            }
            if (scopeindex !== kony.sync.scopes.length - 1) {
                loadSyncScope(scopeindex + 1);
            } else {
                checkForStaleScope(checkForStaleScopeCallback);
            }
        }

        function checkForStaleScopeCallback() {
            sync.log.trace("Entering checkForStaleScopeCallback");
            kony.sync.isResetInProgress = false;
            //before initializing the thread, perform a clean up job to remove stale records.
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined" && !kony.sync.isCleanUpJobCompleted) {
                sync.log.trace("checkForStaleScopeCallback -> Initializing binary stats");
                kony.sync.initBinaryStats();
                sync.log.trace("checkForStaleScopeCallback -> trigger clean up job.");
                kony.sync.blobManager.performCleanUp(function(isError) {
                    sync.log.trace("performCleanUp callback isError " + isError);
                    if (!isError) {
                        syncInitComplete();
                    } else {
                        //error occurred in performCleanup.
                        kony.sync.verifyAndCallClosure(on_sync_init_error, kony.sync.errorObject);
                        kony.sync.errorObject = null;
                    }
                });
            } else {
                sync.log.trace("checkForStaleScopeCallback -> Do not trigger clean up job.");
                syncInitComplete();
            }
        }

        function syncInitComplete() {
            sync.log.trace("syncInitComplete...");
            kony.sync.syncInitialized = true;
            //init the onDemand polling thread
            if (typeof(binary) !== "undefined" && typeof(binary.util) !== "undefined") {
                binary.util.binaryThreadInit(kony.sync.blobManager.prepareJobs, kony.sync.blobManager.getPreparedJobs, kony.sync.blobManager.onDemandUniversalSuccessCallback, kony.sync.blobManager.onDemandUniversalErrorCallback);
                binary.util.createBlobsDir();
            }
            //init the binaryNotifier map
            kony.sync.blobManager.binaryNotifierMap = {};
            kony.sync.verifyAndCallClosure(on_sync_init_success);
        }

        function checkForStaleScope(callback) {
            sync.log.trace("Entering checkForStaleScope");
            var connection = kony.sync.getConnectionOnly(kony.sync.scopes[0][kony.sync.scopeDataSource], kony.sync.scopes[0][kony.sync.scopeDataSource], on_sync_init_error);
            if (connection !== null) {
                kony.sync.startTransaction(connection, transactionCallback, transactionSuccessCallback, initTransactionError);
            }

            function transactionCallback(tx) {
                sync.log.trace("Entering transactionCallback");
                //Create ScopeMap
                var scopeNames = "";
                for (var i = 0; i < kony.sync.scopes.length; i++) {
                    if (i !== 0) {
                        scopeNames += ",";
                    }
                    scopeNames += "'" + kony.sync.scopes[i].ScopeName + "'";
                }
                var sql = "delete from " + kony.sync.metaTableName + " where " + kony.sync.metaTableScopeColumn + " not in (" + scopeNames + ")";
                if (kony.sync.executeSql(tx, sql, null) === false) {
                    isError = true;
                }
            }

            function transactionSuccessCallback() {
                sync.log.trace("Entering transactionSuccessCallback");
                callback();
            }
        }
        var scopename = scope.ScopeName;
        syncscopes[scopename] = scope;
        var connection = kony.sync.getConnectionOnly(scope[kony.sync.scopeDataSource], scope[kony.sync.scopeDataSource], on_sync_init_error);
        if (connection !== null) {
            kony.sync.startTransaction(connection, loadSyncScopeTransaction, loadSyncScopeSuccess, initTransactionError);
        }
    }

    function generateClientDeviceID() {
        sync.log.trace("Entering generateClientDeviceID");

        function createTable() {
            sync.log.trace("Entering createTable");
            var sqltable = "create table " + kony.sync.syncConfigurationTableName + " (" + kony.sync.syncConfigurationColumnDeviceIDName + " nvarchar(4000)," + kony.sync.syncConfigurationColumnInstanceIDName + " nvarchar(4000)," + kony.sync.syncConfigurationColumnVersion + " nvarchar(4000)," + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " nvarchar(4000))";
            kony.sync.single_execute_sql(kony.sync.syncConfigurationDBName, sqltable, null, createDeviceID, on_sync_init_error);
        }

        function createDeviceID() {
            sync.log.trace("Entering createDeviceID");
            kony.sync.deviceId = "";
            kony.sync.instanceId = "";
            var settable = {};
            settable[kony.sync.syncConfigurationColumnDeviceIDName] = kony.sync.deviceId;
            settable[kony.sync.syncConfigurationColumnInstanceIDName] = kony.sync.instanceId;
            kony.sync.configVersion = konysyncClientSyncConfig.Version;
            settable[kony.sync.syncConfigurationColumnVersion] = kony.sync.configVersion;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, settable);
            kony.sync.qb_insert(query, kony.sync.syncConfigurationTableName);
            var query_compile = kony.sync.qb_compile(query);
            var sqlinsert = query_compile[0];
            var params = query_compile[1];
            kony.sync.single_execute_sql(kony.sync.syncConfigurationDBName, sqlinsert, params, loadDatabase, on_sync_init_error);
        }

        function setDeviceID(configRow) {
            sync.log.trace("Entering setDeviceID");
            dbExists = true;
            sync.log.trace("Entering setDeviceID");
            kony.sync.deviceId = configRow[kony.sync.syncConfigurationColumnDeviceIDName];
            kony.sync.instanceId = configRow[kony.sync.syncConfigurationColumnInstanceIDName];
            kony.sync.configVersion = configRow[kony.sync.syncConfigurationColumnVersion];
            loadDatabase();
        }
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.syncConfigurationTableName);
        kony.sync.single_execute_sql(kony.sync.syncConfigurationDBName, "select * from " + kony.sync.syncConfigurationTableName + " LIMIT 1", null, setDeviceID, createTable);
    }

    function initTransactionError() {
        sync.log.trace("Entering initTransactionError");
        kony.sync.callTransactionError(isError, on_sync_init_error);
    }
    generateClientDeviceID();
};
sync.reset = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.reset ");
    if (kony.sync.isResetInProgress) {
        sync.log.warn("Reset already in progress...");
        return;
    }
    if (kony.sync.isValidJSTable(successcallback) === true) {
        //new style, user called as sync.reset(config)
        errorcallback = successcallback[kony.sync.onSyncResetErrorParam];
        kony.sync.createDBEncryptionKey(successcallback[kony.sync.deviceDBEncryptionKeyParam]);
        successcallback = successcallback[kony.sync.onSyncResetSuccessParam];
    }
    kony.sync.isResetInProgress = true;
    kony.sync.schemaUpgradeNeeded = false;
    kony.sync.syncConfigurationDBName = konysyncClientSyncConfig.AppID;
    if (typeof(binarydata) !== "undefined") {
        sync.log.trace("sync.reset -> Reseting BinaryDataManager");
        binarydata.clearBinaryDataManagerState();
    }
    var dbList = [];
    kony.table.insert(dbList, {
        dbname: kony.sync.syncConfigurationDBName,
        tableList: [kony.sync.syncConfigurationTableName, kony.sync.chunkMetaTableName, kony.sync.chunkTableName, kony.sync.metaTableName, kony.sync.pendingUploadTableName, "konysyncDIAGNOSTICS", "konysyncBLOBSTOREMANAGER"]
    });
    if (konysyncClientSyncConfig.ArrayOfSyncScope !== null && konysyncClientSyncConfig.ArrayOfSyncScope !== undefined) {
        for (var i = 0; i < konysyncClientSyncConfig.ArrayOfSyncScope.length; i++) {
            var v = konysyncClientSyncConfig.ArrayOfSyncScope[i];
            var tab = [];
            for (var k = 0; k < v.ScopeTables.length; k++) {
                var w = v.ScopeTables[k];
                kony.table.insert(tab, w.Name);
                kony.table.insert(tab, w.Name + kony.sync.historyTableName);
                kony.table.insert(tab, w.Name + kony.sync.originalTableName);
            }
            /*if ((i === 1)) {
            	kony.table.insert(tab, kony.sync.metaTableName);
            	kony.table.insert(tab, "konysyncDIAGNOSTICS");
            }*/
            kony.table.insert(dbList, {
                dbname: v.ScopeDatabaseName,
                tableList: tab
            });
        }
    }
    kony.sync.syncDropDatabase(dbList, successcallback, errorcallback);
};
sync.rollbackPendingLocalChanges = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.rollbackPendingLocalChanges ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.rollbackCurrentScope = null;
    kony.sync.konySyncRollBackPendingChanges(null, null, null, successcallback, errorcallback, true, 0);
};
sync.getPendingAcknowledgement = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.getPendingAcknowledgement ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.pendingAckIndex = 0;
    kony.sync.pendingAckResult = {};
    var currentScope = kony.sync.scopes[0];
    var dbname = currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    kony.sync.pendingAckCount = 0;
    var isError = false;

    function konysyncPendingAck_transaction(tx) {
        sync.log.trace("Entering konysyncPendingAck_transaction");

        function single_transaction_callback_local(sql, params, tbname) {
            sync.log.trace("Entering single_transaction_callback_local");
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return false;
            }
            var tableData = [];
            var num_records = resultSet.rows.length;
            for (var j = 0; j <= num_records - 1; j++) {
                var record = kony.db.sqlResultsetRowItem(tx, resultSet, j);
                kony.table.insert(tableData, record);
            }
            if ((num_records > 0)) {
                kony.sync.pendingAckCount = kony.sync.pendingAckCount + num_records;
                //table.insert(kony.sync.pendingAckResult,tableData);
                kony.sync.pendingAckResult[tbname] = {};
                kony.sync.pendingAckResult[tbname].count = num_records;
                kony.sync.pendingAckResult[tbname].data = tableData;
            }
        }
        if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
            for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                var syncTable = currentScope.ScopeTables[i];
                var tbname = syncTable.Name;
                var currentversion = kony.sync.getCurrentVersionNumber(tbname);
                var sql = "select * from " + tbname + " WHERE " + kony.sync.mainTableChangeTypeColumn + " is not null AND " + kony.sync.mainTableChangeTypeColumn + " <> -1 AND " + kony.sync.mainTableSyncVersionColumn + " <> " + currentversion + " AND " + kony.sync.mainTableChangeTypeColumn + " NOT LIKE '9%'";
                if (single_transaction_callback_local(sql, null, tbname) === false) {
                    return;
                }
            }
        }
    }

    function konysyncPendingAck_transactionSucessCallback() {
        sync.log.trace("Entering konysyncPendingAck_transactionSucessCallback");
        sync.log.info("Get Pending Acknowledgement Count = ", kony.sync.pendingAckCount);
        sync.log.info("Get Pending Acknowledgement = ", kony.sync.pendingAckResult);
        if ((kony.sync.pendingAckIndex === kony.sync.scopes.scopecount - 1)) {
            var konysyncPendingAckDic = {};
            konysyncPendingAckDic.totalCount = kony.sync.pendingAckCount;
            konysyncPendingAckDic.totalData = kony.sync.pendingAckResult;
            kony.sync.verifyAndCallClosure(successcallback, konysyncPendingAckDic);
        } else {
            kony.sync.pendingAckIndex = kony.sync.pendingAckIndex + 1;
            currentScope = kony.sync.scopes[kony.sync.pendingAckIndex];
            dbname = currentScope[kony.sync.scopeDataSource];
            dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
            if (dbconnection !== null) {
                kony.sync.startTransaction(dbconnection, konysyncPendingAck_transaction, konysyncPendingAck_transactionSucessCallback, konysyncPendingAck_transactionErrorCallback, "Get Pending Acknowledgement");
            }
        }
    }

    function konysyncPendingAck_transactionErrorCallback() {
        sync.log.trace("Entering konysyncPendingAck_transactionErrorCallback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, konysyncPendingAck_transaction, konysyncPendingAck_transactionSucessCallback, konysyncPendingAck_transactionErrorCallback, "Get Pending Acknowledgement");
    }
};
sync.getPendingUpload = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.getPendingUpload ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.pendingUploadIndex = 0;
    kony.sync.pendingUploadResult = {};
    var currentScope = kony.sync.scopes[0];
    var dbname = currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    kony.sync.pendingUploadCount = 0;
    var isError = false;

    function konysyncPendingUpload_transaction(tx) {
        sync.log.trace("Entering konysyncPendingUpload_transaction");

        function single_transaction_callback_local(sql, params, tbname) {
            sync.log.trace("Entering single_transaction_callback_local");
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = false;
                return false;
            }
            var tableData = [];
            var num_records = resultSet.rows.length;
            for (var j = 0; j <= num_records - 1; j++) {
                var record = kony.db.sqlResultsetRowItem(tx, resultSet, j);
                kony.table.insert(tableData, record);
            }
            if ((num_records > 0)) {
                kony.sync.pendingUploadCount = kony.sync.pendingUploadCount + num_records;
                kony.sync.pendingUploadResult[tbname] = {};
                kony.sync.pendingUploadResult[tbname].count = num_records;
                kony.sync.pendingUploadResult[tbname].data = tableData;
            }
        }
        if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
            for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                var syncTable = currentScope.ScopeTables[i];
                var tbname = syncTable.Name;
                var columnsDic = currentScope.syncTableDic[tbname].Columns;
                var columns = "";
                for (var j = 0; j < columnsDic.length; j++) {
                    if (j == 0) {
                        columns = columns + columnsDic[j].Name;
                    } else {
                        columns = columns + ", " + columnsDic[j].Name;
                    }
                }
                var currentversion = kony.sync.getCurrentVersionNumber(tbname);
                var sql = "select " + columns + " from " + tbname + kony.sync.historyTableName + " WHERE " + kony.sync.mainTableChangeTypeColumn + " is not null AND " + kony.sync.mainTableChangeTypeColumn + " <> -1 AND " + kony.sync.mainTableSyncVersionColumn + " = " + currentversion + " AND " + kony.sync.mainTableChangeTypeColumn + " NOT LIKE '9%'";
                if (single_transaction_callback_local(sql, null, tbname) === false) {
                    return;
                }
            }
        }
    }

    function konysyncPendingUpload_transactionSucessCallback() {
        sync.log.trace("Entering konysyncPendingUpload_transactionSucessCallback");
        sync.log.info("Pending Uploads Count = ", kony.sync.pendingUploadCount);
        sync.log.info("Pending Uploads = ", kony.sync.pendingUploadResult);
        if ((kony.sync.pendingUploadIndex === kony.sync.scopes.scopecount - 1)) {
            var konysyncPendingUploadDic = {};
            konysyncPendingUploadDic.totalCount = kony.sync.pendingUploadCount;
            konysyncPendingUploadDic.totalData = kony.sync.pendingUploadResult;
            kony.sync.verifyAndCallClosure(successcallback, konysyncPendingUploadDic);
        } else {
            kony.sync.pendingUploadIndex = kony.sync.pendingUploadIndex + 1;
            currentScope = kony.sync.scopes[kony.sync.pendingUploadIndex];
            dbname = currentScope[kony.sync.scopeDataSource];
            dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
            if (dbconnection !== null) {
                kony.sync.startTransaction(dbconnection, konysyncPendingUpload_transaction, konysyncPendingUpload_transactionSucessCallback, transactionErrorCallback, "Get Pending Upload");
            }
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, konysyncPendingUpload_transaction, konysyncPendingUpload_transactionSucessCallback, transactionErrorCallback, "Get Pending Upload");
    }
};
sync.getDeferredUpload = function(successcallback, errorcallback) {
    sync.log.trace("Entering sync.getDeferredUpload ");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    kony.sync.deferredUploadIndex = 0;
    kony.sync.deferredUploadResult = {};
    var currentScope = kony.sync.scopes[0];
    var dbname = currentScope[kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    kony.sync.deferredUploadCount = 0;
    var isError = false;

    function konysyncDeferredUpload_transaction(tx) {
        sync.log.trace("Entering konysyncDeferredUpload_transaction");

        function single_transaction_callback_local(sql, params, tbname) {
            sync.log.trace("Entering single_transaction_callback_local");
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return false;
            }
            var tableData = [];
            var num_records = resultSet.rows.length;
            for (var j = 0; j <= num_records - 1; j++) {
                var record = kony.db.sqlResultsetRowItem(tx, resultSet, j);
                kony.table.insert(tableData, record);
            }
            if ((num_records > 0)) {
                kony.sync.deferredUploadCount = kony.sync.deferredUploadCount + num_records;
                kony.sync.deferredUploadResult[tbname] = {};
                kony.sync.deferredUploadResult[tbname].count = num_records;
                kony.sync.deferredUploadResult[tbname].data = tableData;
            }
        }
        if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
            for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                var syncTable = currentScope.ScopeTables[i];
                var tbname = syncTable.Name;
                var sql = "select * from " + tbname + " WHERE " + kony.sync.mainTableChangeTypeColumn + " is not null AND " + kony.sync.mainTableChangeTypeColumn + " <> -1 AND " + kony.sync.mainTableChangeTypeColumn + " LIKE '9%'";
                if (single_transaction_callback_local(sql, null, tbname) === false) {
                    return;
                }
            }
        }
    }

    function konysyncDeferredUpload_transactionSucessCallback() {
        sync.log.trace("Entering konysyncDeferredUpload_transactionSucessCallback");
        sync.log.info("Deferred Uploads Count = ", kony.sync.deferredUploadCount);
        sync.log.info("Deferred Uploads = ", kony.sync.deferredUploadResult);
        if ((kony.sync.deferredUploadIndex === kony.sync.scopes.scopecount - 1)) {
            var konysyncDeferredUploadDic = {};
            konysyncDeferredUploadDic.totalCount = kony.sync.deferredUploadCount;
            konysyncDeferredUploadDic.totalData = kony.sync.deferredUploadResult;
            kony.sync.verifyAndCallClosure(successcallback, konysyncDeferredUploadDic);
        } else {
            kony.sync.deferredUploadIndex = kony.sync.deferredUploadIndex + 1;
            currentScope = kony.sync.scopes[kony.sync.deferredUploadIndex];
            dbname = currentScope[kony.sync.scopeDataSource];
            dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
            if (dbconnection !== null) {
                kony.sync.startTransaction(dbconnection, konysyncDeferredUpload_transaction, konysyncDeferredUpload_transactionSucessCallback, transactionErrorCallback, "Get Deferred Upload");
            }
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, konysyncDeferredUpload_transaction, konysyncDeferredUpload_transactionSucessCallback, transactionErrorCallback, "Get Deferred Upload");
    }
};
sync.getAllPendingUploadInstances = function(retrieveOnlyCount, successcallback, errorcallback) {
    sync.log.trace("Entering sync.getAllPendingUploadInstances");
    if (!kony.sync.isSyncInitialized(errorcallback)) {
        return;
    }
    var pendingUploadResult = {};
    pendingUploadResult.totalCount = 0;
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, pendingUploadTransaction, pendingUploadTransactionErrorCallback, pendingUploadTransactionSucessCallback);
    }
    var isError = false;

    function pendingUploadTransaction(tx) {
        sync.log.trace("Entering sync.getAllPendingUploadInstances->pendingUploadTransaction");
        for (var i = 0; i < kony.sync.scopes.length; i++) {
            var currentScope = kony.sync.scopes[i];
            var scopeName = currentScope[kony.sync.scopeName];
            pendingUploadResult[scopeName] = {};
            pendingUploadResult[scopeName].count = 0;
            /*get syncversion from metatable*/
            var syncversion = 0;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, [kony.sync.metaTableSyncVersionCloumn]);
            kony.sync.qb_from(query, kony.sync.metaTableName);
            kony.sync.qb_where(query, [{
                key: kony.sync.metaTableScopeColumn,
                value: scopeName
            }, {
                key: kony.sync.metaTableFilterValue,
                value: "no filter"
            }]);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultset = kony.sync.executeSql(tx, sql, params);
            if (resultset === false) {
                isError = true;
                return;
            }
            var row = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            syncversion = row[kony.sync.metaTableSyncVersionCloumn];
            for (var j = 0; !kony.sync.isNull(currentScope.ScopeTables) && j < currentScope.ScopeTables.length; j++) {
                var syncTable = currentScope.ScopeTables[j];
                //not using query builder to speedup time
                if (retrieveOnlyCount !== true) {
                    sql = "select * from  " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + syncversion;
                } else {
                    sql = "select count(*) from  " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + syncversion;
                }
                resultset = kony.sync.executeSql(tx, sql, null);
                if (resultset === false) {
                    isError = true;
                    return;
                }
                pendingUploadResult[scopeName][syncTable.Name] = {};
                if (retrieveOnlyCount !== true) {
                    pendingUploadResult[scopeName][syncTable.Name].count = resultset.rows.length;
                    pendingUploadResult[scopeName][syncTable.Name].data = [];
                    for (var k = 0; k < resultset.rows.length; k++) {
                        pendingUploadResult[scopeName][syncTable.Name].data[k] = kony.db.sqlResultsetRowItem(tx, resultset, k);
                    }
                } else {
                    var rowCount = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                    pendingUploadResult[scopeName][syncTable.Name].count = rowCount["count(*)"];
                }
                pendingUploadResult[scopeName].count += pendingUploadResult[scopeName][syncTable.Name].count;
                pendingUploadResult.totalCount += pendingUploadResult[scopeName][syncTable.Name].count;
            }
        }
    }

    function pendingUploadTransactionErrorCallback() {
        sync.log.trace("Entering sync.getAllPendingUploadInstances->pendingUploadTransactionErrorCallback");
        kony.sync.verifyAndCallClosure(errorcallback);
    }

    function pendingUploadTransactionSucessCallback() {
        sync.log.trace("Entering sync.getAllPendingUploadInstances->pendingUploadTransactionSucessCallback");
        sync.log.info("getAllPendingUploadInstances success", pendingUploadResult);
        kony.sync.verifyAndCallClosure(successcallback, pendingUploadResult);
    }
};
kony.sync.checkForUpdate556to559Schema = function(tx) {
    sync.log.trace("Entering kony.sync.checkForUpdate556to559Schema ");
    var sql = "select count(*) from " + kony.sync.chunkTableName;
    var resultSet = kony.sync.executeSql(tx, sql, null, null, false);
    if (resultSet === false) {
        //Alter scripts for 5.5.6 to 5.5.9 DB Update 
        kony.sync.DDL556to559Update = ["ALTER TABLE " + kony.sync.metaTableName + " ADD COLUMN " + kony.sync.metaTableUploadSyncTimeColumn + " nvarchar(1000)", "CREATE TABLE " + kony.sync.pendingUploadTableName + " (" + kony.sync.metaTableScopeColumn + " nvarchar(100) not null," + kony.sync.pendingUploadTableUploadRequest + " text," + kony.sync.objectLevelInfo + " text," + kony.sync.pendingUploadTableInsertCount + " int," + kony.sync.pendingUploadTableUpdateCount + " int," + kony.sync.pendingUploadTableDeleteCount + " int," + kony.sync.pendingUploadTableBatchInsertCount + " int," + kony.sync.pendingUploadTableBatchUpdateCount + " int," + kony.sync.pendingUploadTableBatchDeleteCount + " int," + kony.sync.pendingUploadTableUploadLimit + " int,primary key (" + kony.sync.metaTableScopeColumn + "))", "CREATE TABLE " + kony.sync.chunkTableName + " (" + kony.sync.chunkTableChunkId + " int not null," + kony.sync.chunkTablePayloadId + " nvarchar(50) not null," + kony.sync.metaTableScopeColumn + " nvarchar(100) not null," + kony.sync.chunkTableChunkData + " text," + kony.sync.chunkTableTimeStamp + " nvarchar(50),primary key (" + kony.sync.chunkTableChunkId + ", " + kony.sync.chunkTablePayloadId + ", " + kony.sync.metaTableScopeColumn + "))", "CREATE TABLE " + kony.sync.chunkMetaTableName + " (" + kony.sync.chunkTablePayloadId + " nvarchar(50) not null," + kony.sync.metaTableScopeColumn + " nvarchar(100) not null," + kony.sync.metaTableChunkAck + " int," + kony.sync.metaTableChunkSize + " int," + kony.sync.metaTableChunkCount + " int," + kony.sync.metaTableChunkHashSum + " nvarchar(35)," + kony.sync.metaTableChunkDiscarded + " int,primary key (" + kony.sync.chunkTablePayloadId + ", " + kony.sync.metaTableScopeColumn + "))"];
    }
    return kony.sync.executeQueriesInTransaction(tx, kony.sync.DDL556to559Update);
};
kony.sync.checkForUpdate559to560Schema = function(tx) {
    sync.log.trace("Entering kony.sync.checkForUpdate559to560Schema ");
    var sql = "select count(" + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + ") from " + kony.sync.metaTableName;
    var resultSet = kony.sync.executeSql(tx, sql, null, null, false);
    if (resultSet === false) {
        //Alter scripts for 5.5.9 to 5.6.0 DB Update 
        kony.sync.configVersion = konysyncClientSyncConfig.Version;
        kony.sync.DDL559to560Update = ["ALTER TABLE " + kony.sync.syncConfigurationTableName + " ADD COLUMN " + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " nvarchar(4000)", "ALTER TABLE " + kony.sync.syncConfigurationTableName + " ADD COLUMN " + kony.sync.syncConfigurationColumnVersion + " nvarchar(4000)", "ALTER TABLE " + kony.sync.metaTableName + " ADD COLUMN " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " nvarchar(1000)", "UPDATE " + kony.sync.syncConfigurationTableName + " SET " + kony.sync.syncConfigurationColumnVersion + " = '" + konysyncClientSyncConfig.Version + "' where rowid = 1"];
    }
    return kony.sync.executeQueriesInTransaction(tx, kony.sync.DDL559to560Update);
};
kony.sync.checkForUpdate6xto70Schema = function(tx) {
    sync.log.trace("Entering kony.sync.checkForUpdate6xto70Schema ");
    // create table named konysyncBLOBSTOREMANAGER if doesn't exist in sync DB.
    kony.sync.DDL6xto70Update = ["CREATE TABLE IF NOT EXISTS \"konysyncBLOBSTOREMANAGER\" (\"id\" integer not null,\"localPath\" text,\"tableName\"text,\"columnName\" text,\"type\" text,\"state\" integer,\"status\" integer,\"size\" integer,\"retry\" integer,\"lastUpdatedTimeStamp\" TIMESTAMP default CURRENT_TIMESTAMP,primary key (\"id\"))"];
    return kony.sync.executeQueriesInTransaction(tx, kony.sync.DDL6xto70Update);
};
/**
 * Method is used to fetch the records whose binary operation has failed
 * @param isDownload {boolean} true for download/ false for upload
 * @param tablename {String} tablename to filter binary records by tablename.
 * @param columnname {String} column name to filter binary records by binary column.
 * @param successCallback
 * @param errorCallback
 */
sync.getFailedBinaryRecords = function(isDownload, tablename, columnname, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_insert_execute-> main function");
    var isError = false;
    var statusResponse = [];

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (!isError) {
            sync.log.trace("kony.sync.getFailedBinaryRecords - single_transaction_success_callback...");
            kony.sync.verifyAndCallClosure(successCallback, statusResponse);
        } else {
            kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
        }
    }

    function single_transaction_failure_callback() {
        sync.log.trace("kony.sync.getFailedBinaryRecords - single_transaction_error_callback...");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("kony.sync.getFailedBinaryRecords - single_transaction_callback...");
        var selectClause = [kony.sync.blobManager.id, kony.sync.blobManager.tableName, kony.sync.blobManager.columnName];
        var whereClause = [];
        var requiredState = kony.sync.blobManager.DOWNLOAD_FAILED;
        if (!isDownload) {
            requiredState = kony.sync.blobManager.UPLOAD_FAILED;
        }
        kony.table.insert(whereClause, {
            key: kony.sync.blobManager.state,
            value: requiredState,
            optype: "EQ",
            comptype: "AND"
        });
        //if tablename is passed.. add it to the where clause..
        if (!kony.sync.isNullOrUndefined(tablename)) {
            kony.table.insert(whereClause, {
                key: kony.sync.blobManager.tableName,
                value: tablename,
                optype: "EQ",
                comptype: "AND"
            });
            //if column name is passed, add it to the whereclause..
            if (!kony.sync.isNullOrUndefined(columnname)) {
                kony.table.insert(whereClause, {
                    key: kony.sync.blobManager.columnName,
                    value: columnname,
                    optype: "EQ",
                    comptype: "AND"
                });
            }
        }
        var resultset = kony.sync.queryTable(tx, kony.sync.blobStoreManagerTable, selectClause, whereClause);
        if (resultset) {
            for (var k = 0; k < resultset.rows.length; k++) {
                var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, k);
                var binaryColumnName = kony.sync.binaryMetaColumnPrefix + rowItem[kony.sync.blobManager.columnName];
                var tbname = rowItem[kony.sync.blobManager.tableName];
                var pkColumns = kony.sync.currentScope.syncTableDic[tbname].Pk_Columns;
                var blobWhereClause = [{
                    key: binaryColumnName,
                    value: rowItem[kony.sync.blobManager.id]
                }];
                var parentResultSet = kony.sync.queryTable(tx, tbname, pkColumns, blobWhereClause);
                if (!parentResultSet) {
                    return;
                }
                for (var rowCount = 0; rowCount < parentResultSet.rows.length; rowCount++) {
                    var parentRowItem = kony.db.sqlResultsetRowItem(tx, parentResultSet, rowCount);
                    var response = {};
                    for (var pkCount = 0; pkCount < pkColumns.length; pkCount++) {
                        var pkTable = {};
                        pkTable[pkColumns[pkCount]] = parentRowItem[pkColumns[pkCount]];
                    }
                    response.primaryKeys = pkTable;
                    response.tableName = tbname;
                    response.binaryColumn = rowItem[kony.sync.blobManager.columnName];
                    statusResponse.push(response);
                }
            }
        }
    }
    var dbname = kony.sync.getDBName();
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallback, "fetch binary failed records..");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_failure_callback);
    }
};
/**
 * Method is used to fetch status of the binary records of given table.
 * @param tbname - name of the table.
 * @param columnName - name of the binary column
 * @param pks {JSON} - Primary keys values for the record.
 * @param successCallback - callback called upon success.
 * @param errorCallback - callback called upon error.
 */
sync.getStatusForBinary = function(tbname, columnName, pks, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getStatusForBinary ");
    var statusResponse = {};
    var error;

    function single_transaction_callback(tx) {
        sync.log.trace("Entering sync.getStatusForBinary -> single_transaction_callback");
        if (kony.sync.isNullOrUndefined(pks)) {
            //null pk values are received.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, pks));
            return;
        }
        var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tbname].Pk_Columns;
        pks = kony.sync.validatePkTable(pkColumns, pks);
        if (!kony.sync.isNullOrUndefined(pks)) {
            var blobRef = kony.sync.getBlobRef(tx, tbname, columnName, pks, errorCallback);
            statusResponse.primaryKeys = pks;
            if (blobRef === kony.sync.blobRefNotDefined || blobRef === kony.sync.blobRefNotFound) {
                statusResponse.statusCode = 0;
                statusResponse.statusMessage = "Binary record not downloaded";
            } else {
                //blob ref exists. query the blob store manager.
                var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, errorCallback);
                if (blobMeta !== null && blobMeta !== false) {
                    statusResponse.statusCode = blobMeta[kony.sync.blobManager.state];
                    statusResponse.statusMessage = kony.sync.blobManager.states[statusResponse.statusCode];
                }
            }
        } else {
            //error invalid pks.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tbname));
        }
    }

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.getStatusForBinary->single_transaction_success_callback");
        if (!kony.sync.isNullOrUndefined(error)) {
            kony.sync.verifyAndCallClosure(errorCallback, error);
        } else {
            sync.log.trace("status response for the get status request ", statusResponse);
            kony.sync.verifyAndCallClosure(successCallback, statusResponse);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.getStatusForBinary->single_transaction_error_callback");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }
    sync.log.trace("Entering kony.sync.single_binary_select_status_execute-> main function");
    if (kony.sync.isValidFunctionType(successCallback) && kony.sync.isValidFunctionType(errorCallback)) {
        if (columnName === undefined || typeof(columnName) !== "string" || tbname === undefined || typeof(tbname) !== "string") {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
            kony.sync.verifyAndCallClosure(errorCallback, error);
            return;
        }
        var downloadPolicy = kony.sync.getDownloadPolicy(tbname, columnName);
        sync.log.trace("download policy for the column " + tbname + "." + columnName + " is " + downloadPolicy);
        if (downloadPolicy !== kony.sync.notSupported) {
            var dbname = kony.sync.getDBName();
            var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallback, "fetch status for binary records..");
            if (connection !== null) {
                kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
            }
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadPolicyNotSupported, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadPolicyNotSupported, tbname + "." + columnName));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
/**
 * Method is used to fetch Base64 string for a given record.
 * @param tbname {String} - tablename
 * @param columnName {String} - name of the binary column
 * @param pks {JSON} - Primary keys values for the record.
 * @param config {JSON} (optional) - config properties for the binary download. includes {"forceDownload": true/false}
 * @param successCallback
 * @param errorCallback
 */
sync.getBinaryBase64 = function(tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinaryBase64....");
    var dbname = kony.sync.getDBName();
    kony.sync.single_binary_select_base64_execute(dbname, tbname, columnName, pks, config, successCallback, errorCallback);
};
/**
 * Method is used to fetch binary file for a given record
 * @param tbname {String} - tablename
 * @param columnName {String} - name of the binary column
 * @param pks {JSON} - Primary keys values for the record.
 * @param config {JSON} (optional) - config properties for the binary download. includes {"forceDownload": true/false}
 * @param successCallback
 * @param errorCallback
 */
sync.getBinaryFilepath = function(tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinaryFilepath....");
    var dbname = kony.sync.getDBName();
    kony.sync.single_binary_select_file_execute(dbname, tbname, columnName, pks, config, successCallback, errorCallback);
};
sync.createDownloadTask = function(tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.createDownloadTask for table ", tableName, " column name ", binaryColumnName);
    var dbname = kony.sync.getDBName();
    kony.sync.createDownloadTask(dbname, tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback);
};
sync.startDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering sync.startDownload for downloadID " + downloadID);
    kony.sync.startDownload(downloadID, successCallback, errorCallback);
};
sync.pauseDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering sync.pauseDownload for downloadID " + downloadID);
    kony.sync.pauseDownload(downloadID, successCallback, errorCallback);
};
sync.resumeDownload = function(downloadID, successCallback, errorCallback) {
    sync.log.trace("Entering sync.resumeDownload for downloadID " + downloadID);
    kony.sync.resumeDownload(downloadID, successCallback, errorCallback);
};
sync.getBinaryDataFilePath = function(tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinaryDataFilePath for tableName ", tableName, " binary column ", binaryColumnName, " with primary keys ", primaryKeyTable);
    var dbname = kony.sync.getDBName();
    kony.sync.getBinaryDataFilePath(dbname, tableName, binaryColumnName, primaryKeyTable, successCallback, errorCallback);
};
sync.getBinary = function(tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback) {
    sync.log.trace("Entering sync.getBinary..");
    var dbname = kony.sync.getDBName();
    kony.sync.getBinary(dbname, tableName, binaryColumnName, primaryKeyTable, config, successCallback, errorCallback);
};
//delete binary objects api.
sync.deleteBinaryObject = function(tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback) {
    sync.log.trace("Entering sync.deleteBinaryObject for tableName ", tableName, " binary column ", binaryColumnName, " with primary keys ", primaryKeyTable);
    var dbname = kony.sync.getDBName();
    kony.sync.deleteBinaryObject(dbname, tableName, binaryColumnName, primaryKeyTable, options, successCallback, errorCallback);
};
//  **************** End KonySyncInit.js*******************
//  **************** Start KonySyncLogger.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(kony.sync.log) === "undefined") {
    kony.sync.log = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
sync.log = {};
sync.log.trace = function(msg, params) {
    sync.log.getInstance().trace(msg, params);
};
sync.log.debug = function(msg, params) {
    sync.log.getInstance().debug(msg, params);
};
sync.log.info = function(msg, params) {
    sync.log.getInstance().info(msg, params);
};
sync.log.warn = function(msg, params) {
    sync.log.getInstance().warn(msg, params);
};
sync.log.error = function(msg, params) {
    sync.log.getInstance().error(msg, params);
};
sync.log.fatal = function(msg, params) {
    sync.log.getInstance().fatal(msg, params);
};
sync.log.loggerEngineInit = function() {
    KonySyncLoggerObj = kony.logger.createNewLogger("SYNCV1", null);
    KonySyncLoggerObj.setIndirectionLevel = 1;
};
sync.log.getInstance = function() {
        if (typeof(KonySyncLoggerObj) === 'undefined') sync.log.loggerEngineInit();
        return KonySyncLoggerObj;
    }
    //  **************** End KonySyncLogger.js*******************
    //  **************** Start KonySyncMetadata.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
// gets the time when dbname was last syced
kony.sync.getLastSynctime = function(scopename, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSynctime");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: "no filter"
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    kony.sync.single_select_execute(dbname, sql, params, scallback, errorCallback);

    function errorCallback(res) {
        sync.log.error("error occurred while getting timestamp since last sync", res);
        kony.sync.onDownloadCompletion(true, res);
    }
};
// gets the time when dbname was last syced
kony.sync.getLastSynctimeForUpload = function(scopename, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSynctimeForUpload ");

    function callback(rows) {
        sync.log.trace("Entering callback");
        var lastSyncTime = -1;
        var result = "";
        for (var i = 0; i < rows.length; i++) {
            var v = rows[i];
            if (v[kony.sync.metaTableSyncTimeColumn] !== "") {
                var str = v[kony.sync.metaTableSyncTimeColumn];
                var temp = kony.sync.tonumber(str.split(",")[1]);
                if ((lastSyncTime === -1)) {
                    lastSyncTime = temp;
                    result = str;
                } else if ((temp < lastSyncTime)) {
                    lastSyncTime = temp;
                    result = str;
                }
            }
            sync.log.info("Last TimeStamp since Upload :", lastSyncTime);
        }
        var resulttable = {};
        if ((lastSyncTime === -1)) {
            resulttable[kony.sync.metaTableSyncTimeColumn] = "";
            scallback([resulttable]);
        } else {
            resulttable[kony.sync.metaTableSyncTimeColumn] = result;
            scallback([resulttable]);
        }
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableSyncTimeColumn]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    kony.sync.single_select_execute(dbname, sql, params, callback, errorCallback);

    function errorCallback(res) {
        sync.log.error("error occurred while getting timestamp since last upload", res);
        kony.sync.onUploadCompletion(true, res);
    }
};
// gets the time when dbname was last synced
kony.sync.getLastSynctimeFilter1 = function(scopename, filter, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSynctimeFilter ");

    function isDataPresent(result) {
        sync.log.info("last sync time in filter :", result);

        function getscopeindex(resultcount) {
            sync.log.trace("Entering getscopeindex");

            function calscallback() {
                var table = {};
                table[kony.sync.metaTableSyncTimeColumn] = "";
                scallback([table]);
            }
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, {
                id: resultcount.length + 1,
                filtervalue: filter,
                scopename: scopename,
                versionnumber: 0,
                lastserversynccontext: "",
                replaysequencenumber: 0,
                lastgeneratedid: -1
            });
            kony.sync.qb_insert(query, kony.sync.metaTableName);
            var query_compile2 = kony.sync.qb_compile(query);
            var sql2 = query_compile2[0];
            var params2 = query_compile2[1];
            kony.sync.single_select_execute(dbname, sql2, params2, calscallback, errorCallback);
        }
        if (result.length === 1) {
            scallback(result);
        } else {
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_select(query, null);
            kony.sync.qb_from(query, kony.sync.metaTableName);
            var query_compile3 = kony.sync.qb_compile(query);
            var sql3 = query_compile3[0];
            var params3 = query_compile3[1];
            kony.sync.single_select_execute(dbname, sql3, params3, getscopeindex, errorCallback);
        }
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableSyncTimeColumn]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: filter
    }]);
    var query_compile1 = kony.sync.qb_compile(query);
    var sql1 = query_compile1[0];
    var params1 = query_compile1[1];
    kony.sync.single_select_execute(dbname, sql1, params1, isDataPresent, errorCallback);

    function errorCallback(res) {
        sync.log.error("error occurred while getting time-stamp since last upload for filter", res);
        kony.sync.onDownloadCompletion(true, res);
    }
};
/* gets the time when scopename with filter was last synced */
kony.sync.getLastSynctimeFilter = function(scopename, filter, dbname, callback) {
    sync.log.trace("Entering kony.sync.getLastSynctimeFilter ");
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    var isError = false;
    var result = [];
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }

    function transactionCallback(tx) {
        sync.log.trace("Entering kony.sync.getLastSynctimeFilter->transactionCallback");
        //search for row with filter
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.metaTableSyncTimeColumn]);
        kony.sync.qb_from(query, kony.sync.metaTableName);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }, {
            key: kony.sync.metaTableFilterValue,
            value: filter
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            isError = true;
            return;
        }
        if (resultSet.rows.length >= 1) {
            result[0] = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        } else { //if not found, insert it
            //get the count of rows in metainfo
            resultSet = kony.sync.executeSql(tx, "select * from " + kony.sync.metaTableName, null);
            if (resultSet === false) {
                isError = true;
                return;
            }
            //insert the filter
            query = kony.sync.qb_createQuery();
            kony.sync.qb_set(query, {
                id: resultSet.rows.length + 1,
                filtervalue: filter,
                scopename: scopename,
                versionnumber: 0,
                lastserversynccontext: "",
                lastserveruploadsynccontext: "",
                replaysequencenumber: 0,
                lastgeneratedid: -1
            });
            kony.sync.qb_insert(query, kony.sync.metaTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
                return;
            }
            var table = {};
            table[kony.sync.metaTableSyncTimeColumn] = "";
            result[0] = table;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.getLastSynctimeFilter->transactionSuccessCallback");
        callback(result);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.getLastSynctimeFilter->transactionErrorCallback");
        kony.sync.onDownloadCompletion(true, kony.sync.getTransactionError(isError));
    }
};
// Update the meta tables with last sync time
kony.sync.setLastSyncTime = function(tx, scopename, time, tickcount) {
    sync.log.trace("Entering kony.sync.setLastSyncTime ");
    var settable = {};
    if (kony.sync.schemaUpgradeDownloadPending) {
        settable[kony.sync.metaTableSchemaUpgradeSyncTimeColumn] = tickcount;
    } else {
        settable[kony.sync.metaTableSyncTimeColumn] = tickcount;
    }
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: "no filter"
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
// Update the meta tables with last sync time
kony.sync.setLastSyncTimeFilter = function(tx, scopename, filter, time, tickcount) {
    sync.log.trace("Entering kony.sync.setLastSyncTimeFilter ");
    var settable = {};
    if (kony.sync.schemaUpgradeDownloadPending) {
        settable[kony.sync.metaTableSchemaUpgradeSyncTimeColumn] = tickcount;
    } else {
        settable[kony.sync.metaTableSyncTimeColumn] = tickcount;
    }
    //settable[kony.sync.metaTableFilterValue] = filter;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: filter
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
//function getseqnumber (connection,scopename)
kony.sync.getseqnumber = function(connection, scopename) {
    sync.log.trace("Entering kony.sync.getseqnumber ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableSyncVersionCloumn]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "select "..kony.sync.metaTableSyncVersionCloumn.." from "..kony.sync.metaTableName.." where "..kony.sync.metaTableScopeColumn.." = '"..scopename.."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(connection, sql, params);
    if (resultset === false) {
        return false;
    }
    var rowItem = kony.db.sqlResultsetRowItem(connection, resultset, 0);
    return rowItem;
};
kony.sync.setSeqnumber = function(scopename, dsname, uploaded, callback) {
    sync.log.trace("Entering kony.sync.setSeqnumber ");
    var isStatementError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        var settable = {};
        settable[kony.sync.metaTableSyncVersionCloumn] = uploaded;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, kony.sync.metaTableName);
        kony.sync.qb_set(query, settable);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            isStatementError = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.setSeqnumber->transactionSuccessCallback");
        callback();
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.setSeqnumber->transactionErrorCallback");
        sync.log.error("Error occurred while setting sequence number");
        if (!isStatementError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var connection = kony.sync.getConnectionOnly(dsname, dsname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
kony.sync.getSyncOrder = function(scopename, tx) {
    sync.log.trace("Entering kony.sync.getSyncOrder ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params);
    if (resultset !== false) {
        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        sync.log.debug("sync order value" + rowItem);
        if (!kony.sync.isNullOrUndefined(rowItem[kony.sync.metaTableSyncOrderCloumn])) {
            return kony.sync.tonumber(rowItem[kony.sync.metaTableSyncOrderCloumn]);
        } else {
            return null;
        }
    } else {
        return false;
    }
};
kony.sync.clearSyncHistory = function(dbname, tablename) {
    sync.log.trace("Entering kony.sync.clearSyncHistory ");
    var sql = "delete from " + tablename + kony.sync.historyTableName;
    var wcs = " where konysyncchangetype NOT LIKE '9%'";
    var testsql = sql + wcs;
    kony.sync.single_execute_sql(dbname, testsql, null, null);
};
kony.sync.clearSyncOriginal = function(dbname, tbname) {
    sync.log.trace("Entering kony.sync.clearSyncOriginal ");
    var sql = "delete from " + tbname + kony.sync.originalTableName;
    kony.sync.single_execute_sql(dbname, sql, null, null);
};
kony.sync.clearDataForCOE = function(tx, scopename, tablename, wcs, newwcs, changeType, pkset, seqNo, values, isError) {
    sync.log.trace("Entering kony.sync.clearDataForCOE ");
    if (kony.sync.isNullOrUndefined(pkset) && isError) {
        return false;
    }
    var whereClause = kony.sync.CreateCopy(wcs);
    var query = null;
    var query_compile = null;
    var sql = null;
    var params = null;
    //hashSum also needs to be updated to avoid conflicts.
    var hashSum = values[kony.sync.historyTableHashSumColumn];
    //update the binary to UPLOAD ACCEPTED.
    //for onDemandColumns,
    var onDemandColumns = kony.sync.getBinaryColumnsByPolicy(tablename, kony.sync.onDemand);
    sync.log.trace("onDemandColumns for " + tablename + " are " + JSON.stringify(onDemandColumns));
    var pkTable = {};
    var binaryColumns = kony.sync.getBinaryColumns(tablename);
    for (var j = 0; j < wcs.length; j++) {
        pkTable[wcs[j].key] = wcs[j].value;
    }
    if (!kony.sync.isNullOrUndefined(binaryColumns)) {
        for (var j = 0; j < binaryColumns.length; j++) {
            if (kony.sync.getDownloadPolicy(tablename, binaryColumns[j]) !== kony.sync.inline) {
                var blobRef = kony.sync.getBlobRef(tx, tablename, binaryColumns[j], pkTable, updateBlobStatusCallback);
                sync.log.trace("blobRef for pkTable " + JSON.stringify(pkTable) + " is " + blobRef);
                if (blobRef !== kony.sync.blobRefNotFound && blobRef !== kony.sync.blobRefNotDefined) {
                    //fetch the current state of the blob before upload_accepting.
                    var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobRef, updateBlobStatusCallback);
                    if (!kony.sync.isNullOrUndefined(blobMeta) && blobMeta !== false) {
                        //if the blob entry is in valid state then accept the binary for upload.
                        if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.NO_OPERATION) {
                            sync.log.trace("marking the blob entry for UPLOAD for blob " + JSON.stringify(blobMeta));
                            var valuesTable = {};
                            valuesTable[kony.sync.blobManager.state] = kony.sync.blobManager.UPLOAD_ACCEPTED;
                            var results = kony.sync.blobManager.updateBlobManager(tx, blobRef, valuesTable, updateBlobStatusCallback);
                            if (results === null || results === false) {
                                return 0;
                            }
                            //increment total number of upload jobs..
                            kony.sync.incrementTotalJobs(false);
                            sync.log.trace("updated the state of the blob entry to UPLOAD_ACCEPTED");
                        } else {
                            sync.log.error("binary file not in a valid state to get picked for upload. ");
                            return 0;
                        }
                    } else {
                        return 0;
                    }
                }
                //invoke the notifier..
                kony.sync.invokeBinaryNotifiers(false);
            }
        }
    }
    //in case I got client pk from server
    if (!kony.sync.isNullOrUndefined(pkset)) {
        //update original table pk with new pk from server
        query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename + kony.sync.originalTableName);
        kony.sync.qb_set(query, pkset);
        kony.sync.qb_where(query, whereClause);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        //update main table pk with new pk from server
        query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename);
        kony.sync.qb_set(query, pkset);
        kony.sync.qb_where(query, whereClause);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        //update history table pk with new pk from server
        pkset[kony.sync.historyTableHashSumColumn] = hashSum;
        query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
        kony.sync.qb_set(query, pkset);
        kony.sync.qb_where(query, whereClause);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        if (isError) {
            return false;
        }
        kony.sync.serverInsertAckCount = kony.sync.serverInsertAckCount + 1;
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsInsertedAck] + 1;
        whereClause = kony.sync.CreateCopy(newwcs);
    } else if (changeType === "update") {
        //update history table hashSum for pending records
        if (!kony.sync.isNullOrUndefined(hashSum)) {
            var updateSet = {};
            updateSet[kony.sync.historyTableHashSumColumn] = hashSum;
            query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, updateSet);
            kony.sync.qb_where(query, whereClause);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return 0;
            }
        }
        /*TODO: non-autogenerated insert ack is currently considered as update ack*/
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsUpdatedAck] + 1;
        kony.sync.serverUpdateAckCount = kony.sync.serverUpdateAckCount + 1;
    } else if (changeType === "delete") {
        kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck] = kony.sync.objectLevelInfoMap[tablename][kony.sync.numberOfRowsDeletedAck] + 1;
        kony.sync.serverDeleteAckCount = kony.sync.serverDeleteAckCount + 1;
    }
    //TODO - throw error.
    function updateBlobStatusCallback(err) {
        sync.log.error("error in blobStoreManager update. --> clearDataForCOE " + JSON.stringify(err));
    }
    if (kony.sync.clearHistoryTable(tx, tablename, whereClause, seqNo) === false) {
        return 0;
    }
    return kony.sync.clearMainTableForRemoveAfterUpload(tx, scopename, tablename, whereClause);
};
kony.sync.clearMainTableForRemoveAfterUpload = function(tx, scopename, tablename, wcs) {
    sync.log.trace("Entering kony.sync.clearMainTableForRemoveAfterUpload ");
    var whereClause = kony.sync.CreateCopy(wcs);
    var removeAfterUpload = kony.sync.checkForDeleteAfterUpload(tablename, scopename);
    //Get records to be deleted from history table;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    kony.sync.qb_distinct(query);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return 0;
    }
    //don't remove from main and original tables if there is pending records in history table
    if (resultSet.rows.length !== 0) {
        return false;
    }
    //remove from original table
    if (kony.sync.clearOriginalTable(tx, tablename, wcs) === false) {
        return 0;
    }
    if (removeAfterUpload) {
        if (kony.sync.isNullOrUndefined(whereClause)) {
            whereClause = [];
        }
        query = kony.sync.qb_createQuery();
        kony.sync.qb_delete(query, tablename);
        kony.sync.qb_where(query, wcs);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return 0;
        }
        return true;
    } else {
        return false;
    }
};
kony.sync.clearHistoryTable = function(tx, tablename, wcs, seqNo) {
    sync.log.trace("Entering kony.sync.clearHistoryTable ");
    var whereClause = kony.sync.CreateCopy(wcs);
    if (kony.sync.isNullOrUndefined(whereClause)) {
        whereClause = [];
    }
    if (!kony.sync.isNullOrUndefined(seqNo)) {
        kony.table.insert(whereClause, {
            key: kony.sync.historyTableReplaySequenceColumn,
            value: seqNo,
            optype: "LT_EQ"
        });
    }
    kony.table.insert(whereClause, {
        key: kony.sync.historyTableChangeTypeColumn,
        value: "9%",
        optype: "NOT LIKE"
    });
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.getRecordsTobeDeletedFromHistoryTable = function(tx, tablename, seqNo) {
    sync.log.trace("Entering kony.sync.getRecordsTobeDeletedFromHistoryTable ");
    var whereClause = [];
    var records = false;
    kony.table.insert(whereClause, {
        key: kony.sync.historyTableReplaySequenceColumn,
        value: seqNo,
        optype: "LT_EQ"
    });
    //Get PK columns
    var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
    //Get records to be deleted from history table;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, pkColumns);
    kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
    kony.sync.qb_where(query, whereClause);
    kony.sync.qb_distinct(query);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet !== false) {
        records = [];
        var i = 0;
        for (; i < resultSet.rows.length; i++) {
            records.push(kony.db.sqlResultsetRowItem(tx, resultSet, i));
        }
        return records;
    } else {
        return false;
    }
};
kony.sync.clearOriginalTable = function(tx, tablename, wcs, seqNo) {
    sync.log.trace("Entering kony.sync.clearOriginalTable ");
    var whereClause = kony.sync.CreateCopy(wcs);
    var query = null;
    var query_compile = null;
    var sql = null;
    var params = null;
    if (!kony.sync.isNull(seqNo)) {
        whereClause = [];
        kony.table.insert(whereClause, {
            key: kony.sync.historyTableReplaySequenceColumn,
            value: seqNo,
            optype: "LT_EQ"
        });
        //Get PK columns
        var pkColumns = kony.sync.currentScope.syncTableDic[tablename].Pk_Columns;
        //Get records to be deleted from history table;
        query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, pkColumns);
        kony.sync.qb_from(query, tablename + kony.sync.historyTableName);
        kony.sync.qb_where(query, whereClause);
        kony.sync.qb_distinct(query);
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            return false;
        }
        var rowItem = null;
        var i = 0;
        var j = 0;
        var originaltbname = tablename + kony.sync.originalTableName;
        for (; i < resultSet.rows.length; i++) {
            rowItem = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            whereClause = [];
            for (j = 0; j < pkColumns.length; j++) {
                kony.table.insert(whereClause, {
                    key: pkColumns[j],
                    value: rowItem[pkColumns[j]],
                    optype: "EQ"
                });
            }
            query = kony.sync.qb_createQuery();
            kony.sync.qb_delete(query, originaltbname);
            kony.sync.qb_where(query, whereClause);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
        }
        return true;
    } else {
        query = kony.sync.qb_createQuery();
        kony.sync.qb_delete(query, tablename + kony.sync.originalTableName);
        if (!kony.sync.isNull(whereClause)) {
            kony.sync.qb_where(query, whereClause);
        }
        query_compile = kony.sync.qb_compile(query);
        sql = query_compile[0];
        params = query_compile[1];
        return kony.sync.executeSql(tx, sql, params);
    }
};
//calls resets sync order for a scope if all the history tables are empty
kony.sync.updateSyncOrderForScope = function(callback) {
    sync.log.trace("Entering kony.sync.updateSyncOrderForScope ");
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var scopename = kony.sync.currentScope[kony.sync.scopeName];
    var isError = false;
    var sql = null;
    var params = null;
    var query = null;
    var query_compile = null;
    kony.sync.getConnection(dbname, dbname, myTransactionCallBack, clear_success, clear_fail);

    function myTransactionCallBack(tx) {
        sync.log.trace("Entering myTransactionCallBack");
        var recordcount = 0;
        var versionNo = kony.sync.getseqnumber(tx, scopename);
        if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
            for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
                var syncTable = kony.sync.currentScope.ScopeTables[i];
                if (kony.sync.isNullOrUndefined(syncTable)) {
                    continue;
                }
                var tbname = syncTable.Name;
                query = kony.sync.qb_createQuery();
                kony.sync.qb_select(query, null);
                kony.sync.qb_from(query, tbname + kony.sync.historyTableName);
                query_compile = kony.sync.qb_compile(query);
                sql = query_compile[0];
                params = query_compile[1];
                var resultSet = kony.sync.executeSql(tx, sql, params);
                if (resultSet !== false) {
                    var num_records = resultSet.rows.length;
                    recordcount = recordcount + num_records;
                    if (num_records > 0) {
                        var versionMap = {};
                        versionMap[kony.sync.historyTableSyncVersionColumn] = versionNo.versionnumber;
                        var whereClause = [];
                        kony.table.insert(whereClause, {
                            key: kony.sync.historyTableChangeTypeColumn,
                            value: "9%",
                            optype: "NOT LIKE"
                        });
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_update(query, tbname + kony.sync.historyTableName);
                        kony.sync.qb_set(query, versionMap);
                        kony.sync.qb_where(query, whereClause);
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        if (kony.sync.executeSql(tx, sql, params) === false) {
                            isError = true;
                            return;
                        }
                    }
                } else {
                    isError = true;
                    return;
                }
            }
        }
        if (recordcount === 0) {
            if (kony.sync.updateSyncOrder(tx, scopename) === false) {
                isError = true;
                return;
            }
        }
    }

    function clear_fail() {
        sync.log.trace("Entering clear_fail");
        //kony.sync.downloadFailed(isError);
        if (isError) {
            callback(kony.sync.errorCodeSQLStatement);
        } else {
            callback(kony.sync.errorCodeTransaction);
        }
    }

    function clear_success() {
        sync.log.trace("Entering clear_success");
        if (callback != null) {
            callback(0);
        }
    }
};
//resets sync order for a scope
kony.sync.updateSyncOrder = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.updateSyncOrder ");
    var settable = {};
    settable[kony.sync.metaTableSyncOrderCloumn] = 0;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.clearSyncOrder = function(dbname, limit, serverblob, deleteLastUploadRequest, callback) {
    sync.log.trace("Entering kony.sync.clearSyncOrder ");
    var recordcount = 0;
    var isError = false;
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, clear_fail);
    if (dbconnection !== null) {
        kony.db.transaction(dbconnection, clear_transaction, clear_fail, clear_success);
    }

    function clear_transaction(tx) {
        sync.log.trace("Entering clear_transaction");
        var resultSet = null;
        var query_compile = null;
        var sql = null;
        var params = null;
        //updating sync version for all records going in next batch
        if (kony.sync.updateSyncOrderForUploadBatching(tx, limit) === false) {
            isError = true;
            return;
        }
        //updating upload timestamp
        if (kony.sync.setLastSyncUploadContext(tx, kony.sync.currentScope[kony.sync.scopeName], serverblob) === false) {
            isError = true;
            return;
        }
        //delete last upload request
        if (kony.sync.deleteLastUploadRequest(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
            return;
        }
        //Just returning from here, as this is getting handled in clearDataForCOE function, below code is redundant
        return;
        if (kony.sync.isUploadErrorPolicyCOE(kony.sync.currentScope)) {
            return;
        }
        if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
            for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
                var syncTable = kony.sync.currentScope.ScopeTables[i];
                if (kony.sync.isNullOrUndefined(syncTable)) {
                    continue;
                }
                var tbname = syncTable.Name;
                //get whether table is marked for removeAfterUpload
                var removeAfterUpload = kony.sync.checkForDeleteAfterUpload(tbname, kony.sync.currentScope[kony.sync.scopeName]);
                //get Records To be deleted From History Table
                var records = kony.sync.getRecordsTobeDeletedFromHistoryTable(tx, tbname, limit);
                if (records === false) {
                    isError = true;
                    return;
                }
                //clearing history table
                if (kony.sync.clearHistoryTable(tx, tbname, null, limit) === false) {
                    isError = true;
                    return;
                }
                var pkColumns = kony.sync.currentScope.syncTableDic[tbname].Pk_Columns;
                for (var k = 0; k < records.length; k++) {
                    //preparing where clause
                    var whereClause = [];
                    for (var j = 0; j < pkColumns.length; j++) {
                        kony.table.insert(whereClause, {
                            key: pkColumns[j],
                            value: records[k][pkColumns[j]],
                            optype: "EQ"
                        });
                    }
                    var query = kony.sync.qb_createQuery();
                    kony.sync.qb_select(query, null);
                    kony.sync.qb_from(query, tbname + kony.sync.historyTableName);
                    kony.sync.qb_where(query, whereClause);
                    query_compile = kony.sync.qb_compile(query);
                    sql = query_compile[0];
                    params = query_compile[1];
                    resultSet = kony.sync.executeSql(tx, sql, params);
                    if (resultSet === false) {
                        isError = true;
                        return;
                    }
                    //delete records from original and main tables if there is  no pending record in history table
                    if (resultSet.rows.length === 0) {
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_delete(query, tbname + kony.sync.originalTableName);
                        kony.sync.qb_where(query, whereClause);
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        if (kony.sync.executeSql(tx, sql, params) === false) {
                            isError = true;
                            return;
                        }
                        //remove value if table is marked for removeAfterUpload
                        if (removeAfterUpload) {
                            query = kony.sync.qb_createQuery();
                            kony.sync.qb_delete(query, tbname);
                            kony.sync.qb_where(query, whereClause);
                            query_compile = kony.sync.qb_compile(query);
                            sql = query_compile[0];
                            params = query_compile[1];
                            if (kony.sync.executeSql(tx, sql, params) === false) {
                                isError = true;
                                return;
                            }
                        }
                    }
                }
                //currently disabling removeafterupload for P scope
                //kony.sync.clearMainTableForRemoveAfterUpload(tx, scopename, tbname, null);
                //couting deferred uploads
                sql = "select * from " + tbname + kony.sync.historyTableName;
                resultSet = kony.sync.executeSql(tx, sql, null);
                if (resultSet === false) {
                    isError = true;
                    return;
                }
                var num_records = resultSet.rows.length;
                recordcount = recordcount + num_records;
            }
        }
        if (recordcount === 0) {
            if (kony.sync.updateSyncOrder(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
                isError = true;
            }
        }
    }

    function clear_success() {
        sync.log.trace("Entering kony.sync.clearsyncorder->clear_success");
        callback();
    }

    function clear_fail() {
        sync.log.trace("Entering kony.sync.clearsyncorder->clear_fail");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
kony.sync.setSyncOrder = function(scopename, syncorder, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.setSyncOrder ");
    var settable = {};
    settable[kony.sync.metaTableSyncOrderCloumn] = syncorder;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "update ".. kony.sync.metaTableName.." set "..kony.sync.metaTableSyncOrderCloumn.."="..syncorder .." where "..kony.sync.metaTableScopeColumn.." = '".. scopename .."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.debug("setting sync order", sql);
    return kony.sync.executeSql(tx, sql, params, errorCallback);
};
kony.sync.getLastGeneratedID = function(scopename, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.getLastGeneratedID ");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, [kony.sync.metaTableLastGeneratedId]);
    kony.sync.qb_from(query, kony.sync.metaTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "select "..kony.sync.metaTableLastGeneratedId.." from "..kony.sync.metaTableName.." where "..kony.sync.metaTableScopeColumn.." = '"..scopename.."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.debug("getting lastgeneratedid", sql);
    var resultset = kony.sync.executeSql(tx, sql, params, errorCallback);
    if (resultset === false) {
        return false;
    }
    sync.log.debug("result", resultset);
    var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
    sync.log.debug("rowItem", rowItem);
    if (!kony.sync.isNullOrUndefined(rowItem[kony.sync.metaTableLastGeneratedId])) {
        return rowItem[kony.sync.metaTableLastGeneratedId];
    } else {
        //It should never come here
        sync.log.fatal("Last Generated ID is null");
        return false;
    }
};
kony.sync.setLastGeneratedID = function(scopename, lastgeneratedid, tx, errorCallback) {
    sync.log.trace("Entering kony.sync.setLastGeneratedID ");
    var settable = {};
    settable[kony.sync.metaTableLastGeneratedId] = lastgeneratedid;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    //local sql = "update ".. kony.sync.metaTableName.." set "..kony.sync.metaTableLastGeneratedId.."="..lastgeneratedid .." where "..kony.sync.metaTableScopeColumn.." = '".. scopename .."'";
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    sync.log.debug("setting sync order", sql);
    return kony.sync.executeSql(tx, sql, params, errorCallback);
};
//  **************** End KonySyncMetadata.js*******************
//  **************** Start KonySyncORMAPI.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.updateByPK = function(tbname, dbname, relationshipMap, pks, valuestable, successcallback, errorcallback, markForUpload, wcs) {
    sync.log.trace("Entering kony.sync.updateByPK -> main function");
    var isSuccess = true;
    var pkNotFound = false;
    var isRefIntegrityError = false;
    var isMarkForuploadInvalid = false;
    var updateResult = null;
    var errObject = null;
    var twcs = [];
    twcs = kony.sync.CreateCopy(wcs);

    function single_execute_sql_transaction(tx) {
        sync.log.trace("Entering kony.sync.updateByPK -> single_execute_sql_transaction ");
        var record = "";
        if (kony.sync.enableORMValidations) {
            record = kony.sync.getOriginalRow(tx, tbname, wcs, errorcallback);
            if (record === false) {
                isSuccess = false;
                return;
            }
        }
        if (null !== record || !kony.sync.enableORMValidations) {
            errObject = kony.sync.checkIntegrityinTransaction(tx, relationshipMap);
            if (errObject === false) {
                isSuccess = false;
                return;
            } else if (errObject !== true) {
                isSuccess = false;
                isRefIntegrityError = true;
                kony.sync.rollbackTransaction(tx);
                return;
            } else {
                var blobMap = {};
                if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
                    var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
                    for (var i = 0; i < binaryColumns.length; i++) {
                        if (!kony.sync.isNullOrUndefined(valuestable[binaryColumns[i]]) && valuestable[binaryColumns[i]].length > 0) blobMap[binaryColumns[i]] = valuestable[binaryColumns[i]];
                        delete valuestable[binaryColumns[i]];
                    }
                }
                updateResult = kony.sync.update(tx, tbname, valuestable, wcs, markForUpload, errorcallback);
                if (updateResult === false) {
                    isSuccess = false;
                } else if (updateResult === kony.sync.errorCodeInvalidMarkForUploadValue) {
                    isMarkForuploadInvalid = true;
                    isSuccess = false;
                } else {
                    if (Object.keys(blobMap).length > 0) {
                        var blobStoreIndices = kony.sync.blobstore_update(tx, tbname, blobMap, wcs, false, errorcallback);
                        if (!kony.sync.isNullOrUndefined(blobStoreIndices)) {
                            if (Object.keys(blobStoreIndices).length > 0) {
                                var results = kony.sync.blobManager.updateParentWithBlobReference(tx, tbname, blobStoreIndices, wcs, errorcallback);
                                if (results === false || results === null) {
                                    isSuccess = false;
                                }
                            }
                        } else {
                            isSuccess = false;
                        }
                    }
                }
            }
        } else {
            pkNotFound = true;
        }
    }

    function single_transactionErrorCallback() {
        sync.log.error("Entering kony.sync.updatebyPK->single_transactionErrorCallback ");
        if (isSuccess) {
            kony.sync.showTransactionError(errorcallback);
        } else if (isRefIntegrityError === true) {
            kony.sync.verifyAndCallClosure(errorcallback, errObject);
        } else {
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function single_execute_sql_transactionSucessCallback() {
        sync.log.trace("Entering kony.sync.updateByPK->single_execute_sql_transactionSucessCallback -> isSuccess -> " + isSuccess);
        if (pkNotFound === true) {
            kony.sync.pkNotFoundErrCallback(errorcallback, tbname);
            return;
        } else if (isMarkForuploadInvalid) {
            errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeInvalidMarkForUploadValue, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidMarkForUploadValue, tbname)));
        } else if (isSuccess === false) {
            kony.sync.pkNotFoundErrCallback(errorcallback, tbname);
            return;
        } else {
            kony.sync.verifyAndCallClosure(successcallback, {
                rowsupdated: 1
            });
        }
    }
    try {
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
        if (dbconnection !== null) {
            kony.sync.startTransaction(dbconnection, single_execute_sql_transaction, single_execute_sql_transactionSucessCallback, single_transactionErrorCallback, "Single Execute");
        }
    } catch (e) {
        sync.log.error("Unknown error occurred during update", e);
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorUnknown, kony.sync.getErrorMessage(kony.sync.errorUnknown, "Rollback", e), null));
    }
};
kony.sync.checkForFalseUpdateInTransaction = function(tx, dbname, tbname, twcs, markForUpload, errorcallback) {
    sync.log.trace("Entering kony.sync.checkForFalseUpdate ");
    if (kony.sync.getUploadStatus(markForUpload)) {
        return true;
    } else {
        kony.table.insert(twcs, {
            key: kony.sync.historyTableChangeTypeColumn,
            value: "90",
            optype: "EQ",
            comptype: "AND"
        });
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, [kony.sync.historyTableChangeTypeColumn]);
        kony.sync.qb_from(query, tbname + "_history");
        kony.sync.qb_where(query, twcs);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params, errorcallback);
        if ((resultSet !== false)) {
            var num_records = resultSet.rows.length;
            if (num_records !== 0) {
                sync.log.error("Record does not exist on server, mark it for upload before updating/deleting it");
                return kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMarkForUpload, kony.sync.getErrorMessage(kony.sync.errorCodeMarkForUpload), null));
            }
        } else {
            return false;
        }
        return true;
    }
};
//  **************** End KonySyncORMAPI.js*******************
//  **************** Start konySyncQueryBuilder.js*******************
//-------------------------Sample Query Table for reference----------------------------
//sqlquery={
//	["schemaname"] = "",
//	["tablename"]= "",
//	["operationtype"] = "" { Insert, Select, Update, Delete, Custom },
//	["orderbyclause"]="",
//	["topclause"]="",
//  ["isPurge"]=true/false This condition will make insert statement to insert ignore.
//	["purgeValues"] = "";
//	multiple conditions
//	["conditions"]={
//		{
//			["key"]=""
//			["value"]=""
//			["optype"]="" { EQ, NOT_EQ, GT, GT_EQ, LT, LT_EQ, LIKE, JOIN }	 
//			["comptype"]="" { AND, OR }
//			["binary"]="" {true,false}
//		},
//		{
//			["key"]=""
//			["value"]=""
//			["optype"]=""
//			["value"]=""
//		}
//	},
//	["fields"]={
//		"c1","c2","c3"		
//	},
//	["colvals"]={
//		{
//			["key"]="cname"
//			["value"]="vname"
//		},
//		{
//			["key"]="cname"
//			["value"]="vname"
//		}
//	}
//}
//function qb_createQuery()
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.qb_createQuery = function() {
    sync.log.trace("Entering kony.sync.qb_createQuery ");
    return {
        topclause: "",
        distinctclause: "",
        orderbyclause: "",
        colvals: [],
        conditions: [],
        paramindex: 0
    };
};
kony.sync.qb_where = function(query, conditions) {
    sync.log.trace("Entering kony.sync.qb_where ");
    if (kony.sync.isNullOrUndefined(conditions)) {
        return;
    }
    for (var i = 0; i < conditions.length; i++) {
        var cond = conditions[i];
        var condition = {};
        if (kony.sync.isNullOrUndefined(cond.optype)) {
            cond.optype = "EQ";
        }
        if (kony.sync.isNullOrUndefined(cond.comptype)) {
            cond.comptype = "AND";
        }
        condition.key = cond.key;
        condition.optype = cond.optype;
        condition.value = cond.value;
        condition.comptype = cond.comptype;
        condition.openbrace = cond.openbrace;
        condition.closebrace = cond.closebrace;
        kony.table.insert(query.conditions, condition);
    }
};
kony.sync.qb_insert = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_insert ");
    query.operationtype = "insert";
    query.tablename = tablename;
};
kony.sync.qb_purgeInsert = function(query, tablename, values) {
    sync.log.trace("Entering kony.sync.qb_purgeInsert ");
    query.operationtype = "insert";
    query.tablename = tablename;
    query.isPurge = true;
    if (kony.sync.isNullOrUndefined(kony.sync.queryStore[tablename + "purgeInsert"])) {
        kony.sync.qb_set(query, values);
    } else {
        query.purgeValues = values;
    }
};
kony.sync.qb_delete = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_delete ");
    query.operationtype = "delete";
    query.tablename = tablename;
};
kony.sync.qb_update = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_update ");
    query.operationtype = "update";
    query.tablename = tablename;
};
kony.sync.qb_select = function(query, fields) {
    sync.log.trace("Entering kony.sync.qb_select ");
    query.operationtype = "select";
    query.fields = fields;
};
kony.sync.qb_from = function(query, tablename) {
    sync.log.trace("Entering kony.sync.qb_from ");
    query.tablename = tablename;
};
kony.sync.qb_set = function(query, tabcolval) {
    sync.log.trace("Entering kony.sync.qb_set ");
    for (var key in tabcolval) {
        if (typeof(tabcolval[key]) != "function") {
            var value = tabcolval[key];
            if (!kony.sync.isNullOrUndefined(value)) {
                var colval = [];
                colval.key = key;
                colval.value = value;
                kony.table.insert(query.colvals, colval);
            }
        }
    }
};
kony.sync.qb_top = function(query, topno) {
    sync.log.trace("Entering kony.sync.qb_top ");
    query.topclause = " Top " + topno + " ";
};
kony.sync.qb_orderBy = function(query, orderByMap) {
    sync.log.trace("Entering kony.sync.qb_orderBy ");
    var orderByClause = "";
    if (!kony.sync.isNullOrUndefined(orderByMap)) {
        orderByClause = " order by ";
        var j = 0;
        for (var i in orderByMap) {
            if (j === 0) {
                orderByClause = orderByClause + " \"" + orderByMap[i].key + "\"";
                j++;
            } else {
                orderByClause = orderByClause + ",\"" + orderByMap[i].key + "\"";
            }
            if (orderByMap[i].sortType === "desc") {
                orderByClause = orderByClause + " desc";
            }
        }
    }
    query.orderbyclause = orderByClause;
};
kony.sync.qb_distinct = function(query) {
    sync.log.trace("Entering kony.sync.qb_distinct ");
    query.distinctclause = " distinct ";
};
kony.sync.qb_orderby1 = function(query, colname, isasec) {
    sync.log.trace("Entering kony.sync.qb_orderby1 ");
    if ((isasec)) {
        query.orderbyclause = " order by \"" + colname + "\"";
    } else {
        query.orderbyclause = " order by \"" + colname + "\" desc ";
    }
};
kony.sync.qb_createParam = function(pkey, query, pval, params) {
    sync.log.trace("Entering kony.sync.qb_createParam ");
    if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
        kony.table.insert(params, pval);
        return "?";
    } else if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
        query.paramindex = query.paramindex + 1;
        var param = "@" + pkey + query.paramindex;
        params[param] = pval;
        return param;
    }
};
kony.sync.qb_getupdatedfields = function(query) {
    sync.log.trace("Entering kony.sync.qb_getupdatedfields ");
    var updateStr = "";
    for (var i = 0; i < query.colvals; i++) {
        var v = query.colvals[i];
        if (i === 0) {
            updateStr = " set ";
        }
        if (v.value === "nil") {
            updateStr = updateStr + " \"" + v.key + "\"=" + "null";
        } else {
            updateStr = updateStr + " \"" + v.key + "\"=" + "'" + v.value + "'";
        }
        if (i < query.colvals.length - 1) {
            updateStr = updateStr + ",";
        }
    }
    return updateStr;
};
kony.sync.qb_getparamupdatedfields = function(query) {
    sync.log.trace("Entering kony.sync.qb_getparamupdatedfields ");
    var updateStr = "";
    var params = [];
    for (var i = 0; i < query.colvals.length; i++) {
        var v = query.colvals[i];
        if (i === 0) {
            updateStr = " set ";
        }
        if ((v.value === "nil")) {
            updateStr = updateStr + " \"" + v.key + "\"=" + "null";
        } else {
            var param = kony.sync.qb_createParam(v.key, query, v.value, params);
            updateStr = updateStr + " \"" + v.key + "\"=" + param;
        }
        if (i < query.colvals.length - 1) {
            updateStr = updateStr + ",";
        }
    }
    return [updateStr, params];
};
kony.sync.qb_getfieldstring = function(query) {
    sync.log.trace("Entering kony.sync.qb_getfieldstring ");
    var retstr = "";
    if (!kony.sync.isNullOrUndefined(query.fields)) {
        for (var i = 0; i < query.fields.length; i++) {
            var field = query.fields[i];
            retstr = retstr + field;
            if (query.fields.length - 1 !== i) {
                retstr = retstr + ",";
            }
        }
        return retstr;
    } else {
        return "*";
    }
};
kony.sync.qb_getoperatorString = function(optype, isnull) {
    sync.log.trace("Entering kony.sync.qb_getoperatorString ");
    if ((optype === "EQ")) {
        if ((isnull)) {
            return " is ";
        } else {
            return " = ";
        }
    } else if ((optype === "NOT_EQ")) {
        if ((isnull)) {
            return " is not ";
        } else {
            if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLCE)) {
                return " !== ";
            } else if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
                return " <> ";
            }
        }
    } else if ((optype === "GT")) {
        return " > ";
    } else if ((optype === "GT_EQ")) {
        return " >= ";
    } else if ((optype === "LT")) {
        return " < ";
    } else if ((optype === "LT_EQ")) {
        return " <= ";
    } else if ((optype === "LIKE")) {
        return " LIKE ";
    } else if ((optype === "NOT LIKE")) {
        return " NOT LIKE ";
    } else {
        return "";
    }
    return "MARS";
};
kony.sync.qb_getcompstring = function(comptype) {
    sync.log.trace("Entering kony.sync.qb_getcompstring ");
    if ((comptype === "AND")) {
        return " AND ";
    } else if ((comptype === "OR")) {
        return " OR ";
    } else {
        return "";
    }
};
kony.sync.qb_getwhereclause = function(query) {
    sync.log.trace("Entering kony.sync.qb_getwhereclause ");
    var retstr = "";
    if (!kony.sync.isNullOrUndefined(query.conditions)) {
        for (var i = 0; i < query.conditions.length; i++) {
            var condition = query.conditions[i];
            if (i === 0) {
                retstr = " WHERE ";
            }
            var conditionString = "";
            if ((condition.value === "nil")) {
                conditionString = "\"" + condition.key + "\" " + kony.sync.qb_getoperatorString(condition.optype, true) + "null";
            } else {
                conditionString = "\"" + condition.key + "\" " + kony.sync.qb_getoperatorString(condition.optype, false) + "'" + condition.value + "' ";
            }
            if (condition.openbrace === true) {
                conditionString = " ( " + conditionString;
            }
            if (condition.closebrace === true) {
                conditionString = conditionString + ")";
            }
            retstr = retstr + conditionString;
            if (i !== query.conditions.length - 1) {
                retstr = retstr + kony.sync.qb_getcompstring(condition.comptype);
            }
        }
    }
    return retstr;
};
kony.sync.qb_getparamwhereclause = function(query) {
    sync.log.trace("Entering kony.sync.qb_getparamwhereclause ");
    var retstr = "";
    var params = [];
    if (!kony.sync.isNullOrUndefined(query.conditions)) {
        for (var i = 0; i < query.conditions.length; i++) {
            var condition = query.conditions[i];
            if (i === 0) {
                retstr = " WHERE ";
            }
            var conditionString = "";
            if ((condition.value === "nil")) {
                conditionString = condition.key + kony.sync.qb_getoperatorString(condition.optype, true) + "null";
            } else {
                var param = kony.sync.qb_createParam(condition.key, query, condition.value, params);
                conditionString = condition.key + kony.sync.qb_getoperatorString(condition.optype, false) + param;
            }
            if (condition.openbrace === true) {
                conditionString = " ( " + conditionString;
            }
            if (condition.closebrace === true) {
                conditionString = conditionString + ")";
            }
            retstr = retstr + conditionString;
            if (i !== query.conditions.length - 1) {
                retstr = retstr + kony.sync.qb_getcompstring(condition.comptype);
            }
        }
    }
    return [retstr, params];
};
kony.sync.qb_getinsertcolums = function(query) {
    sync.log.trace("Entering kony.sync.qb_getinsertcolums ");
    var retstr = "(";
    var numCols = query.colvals.length;
    var count = 0;
    if (numCols === 0) {
        return "";
    }
    if (!kony.sync.isNullOrUndefined(query.colvals)) {
        for (var i = 0; i < query.colvals.length; i++) {
            var colval = query.colvals[i];
            count = count + 1;
            retstr = retstr + "\"" + colval.key + "\"";
            if ((count !== numCols)) {
                retstr = retstr + ",";
            }
        }
    }
    retstr = retstr + ")";
    return retstr;
};
kony.sync.qb_getinsertvalues = function(query) {
    sync.log.trace("Entering kony.sync.qb_getinsertvalues ");
    var retstr = "(";
    var numCols = query.colvals.length;
    if (numCols === 0) {
        return "";
    }
    if (!kony.sync.isNullOrUndefined(query.colvals)) {
        for (var i = 0; i < query.colvals.length; i++) {
            var colval = query.colvals[i];
            var value = "";
            if ((colval === "nil")) {
                value = "NULL";
            } else {
                value = "'" + colval.value + "'";
            }
            retstr = retstr + value;
            if ((i !== numCols)) {
                retstr = retstr + ",";
            }
        }
    }
    retstr = retstr + ")";
    return retstr;
};
kony.sync.qb_getparaminsertvalues = function(query) {
    sync.log.trace("Entering kony.sync.qb_getparaminsertvalues ");
    var retstr = "(";
    var params = [];
    var numCols = query.colvals.length;
    if (numCols === 0) {
        return "";
    }
    if (!kony.sync.isNullOrUndefined(query.colvals)) {
        for (var i = 0; i < query.colvals.length; i++) {
            var colval = query.colvals[i];
            var value = "";
            if ((colval === "nil")) {
                value = "NULL";
            } else {
                var param = kony.sync.qb_createParam(colval.key, query, colval.value, params);
                value = param;
            }
            retstr = retstr + value;
            if (i !== numCols - 1) {
                retstr = retstr + ",";
            }
        }
    }
    retstr = retstr + ")";
    return [retstr, params];
};
kony.sync.qb_gettablename = function(query) {
    sync.log.trace("Entering kony.sync.qb_gettablename ");
    return query.tablename;
};
//lmit and offset  for select
kony.sync.qb_limitOffset = function(query, limit, offset) {
    sync.log.trace("Entering kony.sync.qb_limitOffset ");
    if (!kony.sync.isNullOrUndefined(limit)) {
        if (kony.sync.isNullOrUndefined(offset)) {
            offset = 0;
        }
        if ((kony.sync.getBackEndDBType() === kony.sync.dbTypeSQLLite)) {
            query.limit = limit;
            query.offset = offset;
        }
    }
};
kony.sync.qb_compile = function(query) {
    sync.log.trace("Entering kony.sync.qb_compile ");
    var params = null;
    var sql = null;
    var wctable = null;
    var wc = null;
    var ret = null;
    if ((kony.sync.isParameter)) {
        ret = "";
        if ((query.operationtype === "insert")) {
            var insertstring = "";
            insertstring = "insert or ignore into ";
            if (query.isPurge === true) {
                if (!kony.sync.isNullOrUndefined(kony.sync.queryStore[query.tablename + "purgeInsert"])) {
                    return [kony.sync.queryStore[query.tablename + "purgeInsert"], query.purgeValues];
                }
            }
            var itable = kony.sync.qb_getparaminsertvalues(query);
            var iv = itable[0];
            params = itable[1];
            sql = insertstring + "\"" + kony.sync.qb_gettablename(query) + "\"" + kony.sync.qb_getinsertcolums(query) + " values " + iv;
            if (query.isPurge === true) {
                kony.sync.queryStore[query.tablename + "purgeInsert"] = sql;
            }
            return [sql, params];
        } else if ((query.operationtype === "select")) {
            wctable = kony.sync.qb_getparamwhereclause(query);
            wc = wctable[0];
            params = wctable[1];
            sql = "select " + query.distinctclause + query.topclause + kony.sync.qb_getfieldstring(query) + " from \"" + kony.sync.qb_gettablename(query) + "\"" + wc + query.orderbyclause;
            if (!kony.sync.isNullOrUndefined(query.limit)) {
                sql += " limit " + query.limit + " offset " + query.offset;
            }
            return [sql, params];
        } else if ((query.operationtype === "update")) {
            wctable = kony.sync.qb_getparamwhereclause(query);
            wc = wctable[0];
            var wparams = wctable[1];
            var uftable = kony.sync.qb_getparamupdatedfields(query);
            var uf = uftable[0];
            var uparams = uftable[1];
            sql = "Update \"" + kony.sync.qb_gettablename(query) + "\" " + uf + " " + wc;
            for (var i = 0; i < wparams.length; i++) {
                uparams.push(wparams[i]);
            }
            params = uparams;
            //kony.sync.syncPrint("update sql : " + sql);
            //kony.sync.syncPrint("update params : " + params);
            return [sql, params];
        } else if ((query.operationtype === "delete")) {
            wctable = kony.sync.qb_getparamwhereclause(query);
            wc = wctable[0];
            params = wctable[1];
            sql = "delete from \"" + kony.sync.qb_gettablename(query) + "\" " + wc;
            return [sql, params];
        }
    } else {
        ret = "";
        if ((query.operationtype === "select")) {
            sql = "select " + query.distinctclause + query.topclause + kony.sync.qb_getfieldstring(query) + " from \"" + kony.sync.qb_gettablename(query) + "\"" + kony.sync.qb_getwhereclause(query) + query.orderbyclause;
            return sql;
        } else if ((query.operationtype === "update")) {
            return "Update \"" + kony.sync.qb_gettablename(query) + "\" " + kony.sync.qb_getupdatedfields(query) + " " + kony.sync.qb_getwhereclause(query);
        } else if ((query.operationtype === "insert")) {
            return "insert into \"" + kony.sync.qb_gettablename(query) + "\"" + kony.sync.qb_getinsertcolums(query) + " values " + kony.sync.qb_getinsertvalues(query);
        } else if ((query.operationtype === "delete")) {
            return "delete from \"" + kony.sync.qb_gettablename(query) + "\" " + kony.sync.qb_getwhereclause(query);
        }
    }
};
//  **************** End konySyncQueryBuilder.js*******************
//  **************** Start konySyncQueryProvider.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.single_execute_sql = function(dsname, sqlstatement, params, result_successcallback, result_errorcallback) {
    sync.log.trace("Entering kony.sync.single_execute_sql-> main function");
    var single_execute_sql_result = null;
    var dbname = dsname;
    var isError = false;

    function single_execute_sql_transaction(tx) {
        sync.log.trace("Entering single_execute_sql_transaction");
        var resultset = kony.sync.executeSql(tx, sqlstatement, params, result_errorcallback);
        if (resultset !== false) {
            if (!(kony.sync.isNullOrUndefined(resultset.rows)) && resultset.rows.length > 0) {
                single_execute_sql_result = kony.db.sqlResultsetRowItem(tx, resultset, 0);
            }
        } else {
            isError = true;
        }
    }

    function single_execute_sql_transactionSucessCallback() {
        sync.log.trace("Entering kony.sync.single_execute_sql->single_execute_sql_transactionSucessCallback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(result_successcallback, single_execute_sql_result);
        }
    }

    function single_execute_sql_transactionErrorCallback() {
        sync.log.error("Entering kony.sync.single_execute_sql->single_execute_sql_transactionErrorCallback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(result_errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.verifyAndCallClosure(result_errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, result_errorcallback);
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, single_execute_sql_transaction, single_execute_sql_transactionSucessCallback, single_execute_sql_transactionErrorCallback, "Single Execute");
    }
};
kony.sync.single_select_execute = function(dsname, sql, params, success_callback, error_callback) {
    sync.log.trace("Entering kony.sync.single_select_execute ");
    var callback_result = [];
    var dbname = dsname;
    var isError = false;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_select_execute->single_transaction_success_callback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_select_execute->single_transaction_error_callback");
        if (!isError) {
            kony.sync.showTransactionError(error_callback);
        } else {
            sync.log.error("Entering kony.sync.single_select_execute->single_transaction_error_callback :", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.single_select_execute->single_transaction_callback");
        var resultSet = kony.sync.executeSql(tx, sql, params, error_callback);
        if (resultSet !== false) {
            if ((kony.sync.is_SQL_select(sql))) {
                var num_records = resultSet.rows.length;
                sync.log.debug("Single Select no of records:", num_records);
                for (var i = 0; i <= num_records - 1; i++) {
                    var record = kony.db.sqlResultsetRowItem(tx, resultSet, i);
                    kony.table.insert(callback_result, record);
                }
            }
        } else {
            isError = true;
        }
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
kony.sync.single_binary_select_ondemand_execute = function(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_ondemand_execute ");
    var response = {};
    var error = null;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_select_execute_binary_onDemand->single_select_binary_transaction_success");
        if (error) {
            sync.log.trace("Invoking error callback - single_binary_select_ondemand_execute");
            kony.sync.verifyAndCallClosure(errorCallback, response);
        } else if (Object.keys(response).length > 0) {
            sync.log.trace("Invoking success callback - single_binary_select_ondemand_execute");
            kony.sync.verifyAndCallClosure(successCallback, response);
        } else {
            sync.log.trace("No response from getBlobOnDemand. Downloading binaries in background.")
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_select_execute_binary_onDemand->single_select_binary_transaction_failed");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tbname].Pk_Columns;
        //validate whether we get all pks in the pk table.
        pks = kony.sync.validatePkTable(pkColumns, pks);
        sync.log.trace("after validation pks are " + JSON.stringify(pks));
        if (!kony.sync.isNullOrUndefined(pks)) {
            var blobRef = kony.sync.getBlobRef(tx, tbname, columnName, pks, errorCallback);
            sync.log.trace(kony.sync.binaryMetaColumnPrefix + columnName + " value is " + blobRef);
            if (!kony.sync.isNullOrUndefined(blobRef)) {
                if (blobRef === kony.sync.blobRefNotFound) {
                    //blobref is not found.
                    sync.log.trace("blobref not found.");
                    response.pkTable = pks;
                    if (blobType === kony.sync.BlobType.BASE64) {
                        response.base64 = null;
                    } else {
                        response.filePath = null;
                    }
                } else {
                    //check if there is any context info.
                    var blobContext = kony.sync.getBlobContext(tx, tbname, columnName, pks, errorCallback);
                    if (blobRef === kony.sync.blobRefNotDefined) {
                        if (blobContext !== kony.sync.blobRefNotDefined) {
                            //trigger download..
                            sync.log.trace("blobref not defined. triggering download");
                            var fetchBinaryResponse = kony.sync.blobManager.getBlobOnDemand(tx, kony.sync.blobRefNotDefined, blobType, tbname, columnName, config, pks, successCallback, errorCallback);
                            if (!kony.sync.isNullOrUndefined(fetchBinaryResponse)) {
                                if (fetchBinaryResponse.hasOwnProperty("errorCode")) {
                                    sync.log.trace("Received error response from getBlobOnDemand");
                                    error = fetchBinaryResponse;
                                } else {
                                    sync.log.trace("Received success response from getBlobONDemand");
                                    response = fetchBinaryResponse;
                                }
                            }
                        } else {
                            sync.log.info("no context available for download.");
                            response.pkTable = pks;
                            if (blobType === kony.sync.BlobType.BASE64) {
                                response.base64 = null;
                            } else {
                                response.filePath = null;
                            }
                        }
                    } else {
                        //fetch from blob store manager.
                        sync.log.trace("blobref defined. fetching from blobStoreManager table");
                        var fetchBinaryResponse = kony.sync.blobManager.getBlobOnDemand(tx, blobRef, blobType, tbname, columnName, config, pks, successCallback, errorCallback);
                        if (!kony.sync.isNullOrUndefined(fetchBinaryResponse)) {
                            if (fetchBinaryResponse.hasOwnProperty("errorCode")) {
                                sync.log.trace("Received error response from getBlobOnDemand");
                                error = fetchBinaryResponse;
                            } else {
                                sync.log.trace("Received success response from getBlobOnDemand");
                                response = fetchBinaryResponse;
                            }
                        }
                    }
                }
            }
        } else {
            //error invalid pks.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tbname));
        }
    }
    var connection = kony.sync.getConnectionOnly(dsname, dsname, errorCallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
    }
};
kony.sync.single_binary_select_inline_execute = function(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_inline_execute ");
    var response = {};
    var error = null;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_binary_select_inline_execute->single_transaction_success_callback");
        if (error) {
            kony.sync.verifyAndCallClosure(errorCallback, response);
        } else if (Object.keys(response).length > 0) {
            kony.sync.verifyAndCallClosure(successCallback, response);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_binary_select_inline_execute->single_transaction_error_callback");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        var scopename = kony.sync.scopes.syncTableScopeDic[tbname];
        var scope = kony.sync.scopes[scopename];
        var pkColumns = scope.syncTableDic[tbname].Pk_Columns;
        //validate whether we get all pks in the pk table.
        pks = kony.sync.validatePkTable(pkColumns, pks);
        if (!kony.sync.isNullOrUndefined(pks)) {
            var blobRef = kony.sync.getBlobRef(tx, tbname, columnName, pks, errorCallback);
            if (!kony.sync.isNullOrUndefined(blobRef)) {
                if (blobRef === -1) {
                    //No record exists with given pks.
                    response.pkTable = pks;
                    if (blobType === kony.sync.BlobType.BASE64) {
                        response.base64 = null;
                    } else {
                        response.filePath = null;
                    }
                } else {
                    //fetch from blob store manager.
                    var fetchBinaryResponse = kony.sync.blobManager.getBlobInline(tx, blobRef, blobType, tbname, columnName, config, pks, successCallback, errorCallback);
                    if (!kony.sync.isNullOrUndefined(fetchBinaryResponse)) {
                        if (fetchBinaryResponse.hasOwnProperty("errorCode")) {
                            error = fetchBinaryResponse;
                        } else {
                            response = fetchBinaryResponse;
                        }
                    }
                }
            } else {
                //blob doesn't exist for given record.
                response.pkTable = pks;
                if (blobType === kony.sync.BlobType.BASE64) {
                    response.base64 = null;
                } else {
                    response.filePath = null;
                }
            }
        } else {
            //error invalid pks.
            error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, tbname));
        }
    }
    if (kony.sync.isBinaryColumn(tbname, columnName) !== -1) {
        var connection = kony.sync.getConnectionOnly(dsname, dsname, errorCallback);
        if (connection !== null) {
            kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback);
        }
    } else {
        //not a binary column. return empty object.
        sync.log.warn("Request column is not a binary column. Empty response is sent");
        kony.sync.verifyAndCallClosure(successCallback, response);
    }
};
kony.sync.single_binary_select_execute = function(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_execute ");
    if (kony.sync.isValidFunctionType(successCallback) && kony.sync.isValidFunctionType(errorCallback)) {
        if (columnName === undefined || typeof(columnName) !== "string" || tbname === undefined || typeof(tbname) !== "string") {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeInvalidColumnParams, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidColumnParams));
            kony.sync.verifyAndCallClosure(errorCallback, error);
            return;
        }
        var downloadPolicy = kony.sync.getDownloadPolicy(tbname, columnName);
        sync.log.trace("download policy for the column " + tbname + "." + columnName + " is " + downloadPolicy);
        if (downloadPolicy !== kony.sync.notSupported) {
            if (downloadPolicy !== kony.sync.inline) {
                kony.sync.single_binary_select_ondemand_execute(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback);
            } else {
                //call inline base64 fetch.
                kony.sync.single_binary_select_inline_execute(dsname, tbname, columnName, pks, config, blobType, successCallback, errorCallback);
            }
        } else {
            var error = kony.sync.getErrorTable(kony.sync.errorCodeDownloadPolicyNotSupported, kony.sync.getErrorMessage(kony.sync.errorCodeDownloadPolicyNotSupported, tbname + "." + columnName));
            kony.sync.verifyAndCallClosure(errorCallback, error);
        }
    }
};
kony.sync.single_binary_select_base64_execute = function(dsname, tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_base64_execute-> main function");
    kony.sync.single_binary_select_execute(dsname, tbname, columnName, pks, config, kony.sync.BlobType.BASE64, successCallback, errorCallback);
};
kony.sync.single_binary_select_file_execute = function(dsname, tbname, columnName, pks, config, successCallback, errorCallback) {
    sync.log.trace("Entering kony.sync.single_binary_select_file_execute-> main function");
    kony.sync.single_binary_select_execute(dsname, tbname, columnName, pks, config, kony.sync.BlobType.FILE, successCallback, errorCallback);
};
/**
 * API is used to fetch stats of binary.. (state, status, error, lastUpdatedTimeStamp)
 * @param tbname
 * @param columnName
 * @param wc
 * @param successCallback
 * @param errorCallback
 */
kony.sync.insert_execute = function(tx, tbname, values, childRecordsArray, error_callback, markForUpload, response, options) {
    sync.log.trace("Entering kony.sync.insert_execute ");
    var callback_result;
    sync.log.trace("Entering kony.sync.insert_execute");
    //remove the binary values.
    var blobMap = {};
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        for (var i = 0; i < binaryColumns.length; i++) {
            if (!kony.sync.isNullOrUndefined(values[binaryColumns[i]]) && values[binaryColumns[i]].length > 0) blobMap[binaryColumns[i]] = values[binaryColumns[i]];
            delete values[binaryColumns[i]];
            //keeping the blob ref as NULL.
            values[kony.sync.binaryMetaColumnPrefix + binaryColumns[i]] = kony.sync.blobRefNotDefined;
        }
    }
    sync.log.trace("removed blob values from the record " + JSON.stringify(values));
    //check if pk_columns for autogenerated - false do not have not null values.
    var tableinfo = kony.sync.getTableInfo(tbname);
    if (kony.sync.isNullOrUndefined(tableinfo)) {
        //invalid table name sent.
        sync.log.error("invalid table name sent for insert operation " + tbname);
        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeInvalidTableName, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidTableName, tbname));
        return false;
    }
    if (!kony.sync.isNullOrUndefined(tableinfo.Pk_Columns)) {
        for (var j = 0; j < tableinfo.Pk_Columns.length; j++) {
            var pkKey = tableinfo.Pk_Columns[j];
            if (tableinfo.ColumnsDic[pkKey].Autogenerated === "false" && kony.sync.isNullOrUndefined(values[pkKey])) {
                //received null for a non auto-generated pk.
                sync.log.error("received null for pk column " + pkKey);
                kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeNullPrimaryKeyValue, kony.sync.getErrorMessage(kony.sync.errorCodeNullPrimaryKeyValue, pkKey));
                return false;
            }
        }
    }
    //CallBack_result contains AutoGenerated PK in hash ({id = value})
    callback_result = kony.sync.insert(tx, tbname, values, error_callback, markForUpload, options);
    if (response.hasOwnProperty(tbname)) {
        //it is a child record. update the array.
        response[tbname].push(callback_result);
    } else {
        response = callback_result;
    }
    if (callback_result === false || kony.sync.isNullOrUndefined(callback_result)) {
        sync.log.error("error in inserting record into " + tbname);
        if (kony.sync.errorObject !== null && kony.sync.errorObject.errorInfo !== null) {
            var errorInfo = kony.sync.errorObject.errorInfo;
            if (errorInfo.dbError && errorInfo.dbError.message) {
                var dbErrorMessage = errorInfo.dbError.message;
                var columnNameWithTable = (dbErrorMessage.split(": ")[1]).split(" ")[0]; //columnNameWithTable = "tableName.columnName"
                var columnName = columnNameWithTable.slice(tbname.length + 1, columnNameWithTable.length); //columnName = "columnName"
                if (dbErrorMessage.search("UNIQUE constraint failed") === 0) {
                    //error message simiar to "UNIQUE constraint failed: tableName.columnName (code 1555)"
                    //checking for columnName in Pk_columns
                    if (tableinfo.Pk_Columns.indexOf(columnName) >= 0) {
                        //columnName is a Primary Key
                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeDuplicatePrimaryKey, kony.sync.getErrorMessage(kony.sync.errorCodeDuplicatePrimaryKey, tbname, columnName), errorInfo);
                    } else {
                        //columnName is a Unique Key
                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeDuplicateUniqueKey, kony.sync.getErrorMessage(kony.sync.errorCodeDuplicateUniqueKey, tbname, columnName), errorInfo);
                    }
                } else if (dbErrorMessage.search("NOT NULL constraint failed") === 0) {
                    kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeMandatoryAttribute, kony.sync.getErrorMessage(kony.sync.errorCodeMandatoryAttribute, tbname, columnName), errorInfo);
                }
            }
        }
        return false;
    } else {
        sync.log.trace("inserted into " + tbname + " with result " + JSON.stringify(callback_result));
        //if insert is successful create rows in blobstore manager for the binary columns.
        if (Object.keys(blobMap).length > 0) {
            var blobStoreIndices = kony.sync.blobstore_insert(tx, tbname, blobMap, error_callback);
            sync.log.trace("inserted blobMap into the blobStoreManager. response is " + JSON.stringify(blobStoreIndices));
            if (blobStoreIndices && Object.keys(blobStoreIndices).length > 0) {
                //update the parent table with blob references.
                var wcs = [];
                for (var key in callback_result) {
                    var wc = {};
                    wc.key = key;
                    wc.value = callback_result[key];
                    wcs.push(wc);
                }
                var resultset = kony.sync.blobManager.updateParentWithBlobReference(tx, tbname, blobStoreIndices, wcs, error_callback);
                sync.log.trace("updating the blob reference in the table " + tbname);
                if (resultset === false || kony.sync.isNullOrUndefined(resultset)) {
                    sync.log.error("error in updating table " + tbname + " with blob references..");
                    return false;
                }
            } else {
                sync.log.error("error in inserting blob data ");
                return false;
            }
        }
    }
    //check for child records.
    if (childRecordsArray.length > 0) {
        sync.log.trace("There are child records... Inserting them");
        for (var k = 0; k < childRecordsArray.length; k++) {
            var childRecordObject = childRecordsArray[k];
            //child records are json objects with childTable name as key.
            for (var table in childRecordObject) {
                if (!response.hasOwnProperty(table)) {
                    response[table] = [];
                }
                //child records are expected to be arary.
                sync.log.trace("inserting child record in table " + table);
                if (childRecordObject[table] instanceof Array) {
                    for (var childRecordsCount = 0; childRecordsCount < childRecordObject[table].length; childRecordsCount++) {
                        //before inserting child records, first remove the nested child records
                        var childRecordToBeInserted = childRecordObject[table][childRecordsCount];
                        var nestedChildRecords = kony.sync.getChildRecords(table, childRecordToBeInserted);
                        sync.log.trace("child records for " + table + " are " + JSON.stringify(nestedChildRecords));
                        //getting the relationship attributes
                        var parentRelationAttributes = kony.sync.getParentRelationshipAttributes(tbname, table);
                        sync.log.trace("parentRelationAttributes for " + tbname + " and " + table + " are " + JSON.stringify(parentRelationAttributes));
                        //adding the values from the generated primary keys.
                        if (!kony.sync.isNullOrUndefined(parentRelationAttributes)) {
                            for (var count in parentRelationAttributes) {
                                var relationAttribute = parentRelationAttributes[count];
                                //check if callback has mapping source attribute
                                if (callback_result.hasOwnProperty(relationAttribute[kony.sync.sourceAttribute]) && !kony.sync.isNullOrUndefined(callback_result[relationAttribute[kony.sync.sourceAttribute]])) {
                                    childRecordToBeInserted[relationAttribute[kony.sync.targetAttribute]] = callback_result[relationAttribute[kony.sync.sourceAttribute]];
                                } else if (values.hasOwnProperty(relationAttribute[kony.sync.sourceAttribute]) && !kony.sync.isNullOrUndefined(values[relationAttribute[kony.sync.sourceAttribute]])) {
                                    childRecordToBeInserted[relationAttribute[kony.sync.targetAttribute]] = values[relationAttribute[kony.sync.sourceAttribute]];
                                } else {
                                    //no mapping source attribute found.
                                    kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeParentMappingAttributeNotFound, kony.sync.getErrorMessage(kony.sync.errorCodeParentMappingAttributeNotFound, relationAttribute[kony.sync.sourceAttribute]));
                                    sync.log.error("no mapping source attribute found from values sent.." + tbname);
                                    return false;
                                }
                            }
                        }
                        var childResponse = {};
                        var childRecordInsertResult = kony.sync.insert_execute(tx, table, childRecordToBeInserted, nestedChildRecords, error_callback, markForUpload, childResponse, options);
                        if (childRecordInsertResult === false || kony.sync.isNullOrUndefined(childRecordInsertResult)) {
                            sync.log.error("error in inserting record " + JSON.stringify(childRecordToBeInserted));
                            return false;
                        }
                        if (response.hasOwnProperty(table)) {
                            response[table].push(childRecordInsertResult);
                        }
                        sync.log.trace("after inserting record in " + table + " response is " + JSON.stringify(childRecordInsertResult));
                    }
                } else {
                    kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeChildObjectShouldBeArray, kony.sync.getErrorMessage(kony.sync.errorCodeChildObjectShouldBeArray));
                    sync.log.error("improper format for sending child objects. ");
                    return false;
                }
            }
        }
    }
    sync.log.trace("callback_result returning for table " + tbname + " is " + JSON.stringify(callback_result));
    return callback_result;
};
kony.sync.update_execute = function(tx, tbname, values, childRecordsArray, wc, isBatch, markForUpload, primaryKey, error_callback, options) {
    sync.log.trace("Entering kony.sync.update_execute ");
    var callback_result;
    var blobMap = {};
    if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
        var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
        for (var i = 0; i < binaryColumns.length; i++) {
            if (!kony.sync.isNullOrUndefined(values[binaryColumns[i]]) && values[binaryColumns[i]].length > 0) blobMap[binaryColumns[i]] = values[binaryColumns[i]];
            delete values[binaryColumns[i]];
        }
    }
    if (isBatch === true) {
        callback_result = kony.sync.updateBatch(tx, tbname, values, wc, markForUpload, primaryKey, options);
    } else {
        callback_result = kony.sync.update(tx, tbname, values, wc, markForUpload, options);
    }
    if (callback_result === false || kony.sync.isNullOrUndefined(callback_result)) {
        return false;
    } else {
        if (Object.keys(blobMap).length > 0) {
            var blobStoreIndices = kony.sync.blobstore_update(tx, tbname, blobMap, wc, isBatch, error_callback);
            if (blobStoreIndices && Object.keys(blobStoreIndices).length > 0) {
                var results = kony.sync.blobManager.updateParentWithBlobReference(tx, tbname, blobStoreIndices, wc, error_callback);
                if (results === false || results === null) {
                    sync.log.error("error in updating parent table with blob reference..");
                    return false;
                }
            } else {
                sync.log.error("Null returned from blobstore_update.");
                return false;
            }
        }
        //check for the child records.
        if (childRecordsArray.length > 0) {
            for (var k = 0; k < childRecordsArray.length; k++) {
                var childRecordObject = childRecordsArray[k];
                for (var table in childRecordObject) {
                    sync.log.trace("updating child record in table " + table);
                    if (childRecordObject[table] instanceof Array) {
                        for (var childRecordsCount = 0; childRecordsCount < childRecordObject[table].length; childRecordsCount++) {
                            //first remove nested childrecords from the values table.
                            var childRecordToBeUpdated = childRecordObject[table][childRecordsCount];
                            var nestedChildRecords = kony.sync.getChildRecords(table, childRecordToBeUpdated);
                            sync.log.trace("child records for " + table + " are " + JSON.stringify(nestedChildRecords));
                            //get pkTable from the childRecord.
                            var pkTable = kony.sync.getPkTableFromJSON(childRecordToBeUpdated, table);
                            sync.log.trace("pkTable for the table " + table + " is " + JSON.stringify(pkTable));
                            if (pkTable && Object.keys(pkTable).length > 0) {
                                //create a whereclause from pkTable.
                                var whereClause = [];
                                for (var key in pkTable) {
                                    if (!kony.sync.isNullOrUndefined(pkTable[key])) {
                                        var child_wc = {};
                                        child_wc.key = key;
                                        child_wc.value = pkTable[key];
                                        child_wc.comptype = "AND";
                                        whereClause.push(child_wc);
                                    } else {
                                        //null send as pkValue. throw error
                                        sync.log.error("received null for pk column " + pkTable[key]);
                                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeNullPrimaryKeyValue, kony.sync.getErrorMessage(kony.sync.errorCodeNullPrimaryKeyValue, pkTable[key]));
                                        return false;
                                    }
                                }
                                if (whereClause.length > 0) {
                                    var childRecordUpdateResult = kony.sync.update_execute(tx, table, childRecordToBeUpdated, nestedChildRecords, whereClause, isBatch, markForUpload, primaryKey, error_callback, options);
                                    if (childRecordUpdateResult === false || kony.sync.isNullOrUndefined(childRecordUpdateResult)) {
                                        sync.log.error("error in updating record " + JSON.stringify(childRecordUpdateResult));
                                        return false;
                                    }
                                    sync.log.trace("after updating record in " + table + " response is " + JSON.stringify(childRecordUpdateResult));
                                }
                            } else {
                                kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeInvalidPksGiven, kony.sync.getErrorMessage(kony.sync.errorCodeInvalidPksGiven, table));
                                sync.log.error("invalid pks send for update of record in " + table);
                                return false;
                            }
                        }
                    } else {
                        sync.log.error("improper format for sending child objects. ");
                        kony.sync.errorObject = kony.sync.getErrorTable(kony.sync.errorCodeChildObjectShouldBeArray, kony.sync.getErrorMessage(kony.sync.errorCodeChildObjectShouldBeArray));
                        return false;
                    }
                }
            }
        }
    }
    return callback_result;
};
kony.sync.single_insert_execute = function(dsname, tbname, values, success_callback, error_callback, markForUpload, options) {
    sync.log.trace("Entering kony.sync.single_insert_execute-> main function");
    var callback_result = [];
    var dbname = dsname;

    function single_transaction_success_callback() {
        sync.log.trace("Entering kony.sync.single_insert_execute->single_transaction_success_callback");
        if (callback_result) {
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        } else {
            single_transaction_failure_callback()
        }
    }

    function single_transaction_failure_callback() {
        sync.log.error("Entering kony.sync.single_insert_execute->single_transaction_failure_callback");
        sync.log.error("Entering kony.sync.single_insert_execute->single_transaction_failure_callback : ", kony.sync.errorObject);
        kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering single_transaction_callback");
        //from the values table, remove the child table records if exists.
        var childRecordsArray = kony.sync.getChildRecords(tbname, values);
        var response = {};
        callback_result = kony.sync.insert_execute(tx, tbname, values, childRecordsArray, error_callback, markForUpload, response, options);
        if (kony.sync.isNullOrUndefined(callback_result) || callback_result === false) {
            sync.log.error("single_insert_execute -> single_transaction_callback rolling back changes");
            try {
                kony.sync.rollbackTransaction(tx);
            } catch (err) {
                sync.log.error("single_insert_execute - error in rollbackTransaction ", err);
            }
        }
        sync.log.info("response from insert operation " + JSON.stringify(callback_result));
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_failure_callback);
    }
};
kony.sync.single_update_execute = function(dsname, tbname, values, wc, success_callback, error_callback, isBatch, markForUpload, primaryKey, options) {
    sync.log.trace("Entering kony.sync.single_update_execute ");
    var callback_result = {};
    var dbname = dsname;

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (callback_result === false) {
            single_transaction_error_callback();
        } else {
            sync.log.trace("Entering kony.sync.single_update_execute->single_transaction_success_callback ");
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        }
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_update_execute->single_transaction_error_callback");
        sync.log.error("Entering kony.sync.single_update_execute->single_transaction_error_callback :", kony.sync.errorObject);
        kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.single_update_execute->single_transaction_callback");
        //from the values table, remove the child table records if exists.
        var childRecordsArray = kony.sync.getChildRecords(tbname, values);
        //(tx, tbname, values,childRecordsArray, wc, isBatch, markForUpload, primaryKey , error_callback)
        callback_result = kony.sync.update_execute(tx, tbname, values, childRecordsArray, wc, isBatch, markForUpload, primaryKey, error_callback, options);
        if (kony.sync.isNullOrUndefined(callback_result) || callback_result === false) {
            sync.log.error("single_update_execute -> single_transaction_callback rolling back changes");
            try {
                kony.sync.rollbackTransaction(tx);
            } catch (err) {
                sync.log.error("single_insert_execute - error in rollbackTransaction ", err);
            }
        }
        sync.log.info("response from update operation " + JSON.stringify(callback_result));
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback, "Single Update Execute");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Single Update Execute");
    }
};
kony.sync.delete_execute = function(tx, tbname, wc, isBatch, isLocal, markForUpload, error_callback, options) {
    sync.log.trace("Entering kony.sync.delete_execute ");
    //get records satisfying given where clause for tbname.
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tbname);
    kony.sync.qb_where(query, wc);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var result_set = kony.sync.executeSql(tx, sql, params, error_callback);
    if (result_set !== null && result_set !== false) {
        //get child relationships for the tbname.
        var relationships = kony.sync.getRelationshipsForTable(tbname);
        sync.log.trace("delete_execute relationships for tbname " + tbname + " are " + JSON.stringify(relationships));
        if (!kony.sync.isNullOrUndefined(relationships) && !kony.sync.isNullOrUndefined(relationships[kony.sync.oneToMany])) {
            sync.log.trace("tbname " + tbname + " has oneToMany relationships");
            var oneToManyRelationships = relationships[kony.sync.oneToMany];
            for (var j = 0; j < oneToManyRelationships.length; j++) {
                //get the target object and delete.
                var relationshipTargetObject = oneToManyRelationships[j][kony.sync.targetObject];
                sync.log.trace("target object on oneToMany relation for " + tbname + " is " + relationshipTargetObject);
                //fetch the source-target mapping for the one-many relation.
                var parentRelationAttributes = kony.sync.getParentRelationshipAttributes(tbname, relationshipTargetObject);
                sync.log.trace("parentRelationAttributes for " + tbname + " and " + relationshipTargetObject + " are " + JSON.stringify(parentRelationAttributes));
                //parse through the result_Set and create where clause for the childs to get deleted.
                if (parentRelationAttributes) {
                    for (var k = 0; k < result_set.rows.length; k++) {
                        //creating a where clause to delete childs as well.
                        var whereClause = [];
                        for (var count in parentRelationAttributes) {
                            var relationAttribute = parentRelationAttributes[count];
                            var rowItem = kony.db.sqlResultsetRowItem(tx, result_set, k);
                            if (!kony.sync.isNullOrUndefined(rowItem[relationAttribute[kony.sync.sourceAttribute]])) {
                                var child_wc = {};
                                child_wc.key = relationAttribute[kony.sync.targetAttribute];
                                child_wc.value = rowItem[relationAttribute[kony.sync.sourceAttribute]];
                                whereClause.push(child_wc);
                            }
                        }
                        sync.log.trace("whereClause for deleting in tbname " + relationshipTargetObject + " is " + JSON.stringify(whereClause));
                        //delete the child first before deleting the parent.
                        if (whereClause.length > 0) {
                            var childRecordDeleteResult = kony.sync.delete_execute(tx, relationshipTargetObject, whereClause, isBatch, isLocal, markForUpload, error_callback, options);
                            if (childRecordDeleteResult === null || childRecordDeleteResult === false) {
                                return false;
                            }
                        } else {
                            //no child records to delete..
                            sync.log.trace("For table " + tbname + " no child records to delete...");
                        }
                    }
                }
            }
        }
        //delete the record once, childs are deleted.
        var callback_result;
        var isBlobDeleted = kony.sync.blobstore_delete(tx, tbname, wc, isBatch, function(err) {
            sync.log.error("kony.sync.delete_exeucte - error in deleting blob values for the table " + tbname);
        });
        sync.log.trace("kony.sync.delete_execute - result from blobstore_delete is " + isBlobDeleted);
        if (isBlobDeleted) {
            if (isBatch === true) {
                callback_result = kony.sync.deleteBatch(tx, tbname, wc, isLocal, markForUpload, error_callback, options);
            } else {
                callback_result = kony.sync.remove(tx, tbname, wc, isLocal, markForUpload, error_callback, options);
            }
        }
        if (callback_result === false) {
            sync.log.error("kony.sync.delete_execute - error in deletion of records in tbname " + tbname);
            return false;
        }
        return callback_result;
    }
    sync.log.error("kony.sync.delete_execute - error in sql select operation on the table " + tbname);
    return false;
};
kony.sync.single_delete_execute = function(dsname, tbname, wc, success_callback, error_callback, isBatch, isLocal, markForUpload, options) {
    sync.log.trace("Entering kony.sync.single_delete_execute-> main function");
    var callback_result = [];
    var dbname = dsname;
    var isError = false;

    function single_transaction_success_callback() {
        sync.log.trace("Entering single_transaction_success_callback");
        if (callback_result === false) {
            single_transaction_error_callback();
        } else {
            sync.log.trace("Entering kony.sync.single_delete_execute->single_transaction_success_callback ");
            kony.sync.verifyAndCallClosure(success_callback, callback_result);
        }
    }

    function single_transaction_callback(tx) {
        sync.log.trace("Entering kony.sync.single_delete_execute->single_transaction_callback");
        callback_result = kony.sync.delete_execute(tx, tbname, wc, isBatch, isLocal, markForUpload, error_callback, options);
        if (kony.sync.isNullOrUndefined(callback_result) || callback_result === false) {
            sync.log.error("single_delete_execute -> single_transaction_callback rolling back changes");
            try {
                kony.sync.rollbackTransaction(tx);
            } catch (err) {
                sync.log.error("single_insert_execute - error in rollbackTransaction ", err);
            }
        }
        sync.log.info("response from delete operation " + JSON.stringify(callback_result));
    }

    function single_transaction_error_callback() {
        sync.log.error("Entering kony.sync.single_delete_execute->single_transaction_error_callback");
        sync.log.error("Entering kony.sync.single_delete_execute->single_transaction_error_callback :", kony.sync.errorObject);
        kony.sync.verifyAndCallClosure(error_callback, kony.sync.errorObject);
        kony.sync.errorObject = null;
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, error_callback, "Single Delete Execute");
    if (connection !== null) {
        kony.sync.startTransaction(connection, single_transaction_callback, single_transaction_success_callback, single_transaction_error_callback, "Single Delete Execute");
    }
};
kony.sync.massInsert = function(dsname, tbname, valuesArray, successCallback, errorCallback, markForUpload) {
    sync.log.trace("Entering kony.sync.massInsert-> main function");
    var callbackResult = [];
    var dbname = dsname;

    function massInsertTransactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.massInsert->massInsertTransactionSuccessCallback");
        kony.sync.verifyAndCallClosure(successCallback, callbackResult);
    }

    function massInsertTransactionErrorCallback() {
        sync.log.error("Entering kony.sync.massInsert->massInsertTransactionErrorCallback");
        kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
    }

    function massInsertTransactionCallback(tx) {
        sync.log.trace("Entering kony.sync.massInsert->massInsertTransactionCallback");
        //CallBack_result contains AutoGenerated PK in hash ({id = value})
        for (var i = 0; i < valuesArray.length; i++) {
            callbackResult.push(kony.sync.insert(tx, tbname, valuesArray[i], null, markForUpload));
        }
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    kony.sync.startTransaction(connection, massInsertTransactionCallback, massInsertTransactionSuccessCallback, massInsertTransactionErrorCallback);
};
kony.sync.massUpdate = function(dbname, tbname, inputArray, successCallback, errorCallback, markForUpload, primaryKey) {
    sync.log.trace("Entering  kony.sync.massUpdate");
    var callbackResultTemp;
    var callbackResult = 0;
    var isError = false;
    var connection = kony.sync.getConnectionOnly(dbname, dbname, errorCallback);
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.massUpdate-> transactionSuccessCallback");
        if (!isError) {
            kony.sync.verifyAndCallClosure(successCallback, {
                rowsUpdated: callbackResult
            });
        }
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering kony.sync.massUpdate-> transactioncallback");
        for (var i = 0; i < inputArray.length; i++) {
            callbackResultTemp = kony.sync.updateBatch(tx, tbname, inputArray[i].changeSet, inputArray[i].whereClause, markForUpload, primaryKey);
            if (callbackResultTemp === false) {
                isError = true;
                return;
            }
            callbackResult += callbackResultTemp.rowsupdated;
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        if (!isError) {
            kony.sync.showTransactionError(errorCallback, "Sync Mass Update");
        } else {
            sync.log.error("Entering kony.sync.massUpdate->transactionErrorCallback :", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorCallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
};
/*This method will open a transaction and then executes the array of queries*/
kony.sync.executeQueries = function(queries, callback) {
    sync.log.trace("Entering kony.sync.executeQueries");
    if (kony.sync.isNullOrUndefined(queries)) {
        kony.sync.verifyAndCallClosure(callback, true);
        return;
    }
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        for (var i = 0; i < queries.length; i++) {
            if (kony.sync.executeSql(tx, queries[i], null) === false) {
                isError = true;
                return;
            }
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        kony.sync.verifyAndCallClosure(callback, false);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.verifyAndCallClosure(callback, true, kony.sync.getTransactionError(isError));
    }
};
/*This method will execute the array of queries provided the transaction is already open*/
kony.sync.executeQueriesInTransaction = function(tx, queries) {
    sync.log.trace("Entering kony.sync.executeQueriesInTransaction");
    if (kony.sync.isNullOrUndefined(queries)) {
        return true;
    }
    for (var i = 0; i < queries.length; i++) {
        if (kony.sync.executeSql(tx, queries[i], null) === false) {
            return false;
        }
    }
    return true;
};
//this API is for developers who want to execute custom sql SELECT queries
sync.executeSelectQuery = function(query, successcallback, errorcallback) {
    sync.log.trace("Entering sync.executeSelectQuery -> main function");
    var dbname = kony.sync.getDBName();
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var resultItems = [];
    var isError = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, executeSelectQueryTransactionCallback, executeSelectQuerySuccessCallback, executeSelectQueryErrorCallback);
    }

    function executeSelectQueryTransactionCallback(tx) {
        sync.log.trace("Entering sync.executeSelectQuery -> transaction callback");
        var resultSet = kony.sync.executeSql(tx, query, null);
        if (resultSet === false) {
            isError = true;
            return;
        }
        // Adding a null check as in some cases resultSet is not null but it does not contains rows.
        if (!kony.sync.isNullOrUndefined(resultSet) && resultSet.rows) {
            for (var i = 0; i < resultSet.rows.length; i++) {
                resultItems[i] = kony.db.sqlResultsetRowItem(tx, resultSet, i);
            }
        }
    }

    function executeSelectQuerySuccessCallback() {
        sync.log.trace("Entering sync.executeSelectQuery -> success callback");
        kony.sync.verifyAndCallClosure(successcallback, resultItems);
    }

    function executeSelectQueryErrorCallback() {
        sync.log.trace("Entering sync.executeSelectQuery -> error callback");
        kony.sync.callTransactionError(isError, errorcallback);
    }
};
//  **************** End konySyncQueryProvider.js*******************
//  **************** End konySyncQueryProvider.js*******************
//  **************** Start KonySyncReset.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.scopeReset = function(scopename, successcallback, failurecallback) {
    sync.log.trace("Entering kony.sync.scopeReset->main function");
    var currentScope = kony.sync.scopes[scopename];
    var dbname = kony.sync.getDBName();
    var isStatementError = false;
    var exceptionMessage = null;
    var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, failurecallback);
    if (dbconnection !== null) {
        kony.sync.startTransaction(dbconnection, ScopeResetTransaction, ScopeResetSuccess, ScopeResetFailure);
    }

    function ScopeResetTransaction(tx) {
        sync.log.trace("Entering kony.sync.scopeReset->transaction function");
        try {
            if (!kony.sync.isNullOrUndefined(currentScope.ScopeTables)) {
                for (var i = 0; i < currentScope.ScopeTables.length; i++) {
                    var syncTable = currentScope.ScopeTables[i];
                    var tbname = syncTable.Name;
                    if (!kony.sync.deleteTable(tx, tbname)) {
                        isStatementError = true;
                        break;
                    }
                }
            }
        } catch (e) {
            exceptionMessage = e;
            throw ("");
        }
        if (!kony.sync.resetMetaTableForScope(tx, scopename)) {
            isStatementError = true;
        }
    }

    function ScopeResetSuccess() {
        sync.log.trace("Entering kony.sync.scopeReset->success callback function");
        kony.sync.verifyAndCallClosure(successcallback, "Scope Reset Successful");
    }

    function ScopeResetFailure() {
        sync.log.error("Entering kony.sync.scopeReset->failure callback function");
        if (isStatementError) {
            kony.sync.verifyAndCallClosure(failurecallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        } else {
            if (exceptionMessage !== null) {
                kony.sync.verifyAndCallClosure(failurecallback, kony.sync.getErrorTable(kony.sync.errorUnknown, kony.sync.getErrorMessage(kony.sync.errorUnknown, "Scope Reset", exceptionMessage), null));
            } else {
                kony.sync.showTransactionError(failurecallback, "Scope Reset");
            }
        }
    }
};
kony.sync.deleteTable = function(tx, tbname) {
    sync.log.trace("Entering kony.sync.deleteTable function");
    if (kony.sync.deleteTableHelper(tx, tbname + kony.sync.historyTableName) === false) {
        return false;
    }
    if (kony.sync.deleteTableHelper(tx, tbname + kony.sync.originalTableName) === false) {
        return false;
    }
    if (kony.sync.deleteTableHelper(tx, tbname) === false) {
        return false;
    }
    return true;
};
kony.sync.deleteTableHelper = function(tx, tbname) {
    sync.log.trace("Entering kony.sync.deleteTableHelper function");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, tbname);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
kony.sync.resetMetaTableForScope = function(tx, scopeName) {
    sync.log.trace("Entering kony.sync.resetMetaTableForScope function");
    var query = kony.sync.qb_createQuery();
    var wcs = [];
    kony.sync.qb_set(query, {
        versionnumber: 0,
        lastserversynccontext: "",
        replaysequencenumber: 0,
        lastgeneratedid: -1
    });
    kony.table.insert(wcs, {
        key: kony.sync.metaTableScopeColumn,
        value: scopeName,
        optype: "EQ"
    });
    kony.sync.qb_where(query, wcs);
    kony.sync.qb_update(query, kony.sync.metaTableName);
    //local sql = "insert into "..kony.sync.metaTableName.." (id,scopename,versionnumber,lastserversynccontext,replaysequencenumber,lastgeneratedid) values ('"..id.."','"..scope.ScopeName.."','0','','0','-1')"
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    return kony.sync.executeSql(tx, sql, params);
};
//  **************** End KonySyncReset.js*******************
//  **************** Start KonySyncRetryHelper.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
//Repetitively calls a service until number of attempts
kony.sync.retryServiceCall = function(url, result, infoObj, retryCount, callback, params) {
    sync.log.trace("Entering kony.sync.retryServiceCall");
    sync.log.error("Error while hitting " + url + " : ", result);
    sync.log.info("Retrying[" + retryCount + " retries left] ....");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var params1 = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onRetry], {
        "request": params,
        "errorResponse": result,
        "retryCount": (kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey] - retryCount)
    });
    if (!kony.sync.isNullOrUndefined(params1)) {
        params = params1;
    }
    var retryWait = 1; //default retry time is 1 second
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.retryWaitKey])) {
        retryWait = kony.sync.tonumber(kony.sync.currentSyncConfigParams[kony.sync.retryWaitKey]);
    }
    sync.log.trace("kony.sync.retryServiceCall, retryWait is: " + retryWait);
    if (!kony.sync.isAppInBackground) {
        kony.timer.schedule("syncRetryTimer", retryTimerCallback, retryWait, false);
    } else {
        retryTimerCallback();
    }

    function downloadNetworkCallbackStatus(status, callResult, info) {
        sync.log.trace("Entering downloadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.retryServiceCall->downloadNetworkCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (retryCount > 0 && kony.sync.checkForRetryErrorCodes(callResult.opstatus)) {
                retryCount--;
                kony.sync.retryServiceCall(url, callResult, info, retryCount, callback, params);
            } else {
                callback(callResult, info, retryCount);
            }
        } else if (status === 300) {
            sync.log.warn("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, Got status 300 i.e.  Network call Cancelled.");
            if (kony.sync.checkForRetryOnNetworkCancel(url, info) === true) {
                if (retryCount > 0) {
                    retryCount--;
                    sync.log.debug("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, Retrying the network call for status 300 ");
                    if (kony.sync.isNullOrUndefined(callResult)) {
                        callResult = kony.sync.getNetworkCancelError();
                    }
                    kony.sync.retryServiceCall(url, callResult, info, retryCount, callback, params);
                } else {
                    sync.log.error("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, All retries exhausted, now raising Network Cancel Error.");
                    callback(kony.sync.getNetworkCancelError(), info, retryCount);
                }
            } else {
                sync.log.error("kony.sync.retryServiceCall->downloadNetworkCallbackStatus, raising Network Cancel Error ");
                callback(kony.sync.getNetworkCancelError(), info, retryCount);
            }
        }
    }

    function retryTimerCallback() {
        sync.log.trace("Entering kony.sync.retryServiceCall->retryTimerCallback");
        kony.sync.invokeServiceAsync(url, params, downloadNetworkCallbackStatus, infoObj);
    }
};
//Checks whether an error code is eligible for retry or not
kony.sync.checkForRetryErrorCodes = function(key) {
    sync.log.trace("Entering kony.sync.checkForRetryErrorCodes, for key: " + key);
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.retryErrorCodes])) {
        return kony.sync.contains(kony.sync.currentSyncConfigParams[kony.sync.retryErrorCodes], key);
    } else {
        return kony.sync.contains([1000, 1013, 1014, 1015], key);
    }
};
kony.sync.eligibleForRetry = function(opstatus, info) {
    sync.log.trace("Entering kony.sync.eligibleForRetry");
    return !kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey]) && info > 0 && kony.sync.checkForRetryErrorCodes(opstatus);
};
kony.sync.checkForRetryOnNetworkCancel = function(url, info) {
        sync.log.info("Entering kony.sync.checkForRetryOnNetworkCancel ,   url:  " + url + ", and info is: " + info);
        if (kony.sync.getDownloadURL() === url || kony.sync.getChunkDownloadURL() === url) {
            return true;
        }
        if (!kony.sync.isNullOrUndefined(info) && !kony.sync.isNullOrUndefined(info.retryOnNetworkCancel)) {
            return info.retryOnNetworkCancel;
        }
        return false;
    }
    //  **************** End KonySyncRetryHelper.js*******************
    //  **************** Start KonySyncRollBack.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.konySyncRollBackPendingChanges = function(tbname, dbname, wcs, successcallback, errorcallback, isGlobal, count) {
    sync.log.trace("Entering kony.sync.konySyncRollBackPendingChanges-> main function");
    var isSuccess = true;
    var totalRows = 0;
    var pkNotFound = false;
    var isStatementError = false;

    function single_execute_sql_transaction(tx) {
        sync.log.trace("Entering kony.sync.konySyncRollBackPendingChanges->single_execute_sql_transaction ");
        if (isGlobal === true) {
            totalRows = kony.sync.konySyncRollBackGlobal(tx, errorcallback);
            isSuccess = totalRows === false ? false : true;
        } else if (!kony.sync.isNullOrUndefined(wcs)) {
            totalRows = kony.sync.konySyncRollBackRow(tx, tbname, wcs, errorcallback);
            if (totalRows === null) {
                pkNotFound = true;
                isSuccess = false;
            } else if (totalRows === false) {
                isStatementError = true;
                isSuccess = false;
            } else {
                isSuccess = true;
                totalRows = 1;
            }
        } else {
            totalRows = kony.sync.konySyncRollBackTable(tx, tbname, errorcallback);
            isSuccess = totalRows === false ? false : true;
        }
    }

    function single_transactionErrorCallback() {
        sync.log.error("Entering kony.sync.konySyncRollBackPendingChanges->single_transactionErrorCallback ");
        if (isSuccess) {
            kony.sync.showTransactionError(errorcallback);
        } else {
            sync.log.error("Entering kony.sync.konySyncRollBackPendingChanges->single_transactionErrorCallback : ", kony.sync.errorObject);
            kony.sync.verifyAndCallClosure(errorcallback, kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function single_execute_sql_transactionSucessCallback() {
        sync.log.trace("Entering kony.sync.konySyncRollBackPendingChanges->single_execute_sql_transactionSucessCallback ");
        if (pkNotFound === true) {
            kony.sync.verifyAndCallClosure(errorcallback);
            return;
        }
        if (isGlobal === true) {
            if (kony.sync.isNull(count)) {
                count = 0;
            }
            count += totalRows;
            if (kony.sync.rollbackCurrentScope.Index === kony.sync.scopes.scopecount - 1) {
                kony.sync.verifyAndCallClosure(successcallback, {
                    rowsrolledback: count
                });
            } else {
                kony.sync.rollbackCurrentScope = kony.sync.scopes[kony.sync.rollbackCurrentScope.Index + 1];
                kony.sync.konySyncRollBackPendingChanges(null, null, null, successcallback, errorcallback, true, count);
            }
        } else {
            kony.sync.verifyAndCallClosure(successcallback, {
                rowsrolledback: totalRows
            });
        }
    }
    try {
        if (isGlobal === true) {
            if (kony.sync.isNullOrUndefined(kony.sync.rollbackCurrentScope)) {
                kony.sync.rollbackCurrentScope = kony.sync.scopes[0];
                sync.log.info("RollBacking Global with Scope name : " + kony.sync.rollbackCurrentScope[kony.sync.scopeName] + " and with DBName : " + kony.sync.rollbackCurrentScope[kony.sync.scopeDataSource]);
            }
            dbname = kony.sync.rollbackCurrentScope[kony.sync.scopeDataSource];
        }
        var dbconnection = kony.sync.getConnectionOnly(dbname, dbname, errorcallback);
        if (dbconnection !== null) {
            kony.sync.startTransaction(dbconnection, single_execute_sql_transaction, single_execute_sql_transactionSucessCallback, single_transactionErrorCallback, "Single Execute");
        }
    } catch (e) {
        sync.log.error("Unknown error occurred during rollback", e);
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorUnknown, kony.sync.getErrorMessage(kony.sync.errorUnknown, "Rollback", e), null));
    }
};
kony.sync.konySyncRollBackTable = function(tx, tbname, errorcallback) {
    sync.log.trace("Entering kony.sync.konySyncRollBackTable");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, tbname + kony.sync.originalTableName);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultset = kony.sync.executeSql(tx, sql, params, errorcallback);
    if (resultset === false) {
        return false;
    }
    var num_records = resultset.rows.length;
    sync.log.debug("Number of records to rollback in " + tbname + "=" + num_records);
    for (var i = 0; i <= num_records - 1; i++) {
        var record = kony.db.sqlResultsetRowItem(tx, resultset, i);
        var tableinfo = kony.sync.getTableInfo(tbname);
        var wcs = [];
        if (!kony.sync.isNullOrUndefined(tableinfo.Pk_Columns)) {
            for (var j = 0; j < tableinfo.Pk_Columns.length; j++) {
                var pk = tableinfo.Pk_Columns[j];
                var wc = {};
                wc.key = pk;
                wc.value = record[pk];
                kony.table.insert(wcs, wc);
            }
        }
        sync.log.debug("Rollbacking Record with Primary Key :", wcs);
        if (!kony.sync.konysyncRollBackOriginal(tx, tbname, record, wcs, errorcallback)) {
            return false;
        }
    }
    return num_records;
};
kony.sync.konySyncRollBackGlobal = function(tx) {
    sync.log.trace("Entering kony.sync.konySyncRollBackGlobal");
    var noOfScopes = kony.sync.scopes.length;
    for (var i = 0; i < noOfScopes; i++) {
        var scope = kony.sync.scopes[i];
        var totalRows = 0;
        if (!kony.sync.isNullOrUndefined(scope.ScopeTables)) {
            for (var j = 0; j < scope.ScopeTables.length; j++) {
                var syncTable = scope.ScopeTables[j];
                sync.log.debug("Rollbacking Table :" + syncTable.Name);
                var rows = kony.sync.konySyncRollBackTable(tx, syncTable.Name);
                if (rows === false) {
                    return false;
                } else {
                    totalRows += rows;
                }
            }
        }
    }
    return totalRows;
};
kony.sync.konySyncRollBackRow = function(tx, tbname, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.konySyncRollBackRow");
    var record = kony.sync.getOriginalRow(tx, tbname + kony.sync.originalTableName, wcs, errorcallback);
    if (null !== record && false !== record) {
        return kony.sync.konysyncRollBackOriginal(tx, tbname, record, wcs);
    } else {
        return record;
    }
};
kony.sync.konysyncRollBackOriginal = function(tx, tbname, values, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.konysyncRollBackOriginal");
    var originalchangetype = values[kony.sync.originalTableChangeTypeColumn] + "";
    //delete the blob reference if exists.
    var isBlobDeleted = kony.sync.blobstore_delete(tx, tbname, wcs, false, function(err) {
        sync.log.error("kony.sync.konysyncRollBackOriginal - error in deleting blob values for the table " + tbname);
    });
    if (isBlobDeleted) {
        //add NULL to blobref columns..
        sync.log.trace("kony.sync.konysyncRollBackOriginal - adding NULL values to blob ref columns for table " + tbname);
        if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname]) && !kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns])) {
            var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[tbname][kony.sync.columns];
            sync.log.trace("binary columns for tbname " + tbname + " are " + JSON.stringify(binaryColumns));
            for (var i = 0; i < binaryColumns.length; i++) {
                values[kony.sync.binaryMetaColumnPrefix + binaryColumns[i]] = kony.sync.blobRefNotDefined;
            }
        }
        if (kony.sync.isrowexists(tx, tbname, wcs)) {
            sync.log.trace("kony.sync.konysyncRollBackOriginal isrowexists = true");
            if ((originalchangetype === kony.sync.insertColStatus) || (originalchangetype === kony.sync.insertColStatusDI)) {
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is insert for values ", values);
                if (!kony.sync.removeEx(tx, tbname, wcs, null, errorcallback)) {
                    return false;
                }
            } else if ((originalchangetype === kony.sync.updateColStatus) || (originalchangetype === kony.sync.updateColStatusDU)) {
                //Revert to original values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is update for values ", values);
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                if (!kony.sync.updateEx(tx, tbname, values, wcs, errorcallback)) {
                    return false;
                }
            } else if ((originalchangetype === kony.sync.deleteColStatus) || (originalchangetype === kony.sync.deleteColStatusDD)) {
                //delete the row which has been inserted/updated with old values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is delete for values ", values);
                if (!kony.sync.removeEx(tx, tbname, wcs, null, errorcallback)) {
                    return false;
                }
                //Insert the row which has been deleted with old values.
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.mainTableHashSumColumn] = values[kony.sync.originalTableHashSumColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                if (!kony.sync.insertEx(tx, tbname, values, wcs, errorcallback)) {
                    return false;
                }
            }
        } else {
            /*if ((originalchangetype === kony.sync.insertColStatus)) {
             //Need not handle this case. Because inserted record has been deleted. So, it is already rollbacked.
             } else*/
            sync.log.trace("kony.sync.konysyncRollBackOriginal - isrowexists false");
            if ((originalchangetype === kony.sync.updateColStatus) || (originalchangetype === kony.sync.updateColStatusDU)) {
                //Insert the row which has been updated and deleted with old values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is update for values ", values);
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                //kony.sync.insertEx(tx, tbname, values);
                if (!kony.sync.insertEx(tx, tbname, values, null, errorcallback)) {
                    return false;
                }
            } else if ((originalchangetype === kony.sync.deleteColStatus) || (originalchangetype === kony.sync.deleteColStatusDD)) {
                //Insert the row which has been deleted with old values.
                sync.log.trace("kony.sync.konysyncRollBackOriginal - original change type is delete for values ", values);
                values[kony.sync.mainTableChangeTypeColumn] = "-1";
                values[kony.sync.mainTableSyncVersionColumn] = values[kony.sync.originalTableSyncVersionColumn];
                values[kony.sync.originalTableChangeTypeColumn] = null;
                values[kony.sync.originalTableSyncVersionColumn] = null;
                if (!kony.sync.insertEx(tx, tbname, values, null, errorcallback)) {
                    return false;
                }
            }
        }
        if (!kony.sync.konySyncRollBackDeleteRow(tx, tbname, wcs, errorcallback)) {
            return false;
        }
        return true;
    } else {
        sync.log.error("kony.sync.konysyncRollBackOriginal error in deleting blob data for table " + tbname);
        return false;
    }
}
kony.sync.konySyncRollBackDeleteRow = function(tx, tbname, wcs, errorcallback) {
    sync.log.trace("Entering kony.sync.konySyncRollBackDeleteRow");
    sync.log.debug("Deleting States in Original Tables with Primary Key : ", wcs);
    if (kony.sync.removeEx(tx, tbname + kony.sync.originalTableName, wcs, errorcallback) === false) {
        return false;
    }
    if (kony.sync.removeEx(tx, tbname + kony.sync.historyTableName, wcs, errorcallback) === false) {
        return false;
    }
    return true;
};
//  **************** End KonySyncRollBack.js*******************
//  **************** Start KonySyncSchemaUpgrade.js*******************
/* This methods calls upgrade schema service and executes the scripts" */
kony.sync.upgradeSchema = function(callback) {
    sync.log.trace("Entering kony.sync.upgradeSchema ");
    sync.log.info("Calling upgradeSchema service...");
    var contextParams = {};
    contextParams.oldApplicationVersion = kony.sync.configVersion;
    contextParams.newApplicationVersion = konysyncClientSyncConfig.Version;
    var schemaUpgrade = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeRequiredKey], contextParams);
    if (schemaUpgrade === kony.sync.onUpgradeActionUploadUpgrade) {
        kony.sync.omitDownload = true;
        kony.sync.forceUploadUpgrade = true;
        kony.sync.currentScope = null;
        kony.sync.schemaUpgradeErrorObject = upgradeRequiredCallback;
        kony.sync.syncStartSession();
    } else { //(schemaUpgrade === kony.sync.onUpgradeActionUpgrade) //default policy
        upgradeRequiredCallback();
    }

    function upgradeRequiredCallback() {
        sync.log.trace("Entering upgradeRequiredCallback");
        kony.sync.callSchemaUpgradeService(schemaUpgradeCallback);
    }

    function schemaUpgradeCallback(serverResponse) {
        sync.log.trace("Entering schemaUpgradeCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse.d));
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
            } else {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse));
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
            }
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse));
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse));
            return;
        }
        if (serverResponse.d.error === "true") {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadErrorKey], kony.sync.getServerError(serverResponse.d));
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], kony.sync.getServerError(serverResponse.d));
            kony.sync.isSessionInProgress = false;
            kony.sync.httprequestsinglesession = false;
            return;
        }
        kony.sync.addServerDetails(kony.sync.currentSyncReturnParams, serverResponse);
        if (serverResponse.d.upgradeavailable === "false") {
            callback(false);
            return;
        }
        //fetch alter scripts
        var queries = [];
        if (!kony.sync.isNullOrUndefined(serverResponse.d.script)) {
            for (var i = 0; i < serverResponse.d.script.length; i++) {
                queries.push(serverResponse.d.script[i].sql);
            }
            kony.sync.schemaUpgradeContext = serverResponse.d.upgradecontext;
        }
        kony.sync.currentSyncReturnParams.upgradeScripts = queries;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadSuccessKey], kony.sync.currentSyncReturnParams);
        delete kony.sync.currentSyncReturnParams.upgradeScripts;
        var myQueries = null;
        myQueries = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesExecutionStartKey], {
            upgradeScripts: queries
        });
        if (!kony.sync.isNullOrUndefined(myQueries)) {
            queries = myQueries;
        }
        kony.sync.executeUpdateSchemaQueries(queries, kony.sync.schemaUpgradeContext, executeQueriesCallback, serverResponse.d.newapplicationversion);
    }

    function executeQueriesCallback(isError, errorInfo) {
        sync.log.trace("Entering executeQueriesCallback");
        if (isError) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesExecutionErrorKey], errorInfo);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], errorInfo);
        } else {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesExecutionSuccessKey]);
            kony.sync.schemaUpgradeNeeded = false; //do not call schema upgrade service again
            kony.sync.omitUpload = true; //only download
            kony.sync.schemaUpgradeDownloadPending = true;
            kony.sync.resetsyncsessionglobals();
            callback(true);
        }
    }
};
/*This method will be called in case of server notifies schema upgrade*/
kony.sync.onSchemaUpgradeErrorFromServer = function(msg) {
    sync.log.trace("Entering kony.sync.onSchemaUpgradeErrorFromServer ");
    /*	var contextParams = {};
    	contextParams.oldVersion = msg.oldApplicationVersion;
    	contextParams.newVersion = msg.newApplicationVersion;
    	contextParams.isMandatory = msg.mandatoryupgrade;*/
    var schemaUpgrade = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeRequiredKey], msg);
    if (schemaUpgrade === kony.sync.onUpgradeActionUploadAbort) {
        //Upload and then Abort Sync Process
        kony.sync.omitDownload = true;
        kony.sync.forceUpload = true;
        kony.sync.resetsyncsessionglobals();
        kony.sync.schemaUpgradeErrorObject = msg;
        kony.sync.syncStartSession();
    } else { //(schemaUpgrade === kony.sync.onUpgradeActionAbort) --default policy
        //Abort Sync Process
        kony.sync.validateScopeSession(true, msg);
    }
    /*else if (schemaUpgrade === kony.sync.onUpgradeActionContinue) {
		//Upgrade first and then continue with normal Sync Process
		//kony.sync.upgradeSchema(kony.sync.syncStartSession);
	} else if (schemaUpgrade === kony.sync.onUpgradeActionContinueOnlyUpload) {
		//Upload first, then upgrade and then continue with normal Sync Process
		kony.sync.omitDownload = true;
		kony.sync.schemaUpgradeNeeded = true;
		kony.sync.validateScopeSession();
	}*/
};
/*This method will execute upgrade scripts, syncconfig table with upgradecontext
and metainfo table with 0,0"*/
kony.sync.executeUpdateSchemaQueries = function(queries, upgradeContext, callback, appVersion) {
    sync.log.trace("Entering kony.sync.executeUpdateSchemaQueries");
    if (kony.sync.isNullOrUndefined(queries)) {
        kony.sync.verifyAndCallClosure(callback, true);
        return;
    }
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        /*Execute alter scripts*/
        if (kony.sync.executeQueriesInTransaction(tx, queries) === false) {
            isError = true;
            return;
        }
        /*update syncconfig table with upgradecontext*/
        var sql = "update " + kony.sync.syncConfigurationTableName + " set " + kony.sync.syncConfigurationColumnSchemaUpgradeContext + " = '" + upgradeContext + "'";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            isError = true;
            return;
        }
        /*upgrade schemaupgradesynccontext in metatable to "0,0" to indicate that download for new columns is pending*/
        sql = "update " + kony.sync.metaTableName + " set " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " = '0,0' where " + kony.sync.metaTableSyncTimeColumn + " <> '' and " + kony.sync.metaTableSyncTimeColumn + " is not null";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            isError = true;
            return;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        kony.sync.configVersion = appVersion;
        kony.sync.currentSyncConfigParams.appVersion = kony.sync.configVersion;
        callback(false);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        callback(true, kony.sync.getTransactionError(isError));
    }
};
/*This function marks download of data after schema upgrade complete for that particular scope*/
kony.sync.setSchemaUpgradeDownloadComplete = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.setSchemaUpgradeDownloadComplete ");
    if (kony.sync.schemaUpgradeDownloadPending) {
        var sql = "update " + kony.sync.metaTableName + " set " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " = '' where " + kony.sync.metaTableScopeColumn + " = '" + scopename + "'";
        if (kony.sync.executeSql(tx, sql, null) === false) {
            return false;
        }
    }
    return true;
};
/*This method checks if download for schema upgrade is pending for any of the scopes*/
kony.sync.isDownloadPendingForSchemaUpgrade = function(callback) {
    sync.log.trace("Entering kony.sync.isDownloadPendingForSchemaUpgrade");
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    var pendingDownload = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        var sql = "select count(*) from " + kony.sync.metaTableName + " where " + kony.sync.metaTableSchemaUpgradeSyncTimeColumn + " = '0,0'";
        var resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            isError = true;
            return;
        }
        var rowCount = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        if (rowCount["count(*)"] > 0) {
            pendingDownload = true;
        }
        sql = "select * from " + kony.sync.syncConfigurationTableName;
        resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            isError = true;
            return;
        }
        var rowitem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        kony.sync.schemaUpgradeContext = rowitem[kony.sync.syncConfigurationColumnSchemaUpgradeContext];
        kony.sync.configVersion = rowitem[kony.sync.syncConfigurationColumnVersion];
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        callback(false, null, pendingDownload);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        kony.sync.verifyAndCallClosure(callback, true, kony.sync.getTransactionError(isError));
    }
};
sync.performUpgrade = function(config) {
    sync.log.trace("Entering kony.sync.performUpgrade");
    if (kony.sync.validateSyncConfigParams("performUpgrade", config) === false) {
        return;
    }
    kony.sync.verifyAndCallClosure(config[kony.sync.onPerformUpgradeStartKey]);
    config[kony.sync.onSyncError] = config[kony.sync.onPerformUpgradeErrorKey];
    config[kony.sync.onSyncSuccess] = config[kony.sync.onPerformUpgradeSuccessKey];
    if (kony.sync.preProcessSyncConfig("performUpgrade", config, config[kony.sync.onSyncError]) === false) {
        return;
    }
    kony.sync.isDownloadPendingForSchemaUpgrade(isDownloadPendingForSchemaUpgradeCallback);

    function isDownloadPendingForSchemaUpgradeCallback(isError, errorObject, pending) {
        sync.log.trace("Entering isDownloadPendingForSchemaUpgradeCallback");
        if (isError) {
            kony.sync.isSessionInProgress = false; // closing the session
            kony.sync.httprequestsinglesession = false;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onSyncError], errorObject);
        } else {
            kony.sync.performOnlySchemaUpgrade = true;
            if (pending) {
                kony.sync.omitUpload = true; //only download
                kony.sync.schemaUpgradeDownloadPending = true;
                kony.sync.syncStartSession(); //download pending for already done schema upgrade
            } else {
                kony.sync.upgradeSchema(upgradeSchemaCallback); //download the scripts and upgrade
            }
        }
    }

    function upgradeSchemaCallback(upgrade) {
        sync.log.trace("Entering upgradeSchemaCallback");
        if (upgrade) {
            kony.sync.syncStartSession(); //download initial data for new columns
        } else {
            kony.sync.isSessionInProgress = false; // closing the session
            kony.sync.httprequestsinglesession = false;
            kony.sync.currentSyncReturnParams.upgradeRequired = false;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onPerformUpgradeSuccessKey], kony.sync.currentSyncReturnParams);
            delete kony.sync.currentSyncReturnParams.upgradeRequired;
        }
    }
};
sync.isUpgradeRequired = function(config) {
    sync.log.trace("Entering kony.sync.isUpgradeRequired");
    if (kony.sync.validateSyncConfigParams("isUpgradeRequired", config) === false) {
        return;
    }
    if (kony.sync.preProcessSyncConfig("isUpgradeRequired", config, config[kony.sync.onIsUpgradeRequiredErrorKey], false) === false) {
        return;
    }
    kony.sync.areSyncConfigVersionDifferent(areSyncConfigVersionDifferentCallback);

    function areSyncConfigVersionDifferentCallback(isError, errorObject, isDifferent) {
        sync.log.trace("Entering areSyncConfigVersionDifferentCallback");
        if (isError) {
            kony.sync.verifyAndCallClosure(config[kony.sync.onIsUpgradeRequiredErrorKey], errorObject);
        } else {
            if (isDifferent) {
                kony.sync.verifyAndCallClosure(config[kony.sync.onIsUpgradeRequiredSuccessKey], {
                    upgradeRequired: true
                });
            } else {
                config[kony.sync.onUpgradeQueriesDownloadStartKey] = config[kony.sync.onIsUpgradeRequiredStartKey];
                kony.sync.callSchemaUpgradeService(schemaUpgradeCallback, false);
            }
        }
    }

    function schemaUpgradeCallback(serverResponse) {
        sync.log.trace("Entering schemaUpgradeCallback");
        if (!kony.sync.isNullOrUndefined(serverResponse.opstatus) && serverResponse.opstatus != 0) {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            if (!kony.sync.isNullOrUndefined(serverResponse.d)) {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse.d));
            } else {
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse));
            }
            return;
        } else if (kony.sync.isNullOrUndefined(serverResponse.d)) {
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse));
            return;
        }
        if (serverResponse.d.error === "true") {
            sync.log.error("Schema Upgrade Response : ", serverResponse);
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onIsUpgradeRequiredErrorKey], kony.sync.getServerError(serverResponse.d));
            return;
        }
        var returnParams = {};
        kony.sync.addServerDetails(returnParams, serverResponse);
        returnParams.upgradeRequired = serverResponse.d.upgradeavailable === "true" ? true : false;
        kony.sync.verifyAndCallClosure(config[kony.sync.onIsUpgradeRequiredSuccessKey], returnParams);
    }
};
kony.sync.areSyncConfigVersionDifferent = function(callback) {
    sync.log.trace("Entering kony.sync.areSyncConfigVersionDifferent ");
    var dbname = kony.sync.scopes[0][kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname);
    var isError = false;
    var isDifferent = false;
    if (connection !== null) {
        kony.sync.startTransaction(connection, transactioncallback, transactionSuccessCallback, transactionErrorCallback);
    }

    function transactioncallback(tx) {
        sync.log.trace("Entering transactioncallback");
        var sql = "select * from " + kony.sync.syncConfigurationTableName;
        var resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            isError = true;
            return;
        }
        var dbSyncConfigVersion = kony.db.sqlResultsetRowItem(tx, resultset, 0)[kony.sync.syncConfigurationColumnVersion];
        if (dbSyncConfigVersion !== konysyncClientSyncConfig.Version) {
            isDifferent = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        callback(false, null, isDifferent);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering transactionErrorCallback");
        callback(true, kony.sync.getTransactionError(isError));
    }
};
kony.sync.isSchemaUpgradeTimeStampEmpty = function(val) {
    sync.log.trace("Entering kony.sync.isSchemaUpgradeTimeStampEmpty ");
    if (val === "" || val === "0,0" || kony.sync.isNullOrUndefined(val)) {
        return true;
    } else {
        return false;
    }
};
//  **************** End KonySyncSchemaUpgrade.js*******************
//  **************** Start konySyncServiceProvider.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
kony.sync.konyDownloadChanges = function(serverblob, scope, downloadNetworkCallback, isInitialized, schemaUpgradeServerblob) {
    sync.log.trace("Entering kony.sync.konyDownloadChanges ");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function downloadNetworkCallbackStatus(status, result) {
        sync.log.trace("Entering downloadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyDownloadChanges->downloadNetworkCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, null, retries, checkForChunking, params);
            } else {
                if (kony.sync.eligibleForChunking(result)) {
                    kony.sync.startChunking(kony.sync.getChunkDownloadURL(), params, result, downloadNetworkCallback);
                } else {
                    kony.sync.setSessionID(result);
                    downloadNetworkCallback(result);
                }
            }
        } else if (status === 300) {
            sync.log.warn("Got status 300 for Download, Network call Cancelled.");
            if (!kony.sync.isNullOrUndefined(retries) && (retries > 0)) {
                retries--;
                var infoObj = {};
                infoObj.retryOnNetworkCancel = true;
                sync.log.debug("Retrying the network call for status 300 ");
                if (kony.sync.isNullOrUndefined(result)) {
                    result = kony.sync.getNetworkCancelError();
                }
                kony.sync.retryServiceCall(kony.sync.getDownloadURL(), result, infoObj, retries, checkForChunking, params);
            } else {
                downloadNetworkCallback(kony.sync.getNetworkCancelError());
            }
        }
    }

    function checkForChunking(result, info, retry) {
        sync.log.trace("Entering kony.sync.konyDownloadChanges->checkForChunking");
        retries = retry;
        downloadNetworkCallbackStatus(400, result, info);
    }
    if (kony.sync.isNullOrUndefined(serverblob)) {
        serverblob = "";
    }
    var params = {};
    //check for pending chunks
    kony.sync.checkForChunkingBeforeDownload(serverblob, normaldownloadCallback, downloadNetworkCallback, schemaUpgradeServerblob);

    function normaldownloadCallback(payloadId) {
        sync.log.trace("Entering kony.sync.konyDownloadChanges->normaldownloadCallback");
        var jsonContext = null;
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncScopeFilter)) {
            var scopejsonfilter = {
                "d": {
                    Filters: kony.sync.currentSyncScopeFilter
                }
            };
            jsonContext = JSON.stringify(scopejsonfilter);
        }
        if (isInitialized === false) {
            kony.sync.downloadClientContext.InitialSync = "true";
        } else {
            delete kony.sync.downloadClientContext.InitialSync;
        }
        params.clientcontext = kony.sync.downloadClientContext;
        kony.sync.commonServiceParams(params);
        params.context = jsonContext;
        params.enablebatching = "true";
        params.batchsize = kony.sync.getBatchSize();
        if (kony.sync.schemaUpgradeDownloadPending) {
            params.tickcount = schemaUpgradeServerblob;
            params.uppertickcount = serverblob;
            if (!kony.sync.isNullOrUndefined(kony.sync.schemaUpgradeContext)) {
                params.upgradecontext = kony.sync.schemaUpgradeContext;
            }
        } else {
            params.tickcount = serverblob;
        }
        params.scopename = kony.sync.currentScope[kony.sync.scopeName];
        params.strategy = kony.sync.currentScope[kony.sync.syncStrategy];
        params.instanceid = kony.sync.getInstanceID();
        params.clientid = kony.sync.getDeviceID();
        params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
        params[kony.sync.chunkSizeKey] = kony.sync.getChunkSize();
        //include payloadid if it is not null
        if (!kony.sync.isNull(payloadId)) {
            params.deletechunkpayloadid = payloadId;
        }
        if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
            params.httpconfig = {
                timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
            };
        }
        if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]])) {
            params[kony.sync.sessionTaskUploadErrorPolicy] = kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]][kony.sync.sessionTaskUploadErrorPolicy];
        }
        var paramsToSend = null;
        var currentSyncReturnParamsTemp = kony.sync.currentSyncReturnParams;
        currentSyncReturnParamsTemp.downloadRequest = params;
        kony.sync.deleteMapKey(currentSyncReturnParamsTemp, kony.sync.serverDetails);
        if (kony.sync.globalIsDownloadStarted || kony.sync.isChunkingResumedPostSyncError) {
            paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onDownloadStart], currentSyncReturnParamsTemp);
            kony.sync.globalIsDownloadStarted = false;
            kony.sync.isChunkingResumedPostSyncError = false;
            if (!kony.sync.isNullOrUndefined(paramsToSend)) {
                params = paramsToSend;
                kony.sync.downloadClientContext = params.clientcontext;
            }
        }
        currentSyncReturnParamsTemp.downloadRequest = params;
        kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onBatchProcessingStart], kony.sync.currentSyncReturnParams);
        if (paramsToSend != null) {
            params = paramsToSend;
            kony.sync.downloadClientContext = params.clientcontext;
        }
        currentSyncReturnParamsTemp = null;
        paramsToSend = null;
        params.clientcontext = JSON.stringify(kony.sync.downloadClientContext);
        sync.log.info("Hitting the service with URL " + kony.sync.getDownloadURL(), params);
        kony.sync.invokeServiceAsync(kony.sync.getDownloadURL(), params, downloadNetworkCallbackStatus, null);
    }
};
kony.sync.konyUploadChanges = function(changes, uploadNetworkcallback, lastBatch, lastjson) {
    sync.log.trace("Entering kony.sync.konyUploadChanges");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var results1 = [];
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];
    var jsonLua = null;
    var json = null;

    function uploadNetworkCallbackStatus(status, result, info) {
        sync.log.trace("Entering uploadNetworkCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyUploadChanges->uploadNetworkCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getUploadURL(), result, info, retries, retryCallback, params);
            } else {
                kony.sync.setSessionID(result);
                uploadNetworkcallback(result, json);
                results1 = null;
                jsonLua = null;
            }
        } else if (status === 300) {
            uploadNetworkcallback(kony.sync.getNetworkCancelError(), json);
        }
    }

    function retryCallback(result, info, retry) {
        sync.log.trace("Entering kony.sync.konyUploadChanges->retryCallback");
        retries = retry;
        uploadNetworkCallbackStatus(400, result);
    }
    if (lastjson === null) {
        if (!kony.sync.isNullOrUndefined(changes.tables)) {
            for (var i = 0; i < changes.tables.length; i++) {
                var tableChange = changes.tables[i];
                var tableName = tableChange.tableName;
                if (!kony.sync.isNullOrUndefined(tableChange.changes)) {
                    for (var j = 0; j < tableChange.changes.length; j++) {
                        var rowChange = tableChange.changes[j];
                        if (kony.sync.isNullOrUndefined(rowChange.syncConflict)) {
                            rowChange.syncConflict = "";
                        }
                        var result = {
                            metadata: {
                                type: tableName,
                                uri: changes.uri,
                                changetype: rowChange.changeType,
                                syncConflict: rowChange.syncConflict
                            }
                        };
                        if (!kony.sync.isNullOrUndefined(rowChange.fields)) {
                            var fcount = kony.sync.getArrayCount(rowChange.fields);
                            for (var k = 0; k < fcount; k++) {
                                if (rowChange.fields[k] !== "ServerId" && rowChange.fields[k] !== "UpdateId") {
                                    result[rowChange.fields[k]] = rowChange.values[k];
                                }
                            }
                        }
                        results1.push(result);
                    }
                }
            }
        }
        var moreChangesAvailable = null;
        if (lastBatch === true) {
            moreChangesAvailable = false;
        } else {
            moreChangesAvailable = true;
        }
        jsonLua = {
            d: {
                results: results1,
                sync: "not implemented",
                scopeName: changes.scopeName,
                serverBlob: changes.serverblob,
                clientid: changes.clientid,
                SequenceNumber: changes.SequenceNumber,
                moreChangesAvailable: moreChangesAvailable
            }
        };
        json = JSON.stringify(jsonLua);
    } else {
        json = lastjson;
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    params.UploadRequest = json;
    params.scopename = kony.sync.currentScope[kony.sync.scopeName];
    params.strategy = kony.sync.currentScope[kony.sync.syncStrategy];
    params.instanceid = kony.sync.getInstanceID();
    params.clientid = kony.sync.getDeviceID();
    params.appVersion = kony.sync.currentSyncConfigParams.appVersion;
    if (kony.sync.forceUpload || kony.sync.forceUploadUpgrade) {
        params.usehistoryconfig = "true";
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks]) && !kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]])) {
        params[kony.sync.sessionTaskUploadErrorPolicy] = kony.sync.currentSyncConfigParams[kony.sync.sessionTasks][kony.sync.currentScope[kony.sync.scopeName]][kony.sync.sessionTaskUploadErrorPolicy];
    }
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    params.clientcontext = kony.sync.uploadClientContext;
    var paramsToSend = null;
    var currentSyncReturnParamsTemp = kony.sync.currentSyncReturnParams;
    currentSyncReturnParamsTemp.uploadRequest = params;
    kony.sync.deleteMapKey(currentSyncReturnParamsTemp, kony.sync.serverDetails);
    if (kony.sync.isUploadStarted) {
        paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadStart], currentSyncReturnParamsTemp);
        if (paramsToSend != null) {
            params = paramsToSend;
            kony.sync.uploadClientContext = params.clientcontext;
        }
        kony.sync.isUploadStarted = false;
    }
    currentSyncReturnParamsTemp.uploadRequest = params;
    paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadBatchStart], currentSyncReturnParamsTemp);
    if (!kony.sync.isNullOrUndefined(paramsToSend)) {
        params = paramsToSend;
        kony.sync.uploadClientContext = params.clientcontext;
    }
    params.clientcontext = JSON.stringify(kony.sync.uploadClientContext);
    currentSyncReturnParamsTemp = null;
    paramsToSend = null;
    sync.log.info("Hitting the service with URL : " + kony.sync.getUploadURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getUploadURL(), params, uploadNetworkCallbackStatus, null);
};
kony.sync.konyRegisterDevice = function(registerDeviceCallback) {
    sync.log.trace("Entering kony.sync.konyRegisterDevice");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function registerDeviceCallbackStatus(status, result) {
        sync.log.trace("Entering registerDeviceCallbackStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.konyRegisterDevice->registerDeviceCallbackStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getRegisterDeviceURL(), result, null, retries, retryCallback, params);
            } else {
                kony.sync.setSessionID(result);
                registerDeviceCallback(result);
            }
        } else if (status === 300) {
            registerDeviceCallback(kony.sync.getNetworkCancelError());
        }
    }

    function retryCallback(result, info, retry) {
        sync.log.trace("Entering kony.sync.konyRegisterDevice->retryCallback");
        retries = retry;
        registerDeviceCallbackStatus(400, result, info);
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    params.os = kony.os.deviceInfo().name;
    params.model = kony.os.deviceInfo().model;
    params.version = kony.os.deviceInfo().version + "";
    params.deviceID = kony.sync.getDeviceID();
    params.userAgent = kony.os.userAgent();
    params.channel = kony.sync.getChannelName();
    params.platform = kony.sync.getPlatformName();
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    sync.log.info("Hitting the service with URL :" + kony.sync.getRegisterDeviceURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getRegisterDeviceURL(), params, registerDeviceCallbackStatus, null);
};
kony.sync.callSchemaUpgradeService = function(schemaUpgradeCallback, scriptsRequired) {
    sync.log.trace("Entering kony.sync.callSchemaUpgradeService");
    if (kony.sync.isSyncStopped) {
        kony.sync.stopSyncSession();
        return;
    }
    var retries = kony.sync.currentSyncConfigParams[kony.sync.numberOfRetriesKey];

    function schemaUpgradeServiceStatus(status, result) {
        sync.log.trace("Entering schemaUpgradeServiceStatus");
        if (status === 400) {
            sync.log.trace("Entering kony.sync.callSchemaUpgradeService->schemaUpgradeServiceStatus");
            //fallback when opstatus < 0
            if (result.opstatus < 0) {
                sync.log.info("Got result.opstatus:" + result.opstatus + " and result.errcode:" + result.errcode + "setting errcode to opstatus");
                result.opstatus = result.errcode;
            }
            if (kony.sync.eligibleForRetry(result.opstatus, retries)) {
                retries--;
                kony.sync.retryServiceCall(kony.sync.getSchemaUpgradeURL(), result, null, retries, retryCallback, params);
            } else {
                kony.sync.setSessionID(result);
                schemaUpgradeCallback(result);
            }
        }
    }

    function retryCallback(result, info, retry) {
        sync.log.trace("Entering kony.sync.callSchemaUpgradeService->retryCallback");
        retries = retry;
        schemaUpgradeServiceStatus(400, result, info);
    }
    var params = {};
    kony.sync.commonServiceParams(params);
    params.clientid = kony.sync.getDeviceID();
    params.appversion = konysyncClientSyncConfig.Version;
    params.dbversion = kony.sync.configVersion;
    params.scriptsrequired = (scriptsRequired === false) ? "false" : "true";
    var paramsToSend = null;
    paramsToSend = kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUpgradeQueriesDownloadStartKey], params);
    if (!kony.sync.isNullOrUndefined(paramsToSend)) {
        params = paramsToSend;
    }
    if (!kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey])) {
        params.httpconfig = {
            timeout: kony.sync.currentSyncConfigParams[kony.sync.networkTimeOutKey]
        };
    }
    sync.log.info("Hitting the service with URL :" + kony.sync.getSchemaUpgradeURL(), params);
    kony.sync.invokeServiceAsync(kony.sync.getSchemaUpgradeURL(), params, schemaUpgradeServiceStatus, null);
};
kony.sync.getServerURL = function() {
    sync.log.trace("Entering kony.sync.getServerURL ");
    if (!kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance()) && !kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance().sync) && !kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance().sync.url)) {
        sync.log.trace("Fetching sync url from mbaas-sdk service docs instance");
        return kony.sdk.getCurrentInstance().sync.url + "/";
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.serverurl)) {
        return kony.sync.currentSyncConfigParams.serverurl;
    }
    var server = "";
    if (kony.sync.currentSyncConfigParams.issecure === true) {
        server = "https://" + kony.sync.currentSyncConfigParams.serverhost;
    } else {
        server = "http://" + kony.sync.currentSyncConfigParams.serverhost;
    }
    if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.serverport)) {
        server = server + ":80";
    } else if (kony.sync.currentSyncConfigParams.serverport !== "") {
        server = server + ":" + kony.sync.currentSyncConfigParams.serverport;
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.authTokenKey])) {
        return server + "/syncservice/api/v1/" + kony.sync.getAppId() + "/";
    } else {
        return server + "/syncservice/resources/";
    }
};
kony.sync.getUploadURL = function() {
    sync.log.trace("Entering kony.sync.getUploadURL ");
    var server = kony.sync.getServerURL();
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.uploadwebcontext)) {
        return server + kony.sync.currentSyncConfigParams.uploadwebcontext;
    }
    return server + "upload";
};
kony.sync.getDownloadURL = function() {
    sync.log.trace("Entering kony.sync.getDownloadURL ");
    var server = kony.sync.getServerURL();
    if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.downloadwebcontext)) {
        return server + kony.sync.currentSyncConfigParams.downloadwebcontext;
    }
    return server + "download";
};
kony.sync.getRegisterDeviceURL = function() {
    sync.log.trace("Entering kony.sync.getRegisterDeviceURL ");
    var server = kony.sync.getServerURL();
    return server + "registerdevice";
};
kony.sync.getSchemaUpgradeURL = function() {
    sync.log.trace("Entering kony.sync.getSchemaUpgradeURL ");
    var server = kony.sync.getServerURL();
    return server + "upgrade";
};
kony.sync.httprequest = null;
kony.sync.httprequestsinglesession = false;
//IF user passes his own function instead of using kony.net.invokeServiceAsync
//this is how it would be called.
kony.sync.invokeServiceAsync = function(url, params, callback, context) {
    sync.log.trace("Entering kony.sync.invokeServiceAsync ");
    if (kony.sync.isMbaasEnabled) {
        kony.sdk.claimsRefresh(claimsRefreshSuccessCallBack, claimsRefreshFailureCallBack);

        function claimsRefreshSuccessCallBack() {
            sync.log.trace("Entering claimsRefreshSuccessCallBack");
            if (params && params.httpheaders) {
                var currentClaimToken = kony.sdk.getCurrentInstance().currentClaimToken;
                if (kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] != currentClaimToken) {
                    kony.sync.currentSyncConfigParams[kony.sync.authTokenKey] = currentClaimToken;
                }
                params.httpheaders["X-Kony-Authorization"] = currentClaimToken;
                invokeServiceAsyncHelper(url, params, callback, context);
            }
        }

        function claimsRefreshFailureCallBack(res) {
            sync.log.trace("Entering claimsRefreshFailureCallBack");
            callback(400, res, context);
        }
    } else {
        invokeServiceAsyncHelper(url, params, callback, context);
    }

    function invokeServiceAsyncHelper(url, params, callback, context) {
        sync.log.info("Entering invokeServiceAsyncHelper");
        if (kony.sync.isNull(kony.sync.currentSyncConfigParams[kony.sync.invokeServiceFunctionKey])) {
            var deviceInfo = kony.os.deviceInfo();
            var timeoutValue = 0;
            var paramsHttpheaders = null;
            if (kony.sync.isPhonegap) {
                kony.net.invokeServiceAsync(url, params, callback, context);
            } else {
                if (!kony.net.isNetworkAvailable(constants.NETWORK_TYPE_ANY)) {
                    var response = {
                        'opstatus': 1011,
                        'errmsg': "Device has no WIFI or mobile connectivity. Please try the operation after establishing connectivity."
                    };
                    callback(400, response, context);
                    return;
                }
                var paramsTable = new kony.net.FormData();
                for (var key in params) {
                    if (!kony.sync.isNull(params[key])) {
                        if (key.toLowerCase() === "httpheaders") {
                            paramsHttpheaders = params[key];
                            continue;
                        }
                        if (key.toLowerCase() === "httpconfig") {
                            timeoutValue = kony.sync.tonumber(params[key]["timeout"]);
                            continue;
                        }
                        paramsTable.append((key), (params[key]));
                    }
                }

                function appendGlobalHeaders(headers) {
                    sync.log.trace("Entering appendGlobalHeaders ");
                    var sdkInstance = kony.sdk.getCurrentInstance();
                    if (sdkInstance) {
                        var globalHeaders = sdkInstance.getGlobalRequestParams(sdkInstance.globalRequestParamType.headers);
                        if (!kony.sdk.isNullOrUndefined(globalHeaders)) {
                            if (kony.sdk.isNullOrUndefined(headers)) {
                                headers = {};
                            }
                            for (var obj in globalHeaders) {
                                if (kony.sdk.isNullOrUndefined(headers[obj])) {
                                    headers[obj] = globalHeaders[obj];
                                }
                            }
                        }
                    }
                };

                function createNewHttpRequest(sessionid, paramsHttpheaders, localRequestCallback, url, timeoutValue) {
                    sync.log.info("Entering createNewHttpRequest");
                    var httprequest = null;
                    httprequest = (sessionid === null) ? new kony.net.HttpRequest() : new kony.net.HttpRequest(sessionid);
                    if (timeoutValue > 0) {
                        httprequest.timeout = timeoutValue * 1000;
                    }
                    httprequest.onReadyStateChange = localRequestCallback;
                    httprequest.open(constants.HTTP_METHOD_POST, url);
                    if (paramsHttpheaders !== null) {
                        for (var key in paramsHttpheaders) {
                            httprequest.setRequestHeader(key, paramsHttpheaders[key]);
                        }
                    }
                    var isContentTypeAvailable = false;
                    if (typeof(paramsHttpheaders) !== 'undefined' && paramsHttpheaders !== null) {
                        //check for content-type case insensitive
                        for (var header in paramsHttpheaders) {
                            if (header !== null && header !== 'undefined') {
                                if (header.toLowerCase() === "content-type") isContentTypeAvailable = true
                            }
                        }
                        if (!isContentTypeAvailable) {
                            httprequest.setRequestHeader("Content-Type", "application/json");
                        }
                    }
                    return httprequest;
                };
                appendGlobalHeaders(paramsHttpheaders);
                var httprequest = kony.sync.httprequest;
                httprequest = createNewHttpRequest(null, paramsHttpheaders, localRequestCallback, url, timeoutValue);
                httprequest.send(paramsTable);
            }
        } else {
            kony.sync.currentSyncConfigParams[kony.sync.invokeServiceFunctionKey](url, params, callback, context);
        }

        function localRequestCallback(httprequest) {
            sync.log.trace("Entering localRequestCallback");
            var readyState = Number(httprequest.readyState.toString());
            var status = Number(httprequest.status.toString());
            var localresponse = {};
            if (readyState == 4) {
                kony.sdk.setLogLevelFromServerResponse(httprequest.getAllResponseHeaders()); //
                if (status == 200) {
                    if (kony.sync.isNullOrUndefined(httprequest.response)) {
                        localresponse = {
                            'opstatus': 1012
                        };
                    } else {
                        localresponse = httprequest.response;
                    }
                } else {
                    localresponse = {
                        'opstatus': 1012
                    };
                }
                callback(400, localresponse, context);
            }
        }
    } //end of invokeServiceAsyncHelper
};
kony.sync.commonServiceParams = function(params) {
    sync.log.trace("Entering kony.sync.commonServiceParams ");
    var httpheaders = {};
    if (!(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams)) && !(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.userid)) && !(kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams.password))) {
        params.userid = kony.sync.currentSyncConfigParams.userid;
        params.password = kony.sync.genHash(kony.sync.currentSyncConfigParams[kony.sync.passwordHashingAlgo], kony.sync.currentSyncConfigParams.password);
    }
    if (!kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance()) && !kony.sync.isNullOrUndefined(kony.sdk.getCurrentInstance().currentClaimToken)) {
        sync.log.trace("mbaas sdk instance is alive so adding current claims token");
        if (!kony.sync.isMbaasEnabled) {
            kony.sync.isMbaasEnabled = true;
        }
        httpheaders["X-Kony-Authorization"] = kony.sdk.getCurrentInstance().currentClaimToken;
    } else if (!kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams)) {
        if (kony.sync.isNullOrUndefined(kony.sync.currentSyncConfigParams[kony.sync.authTokenKey])) {
            sync.log.trace("Neither Mbaas sdk instance and sync config auth token are not there, so adding userid, password and appid instead of token");
            params.AppID = kony.sync.getAppId();
        } else {
            if (!kony.sync.isMbaasEnabled) {
                kony.sync.isMbaasEnabled = true;
            }
            params.AppID = kony.sync.getAppId();
            httpheaders["X-Kony-Authorization"] = kony.sync.currentSyncConfigParams[kony.sync.authTokenKey];
        }
    }
    if (!kony.sync.isNullOrUndefined(kony.sync.sessionMap[kony.sync.konySyncSessionID]) && !kony.sync.isNullOrUndefined(kony.sync.sessionMap[kony.sync.konySyncRequestNumber])) {
        params.konysyncsessionid = kony.sync.sessionMap[kony.sync.konySyncSessionID];
        params.konysyncrequestnumber = kony.sync.sessionMap[kony.sync.konySyncRequestNumber];
    }
    httpheaders["Content-Type"] = "application/json";
    params.httpheaders = httpheaders;
};
kony.sync.setSessionID = function(response) {
    if (!kony.sync.isNullOrUndefined(response.d) && !kony.sync.isNullOrUndefined(response.d.__session)) {
        kony.sync.sessionMap[kony.sync.konySyncSessionID] = response.d.__session.id;
        kony.sync.sessionMap[kony.sync.konySyncRequestNumber] = response.d.__session.requestnumber;
    }
};
kony.sync.resetSessionVars = function() {
    sync.log.trace("Entering kony.sync.resetSessionVars ");
    kony.sync.sessionMap = {};
};
kony.sync.getDownloadBinaryURL = function() {
    sync.log.trace("Entering kony.sync.getDownloadBinaryURL ");
    var server = kony.sync.getServerURL();
    sync.log.trace("server url created -> kony.sync.getDownloadBinaryURL " + server);
    return server + "downloadBinary";
};
kony.sync.getUploadBinaryURL = function() {
        sync.log.trace("Entering kony.sync.getUploadBinaryURL ");
        var server = kony.sync.getServerURL();
        sync.log.trace("server url created -> kony.sync.getUploadBinaryURL " + server);
        return server + "uploadBinary";
    }
    //  **************** End konySyncServiceProvider.js*******************
    //  **************** Start KonySyncSkyLib.js*******************
kony.sky = {};
//Sky Constants
kony.sky.EventStart = "START";
kony.sky.EventFinish = "FINISH";
kony.sky.EventError = "ERROR";
kony.sky.ConfigParamServer = "SERVER";
kony.sky.ConfigParamPort = "PORT";
kony.sky.ConfigParamProfile = "PROFILE";
kony.sky.ConfigParamSslDisabledProtocols = "SSLDISABLEDPROTOCOLS";
kony.sky.ConfigParamUsewifi = "USEWIFI";
kony.sky.ConfigParamUser = "USER";
kony.sky.ConfigParamPasswd = "PASSWORD";
kony.sky.BBPlatform = "blackberry";
kony.sky.TrueStr = "TRUE";
kony.sky.BBPlatformName = "blackberry";
kony.sky.ConfigParamConnMode = "CONNECTIONMODE";
kony.sky.startSkyCallback = "onSkyStart";
kony.sky.startIdentifyCallback = "onIndentifyStart";
kony.sky.successIdentifyCallback = "onIndentifySuccess";
kony.sky.errorIdentifyCallback = "onIndentifyError";
kony.sky.errorSkyCallback = "onSkyError";
kony.sky.startSessionCallback = "onSessionStart";
kony.sky.successSessionCallback = "onSessionSuccess";
kony.sky.errorSessionCallback = "onSessionError";
kony.sky.successSkyCallback = "onSkySuccess";
kony.sky.errorCode = "errorCode";
kony.sky.errorMessage = "errorMessage";
//provision callback methods
kony.sky.startProvisionCallback = "onProvisionStart";
kony.sky.successProvisionCallback = "onProvisionSuccess";
kony.sky.errorProvisionCallback = "onProvisionError";
//reset callback methods
kony.sky.startResetCallback = "onResetStart";
kony.sky.successResetCallback = "onResetSuccess";
kony.sky.errorResetCallback = "onResetError";
//stop callback methods
kony.sky.startStopCallback = "onStopStart";
kony.sky.successStopCallback = "onStopSuccess";
kony.sky.errorStopCallback = "onStopError";
//dataobject upload callback methods
kony.sky.startUploadCallback = "onUploadStart";
kony.sky.successUploadCallback = "onUploadSuccess";
kony.sky.errorUploadCallback = "onUploadError";
//transaction
kony.sky.startTransactionCallback = "onStartTransaction";
kony.sky.successTransactionCallback = "onSuccessTransaction";
kony.sky.parentTableInfo = "parentTable";
kony.sky.provisionSkySync = function(config) {
    sync.log.trace("Entering kony.sky.provisionSkySync ");
    var isProvisioned = sky.isProvisioned();
    sync.log.info("SkySync engine provisioned status : ", isProvisioned);
    if (config[kony.sky.ConfigParamServer] === null || config[kony.sky.ConfigParamServer] === "" || config[kony.sky.ConfigParamPort] === null || config[kony.sky.ConfigParamPort] === "" || config[kony.sky.ConfigParamProfile] === null || config[kony.sky.ConfigParamProfile] === "") {
        var params = {};
        params[kony.sky.errorCode] = "7101";
        params[kony.sky.errorMessage] = kony.sky.errorMessageForCode(params[kony.sky.errorCode]);
        kony.sync.verifyAndCallClosure(config[kony.sky.errorProvisionCallback], params);
        return;
    }
    if (!isProvisioned) {
        var inputParam = {};
        inputParam[kony.sky.ConfigParamServer] = config[kony.sky.ConfigParamServer];
        inputParam[kony.sky.ConfigParamPort] = config[kony.sky.ConfigParamPort];
        inputParam[kony.sky.ConfigParamProfile] = config[kony.sky.ConfigParamProfile];
        if (!kony.sync.isNull(config[kony.sky.ConfigParamPasswd])) {
            inputParam[kony.sky.ConfigParamPasswd] = config[kony.sky.ConfigParamPasswd];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamUser])) {
            inputParam[kony.sky.ConfigParamUser] = config[kony.sky.ConfigParamUser];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamUsewifi])) {
            inputParam[kony.sky.ConfigParamUsewifi] = config[kony.sky.ConfigParamUsewifi];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamConnMode])) {
            inputParam[kony.sky.ConfigParamConnMode] = config[kony.sky.ConfigParamConnMode];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamSslDisabledProtocols])) {
            inputParam[kony.sky.ConfigParamSslDisabledProtocols] = config[kony.sky.ConfigParamSslDisabledProtocols];
        }
        sky.provision(inputParam, provisionSkySyncCallback);
    } else {
        kony.sync.verifyAndCallClosure(config[kony.sky.successProvisionCallback], null);
    }

    function provisionSkySyncCallback(event, args) {
        sync.log.trace("Entering provisionSkySyncCallback");
        if ((event !== kony.sky.EventStart)) {
            if ((event === kony.sky.EventError)) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorProvisionCallback], params);
                }
            }
            if ((event === kony.sky.EventFinish)) {
                kony.sync.verifyAndCallClosure(config[kony.sky.successProvisionCallback], null);
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startProvisionCallback], null);
        }
    }
};
kony.sky.startSkySyncSession = function(config) {
    sync.log.trace("Entering kony.sky.startSkySyncSession ");
    var isIdentified = sky.isIdentified();
    if (config[kony.sky.ConfigParamUser] === null || config[kony.sky.ConfigParamPasswd] === null) {
        var params = {};
        params[kony.sky.errorCode] = "7101";
        params[kony.sky.errorMessage] = kony.sky.errorMessageForCode(params[kony.sky.errorCode]);
        kony.sync.verifyAndCallClosure(config[kony.sky.errorSkyCallback], params);
        return;
    }
    kony.sync.verifyAndCallClosure(config[kony.sky.startSkyCallback], null);
    if (!isIdentified) {
        var identifyParams = {};
        identifyParams[kony.sky.ConfigParamUser] = config[kony.sky.ConfigParamUser];
        identifyParams[kony.sky.ConfigParamPasswd] = config[kony.sky.ConfigParamPasswd];
        if (!kony.sync.isNull(config[kony.sky.ConfigParamUsewifi])) {
            identifyParams[kony.sky.ConfigParamUsewifi] = config[kony.sky.ConfigParamUsewifi];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamConnMode])) {
            identifyParams[kony.sky.ConfigParamConnMode] = config[kony.sky.ConfigParamConnMode];
        }
        if (!kony.sync.isNull(config[kony.sky.ConfigParamSslDisabledProtocols])) {
            identifyParams[kony.sky.ConfigParamSslDisabledProtocols] = config[kony.sky.ConfigParamSslDisabledProtocols];
        }
        sky.identify(identifyParams, false, identifySkySyncCallback);
    } else {
        identifySkySyncCallback(kony.sky.EventFinish, []);
    }

    function identifySkySyncCallback(event, args) {
        sync.log.trace("Entering identifySkySyncCallback");
        if (event !== kony.sky.EventStart) {
            if (event === kony.sky.EventError) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorIdentifyCallback], params);
                }
            }
            if (event === kony.sky.EventFinish) {
                kony.sync.verifyAndCallClosure(config[kony.sky.successIdentifyCallback], null);
                startSkySync();
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startIdentifyCallback], null);
        }
    }

    function startSkySync() {
        sync.log.trace("Entering startSkySync ");
        var isStarted = sky.isStarted();
        sync.log.info("SkySync server status : ", isStarted);
        kony.sync.verifyAndCallClosure(config[kony.sky.startSessionCallback], null);
        if ((!isStarted)) {
            sky.start(startSkySyncCallback);
        } else {
            startSkySyncCallback(kony.sky.EventFinish, []);
        }
    }

    function startSkySyncCallback(event, args) {
        sync.log.trace("Entering startSkySyncCallback");
        if (event !== kony.sky.EventStart) {
            if (event === kony.sky.EventError) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorSessionCallback], params);
                }
            }
            if (event === kony.sky.EventFinish) {
                sync.log.info("SkySync server started Successful");
                kony.sync.verifyAndCallClosure(config[kony.sky.successSessionCallback], null);
                kony.sync.verifyAndCallClosure(config[kony.sky.successSkyCallback], null);
            }
        }
    }
};
kony.sky.skyEmptyFunction = function() {
    sync.log.trace("Entering kony.sky.skyEmptyFunction ");
};
kony.sky.getSkyGuiID = function() {
    sync.log.trace("Entering kony.sky.getSkyGuiID ");
    var serviceId = sky.getParameter("SERVERID");
    var currendate = kony.os.date("mm/dd/yyyy");
    var currtime = kony.sky.replaceColon(kony.os.time());
    var datevalue = currendate.split("/");
    var resultDate = datevalue[2] + datevalue[0] + datevalue[1] + currtime;
    var GUID = serviceId + "-" + resultDate;
    return GUID;
};
kony.sky.replaceColon = function(currtime) {
    sync.log.trace("Entering kony.sky.replaceColon ");
    if (kony.string.containsChars(currtime, [":"])) {
        currtime = currtime.replace(":", "");
        currtime = kony.sky.replaceColon(currtime);
    }
    return currtime;
};
kony.sky.generatePKTable = function(pk) {
    sync.log.trace("Entering kony.sky.generatePKTable ");
    var i = 0;
    var pks = [];
    for (var j in pk) {
        var v = pk[j];
        if (!kony.sync.isNull(v.key)) {
            pks[i] = v.key + " = " + v.value;
        } else {
            pks[i] = j + " = " + v;
        }
        i = i + 1;
    }
    return pks;
};
kony.sky.buildConditionSet = function(srchByTargetAttribute, targetKey) {
    sync.log.trace("Entering kony.sky.buildConditionSet ");
    var conditionSet = [];
    conditionSet[0] = srchByTargetAttribute + " = " + targetKey;
    return conditionSet;
};
kony.sky.beginTransaction = function(config) {
    sync.log.trace("Entering kony.sky.beginTransaction ");
    sky.beginTransaction(config[kony.sky.successTransactionCallback]);
};
kony.sky.commitTransaction = function(config) {
    sync.log.trace("Entering kony.sky.commitTransaction ");
    sky.commitTransaction(config[kony.sky.successTransactionCallback]);
};
kony.sky.rollbackTransaction = function(config) {
    sync.log.trace("Entering kony.sky.rollbackTransaction ");
    sky.rollbackTransaction(config[kony.sky.successTransactionCallback]);
};
kony.sky.resetSkyEngine = function(config) {
    sync.log.trace("Entering kony.sky.resetSkyEngine ");

    function resetCallback(event, args) {
        sync.log.trace("Entering resetCallback");
        if ((event !== kony.sky.EventStart)) {
            if ((event === kony.sky.EventError)) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorResetCallback], params);
                }
            }
            if ((event === kony.sky.EventFinish)) {
                kony.sync.verifyAndCallClosure(config[kony.sky.successResetCallback], null);
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startResetCallback], null);
        }
    }
    sky.reset(resetCallback);
};
kony.sky.stopSkyEngine = function(config) {
    sync.log.trace("Entering kony.sky.stopSkyEngine ");

    function stopCallback(event, args) {
        sync.log.trace("Entering stopCallback");
        if ((event !== kony.sky.EventStart)) {
            if ((event === kony.sky.EventError)) {
                if ((args !== null)) {
                    var params = {};
                    params[kony.sky.errorCode] = args.ERRORCODE;
                    params[kony.sky.errorMessage] = args.ERRORDESC;
                    kony.sync.verifyAndCallClosure(config[kony.sky.errorStopCallback], params);
                }
            }
            if ((event === kony.sky.EventFinish)) {
                if (sky.isStarted()) {
                    sky.stop(stopCallback);
                } else {
                    kony.sync.verifyAndCallClosure(config[kony.sky.successStopCallback], null);
                }
            }
        } else {
            kony.sync.verifyAndCallClosure(config[kony.sky.startStopCallback], null);
        }
    }
    if (sky.isStarted()) {
        sky.stop(stopCallback);
    } else {
        kony.sync.verifyAndCallClosure(config[kony.sky.successStopCallback], null);
    }
};
kony.sky.errorMessageForCode = function(errorCode) {
    sync.log.trace("Entering kony.sky.errorMessageForCode ");
    var statusMsgTable = {};
    statusMsgTable["-1002"] = "ERROR_ALREADY_IDENTIFIED";
    statusMsgTable["-1003"] = "ERROR_ALREADY_PROVISIONED";
    statusMsgTable["-1004"] = "ERROR_BAD_CONDITION_SET";
    statusMsgTable["-1005"] = "ERROR_BLACKLISTED";
    statusMsgTable["-1006"] = "ERROR_CONFIGURATION";
    statusMsgTable["-1007"] = "ERROR_DATA_OBJECT_NOT_FOUND";
    statusMsgTable["-1008"] = "ERROR_DUPLICATE_ITEM";
    statusMsgTable["-1009"] = "ERROR_ENCRYPTION_HANDSHAKE";
    statusMsgTable["-1010"] = "ERROR_ENCRYPTION_MISMATCH";
    statusMsgTable["-1001"] = "ERROR_GENERAL_FAILURE";
    statusMsgTable["-1011"] = "ERROR_HOST_IF_SETUP_ERROR";
    statusMsgTable["-1012"] = "ERROR_HOST_NOT_AVAILABLE";
    statusMsgTable["-1013"] = "ERROR_IDENTITY_FAILURE";
    statusMsgTable["-1014"] = "ERROR_INVALID_PARAMETER";
    statusMsgTable["-1015"] = "ERROR_IS_STARTED";
    statusMsgTable["-1016"] = "ERROR_MEAP_IS_DISABLED";
    statusMsgTable["-1017"] = "ERROR_NO_CONFIGURATION";
    statusMsgTable["-1018"] = "ERROR_NO_INSTANCES_SELECTED";
    statusMsgTable["-1019"] = "ERROR_NOT_IDENTIFIED";
    statusMsgTable["-1020"] = "ERROR_NOT_PROVISIONED";
    statusMsgTable["-1021"] = "ERROR_NOT_RUNNING";
    statusMsgTable["-1022"] = "ERROR_PROFILE_DEACTIVATED";
    statusMsgTable["-1023"] = "ERROR_PROFILE_NOT_FOUND";
    statusMsgTable["-1024"] = "ERROR_RETRY";
    statusMsgTable["-1025"] = "ERROR_TABLE_NOT_FOUND";
    statusMsgTable["-1026"] = "ERROR_UNCAUGHT_EXCEPTION";
    statusMsgTable["-1027"] = "ERROR_USER_NOT_FOUND";
    statusMsgTable["7101"] = "MISSING ATTRIBUTES FOR SKY";
    var errMsg = "";
    if (statusMsgTable[errorCode] === null) {
        errMsg = "Some unknown error";
    } else {
        errMsg = statusMsgTable[errorCode];
    }
    return errMsg;
};
kony.sky.buildSkyOrderByMap = function(orderByMap) {
    sync.log.trace("Entering kony.sky.buildSkyOrderByMap ");
    var i = 0;
    var ordering = [];
    for (var j in orderByMap) {
        var v = orderByMap[j];
        var sortType = v.sortType;
        var orderBy = (v.key).toString();
        if (sortType === "desc") {
            orderBy = orderBy + " D*";
        } else {
            orderBy = orderBy + " *";
        }
        ordering[i] = orderBy;
        i = i + 1;
    }
    return ordering;
};
skySync = {
    init: kony.sky.provisionSkySync,
    startSession: kony.sky.startSkySyncSession,
    reset: kony.sky.resetSkyEngine,
    stop: kony.sky.stopSkyEngine,
    beginTransaction: kony.sky.beginTransaction,
    rollbackTransaction: kony.sky.rollbackTransaction,
    commitTransaction: kony.sky.commitTransaction,
    //	quiesce : kony.sky.quiesce,
    //unquiesce : kony.sky.unquiesce
};
//  **************** End KonySyncSkyLib.js*******************
//  **************** Start KonySyncUpload.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
if (typeof(sync) === "undefined") {
    sync = {};
}
if (typeof(kony.sync.blobManager) === "undefined") {
    kony.sync.blobManager = {};
}
kony.sync.syncUploadChanges = function(sname, dsname, onCompletion) {
    sync.log.trace("Entering kony.sync.syncUploadChanges ");
    kony.sync.onUploadCompletion = onCompletion;
    kony.sync.resetuploadsessioglobals();
    kony.sync.objectLevelInfoMap = {};
    kony.sync.OTAChangestobeDeleted = [];
    kony.sync.uploadcontextMap = {};
    kony.sync.getLastSyncUploadContext(sname, dsname, kony.sync.syncUploadChangesForBatch);
};
kony.sync.createClone = function(obj) {
    sync.log.trace("Entering kony.sync.createClone ");
    var copy;
    if (null == obj || "object" != typeof obj) return obj;
    if (obj instanceof Array) {
        copy = [];
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = kony.sync.createClone(obj[attr]);
        }
        return copy;
    }
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = kony.sync.createClone(obj[attr]);
        }
        return copy;
    }
}
kony.sync.syncUploadChangesForBatch = function(rowItem, previousUpload, limit) {
    sync.log.trace("Entering kony.sync.syncUploadChangesForBatch");
    var batchSize = kony.sync.getUploadBatchSize();
    var offset = 0;
    var serverblob1 = rowItem[kony.sync.metaTableUploadSyncTimeColumn];
    var lastSeqNo = rowItem[kony.sync.metaTableSyncOrderCloumn];
    //previousUpload = "";//temporary -- to be removed while handling duplicate row issue
    sync.log.info("Current Scope Server Time Stamp", serverblob1);
    kony.sync.currentSyncReturnParams[kony.sync.lastSyncTimestamp] = serverblob1;
    kony.sync.currentSyncReturnParams[kony.sync.uploadSequenceNumber] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName];
    var firstBatch = false;
    var lastBatch = false;
    var isError = false;
    var changeset = {
        clientid: kony.sync.getDeviceID(),
        SequenceNumber: kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName],
        serverblob: serverblob1,
        scopeName: kony.sync.currentScope[kony.sync.scopeName],
        uri: kony.sync.currentScope[kony.sync.scopeDataSource],
        totalChanges: 0,
        tables: []
    };

    function updateSyncOrderForDeferredRows(tx, limit) {
        sync.log.trace("Entering kony.sync.updateSyncOrderForDeferredRows");
        if (kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
            return true;
        }
        for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
            var syncTable = kony.sync.currentScope.ScopeTables[i];
            if (kony.sync.isNullOrUndefined(syncTable)) {
                continue;
            }
            var tablename = syncTable.Name;
            var settable = {};
            settable[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName];
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
            kony.sync.qb_set(query, settable);
            kony.sync.qb_where(query, [{
                key: kony.sync.historyTableReplaySequenceColumn,
                value: limit,
                optype: "LT"
            }]);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
        }
        return true;
    }

    function uploadAllTransaction(tx) {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->uploadAllTransaction");
        //get offset for the 1st batch
        if (kony.sync.isNull(limit) || previousUpload === "*") {
            if ((previousUpload == "*") && !kony.sync.isNull(limit)) {
                if (updateSyncOrderForDeferredRows(tx, limit) === false) {
                    isError = true;
                }
            }
            offset = kony.sync.getSmallestSequenceNumber(tx);
            if (offset === false) {
                isError = true;
                return;
            }
            if (previousUpload !== "*") {
                firstBatch = true; //If not resuming after sending duplicate row
            } else {
                previousUpload = "";
            }
        }
        //otherwise increase it by limit + 1
        else {
            offset = limit + 1;
        }
        limit = offset + batchSize - 1;
        var uploadCache = {};
        if (offset !== -1) {
            kony.sync.syncTotalBatchInserts = 0;
            kony.sync.syncTotalBatchUpdates = 0;
            kony.sync.syncTotalBatchDeletes = 0;
            var scopeName = kony.sync.currentScope[kony.sync.scopeName];
            var changeSetCopy = kony.sync.createClone(changeset);
            uploadCache[kony.sync.scope] = scopeName;
            uploadCache[kony.sync.offset] = offset;
            uploadCache[kony.sync.limit] = limit;
            uploadCache[kony.sync.changeSet] = JSON.stringify(changeSetCopy);
            uploadCache[kony.sync.lastSequenceNumber] = lastSeqNo;
            uploadCache[kony.sync.batchSize] = batchSize;
            //updating the offset in case of kony.sync.getBatchChanges is not able to get records in 1st attempt
            limit = kony.sync.getBatchChanges(tx, kony.sync.currentScope, offset, limit, changeset, lastSeqNo, batchSize);
            if (limit === false) {
                isError = true;
                return;
            }
            kony.sync.syncTotalInserts += kony.sync.syncTotalBatchInserts;
            kony.sync.syncTotalUpdates += kony.sync.syncTotalBatchUpdates;
            kony.sync.syncTotalDeletes += kony.sync.syncTotalBatchDeletes;
        }
        if (limit >= lastSeqNo) {
            lastBatch = true;
        }
        if (offset !== -1) {
            uploadCache[kony.sync.lastBatch] = lastBatch;
            uploadCache[kony.sync.uploadChangesLimit] = kony.sync.uploadLimit;
            cacheLastUploadRequest(tx, uploadCache);
        }
    }

    function cacheLastUploadRequest(tx, uploadCache) {
        sync.log.trace("Entering cacheLastUploadRequest");
        if (changeset.totalChanges > 0) {
            var scopeName = kony.sync.currentScope[kony.sync.scopeName]
            var lastRequest = kony.sync.checkForPendingUpload(tx, scopeName);
            if (lastRequest != "") {
                return;
            }
            var contextInfo = {};
            contextInfo[kony.sync.metaTableScopeColumn] = scopeName;
            contextInfo[kony.sync.pendingUploadTableInsertCount] = kony.sync.syncTotalInserts;
            contextInfo[kony.sync.pendingUploadTableUpdateCount] = kony.sync.syncTotalUpdates;
            contextInfo[kony.sync.pendingUploadTableDeleteCount] = kony.sync.syncTotalDeletes;
            contextInfo[kony.sync.pendingUploadTableBatchInsertCount] = kony.sync.syncTotalBatchInserts;
            contextInfo[kony.sync.pendingUploadTableBatchUpdateCount] = kony.sync.syncTotalBatchUpdates;
            contextInfo[kony.sync.pendingUploadTableBatchDeleteCount] = kony.sync.syncTotalBatchDeletes;
            contextInfo[kony.sync.pendingUploadTableObjectLevelInfo] = JSON.stringify(kony.sync.objectLevelInfoMap);
            contextInfo[kony.sync.pendingUploadTableUploadRequest] = JSON.stringify(uploadCache);
            contextInfo[kony.sync.pendingUploadTableUploadLimit] = kony.sync.uploadLimit;
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_insert(query, kony.sync.pendingUploadTableName);
            kony.sync.qb_set(query, contextInfo);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            var resultSet = kony.sync.executeSql(tx, sql, params);
            if (resultSet === false) {
                isError = true;
            }
        }
    }

    function uploadTransactionSuccess() {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->uploadTransactionSuccess");
        if (changeset.totalChanges > 0 || previousUpload !== "") {
            if (firstBatch) {
                //kony.sync.deleteMapKey(kony.sync.currentSyncReturnParams, kony.sync.serverDetails);
                //kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadStart], kony.sync.currentSyncReturnParams);
                kony.sync.isUploadStarted = true;
            }
            //kony.sync.konyUploadChanges(changeset, uploadAllTransactionSuccess, lastBatch);
            if (previousUpload === "") {
                kony.sync.konyUploadChanges(changeset, uploadAllTransactionSuccess, lastBatch, null);
            } else {
                kony.sync.konyUploadChanges(null, uploadAllTransactionSuccess, null, changeset);
            }
        } else {
            if (firstBatch) { //nothing to upload, hence skip it
                kony.sync.uploadCompleted();
            } else { //upload batch processing finished
                kony.sync.currentSyncReturnParams[kony.sync.uploadContext] = kony.sync.uploadcontextMap;
                kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadSuccess], kony.sync.currentSyncReturnParams);
                kony.sync.currentSyncReturnParams[kony.sync.uploadContext] = {};
                kony.sync.uploadcontextMap = {};
                kony.sync.onUploadCompletion(false, null);
            }
        }
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->transactionErrorCallback");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }

    function uploadAllTransactionSuccess(otaServerChanges, oldJson) {
        sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->uploadAllTransactionSuccess");
        sync.log.info("Upload response:", otaServerChanges);
        if (!kony.sync.isNullOrUndefined(otaServerChanges.opstatus) && otaServerChanges.opstatus != 0) {
            if (!kony.sync.isNullOrUndefined(otaServerChanges.d)) {
                kony.sync.deleteLastUploadRequestWithNewTransaction(deleteLastUploadRequestCallback);
            } else {
                addLastUploadRequestCallback();
            }
            return;
        } else if (kony.sync.isNullOrUndefined(otaServerChanges.d)) {
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in kony.sync.syncUploadChangesForBatch->uploadAllTransactionSuccess");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.onUploadCompletion(true, kony.sync.getServerError(otaServerChanges.d));
            return;
        }

        function addLastUploadRequestCallback() {
            sync.log.trace("Entering addLastUploadRequestCallback");
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in kony.sync.syncUploadChangesForBatch->addLastUploadRequestCallback");
                kony.sync.stopSyncSession();
                return;
            }
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->addLastUploadRequestCallback");
            kony.sync.onUploadCompletion(true, kony.sync.getServerError(otaServerChanges.d));
        }
        if (otaServerChanges.d.error === "false") {
            if (!kony.sync.isNullOrUndefined(otaServerChanges.d.__sync) && !kony.sync.isNullOrUndefined(otaServerChanges.d.__sync.serverblob)) {
                rowItem[kony.sync.metaTableUploadSyncTimeColumn] = otaServerChanges.d.__sync.serverblob;
                kony.sync.currentSyncReturnParams[kony.sync.serverDetails] = {};
                kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(otaServerChanges);
                kony.sync.currentSyncReturnParams[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(otaServerChanges);
                //setSequenceNumberForUploadResponse(limit);
                if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                    kony.sync.clearSyncOrder(kony.sync.currentScope[kony.sync.scopeDataSource], limit, rowItem[kony.sync.metaTableUploadSyncTimeColumn], true, setSeqNoWrapper);
                } else {
                    kony.sync.setOTAUploadResponse(otaServerChanges, setSeqNoWrapper, limit);
                }
            } else {
                addLastUploadRequestCallback();
            }
        } else {
            kony.sync.deleteLastUploadRequestWithNewTransaction(deleteLastUploadRequestCallback);
            return;
        }

        function deleteLastUploadRequestCallback() {
            sync.log.trace("Entering deleteLastUploadRequestCallback");
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in kony.sync.syncUploadChangesForBatch->deleteLastUploadRequestCallback");
                kony.sync.stopSyncSession();
                return;
            }
            kony.sync.onUploadCompletion(true, kony.sync.getServerError(otaServerChanges.d));
        }

        function setSequenceNumberForUploadResponse(limit) {
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->setSequenceNumberForUploadResponse");
            if (kony.sync.currentScope[kony.sync.syncStrategy] !== kony.sync.syncStrategy_OTA) {
                setSeqNoWrapper();
            } else {
                kony.sync.setOTAUploadResponse(otaServerChanges, setSeqNoWrapper, limit);
            }
        }

        function setSeqNoWrapper() {
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->setSeqNoWrapper");
            kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + 1;
            kony.sync.setSeqnumber(kony.sync.currentScope.ScopeName, kony.sync.currentScope[kony.sync.scopeDataSource], kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName], setSeqNoCallback);
        }

        function setSeqNoCallback() {
            sync.log.trace("Entering setSeqNoCallback");
            if (kony.sync.isSyncStopped) {
                sync.log.debug("sync stopped in uploadAllTransactionSuccess -> setSeqNoCallback");
                kony.sync.stopSyncSession();
                return;
            }
            sync.log.trace("Entering kony.sync.syncUploadChangesForBatch->setSeqNoCallback");
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsUploaded] = kony.sync.syncTotalInserts + kony.sync.syncTotalUpdates + kony.sync.syncTotalDeletes;
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsInserted] = kony.sync.syncTotalInserts;
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsUpdated] = kony.sync.syncTotalUpdates;
            kony.sync.uploadcontextMap[kony.sync.numberOfRowsDeleted] = kony.sync.syncTotalDeletes;
            var uploadBatchContextMap = {};
            uploadBatchContextMap[kony.sync.numberOfRowsUploaded] = kony.sync.syncTotalBatchInserts + kony.sync.syncTotalBatchUpdates + kony.sync.syncTotalBatchDeletes;
            uploadBatchContextMap[kony.sync.numberOfRowsInserted] = kony.sync.syncTotalBatchInserts;
            uploadBatchContextMap[kony.sync.numberOfRowsUpdated] = kony.sync.syncTotalBatchUpdates;
            uploadBatchContextMap[kony.sync.numberOfRowsDeleted] = kony.sync.syncTotalBatchDeletes;
            uploadBatchContextMap[kony.sync.serverDetails] = {};
            uploadBatchContextMap[kony.sync.serverDetails][kony.sync.hostName] = kony.sync.getServerDetailsHostName(otaServerChanges);
            uploadBatchContextMap[kony.sync.serverDetails][kony.sync.ipAddress] = kony.sync.getServerDetailsIpAddress(otaServerChanges);
            if (kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA) {
                kony.sync.uploadcontextMap[kony.sync.objectLevelInfo] = kony.sync.objectLevelInfoMap;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsAcknowledged] = kony.sync.serverInsertAckCount + kony.sync.serverUpdateAckCount + kony.sync.serverDeleteAckCount;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsInsertedAck] = kony.sync.serverInsertAckCount;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsUpdatedAck] = kony.sync.serverUpdateAckCount;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsDeletedAck] = kony.sync.serverDeleteAckCount;
                kony.sync.uploadcontextMap[kony.sync.failedRowInfo] = kony.sync.uploadSummary;
                kony.sync.uploadcontextMap[kony.sync.numberOfRowsFailedtoUpload] = kony.sync.serverFailedCount;
            }
            var uploadBatchParams = {};
            uploadBatchParams[kony.sync.uploadContext] = kony.sync.uploadcontextMap;
            uploadBatchParams[kony.sync.uploadBatchContext] = uploadBatchContextMap;
            kony.sync.verifyAndCallClosure(kony.sync.currentSyncConfigParams[kony.sync.onUploadBatchSuccess], uploadBatchParams);
            //clearing variables before calling 2nd batch
            otaServerChanges = null;
            uploadBatchParams = null;
            uploadBatchContextMap = null;
            changeset = null;
            firstBatch = null;
            lastBatch = null;
            batchSize = null;
            offset = null;
            serverblob1 = null;
            //call upload batching recursively
            kony.sync.syncUploadChangesForBatch(rowItem, previousUpload !== "" ? "*" : "", limit);
        }
    }
    if (previousUpload === "" || previousUpload === "*") {
        var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
        var connection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncUploadFailed);
        if (connection !== null) {
            kony.db.transaction(connection, uploadAllTransaction, transactionErrorCallback, uploadTransactionSuccess);
        }
    } else {
        changeset = previousUpload[kony.sync.pendingUploadTableUploadRequest];
        try {
            kony.sync.objectLevelInfoMap = JSON.parse(previousUpload[kony.sync.pendingUploadTableObjectLevelInfo]);
        } catch (e) {
            sync.log.error("Error occurred while re-framing last persisted upload request:" + e);
            kony.sync.onUploadCompletion(true, kony.sync.getErrorTable(kony.sync.errorCodeParseError, kony.sync.getErrorMessage(kony.sync.errorCodeParseError, previousUpload[kony.sync.pendingUploadTableObjectLevelInfo], e)));
            return;
        }
        changeset = previousUpload[kony.sync.pendingUploadTableUploadRequest];
        kony.sync.syncTotalInserts = previousUpload[kony.sync.pendingUploadTableInsertCount];
        kony.sync.syncTotalUpdates = previousUpload[kony.sync.pendingUploadTableUpdateCount];
        kony.sync.syncTotalDeletes = previousUpload[kony.sync.pendingUploadTableDeleteCount];
        kony.sync.syncTotalBatchInserts = previousUpload[kony.sync.pendingUploadTableBatchInsertCount];
        kony.sync.syncTotalBatchUpdates = previousUpload[kony.sync.pendingUploadTableBatchUpdateCount];
        kony.sync.syncTotalBatchDeletes = previousUpload[kony.sync.pendingUploadTableBatchDeleteCount];
        limit = previousUpload[kony.sync.pendingUploadTableUploadLimit];
        firstBatch = true;
        uploadTransactionSuccess();
    }
};
kony.sync.setOTAUploadResponse = function(serverChanges, callback, limit) {
    sync.log.trace("Entering kony.sync.setOTAUploadResponse");
    var isError = false;
    if (!kony.sync.isNullOrUndefined(serverChanges.d) && !kony.sync.isNullOrUndefined(serverChanges.d.results)) {
        for (var i = 0; i < serverChanges.d.results.length; i++) {
            kony.sync.OTAChangestobeDeleted.push(serverChanges.d.results[i]);
        }
    }

    function setOTAUploadResponseTransaction(tx) {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransaction");
        if (!kony.sync.isNullOrUndefined(limit)) {
            //updating sync version for all records going in next batch
            if (kony.sync.updateSyncOrderForUploadBatching(tx, limit) === false) {
                isError = true;
                return;
            }
            var serverblob = serverChanges.d.__sync.serverblob;
            //updating upload timestamp
            if (kony.sync.setLastSyncUploadContext(tx, kony.sync.currentScope[kony.sync.scopeName], serverblob) === false) {
                isError = true;
                return;
            }
        }
        //apply response to DB for the uploaded items.
        isError = kony.sync.applyChanges(tx, kony.sync.currentScope, serverChanges, kony.sync.gPolicy);
        sync.log.trace("kony.sync.setOTAUploadResponse->After kony.sync.applyChanges and isError = " + isError);
        if (isError) {
            sync.log.trace("kony.sync.setOTAUploadResponse-> isError = true;  lastUploadRequest will not be deleted from the storage.");
            return;
        }
        //delete last upload request
        if (kony.sync.deleteLastUploadRequest(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
            return;
        }
    }

    function setOTAUploadResponseTransactionSuccess() {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransactionSuccess");
        callback();
    }

    function setOTAUploadResponseTransactionFailure() {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransactionFailure");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname, kony.sync.syncUploadFailed);
    if (connection !== null) {
        kony.db.transaction(connection, setOTAUploadResponseTransaction, setOTAUploadResponseTransactionFailure, setOTAUploadResponseTransactionSuccess);
    }
};
kony.sync.syncUploadFailed = function(connection) {
    sync.log.trace("Entering kony.sync.syncUploadFailed");
    kony.sync.onUploadCompletion(true, JSON.stringify(connection));
    sync.log.error("Upload Failed", connection);
};
//To get smallest sequence number from all history tables of a scope
kony.sync.getSmallestSequenceNumber = function(tx) {
    sync.log.trace("Entering kony.sync.getSmallestSequenceNumber");
    if (kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
        return -1;
    }
    var seqNo = -1; //initialize sequence number
    for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
        var syncTable = kony.sync.currentScope.ScopeTables[i];
        //not using query builder to speedup sync time
        var sql = "select min(" + kony.sync.historyTableReplaySequenceColumn + ") from " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName];
        var resultset = kony.sync.executeSql(tx, sql, null);
        if (resultset === false) {
            return false; //error occurred while executing query
        }
        var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
        var seqNoFromTable = kony.sync.tonumber(rowItem["min(" + kony.sync.historyTableReplaySequenceColumn + ")"]);
        seqNo = (seqNo === -1 || seqNoFromTable < seqNo) && seqNoFromTable !== null ? seqNoFromTable : seqNo;
    }
    return seqNo;
};
kony.sync.getBatchChanges = function(tx, scope, offset, limit, changeset, lastSeqNo, batchSize) {
    sync.log.trace("Entering kony.sync.getBatchChanges");
    var tc = null;
    var continueGettingChanges = true;
    kony.sync.uploadLimit = 0;
    var tempUploadLimit;
    var tableDictionary = {}; //dictionary to get index of a table in changeset
    var tableDictionarySize = 0;
    var replaySequenceDictionary = [];
    var dummyReplaySequenceNumber = -1 * batchSize;
    do {
        for (var i = 0; !kony.sync.isNull(kony.sync.currentScope.ScopeTables) && i < kony.sync.currentScope.ScopeTables.length; i++) {
            var syncTable = kony.sync.currentScope.ScopeTables[i];
            if (kony.sync.isNullOrUndefined(kony.sync.objectLevelInfoMap[syncTable.Name])) {
                kony.sync.objectLevelInfoMap[syncTable.Name] = {};
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUploaded] = 0;
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] = 0;
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] = 0;
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted] = 0;
                if ((kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA)) {
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInsertedAck] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdatedAck] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeletedAck] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsAcknowledged] = 0;
                    kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsFailedtoUpload] = 0;
                }
            }
            if (kony.sync.currentScope.isHierarchical === true) {
                tableDictionary[syncTable.Name] = i;
                tableDictionarySize++;
            }
            tc = null;
            if (kony.sync.isNullOrUndefined(changeset.tables[i])) {
                tc = {
                    tableName: syncTable.Name,
                    changes: []
                };
                changeset.tables[i] = tc;
            } else {
                tc = changeset.tables[i];
            }
            var fields = [];
            if (!kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables[i].Columns)) {
                for (var j = 0; j < kony.sync.currentScope.ScopeTables[i].Columns.length; j++) {
                    var col = kony.sync.currentScope.ScopeTables[i].Columns[j];
                    kony.table.insert(fields, col.Name);
                }
            }
            kony.table.insert(fields, kony.sync.historyTableChangeTypeColumn);
            kony.table.insert(fields, kony.sync.historyTableReplaySequenceColumn);
            kony.table.insert(fields, kony.sync.historyTableSyncVersionColumn);
            kony.table.insert(fields, kony.sync.historyTableHashSumColumn);
            //not using query builder to speedup sync time
            var sql = "select * from " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + " AND " + kony.sync.historyTableReplaySequenceColumn + " between " + offset + " AND " + limit;
            var resultset = kony.sync.executeSql(tx, sql, null);
            if (resultset === false) {
                return false;
            }
            prepareChangeSet(tx, resultset);
            sync.log.info("changes for " + syncTable.Name + ":", changeset.tables[i].changes);
            sql = "select max(" + kony.sync.historyTableReplaySequenceColumn + ") from " + syncTable.Name + kony.sync.historyTableName + " where " + kony.sync.historyTableChangeTypeColumn + " NOT LIKE '9%' AND " + kony.sync.historyTableSyncVersionColumn + " = " + kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + " AND " + kony.sync.historyTableReplaySequenceColumn + " between " + offset + " AND " + limit;
            resultset = kony.sync.executeSql(tx, sql, null);
            if (resultset === false) {
                return false;
            }
            tempUploadLimit = kony.db.sqlResultsetRowItem(tx, resultset, 0)["max(" + kony.sync.historyTableReplaySequenceColumn + ")"];
            if (tempUploadLimit !== null && tempUploadLimit > kony.sync.uploadLimit) {
                kony.sync.uploadLimit = tempUploadLimit;
            }
            if (changeset.totalChanges === batchSize) {
                break; //got all changes
            }
        }
        if (changeset.totalChanges < batchSize && limit < lastSeqNo) {
            offset = limit + 1;
            limit += batchSize - changeset.totalChanges;
        } else {
            if (kony.sync.currentScope.isHierarchical === true) {
                function createDummyChangeSet(parentTableName, row) {
                    sync.log.trace("Creating Dummy ChangeSet Record");
                    var changesetIndex = tableDictionary[parentTableName];
                    tc = null;
                    //getting the actual table
                    if (kony.sync.isNullOrUndefined(changeset.tables[changesetIndex])) {
                        tc = {
                            tableName: parentTableName,
                            changes: []
                        };
                        changeset.tables[changesetIndex] = tc;
                    } else {
                        tc = changeset.tables[changesetIndex];
                    }
                    var changeType = row[kony.sync.historyTableChangeTypeColumn] + "";
                    var rc = {
                        fields: [],
                        values: []
                    };
                    syncTable = kony.sync.currentScope.syncTableDic[parentTableName];
                    if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                        for (var x = 0; x < syncTable.Columns.length; x++) {
                            var column = syncTable.Columns[x];
                            if (kony.sync.isNullOrUndefined(row[column.Name])) {
                                kony.table.insert(rc.fields, column.Name);
                                kony.table.insert(rc.values, "null");
                            }
                        }
                    }
                    row[kony.sync.mainTableChangeTypeColumn] = 1;
                    row[kony.sync.historyTableChangeTimeColumn] = null;
                    row[kony.sync.mainTableHashSumColumn] = null;
                    for (var key in row) {
                        if (key !== kony.sync.syncStatusColumn) {
                            kony.table.insert(rc.fields, key);
                            kony.table.insert(rc.values, row[key]);
                        }
                    }
                    rc.changeType = "update";
                    //creating metainfo if it doesnot exist
                    if (kony.sync.isNullOrUndefined(kony.sync.objectLevelInfoMap[parentTableName])) {
                        kony.sync.objectLevelInfoMap[parentTableName] = {};
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUploaded] = 0;
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsInserted] = 0;
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdated] = 0;
                        kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsDeleted] = 0;
                        if ((kony.sync.currentScope[kony.sync.syncStrategy] === kony.sync.syncStrategy_OTA)) {
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsInsertedAck] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdatedAck] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsDeletedAck] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsAcknowledged] = 0;
                            kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsFailedtoUpload] = 0;
                        }
                    }
                    kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[parentTableName][kony.sync.numberOfRowsUpdated] + 1;
                    kony.sync.syncTotalBatchUpdates += 1;
                    sync.log.info("adding the dummy record metadata to batchchangeset metadata");
                    kony.table.insert(rc.fields, kony.sync.historyTableReplaySequenceColumn);
                    kony.table.insert(rc.values, dummyReplaySequenceNumber);
                    //giving dummy replay sequence number for the record and sending it as update
                    dummyReplaySequenceNumber++;
                    sync.log.info("updated dummy replay sequence number " + dummyReplaySequenceNumber);
                    //finally adding the record to the changeset
                    sync.log.info("inserted the record into the change set " + JSON.stringify(rc));
                    kony.table.insert(tc.changes, rc);
                    sync.log.info("changeset of table " + parentTableName + " " + JSON.stringify(tc.changes));
                    //return the index of newly inserted record
                    return (tc.changes.length - 1);
                }

                function isEmptyObject(object) {
                    for (var key in object) {
                        return false;
                    }
                    return true;
                }

                function fetchParentFromMainTable(parentTableName, childRecord, childTableName) {
                    sync.log.trace("entering into fetch parent from main table");
                    wherecondition = [];
                    //getting the parents of the child table
                    parentRelationshipMap = kony.sync.currentScope.syncTableDic[childTableName + kony.sync.parentRelationshipMap];
                    childTable = kony.sync.currentScope.syncTableDic[childTableName];
                    var childValues = childRecord.values;
                    if (parentRelationshipMap[parentTableName]) { //checking whether child is a part of any onetomany relationship of parent
                        var relationshipAttributes = parentRelationshipMap[parentTableName];
                        for (var k = 0; k < relationshipAttributes.length; k++) {
                            relationshipAttribute = relationshipAttributes[k];
                            var columnName = relationshipAttribute["ParentObject_Attribute"];
                            var childColumnName = relationshipAttribute["ChildObject_Attribute"];
                            childFieldIndex = getFieldsIndex(childRecord.fields, childColumnName);
                            kony.table.insert(wherecondition, {
                                key: columnName,
                                value: childValues[childFieldIndex]
                            });
                        }
                    } else {
                        ManyToOne = childTable.Relationships.ManyToOne;
                        if (!kony.sync.isNullOrUndefined(ManyToOne)) {
                            for (var k = 0; k < ManyToOne.length; k++) {
                                var currentRelation = ManyToOne[k];
                                if (currentRelation.TargetObject == parentTableName) {
                                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                                    for (var j = 0; j < relationshipAttributes.length; j++) {
                                        var columnName = relationshipAttributes[j].TargetObject_Attribute;
                                        var childColumnName = relationshipAttributes[j].SourceObject_Attribute;
                                        childFieldIndex = getFieldsIndex(childRecord.fields, childColumnName);
                                        kony.table.insert(wherecondition, {
                                            key: columnName,
                                            value: childValues[childFieldIndex]
                                        });
                                    };
                                }
                            }
                        }
                    }
                    if (wherecondition.length != 0) {
                        //fetchParentFromMainTable
                        query = kony.sync.qb_createQuery();
                        kony.sync.qb_select(query, null);
                        kony.sync.qb_from(query, parentTableName);
                        kony.sync.qb_where(query, wherecondition);
                        query_compile = kony.sync.qb_compile(query);
                        sql = query_compile[0];
                        params = query_compile[1];
                        resultset = kony.sync.executeSql(tx, sql, params);
                        if (resultset.rows.length >= 1) {
                            var rowItem = kony.db.sqlResultsetRowItem(tx, resultset, 0);
                            parentRecordIndex = createDummyChangeSet(parentTableName, rowItem);
                            sync.log.info("index of the dummy record in the changeset corrrespoding to the " + parentTableName + " is " + parentRecordIndex);
                            return parentRecordIndex; //actual index according to zero based indexing
                        } else {
                            sync.log.error("no records in  :" + parentTableName + " with a child in " + childTableName);
                            return -1;
                        }
                    } else {
                        sync.log.error("Invalid Operation is defined for table :" + childTable + " with operations to" + parentTable);
                        return -1;
                    }
                }

                function checkInChangeSet(parentTableName, childRecord, childTableName) {
                    sync.log.trace("entering into checkInChangeSet function ");
                    var parentColumns = [];
                    var childColumns = [];
                    sync.log.info("check in changeset for parent " + parentTableName + " with child " + childTableName);
                    parentRelationshipMap = kony.sync.currentScope.syncTableDic[childTableName + kony.sync.parentRelationshipMap];
                    if (parentRelationshipMap[parentTableName]) { //checking whether child is a part of any onetomany relationship of parent
                        var relationshipAttributes = parentRelationshipMap[parentTableName];
                        var relationshipAttributes_length = relationshipAttributes.length;
                        for (var k = 0; k < relationshipAttributes_length; k++) {
                            relationshipAttribute = relationshipAttributes[k];
                            var columnName = relationshipAttribute["ParentObject_Attribute"];
                            var childColumnName = relationshipAttribute["ChildObject_Attribute"];
                            parentColumns.push(columnName);
                            childColumns.push(childColumnName);
                        }
                    } else {
                        ManyToOne = childTable.Relationships.ManyToOne;
                        if (!kony.sync.isNullOrUndefined(ManyToOne)) {
                            for (var k = 0; k < ManyToOne.length; k++) {
                                currentRelation = ManyToOne[k];
                                if (currentRelation.TargetObject == parentTableName) {
                                    var relationshipAttributes = currentRelation.RelationshipAttributes;
                                    for (var j = 0; j < relationshipAttributes.length; j++) {
                                        var columnName = relationshipAttributes[j].TargetObject_Attribute;
                                        var childColumnName = relationshipAttributes[j].SourceObject_Attribute;
                                        parentColumns.push(columnName);
                                        childColumns.push(childColumnName);
                                    }
                                }
                            }
                        }
                    }
                    if (kony.sync.isNullOrUndefined(tableDictionary[parentTableName])) return false;
                    var changeSetIndex = tableDictionary[parentTableName]; //index in changeset
                    var records = changeset.tables[changeSetIndex].changes; //child object changeset
                    for (var j = 0; j < records.length; j++) {
                        parentRecord = records[j]; //parent records
                        var matchCount = 0;
                        var parentValues = parentRecord.values;
                        var childValues = childRecord.values;
                        for (var k = 0; k < parentColumns.length; k++) {
                            parentFieldIndex = getFieldsIndex(parentRecord.fields, parentColumns[k]);
                            childFieldIndex = getFieldsIndex(childRecord.fields, childColumns[k]);
                            if (parentValues[parentFieldIndex] != childValues[childFieldIndex]) {
                                break;
                            }
                            matchCount++;
                        }
                        if (matchCount == parentColumns.length) {
                            sync.log.info("record found in changeset for parent " + parentTableName + " with child " + childTableName);
                            return true;
                        }
                    }
                    return false;
                }

                function getFieldsIndex(fields, columnName) { //helper function
                    for (var k = 0; k < fields.length; k++) {
                        if (fields[k] === columnName) return k; //fieldIndex
                    }
                    sync.log.error("error in changeSet record creation: no " + columnName + " found in fields");
                }

                function fetchAndAddParents(parentTableName, childRecord, childTableName) {
                    sync.log.trace("entering into fetchAndAddParents");
                    //checking whether this parentTable is a part of changesetdictionary
                    if (tableDictionary[parentTableName] === undefined) {
                        tableDictionary[parentTableName] = tableDictionarySize; //for the changeset
                        tableDictionarySize++;
                    }
                    parentRecordIndex = fetchParentFromMainTable(parentTableName, childRecord, childTableName);
                    if (parentRecordIndex == -1) {
                        sync.log.error("improper relationships defined for " + parentTableName);
                        return -1; //
                    }
                    var tablesIndex = tableDictionary[parentTableName];
                    var parentRecord = changeset.tables[tablesIndex].changes[parentRecordIndex];
                    var parentTable = kony.sync.currentScope.syncTableDic[parentTableName];
                    //hierarchial upload operations  metadata
                    var parentTableOperations = parentTable.InputOperations;
                    if (parentTableOperations === undefined) return; //no operations defined for the parent
                    var parentRecordChangeType = parentRecord.changeType;
                    var currentOperation = parentTableOperations[parentRecordChangeType];
                    if (currentOperation === undefined) return; //no operation defined with this change type
                    var parentTableNames = currentOperation.Parents;
                    var childTableNames = currentOperation.Children;
                    if (isRoot(currentOperation) === false) { //not root
                        if (parentTableNames != undefined) {
                            for (var i = 0; i < parentTableNames.length; i++) {
                                //to avoid sending a record which is already in changeset
                                if (checkInChangeSet(parentTableNames[i], parentRecord, parentTableName) === false) {
                                    parentRecordIndex = fetchAndAddParents(parentTableNames[i], parentRecord, parentTableName);
                                }
                            }
                        }
                    }
                    sync.log.info("mark all the child records in the changeSet");
                    //mark all the children in the changeset
                    if (childTableNames != undefined) {
                        for (var i = 0; i < childTableNames.length; i++) {
                            markChildRecords(childRelationInfo[parentTableName], parentRecord, parentTableName, childTableNames[i]);
                        }
                    }
                }

                function markChildRecords(childRelation, parentRecord, parentTableName, childTableName) {
                    sync.log.trace("entering into markChildRecords function");
                    changeSetIndex = tableDictionary[childTableName]; //index in changeset
                    if (changeSetIndex === undefined) {
                        sync.log.info("no child records found in the change set to mark");
                        //when the childRecords are no there at all in changeset they wont be present in tabledictionary
                        return;
                    }
                    var records = changeset.tables[changeSetIndex].changes; //child object changeset
                    // not putting a null check as changes is an array
                    for (var j = 0; j < records.length; j++) {
                        var parentColumns = childRelation[childTableName].parentColumns;
                        var childColumns = childRelation[childTableName].childColumns;
                        childRecord = records[j]; //child records
                        var matchCount = 0;
                        var parentValues = parentRecord.values;
                        var childValues = childRecord.values;
                        for (var k = 0; k < parentColumns.length; k++) {
                            parentFieldIndex = getFieldsIndex(parentRecord.fields, parentColumns[k]);
                            childFieldIndex = getFieldsIndex(childRecord.fields, childColumns[k]);
                            if (parentValues[parentFieldIndex] != childValues[childFieldIndex]) {
                                break;
                            }
                            matchCount++;
                        }
                        if (matchCount == parentColumns.length) {
                            if (childRecord.visitedParents === undefined) childRecord.visitedParents = [];
                            sync.log.info("child record found in changeset with parent " + parentTableName + " and child " + childTableName);
                            childRecord.visitedParents.push(parentTableName);
                        }
                    }
                }

                function getChildRelationsInfo(currentTableName) {
                    sync.log.trace("entering into getChildRelationsInfo ");
                    var childRelation = {};
                    // dictionary for relationships,need to optimise
                    currentTable = kony.sync.currentScope.syncTableDic[currentTableName];
                    OneToMany = currentTable.Relationships.OneToMany;
                    if (!kony.sync.isNullOrUndefined(currentTable.Relationships.OneToMany)) {
                        for (var j = 0; j < OneToMany.length; j++) {
                            var currentRelation = OneToMany[j];
                            if (childRelation[currentRelation.TargetObject] === undefined) {
                                childRelation[currentRelation.TargetObject] = {};
                                childRelation[currentRelation.TargetObject].parentColumns = [];
                                childRelation[currentRelation.TargetObject].childColumns = [];
                            }
                            RelationshipAttributes = currentRelation.RelationshipAttributes;
                            for (var k = 0; k < RelationshipAttributes.length; k++) {
                                childRelation[currentRelation.TargetObject].parentColumns.push(RelationshipAttributes[k].SourceObject_Attribute);
                                childRelation[currentRelation.TargetObject].childColumns.push(RelationshipAttributes[k].TargetObject_Attribute);
                            }
                        }
                    }
                    reverseRelationships = kony.sync.currentScope.reverseRelationships[currentTableName];
                    if (!kony.sync.isNullOrUndefined(reverseRelationships)) {
                        for (var k = 0; k < reverseRelationships.length; k++) {
                            var currentRelation = reverseRelationships[k]
                            if (childRelation[currentRelation.TargetObject] === undefined) {
                                childRelation[currentRelation.TargetObject] = {};
                                childRelation[currentRelation.TargetObject].parentColumns = [];
                                childRelation[currentRelation.TargetObject].childColumns = [];
                            }
                            relationshipAttributes = currentRelation.RelationshipAttributes;
                            for (var j = 0; j < relationshipAttributes.length; j++) {
                                childRelation[currentRelation.TargetObject].parentColumns.push(relationshipAttributes[j].SourceObject_Attribute);
                                childRelation[currentRelation.TargetObject].childColumns.push(relationshipAttributes[j].TargetObject_Attribute);
                            }
                        }
                    }
                    return childRelation;
                }
                //entry point here
                childRelationInfo = {};
                scopeTables = kony.sync.currentScope.ScopeTables;
                for (var j = 0; j < scopeTables.length; j++) {
                    childRelationInfo[scopeTables[j].Name] = getChildRelationsInfo(scopeTables[j].Name);
                }
                //comparator function to sort dictionary
                function compare(a, b) {
                    if (a.konysyncreplaysequence < b.konysyncreplaysequence) return -1;
                    if (a.konysyncreplaysequence > b.konysyncreplaysequence) return 1;
                    return 0;
                }
                sync.log.info("sorting the dictionary of changeset metadata w.r.t konyreplaysequence");
                //sorting the dictionary of changeset metadata w.r.t konyreplaysequence
                replaySequenceDictionary.sort(compare);
                //Parent-child heirarchy upload Algoritm starts here ......
                for (var j = 0; j < replaySequenceDictionary.length; j++) {
                    var replaySequenceValue = replaySequenceDictionary[j];
                    var changeSetIndex = replaySequenceValue.changeSetIndex;
                    var syncTableName = replaySequenceValue.syncTableName;
                    var tableIndex = tableDictionary[syncTableName];
                    var currentRecord = changeset.tables[tableIndex].changes[changeSetIndex];
                    var changeType = currentRecord.changeType;
                    if (kony.sync.currentScope.syncTableDic[syncTableName].InputOperations === undefined) {
                        sync.log.info("no operation defined for " + syncTableName + " table");
                        continue; //no operation defined for this table
                    }
                    var operations = kony.sync.currentScope.syncTableDic[syncTableName].InputOperations;
                    var currentOperation = operations[changeType];
                    if (currentOperation === undefined) {
                        sync.log.info("no operation defined for " + syncTableName + " table with changetype " + changeType);
                        continue; //no operation with this change type defined for this table
                    }
                    var childTableNames = currentOperation.Children;
                    if (isRoot(currentOperation) === false) {
                        var parentsTable = kony.sync.createClone(currentOperation.Parents);
                        if (parentsTable === undefined) {
                            sync.log.info("no parents defined for " + syncTableName + " table with changetype " + changeType);
                            continue; //no parents defined for a child
                        }
                        if (currentRecord.visitedParents === undefined) {
                            currentRecord.visitedParents = [];
                        }
                        //getting the parents that are not visited
                        for (var k = 0; k < currentRecord.visitedParents.length; k++) {
                            var index = parentsTable.indexOf(currentRecord.visitedParents[k]);
                            if (index > -1) {
                                parentsTable.splice(index, 1);
                            } else {
                                sync.log.error("operations not defined properly for " + syncTableName);
                            }
                        }
                        for (var k = 0; k < parentsTable.length; k++) {
                            sync.log.info("fetch parent records  of " + currentRecord + " tablename " + syncTableName + "  with parent " + parentsTable[k]);
                            parentRecord = fetchAndAddParents(parentsTable[k], currentRecord, syncTableName);
                        }
                    }
                    //mark all the children in the changeset
                    if (childTableNames != undefined) {
                        for (var k = 0; k < childTableNames.length; k++) {
                            sync.log.info("mark child records of " + syncTableName + " for child " + childTableNames[k]);
                            markChildRecords(childRelationInfo[syncTableName], currentRecord, syncTableName, childTableNames[k]);
                        }
                    }
                }

                function isRoot(currentOperation) {
                    sync.log.trace("entering into isRoot");
                    if (currentOperation.isRoot != undefined) {
                        isRootFlag = currentOperation.isRoot[0];
                        if (isRootFlag === "true") return true;
                    }
                    return false;
                }
            }
            continueGettingChanges = false;
        }
    } while (continueGettingChanges);

    function prepareChangeSet(tx, resultset) {
        sync.log.trace("Entering kony.sync.getBatchChanges->prepareChangeSet");
        var len = resultset.rows.length;
        for (var k = 0; k < len; k++) {
            var row = kony.db.sqlResultsetRowItem(tx, resultset, k);
            if (!kony.sync.isNullOrUndefined(kony.sync.scopes.syncScopeBlobInfoMap[syncTable.Name])) {
                populateBinaryData(tx, row);
            }
            var changeType = row[kony.sync.historyTableChangeTypeColumn] + "";
            if (kony.sync.currentScope.isHierarchical === true) {
                var replaySequenceMap = {};
                replaySequenceMap["syncTableName"] = syncTable.Name;
                replaySequenceMap["changeSetIndex"] = k;
                replaySequenceMap["konysyncreplaysequence"] = row[kony.sync.historyTableReplaySequenceColumn];
                replaySequenceDictionary.push(replaySequenceMap); //need to check
            }
            var rc = {
                fields: [],
                values: []
            };
            if (changeType === kony.sync.insertColStatus) {
                rc.changeType = "insert";
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] + 1;
                kony.sync.syncTotalBatchInserts += 1;
            } else if (changeType === kony.sync.updateColStatus) {
                rc.changeType = "update";
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] + 1;
                kony.sync.syncTotalBatchUpdates += 1;
            } else if (changeType === kony.sync.deleteColStatus) {
                rc.changeType = "delete";
                kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted] + 1;
                kony.sync.syncTotalBatchDeletes += 1;
            }
            //for all the missing columns, insert null.
            if (!kony.sync.isNullOrUndefined(syncTable.Columns)) {
                for (var x = 0; x < syncTable.Columns.length; x++) {
                    var column = syncTable.Columns[x];
                    if (kony.sync.isNullOrUndefined(row[column.Name])) {
                        if (column.Name.indexOf(kony.sync.binaryMetaColumnPrefix) !== 0 && column.type !== kony.sync.blob) {
                            kony.table.insert(rc.fields, column.Name);
                            kony.table.insert(rc.values, "null");
                        }
                    }
                }
            }
            for (var key in row) {
                if (key !== kony.sync.syncStatusColumn) {
                    kony.table.insert(rc.fields, key);
                    kony.table.insert(rc.values, row[key]);
                }
            }
            kony.table.insert(tc.changes, rc);
        }
        changeset.totalChanges = changeset.totalChanges + len;
        kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUploaded] = kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsInserted] + kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsUpdated] + kony.sync.objectLevelInfoMap[syncTable.Name][kony.sync.numberOfRowsDeleted];
    }

    function populateBinaryData(tx, row) {
        sync.log.trace("Entering populateBinaryData");
        var binaryColumns = kony.sync.scopes.syncScopeBlobInfoMap[syncTable.Name][kony.sync.columns];
        var binaryColumnName = null;
        var binaryMetaFieldKey = null;
        for (var i = 0; i < binaryColumns.length; i++) {
            binaryColumnName = binaryColumns[i];
            var downloadPolicy = kony.sync.getDownloadPolicy(syncTable.Name, binaryColumnName);
            if (downloadPolicy !== kony.sync.inline) {
                delete row[binaryColumnName];
                binaryMetaFieldKey = kony.sync.binaryMetaColumnPrefix + binaryColumnName;
                delete row[binaryMetaFieldKey];
            }
            //Add the columns with inline downloadpolicy.
            else if (downloadPolicy === kony.sync.inline) {
                binaryMetaFieldKey = kony.sync.binaryMetaColumnPrefix + binaryColumnName;
                var blobIndex = row[binaryMetaFieldKey];
                //If the record has any binary data..
                if (blobIndex && blobIndex !== kony.sync.blobRefNotFound && blobIndex !== kony.sync.blobRefNotDefined) {
                    //get the state of the blob. if is in stable, then only push.
                    var blobMeta = kony.sync.blobManager.getBlobMetaDetails(tx, blobIndex, function(err) {
                        kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
                    });
                    if (blobMeta[kony.sync.blobManager.state] === kony.sync.blobManager.NO_OPERATION && blobMeta[kony.sync.blobManager.status] === 100) {
                        //file exists. upload.
                        var base64String = binary.util.getBase64FromFiles([blobMeta[kony.sync.blobManager.localPath]]);
                        if (base64String[0].length > 0) {
                            row[binaryColumnName] = base64String[0];
                        } else {
                            //FILE Doesn't exist.
                            var valuesTable = {};
                            valuesTable.state = kony.sync.blobManager.FILE_DOESNOT_EXIST;
                            var resultset = kony.sync.blobManager.updateBlobManager(tx, blobIndex, valuesTable, function(err) {
                                kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
                            });
                            if (resultset !== null && resultset !== false) {
                                kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeBlobFileDoesnotExist, kony.sync.getErrorMessage(kony.sync.errorCodeBlobFileDoesnotExist), null));
                            }
                            delete row[binaryMetaFieldKey];
                        }
                    } else {
                        //file is in invalid state.
                        //TODO-throw error..blob in invalid state..
                        kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeBlobInvalidState, kony.sync.getErrorMessage(kony.sync.errorCodeBlobInvalidState), null));
                    }
                }
            }
        }

        function errorCallback(error) {
            sync.log.trace(" error occured while fetching blob ");
        }
    }
    sync.log.info("Total number of changes to be uploaded = ", changeset.totalChanges);
    return limit;
};
//This will update syncorder for Pending uploads
kony.sync.updateSyncOrderForUploadBatching = function(tx, limit) {
    sync.log.trace("Entering kony.sync.updateSyncOrderForUploadBatching");
    if (kony.sync.isNullOrUndefined(kony.sync.currentScope.ScopeTables)) {
        return true;
    }
    for (var i = 0; i < kony.sync.currentScope.ScopeTables.length; i++) {
        var syncTable = kony.sync.currentScope.ScopeTables[i];
        if (kony.sync.isNullOrUndefined(syncTable)) {
            continue;
        }
        var tablename = syncTable.Name;
        var settable = {};
        settable[kony.sync.historyTableSyncVersionColumn] = kony.sync.currentSyncScopesState[kony.sync.currentScope.ScopeName] + 1;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_update(query, tablename + kony.sync.historyTableName);
        kony.sync.qb_set(query, settable);
        kony.sync.qb_where(query, [{
            key: kony.sync.historyTableReplaySequenceColumn,
            value: limit,
            optype: "GT"
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        if (kony.sync.executeSql(tx, sql, params) === false) {
            return false;
        }
    }
    return true;
};
//This method reconciles Foreign key relationships in case of autogenerated pk
kony.sync.reconcileForeignKey = function(tx, setClause, whereClause, tablename) {
    sync.log.trace("Entering kony.sync.reconcileForeignKey");
    //Forward Relationships(OneToMany) reconcilation
    var OTM = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToMany;
    if (kony.sync.reconcileForeignKeyForRelationShip(tx, setClause, whereClause, tablename, OTM) === false) {
        return false;
    }
    //Forward Relationships(OneToOne) reconcilation
    var OTO = kony.sync.currentScope.syncTableDic[tablename].Relationships.OneToOne;
    if (kony.sync.reconcileForeignKeyForRelationShip(tx, setClause, whereClause, tablename, OTO) === false) {
        return false;
    }
    //Reverse Relationships(ManyToOne) reconcilation
    var MTO = kony.sync.currentScope.reverseRelationships[tablename];
    return kony.sync.reconcileForeignKeyForRelationShip(tx, setClause, whereClause, tablename, MTO);
};
kony.sync.reconcileForeignKeyForRelationShip = function(tx, setClause, whereClause, tablename, relationshipSet) {
    sync.log.trace("Entering kony.sync.reconcileForeignKeyForRelationShip");
    if (!kony.sync.isNullOrUndefined(relationshipSet)) {
        for (var i = 0; i < relationshipSet.length; i++) {
            sync.log.info("Reconciling relationships for object " + tablename + " with relationship ", relationshipSet[i]);
            var setC = {};
            var tbname = relationshipSet[i].TargetObject;
            var wcs = [];
            if (!kony.sync.isNullOrUndefined(relationshipSet[i].RelationshipAttributes)) {
                var relationshipAttributes = relationshipSet[i].RelationshipAttributes;
                for (var j = 0; j < relationshipAttributes.length; j++) {
                    if (!kony.sync.isNullOrUndefined(setClause[relationshipAttributes[j].SourceObject_Attribute])) {
                        setC[relationshipAttributes[j].TargetObject_Attribute] = setClause[relationshipAttributes[j].SourceObject_Attribute];
                    }
                }
                for (var j = 0; j < whereClause.length; j++) {
                    for (var k = 0; k < relationshipAttributes.length; k++) {
                        if (whereClause[j].key === relationshipAttributes[k].SourceObject_Attribute) {
                            wcs.push({
                                key: relationshipAttributes[k].TargetObject_Attribute,
                                value: whereClause[j].value
                            });
                        }
                    }
                }
            } else if (!kony.sync.isNullOrUndefined(setClause[relationshipSet[i].SourceObject_Attribute])) {
                setC = {};
                setC[relationshipSet[i].TargetObject_Attribute] = setClause[relationshipSet[i].SourceObject_Attribute];
                tbname = relationshipSet[i].TargetObject;
                wcs = [];
                for (var j = 0; j < whereClause.length; j++) {
                    if (whereClause[j].key === relationshipSet[i].SourceObject_Attribute) {
                        wcs[0] = {
                            key: relationshipSet[i].TargetObject_Attribute,
                            value: whereClause[j].value
                        };
                        break;
                    }
                }
            }
            if (kony.sync.isEmpty(setC)) {
                return;
            }
            //update main foreign table
            var query = kony.sync.qb_createQuery();
            kony.sync.qb_update(query, tbname);
            kony.sync.qb_set(query, setC);
            kony.sync.qb_where(query, wcs);
            var query_compile = kony.sync.qb_compile(query);
            var sql = query_compile[0];
            var params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
            //update history foreign table
            kony.sync.qb_update(query, tbname + kony.sync.historyTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
            //update original foreign table
            kony.sync.qb_update(query, tbname + kony.sync.originalTableName);
            query_compile = kony.sync.qb_compile(query);
            sql = query_compile[0];
            params = query_compile[1];
            if (kony.sync.executeSql(tx, sql, params) === false) {
                return false;
            }
        }
    }
};
kony.sync.checkForPendingUpload = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.checkForPendingUpload");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_select(query, null);
    kony.sync.qb_from(query, kony.sync.pendingUploadTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    var resultSet = kony.sync.executeSql(tx, sql, params);
    if (resultSet === false) {
        return false;
    }
    if (resultSet.rows.length === 0) {
        return "";
    } else {
        return kony.db.sqlResultsetRowItem(tx, resultSet, 0);
    }
};
kony.sync.getUploadRequest = function(changes, lastBatch) {
    sync.log.trace("Entering kony.sync.getUploadRequest ");
    var totalChanges = [];
    if (!kony.sync.isNullOrUndefined(changes.tables)) {
        for (var i = 0; i < changes.tables.length; i++) {
            var tableChange = changes.tables[i];
            var tableName = tableChange.tableName;
            if (!kony.sync.isNullOrUndefined(tableChange.changes)) {
                for (var j = 0; j < tableChange.changes.length; j++) {
                    var rowChange = tableChange.changes[j];
                    if (kony.sync.isNullOrUndefined(rowChange.syncConflict)) {
                        rowChange.syncConflict = "";
                    }
                    var result = {
                        metadata: {
                            type: tableName,
                            uri: changes.uri,
                            changetype: rowChange.changeType,
                            syncConflict: rowChange.syncConflict
                        }
                    };
                    if (!kony.sync.isNullOrUndefined(rowChange.fields)) {
                        var fcount = kony.sync.getArrayCount(rowChange.fields);
                        for (var k = 0; k < fcount; k++) {
                            if (rowChange.fields[k] !== "ServerId" && rowChange.fields[k] !== "UpdateId") {
                                result[rowChange.fields[k]] = rowChange.values[k];
                            }
                        }
                    }
                    totalChanges.push(result);
                }
            }
        }
    }
    var moreChangesAvailable = null;
    if (lastBatch === true) {
        moreChangesAvailable = false;
    } else {
        moreChangesAvailable = true;
    }
    var jsonLua = {
        d: {
            results: totalChanges,
            sync: "not implemented",
            scopeName: changes.scopeName,
            serverBlob: changes.serverblob,
            clientid: changes.clientid,
            SequenceNumber: changes.SequenceNumber,
            moreChangesAvailable: moreChangesAvailable
        }
    };
    return JSON.stringify(jsonLua);
}
kony.sync.getLastSyncUploadContext = function(scopename, dbname, scallback) {
    sync.log.trace("Entering kony.sync.getLastSyncUploadContext");
    var uploadContext = null;
    var pendingUploads = null;
    var isError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_select(query, null);
        kony.sync.qb_from(query, kony.sync.metaTableName);
        kony.sync.qb_where(query, [{
            key: kony.sync.metaTableScopeColumn,
            value: scopename
        }, {
            key: kony.sync.metaTableFilterValue,
            value: "no filter"
        }]);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            isError = true;
            return;
        }
        pendingUploads = kony.sync.checkForPendingUpload(tx, scopename);
        if (pendingUploads === false) {
            return;
        }
        if (pendingUploads) {
            if (pendingUploads.uploadrequest) {
                var uploadrequest = JSON.parse(pendingUploads.uploadrequest);
                var scopeName = uploadrequest[kony.sync.scope];
                var cachedCurrentScope = kony.sync.scopes[scopeName];
                var cachedOffset = uploadrequest[kony.sync.offset];
                var cachedLimit = uploadrequest[kony.sync.limit];
                var cachedLastSeqNo = uploadrequest[kony.sync.lastSequenceNumber];
                var cachedBatchSize = uploadrequest[kony.sync.batchSize];
                var cacheChangeSet = JSON.parse(uploadrequest[kony.sync.changeSet]);
                var cacheUploadLimit = uploadrequest[kony.sync.uploadChangesLimit];
                kony.sync.getBatchChanges(tx, cachedCurrentScope, cachedOffset, cacheUploadLimit, cacheChangeSet, cachedLastSeqNo, cachedBatchSize);
                var cacheLastBatch = uploadrequest[kony.sync.lastBatch];
                pendingUploads[kony.sync.pendingUploadTableUploadRequest] = kony.sync.getUploadRequest(cacheChangeSet, cacheLastBatch);
            }
        }
        if (resultSet.rows.length === 0) {
            return "";
        } else {
            uploadContext = kony.db.sqlResultsetRowItem(tx, resultSet, 0);
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering transactionSuccessCallback");
        scallback(uploadContext, pendingUploads);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.setOTAUploadResponse->setOTAUploadResponseTransactionFailure");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
kony.sync.setLastSyncUploadContext = function(tx, scopename, serverblob) {
    sync.log.trace("Entering kony.sync.setLastSyncUploadContext");
    var settable = {};
    settable[kony.sync.metaTableUploadSyncTimeColumn] = serverblob;
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_update(query, kony.sync.metaTableName);
    kony.sync.qb_set(query, settable);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }, {
        key: kony.sync.metaTableFilterValue,
        value: "no filter"
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    if (kony.sync.executeSql(tx, sql, params) === false) {
        return false;
    }
};
kony.sync.addLastUploadRequest = function(json, scopename, limit, callback) {
    sync.log.trace("Entering kony.sync.addLastUploadRequest");
    var isError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        //check whether failed upload request is already logged
        var lastRequest = kony.sync.checkForPendingUpload(tx, scopename);
        //return if query failed, should go to error callback
        if (lastRequest === false) {
            return;
        }
        //return if request already logged, should go to success callback
        if (lastRequest !== "") {
            return;
        }
        var settable = {};
        settable[kony.sync.metaTableScopeColumn] = scopename;
        settable[kony.sync.pendingUploadTableInsertCount] = kony.sync.syncTotalInserts;
        settable[kony.sync.pendingUploadTableUpdateCount] = kony.sync.syncTotalUpdates;
        settable[kony.sync.pendingUploadTableDeleteCount] = kony.sync.syncTotalDeletes;
        settable[kony.sync.pendingUploadTableBatchInsertCount] = kony.sync.syncTotalBatchInserts;
        settable[kony.sync.pendingUploadTableBatchUpdateCount] = kony.sync.syncTotalBatchUpdates;
        settable[kony.sync.pendingUploadTableBatchDeleteCount] = kony.sync.syncTotalBatchDeletes;
        settable[kony.sync.pendingUploadTableObjectLevelInfo] = JSON.stringify(kony.sync.objectLevelInfoMap);
        settable[kony.sync.pendingUploadTableUploadRequest] = json;
        settable[kony.sync.pendingUploadTableUploadLimit] = limit;
        var query = kony.sync.qb_createQuery();
        kony.sync.qb_insert(query, kony.sync.pendingUploadTableName);
        kony.sync.qb_set(query, settable);
        var query_compile = kony.sync.qb_compile(query);
        var sql = query_compile[0];
        var params = query_compile[1];
        var resultSet = kony.sync.executeSql(tx, sql, params);
        if (resultSet === false) {
            isError = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.addLastUploadRequest->transactionSuccessCallback");
        callback(true);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.addLastUploadRequest->transactionErrorCallback");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
kony.sync.deleteLastUploadRequest = function(tx, scopename) {
    sync.log.trace("Entering kony.sync.deleteLastUploadRequest");
    var query = kony.sync.qb_createQuery();
    kony.sync.qb_delete(query, kony.sync.pendingUploadTableName);
    kony.sync.qb_where(query, [{
        key: kony.sync.metaTableScopeColumn,
        value: scopename
    }]);
    var query_compile = kony.sync.qb_compile(query);
    var sql = query_compile[0];
    var params = query_compile[1];
    if (kony.sync.executeSql(tx, sql, params) === false) {
        return false;
    }
    return true;
};
kony.sync.deleteLastUploadRequestWithNewTransaction = function(callback) {
    sync.log.trace("Entering kony.sync.deleteLastUploadRequestWithNewTransaction");
    var isError = false;

    function transactionCallback(tx) {
        sync.log.trace("Entering transactionCallback");
        if (kony.sync.deleteLastUploadRequest(tx, kony.sync.currentScope[kony.sync.scopeName]) === false) {
            isError = true;
        }
    }

    function transactionSuccessCallback() {
        sync.log.trace("Entering kony.sync.deleteLastUploadRequestWithNewTransaction->transactionSuccessCallback");
        callback(true);
    }

    function transactionErrorCallback() {
        sync.log.trace("Entering kony.sync.deleteLastUploadRequestWithNewTransaction->transactionErrorCallback");
        if (!isError) {
            kony.sync.syncUploadFailed(kony.sync.getErrorTable(kony.sync.errorCodeTransaction, kony.sync.getErrorMessage(kony.sync.errorCodeTransaction), null));
        } else {
            kony.sync.syncUploadFailed(kony.sync.errorObject);
            kony.sync.errorObject = null;
        }
    }
    var dbname = kony.sync.currentScope[kony.sync.scopeDataSource];
    var connection = kony.sync.getConnectionOnly(dbname, dbname, transactionErrorCallback);
    if (connection !== null) {
        kony.db.transaction(connection, transactionCallback, transactionErrorCallback, transactionSuccessCallback);
    }
};
//  **************** End KonySyncUpload.js*******************
//  **************** Start KonySyncValidations.js*******************
if (typeof(kony.sync) === "undefined") {
    kony.sync = {};
}
kony.sync.attributeValidation = function(valuestable, tablename, errorcallback, isInsert) {
    sync.log.trace("kony.sync.attributeValidation ", valuestable);
    if (!kony.sync.enableORMValidations) {
        return true;
    }
    if (valuestable != null) {
        var scope = kony.sync.scopes[kony.sync.scopes.syncTableScopeDic[tablename]];
        var columns = scope.syncTableDic[tablename].ColumnsDic;
        kony.sync.filterAttributes(valuestable, columns, tablename, isInsert);
        var expectedType = null;
        var expectedLength = null;
        var jsType = null;
        for (var key in columns) {
            expectedType = columns[key].type;
            expectedLength = columns[key].Length;
            jsType = kony.sync.getJSType(expectedType);
            //Type validation
            sync.log.debug("kony.sync.attributeValidation:Starting Type Validations");
            if (jsType === "number" || jsType === "boolean") {
                if (!kony.sync.isEmptyString(valuestable[key])) {
                    if (!kony.sync.isNull(valuestable[key]) && jsType === "number" && !kony.sync.isValidNumberType(valuestable[key])) {
                        sync.log.error("Invalid data type for the attribute " + key + " in " + tablename + ".\nExpected:\"" + expectedType + "\"\nActual:\"" + kony.type(valuestable[key]) + "\"");
                        errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeInvalidDataType, kony.sync.getInvalidDataTypeMsg(tablename, key, expectedType, kony.type(valuestable[key]))));
                        return false;
                    }
                    if (!kony.sync.isNull(valuestable[key]) && jsType === "boolean" && !kony.sync.isValidBooleanType(valuestable[key])) {
                        sync.log.error("Invalid data type for the attribute " + key + " in " + tablename + ".\nExpected:\"" + expectedType + "\"\nActual:\"" + kony.type(valuestable[key]) + "\"");
                        errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeInvalidDataType, kony.sync.getInvalidDataTypeMsg(tablename, key, expectedType, kony.type(valuestable[key]))));
                        return false;
                    }
                } else {
                    valuestable[key] = "null";
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Type Validations done");
            //Malicious type validation
            sync.log.debug("kony.sync.attributeValidation:Starting Malicious Validations");
            if (jsType === "number" || typeof(valuestable[key]) === "number") {
                var maliciousType = kony.sync.isMaliciousType(valuestable[key]);
                if (maliciousType !== false) {
                    var errorMessage = kony.sync.getErrorMessage(kony.sync.errorCodeMaliciousType, key, maliciousType);
                    sync.log.error("Malicious object detected", kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                    kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeMaliciousType, errorMessage));
                    return false;
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Malicious Validations done");
            //Length Validation
            sync.log.debug("kony.sync.attributeValidation:Starting Length Validations");
            if (jsType === "string") {
                if (kony.sync.validateLength(tablename, key, valuestable[key], expectedLength, errorcallback) === false) {
                    return false;
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Length Validations done");
            //Mandatory Attribute Validation
            sync.log.debug("kony.sync.attributeValidation:Starting Mandatory Attribute Validations");
            // if(columns[key].IsNullable === false && !(columns[key].Autogenerated === "true") && !(isInsert===false && columns[key].IsPrimaryKey===true)){
            // if(kony.sync.validateMandatoryColumns(tablename, key, valuestable[key], errorcallback)===false){
            // return false;
            // }
            // }
            if (isInsert) {
                //check all mandatory attributes
                if (columns[key].IsNullable === false) {
                    if (columns[key].Autogenerated !== "true") {
                        if (kony.sync.validateMandatoryColumns(tablename, key, valuestable[key], errorcallback) === false) {
                            return false;
                        }
                    }
                }
            } else {
                //check mandatory attributes only if they are defined
                if (columns[key].IsNullable === false) {
                    if (columns[key].Autogenerated !== "true") {
                        if (typeof(valuestable[key]) !== "undefined") {
                            if (kony.sync.validateMandatoryColumns(tablename, key, valuestable[key], errorcallback) === false) {
                                return false;
                            }
                        }
                    }
                }
            }
            sync.log.debug("kony.sync.attributeValidation:Mandatory Attribute Validations done");
        }
    }
    return true;
};
kony.sync.filterAttributes = function(valuestable, attributeTable, tablename, isInsert) {
    sync.log.trace("Entering kony.sync.filterAttributes ");
    for (var k in valuestable) {
        if (kony.sync.isNull(attributeTable[k])) {
            sync.log.warn("Ignoring the attribute " + k + " for the SyncObject " + tablename + ". " + k + " is not defined as an attribute in SyncConfiguration.");
            delete valuestable[k];
        } else if (attributeTable[k].IsPrimaryKey) {
            if (isInsert === false) {
                sync.log.warn("Ignoring the primary key " + k + " for the SyncObject  " + tablename + ". Primary Key should not be the part of the attributes to be updated in the local device database.");
                delete valuestable[k];
            } else if (attributeTable[k].Autogenerated === "true") {
                sync.log.warn("Ignoring the auto-generated primary key " + k + " for the SyncObject " + tablename + ". Auto-generated Primary Key should not be the part of the attributes to be inserted in the local device database.");
                delete valuestable[k];
            }
        }
    }
};
kony.sync.getJSType = function(myType) {
    sync.log.trace("Entering kony.sync.getJSType ");
    myType = myType.toLowerCase();
    var stringTypes = {
        "string": true,
        "character": true,
        "java.lang.String": true,
        "char": true
    };
    var numberTypes = {
        "int": true,
        "double": true,
        "float": true,
        "long": true,
        "short": true,
        "integer": true,
        "big_decimal": true,
        "byte": true,
        "big_integer": true
    };
    var booleanTypes = {
        "boolean": true,
        "yes_no": true
    };
    if (stringTypes[myType] === true) {
        return "string";
    }
    if (numberTypes[myType] === true) {
        return "number";
    }
    if (booleanTypes[myType] === true) {
        return "boolean";
    }
    return null;
};
kony.sync.validateLength = function(tablename, colname, colvalue, length, errorcallback) {
    sync.log.trace("Entering kony.sync.validateLength ");
    if (!kony.sync.isNull(colvalue) && kony.string.equalsIgnoreCase(kony.type(colvalue), "string") && kony.string.len(colvalue) > length) {
        sync.log.error("Length exceeds the limit for the attribute " + colname + " in " + tablename + ".\nExpected:\'" + length + "\'\nActual:\'" + kony.string.len(colvalue) + "\'");
        kony.sync.verifyAndCallClosure(errorcallback, kony.sync.getErrorTable(kony.sync.errorCodeLengthValidationFailed, kony.sync.getValidateLengthErrMsg(tablename, colname, length, kony.string.len(colvalue))));
        return false;
    }
    return true;
};
kony.sync.validateMandatoryColumns = function(tablename, colname, colvalue, errorcallback) {
    sync.log.trace("Entering Address.validateNullInsert function");
    if (kony.sync.isNull(colvalue)) {
        sync.log.error("Mandatory attribute " + colname + " is missing for the SyncObject" + tablename + ".");
        errorcallback(kony.sync.getErrorTable(kony.sync.errorCodeMandatoryAttribute, kony.sync.getErrorMessage(kony.sync.errorCodeMandatoryAttribute, tablename, colname)));
        return false;
    }
    return true;
};
kony.sync.isSyncInitialized = function(errorcallback) {
    sync.log.trace("Entering kony.sync.isSyncInitialized");
    if (!kony.sync.syncInitialized) {
        sync.log.error("Please initialize sync by calling sync.init");
        kony.sync.alert("Please initialize sync by calling sync.init");
        kony.sync.verifyAndCallClosure(errorcallback, {});
        return false;
    }
    return true;
};
kony.sync.validateInput = function(input, objectName, ormType, errorcallback) {
    sync.log.trace("Entering kony.sync.validateInput");
    if (ormType === "create") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "updateByPk") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 2)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
            if (!kony.sync.validateInputField(objectName, ormType, input[1], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "update") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 2)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
            if (!kony.sync.validateInputField(objectName, ormType, input[1], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "getCount") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "createAll") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "updateAll") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "object", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "deleteByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "remove") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "removeDeviceInstanceByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "getAllDetailsByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "find") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "markForUploadbyPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "markForUpload") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validateInputField(objectName, ormType, input[0], "string", errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "rollbackPendingLocalChangesByPK") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    } else if (ormType === "relationship") {
        if (kony.sync.validateArgumentLength(objectName, ormType, input.length, 1)) {
            if (!kony.sync.validatePrimaryKeyField(objectName, ormType, input[0], errorcallback)) {
                return false;
            }
        } else {
            return false;
        }
    }
    return true;
};
kony.sync.validatePrimaryKeyField = function(objName, opType, inputAttribute, errorcallback) {
    sync.log.trace("Entering kony.sync.validatePrimaryKeyField");
    if (kony.sync.isNullOrUndefined(inputAttribute)) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for operation:" + objName + ".  Expected 'integer, string or object ' Actual null or undefined '");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected 'integer, string or object' Actual 'null or undefined'");
        return false;
    }
    var actualType = typeof(inputAttribute);
    if (!(actualType === "number" || actualType === "string" || actualType === "object")) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for Primary Key in operation:" + objName + ".  Expected 'integer, string or object' Actual '" + actualType + "'");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected 'integer, string or object' Actual '" + actualType + "'");
        return false;
    }
    return true;
};
kony.sync.validateInputField = function(objName, opType, inputAttribute, expectedType, errorcallback) {
    sync.log.trace("Entering kony.sync.validateInputField");
    if (kony.sync.isNullOrUndefined(inputAttribute)) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual 'null or undefined '");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual 'null or undefined'");
        return false;
    }
    var actualType = typeof(inputAttribute);
    if (actualType !== expectedType) {
        kony.sync.verifyAndCallClosure(errorcallback, "Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual '" + actualType + "'");
        kony.sync.alert("Argument type mismatch found for operation:" + objName + ".  Expected '" + expectedType + "' Actual '" + actualType + "'");
        return false;
    }
    return true;
};
kony.sync.validateArgumentLength = function(objName, ormType, actualLength, expectedLength) {
    sync.log.trace("Entering kony.sync.validateArgumentLength");
    if (actualLength < expectedLength) {
        kony.sync.alert("Insufficient number of arguments passed for operation: " + objName);
        return false;
    }
    return true;
};
kony.sync.alert = function(msg) {
    sync.log.trace("Entering kony.sync.alert ");
    if (kony.sync.isAlertEnabled) {
        alert(msg);
    } else {
        sync.log.warn(msg);
    }
};
//  **************** End KonySyncValidations.js*******************
function initializeMVCTemplates() {}
var base64Global;
var appKey = "276cd5d9697082c509240e05ced84e8d";
var appSecret = "5bb54d20c2afe4b8c23b7bea1af656dd";
var serviceUrl = "http://KH2321.kitspl.com:8443/authService/100000002/appconfig";
var client = null;
var stateNewsRecords = [];
var currentNewsObject = null;
var stateNewsListBoxMasterData;
var currentNews = [];

function getFileObject() {
    var config = {
        selectMultipleFiles: false,
        filter: ["image/png", "image/jpeg", "image/jpg"]
    };
    kony.io.FileSystem.browse(config, function(res, file) {
        fileObject = file[0].file;
        getBase64FromBlob(fileObject, function(base64Str) {
            base64Global = base64Str;
            Form1.imgWidget.base64 = base64Global;
        });
    });
}
getBase64FromBlob = function(blobObj, callback) {
    // blobObj = blobObj.BlobObject;
    var reader = new FileReader();
    reader.readAsDataURL(blobObj);
    reader.onloadend = function() {
        var dataUrl = reader.result;
        var base64Data = dataUrl.split(',')[1];
        callback(base64Data);
    };
};

function sdkInit() {
    kony.print("init sdk");

    function initSuccess(result) {
        kony.print("init success " + JSON.stringify(result));
        alert("init success " + JSON.stringify(result));
        setup();
    }

    function initFailure(err) {
        kony.print("init failure " + JSON.stringify(err));
        alert("init failure " + JSON.stringify(err));
    }
    client = new kony.sdk();
    client.init(appKey, appSecret, serviceUrl, initSuccess, initFailure);
}

function setup() {
    kony.print("setup");

    function setupSucccess(result) {
        kony.print("setup success " + JSON.stringify(result));
        alert("setup success " + JSON.stringify(result));
        syncStateNews();
    }

    function setupFailure(err) {
        kony.print("setup failed " + JSON.stringify(err));
        alert("setup failed " + JSON.stringify(err));
    }
    var options = {};
    KNYMobileFabric.OfflineObjects.setup(options, setupSucccess, setupFailure);
}

function syncStateNews() {
    var objectName = "state_news";
    kony.print("syncing " + objectName);
    var sdkObject = new kony.sdk.KNYObj(objectName);

    function syncStateNewsSuccess(result) {
        kony.print(objectName + " sync success " + JSON.stringify(result));
        alert(objectName + " sync success " + JSON.stringify(result));
        fetchStateNews();
    }

    function syncStateNewsFailure(err) {
        kony.print(objectName + " sync failed " + JSON.stringify(err));
        alert(objectName + " sync failed " + JSON.stringify(err));
    }

    function syncStateNewsProgress() {}
    sdkObject.startSync({}, syncStateNewsSuccess, syncStateNewsFailure, syncStateNewsProgress);
}

function fetchStateNews() {
    var objectName = "state_news";
    kony.print("fetching " + objectName + " records");
    var sdkObject = new kony.sdk.KNYObj(objectName);
    var options = {};
    var orderByMap = [];
    orderByMap.push({
        "stateName": "ASC"
    });
    options.orderByMap = orderByMap;

    function getStateNewsSuccess(records) {
        kony.print(objectName + " fetch success " + JSON.stringify(records));
        alert(objectName + " fetch success " + JSON.stringify(records));
        stateNewsRecords = records;
        loadStateNewsDropDown();
    }

    function getStateNewsFailure(err) {
        kony.print(objectName + " fetch failed " + JSON.stringify(err));
        alert(objectName + " fetch failed " + JSON.stringify(err));
    }
    sdkObject.get(options, getStateNewsSuccess, getStateNewsFailure);
}

function loadStateNewsDropDown() {
    stateNewsListBoxMasterData = [];
    var key = "key";
    for (var i = 0; i < stateNewsRecords.length; i++) {
        var keyValuePair = [];
        if (stateNewsRecords[i] !== null && typeof(stateNewsRecords[i]) != 'undefined') {
            keyValuePair[0] = key + i;
            keyValuePair[1] = stateNewsRecords[i].stateName;
            stateNewsListBoxMasterData.push(keyValuePair);
        }
    }
    frmWelcome.lstBoxState.masterData = stateNewsListBoxMasterData;
}

function getNews() {
    var newsType = frmWelcome.lstBoxNewsType.selectedKeyValue[1];
    alert("news type " + newsType);
    var objectName = "";

    function syncSuccessCallback() {
        kony.print(objectName + " sync success ");
        alert(objectName + " sync success ");
        getCurrentNews();
    }

    function syncFailureCallback(err) {
        kony.print(objectName + " sync failure " + JSON.stringify(err));
        alert(objectName + " sync failure " + JSON.stringify(err));
    }

    function syncProgressCallback() {}
    if (newsType !== null) {
        objectName = newsType + "_news";
        currentNewsObject = objectName;
        var sdkObject = new kony.sdk.KNYObj(objectName);
        var filter = frmWelcome.calBtn.day + "/" + frmWelcome.calBtn.month + "/" + frmWelcome.calBtn.year;
        var syncConfig = {};
        syncConfig.syncType = "downloadOnly";
        //TODO: Have to use filter
        //syncConfig.filter = "Date eq " + filter;
        sdkObject.startSync(syncConfig, syncSuccessCallback, syncFailureCallback, syncProgressCallback);
    }
}

function getCurrentNews() {
    kony.print("fetching current news");
    alert("fetching current news");

    function getCurrentNewsSuccess(records) {
        kony.print(currentNewsObject + " fetch success " + JSON.stringify(records));
        alert(currentNewsObject + " fetch success " + JSON.stringify(records));
        currentNews = records;
        frmNews.show();
    }

    function getCurrentNewsFailure(err) {
        kony.print(currentNewsObject + " fetch failure " + JSON.stringify(err));
        alert(currentNewsObject + " fetch failure " + JSON.stringify(err));
    }
    if (currentNewsObject !== null) {
        var sdkObject = new kony.sdk.KNYObj(currentNewsObject);
        var options = {};
        var orderByMap = [];
        orderByMap.push({
            "Date": "ASC"
        });
        options.orderByMap = orderByMap;
        sdkObject.get(options, getCurrentNewsSuccess, getCurrentNewsFailure);
    }
}

function populateCurrentNews() {
    kony.print("populateCurrentNews");
    alert("populateCurrentNews");
    var segmentData = [];
    for (var i = 0; i < currentNews.length; i++) {
        var rowData = {};
        rowData.lblTitle = currentNews[i].title;
        rowData.lblDescription = currentNews[i].description;
        var crawBytes = kony.convertToRawBytes(currentNews[i].image1);
        rowData.imgNews = {
            "rawBytes": crawBytes
        };
        segmentData.push(rowData);
    }
    frmNews.segNews.setData(segmentData);
}

function syncAll() {
    var syncOptions = {};
    KNYMobileFabric.OfflineObjects.startSync(syncOptions, successCallback, failureCallback);
}
function initializeSampleRowTemplate() {
    flxSampleRowTemplate = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "75dp",
        "id": "flxSampleRowTemplate",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "isModalContainer": false,
        "skin": "sknSampleRowTemplate"
    }, {}, {});
    flxSampleRowTemplate.setDefaultUnit(kony.flex.DP);
    var lblHeading = new kony.ui.Label({
        "id": "lblHeading",
        "isVisible": true,
        "left": "4%",
        "maxWidth": "50%",
        "skin": "sknLblRowHeading",
        "text": "Heading",
        "textStyle": {},
        "top": "8.00%",
        "width": "45%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lblDescription = new kony.ui.Label({
        "bottom": "10%",
        "id": "lblDescription",
        "isVisible": true,
        "left": "4%",
        "maxNumberOfLines": 3,
        "maxWidth": "70%",
        "skin": "sknLblDescription",
        "text": "Sub-Heading",
        "textStyle": {},
        "textTruncatePosition": constants.TEXT_TRUNCATE_NONE,
        "top": "42%",
        "width": "70%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_TOP_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lblTime = new kony.ui.Label({
        "id": "lblTime",
        "isVisible": true,
        "right": "9%",
        "skin": "sknLblTimeStamp",
        "text": "Timestamp",
        "textStyle": {},
        "top": "10%",
        "width": kony.flex.USE_PREFFERED_SIZE,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lblStrip = new kony.ui.Label({
        "height": "100%",
        "id": "lblStrip",
        "isVisible": true,
        "left": "0dp",
        "maxWidth": "1%",
        "skin": "sknLblStrip",
        "textStyle": {},
        "top": "0dp",
        "width": kony.flex.USE_PREFFERED_SIZE,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    flxSampleRowTemplate.add(lblHeading, lblDescription, lblTime, lblStrip);
}
function initializeSampleSectionHeaderTemplate() {
    flxSectionHeaderTemplate = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "45dp",
        "id": "flxSectionHeaderTemplate",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "isModalContainer": false,
        "skin": "sknSampleSectionHeaderTemplate"
    }, {}, {});
    flxSectionHeaderTemplate.setDefaultUnit(kony.flex.DP);
    var lblHeading = new kony.ui.Label({
        "centerY": "50%",
        "id": "lblHeading",
        "isVisible": true,
        "left": "4%",
        "maxWidth": "50%",
        "skin": "sknSectionHeaderLabelSkin",
        "text": "Heading",
        "textStyle": {},
        "width": "75%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    flxSectionHeaderTemplate.add(lblHeading);
}
/*actions.js file*/
function AS_Button_cbbe09bffa5a4efdb12786bcd5ee0c1c(eventobject) {
    return getFileObject.call(this);
}

function AS_Button_f18acf7e675b4050b82c7e9c0b0aabfc(eventobject) {
    return getNews.call(this);
}

function AS_Form_a35f54468796495ebbdefd7b712fb6e2(eventobject) {
    return sdkInit.call(this);
}

function AS_Form_bc97732823dc4f9c83c0ca62930bac31(eventobject) {}

function AS_Form_c71e1d5f52fa41b78804badc75da6965(eventobject) {
    return sdkInit.call(this);
}

function AS_Form_f457551e7c354cb49cff22d4f0d032aa(eventobject) {}

function AS_Form_i741e54bfd644ff7ad50b530ea86e115(eventobject) {
    return populateCurrentNews.call(this);
}

function AS_ListBox_e8668bbaaaa34d58aabb7bf9745faa49(eventobject) {}

function AS_ListBox_jb67fcbba2f3465385d750daecdcafb1(eventobject) {}

function AS_Button_b42b43ee1ee5441d83d8151be33eeee5(eventobject) {
    FormSubNewsCreate.show();
}

function AS_Form_e2e3f625f096474eabfae3ce17f6c24d(eventobject) {}

function AS_Form_fba508c029774b02ae682f46b056530c(eventobject) {
    return FormSubNewsCreatePostShow.call(this);
}
//app.js file
kony.visualizer = {};
kony.visualizer.actions = {};

function displayMWError() {
    kony.ui.Alert("Middleware Error ", null, "error", null, null);
};

function displaySessionError() {
    kony.ui.Alert("Session Expired .. Please re-login", null, "error", null, null);
};

function displayError(code, msg) {
    // Commented for SWA: kony.ui.Alert("Error Code: "..code .." Message: " ..msg,null,"error",null,null);
    kony.ui.Alert(code + "- " + msg, null, "error", null, null);
};
var mergeHeaders = function(httpHeaders, globalHeaders) {
    for (var attrName in globalHeaders) {
        httpHeaders[attrName] = globalHeaders[attrName];
    }
    return httpHeaders;
};

function appmiddlewareinvokerasync(inputParam, callBack) {
    var url = appConfig.url;
    var sessionIdKey = "cacheid";
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam.httpheaders = globalhttpheaders;
        };
    };
    var connHandle = _invokeServiceAsyncForMF_(url, inputParam, callBack);
    return connHandle;
};

function appmiddlewaresecureinvokerasync(inputParam, callBack) {
    var url = appConfig.secureurl;
    var sessionIdKey = "cacheid";
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam["httpheaders"] = globalhttpheaders;
        };
    };
    var connHandle = _invokeServiceAsyncForMF_(url, inputParam, callBack);
    return connHandle;
};

function mfgetidentityservice(idProviderName) {
    var currentInstance = kony.sdk.getCurrentInstance();
    if (!currentInstance) {
        throw new Exception("INIT_FAILURE", "Please call init before getting identity provider");
    }
    return currentInstance.getIdentityService(idProviderName);
};
/**
 * @function mfidentityserviceinvoker
 * @description Invokes identity service
 * @public
 * @param {string} idProviderName
 * @param {object} params {userid : <userid>, password : <password>, browserWidget : <browserwidget>, operation : "login/logout"}
 * and other optional params like callerID and custom params in case of custom provider.
 * @param {function} successCallback
 * @param {function} failureCallback
 */
function mfidentityserviceinvoker(idProviderName, params, successCallback, failureCallback) {
    var authorizationClient = mfgetidentityservice(idProviderName);
    kony.print("Invoking identity service " + idProviderName + " through Kony Fabric.");
    if (!params.operation || params.operation == "login") {
        authorizationClient.login(params, successCallback, failureCallback);
    } else {
        authorizationClient.logout(successCallback, failureCallback, params);
    }
};

function mfintegrationsecureinvokerasync(inputParam, serviceID, operationID, callBack) {
    var url = appConfig.secureurl;
    var sessionIdKey = "cacheid";
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam["httpheaders"] = mergeHeaders({}, globalhttpheaders);
        };
    };
    kony.print("Async : Invoking service through Kony Fabric with url : " + url + " service id : " + serviceID + " operationid : " + operationID + "\n input params" + JSON.stringify(inputParam));
    if (kony.mbaas) {
        kony.mbaas.invokeMbaasServiceFromKonyStudio(url, inputParam, serviceID, operationID, callBack);
    } else {
        alert("Unable to find the Kony Fabric SDK for KonyStudio. Please download the SDK from the Kony Cloud Console and add as module to the Kony Project.");
    }
};

function mfintegrationsecureinvokersync(inputParam, serviceID, operationID) {
    var url = appConfig.secureurl;
    var sessionIdKey = "cacheid";
    var resulttable;
    inputParam.appID = appConfig.appId;
    inputParam.appver = appConfig.appVersion;
    inputParam["channel"] = "wap";
    inputParam["platform"] = kony.os.deviceInfo().name;
    inputParam[sessionIdKey] = sessionID;
    if (globalhttpheaders) {
        if (inputParam["httpheaders"]) {
            inputParam.httpheaders = mergeHeaders(inputParam.httpheaders, globalhttpheaders);
        } else {
            inputParam["httpheaders"] = mergeHeaders({}, globalhttpheaders);
        };
    };
    kony.print("Invoking service through Kony Fabric with url : " + url + " service id : " + serviceID + " operationid : " + operationID + "\n input params" + JSON.stringify(inputParam));
    if (kony.mbaas) {
        resulttable = kony.mbaas.invokeMbaasServiceFromKonyStudioSync(url, inputParam, serviceID, operationID);
        kony.print("Result table for service id : " + serviceID + " operationid : " + operationID + " : " + JSON.stringify(resulttable));
    } else {
        alert("Unable to find the Kony Fabric SDK for KonyStudio. Please download the SDK from the Kony Cloud Console and add as module to the Kony Project.");
    }
    return resulttable;
};
_invokeServiceAsyncForMF_ = function(url, inputParam, callBack, info) {
    var operationID = inputParam["serviceID"];
    if (!operationID) {
        resulttable = kony.net.invokeServiceAsync(url, inputParam, callBack, info);
    } else {
        var _mfServicesMap_ = {};
        kony.print("Getting serviceID for : " + operationID);
        var serviceID = _mfServicesMap_[operationID] && _mfServicesMap_[operationID]["servicename"];
        kony.print("Got serviceID for : " + operationID + " : " + serviceID);
        kony.print("Async : Invoking service through Kony Fabric with url : " + url + " service id : " + serviceID + " operationid : " + operationID + "\n input params" + JSON.stringify(inputParam));
        if (serviceID && operationID) {
            var url = appConfig.secureurl;
            if (kony.mbaas) {
                kony.mbaas.invokeMbaasServiceFromKonyStudio(url, inputParam, serviceID, operationID, callBack, info);
            } else {
                alert("Unable to find the Kony Fabric SDK for KonyStudio. Please download the SDK from the Kony Cloud Console and add as module to the Kony Project.");
            }
        } else {
            resulttable = kony.net.invokeServiceAsync(url, inputParam, callBack, info);
        }
    }
};
_invokeServiceSyncForMF_ = function(url, inputParam, isBlocking, info) {
    var resulttable;
    var operationID = inputParam["serviceID"];
    if (!operationID) {
        resulttable = kony.net.invokeService(url, inputParam, isBlocking);
    } else {
        var _mfServicesMap_ = {};
        kony.print("Getting serviceID for : " + operationID);
        var serviceID = _mfServicesMap_[operationID] && _mfServicesMap_[operationID]["servicename"];
        kony.print("Got serviceID for : " + operationID + " : " + serviceID);
        kony.print("Invoking service through Kony Fabric with url : " + url + " service id : " + serviceID + " operationid : " + operationID + "\n input params" + JSON.stringify(inputParam));
        if (serviceID && operationID) {
            var url = appConfig.secureurl;
            if (kony.mbaas) {
                resulttable = kony.mbaas.invokeMbaasServiceFromKonyStudioSync(url, inputParam, serviceID, operationID, info);
                kony.print("Result table for service id : " + serviceID + " operationid : " + operationID + " : " + JSON.stringify(resulttable));
            } else {
                alert("Unable to find the Kony Fabric SDK for KonyStudio. Please download the SDK from the Kony Cloud Console and add as module to the Kony Project.");
            }
        } else {
            resulttable = kony.net.invokeService(url, inputParam, isBlocking);
        }
    }
    return resulttable;
};
/*
   Sample invocation code
   var inputparam = {};
   inputparam.options = {
       "access": "online",
       "CRUD_TYPE": "get",//get/create..
       "odataurl": "$filter=UserId eq xxx",
       "data" : {a:1,b:2}//in case of create/update
   };
*/
function mfobjectsecureinvokerasync(inputParam, serviceID, objectID, callBack) {
    var options = {
        "access": inputParam.options.access
    };
    var serviceObj = kony.sdk.getCurrentInstance().getObjectService(serviceID, options);
    var CRUD_TYPE = inputParam.options.CRUD_TYPE;
    switch (CRUD_TYPE) {
        case 'get':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            if (inputParam.options && inputParam.options.odataurl) dataObject.setOdataUrl(inputParam.options.odataurl.toString());
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.fetch(options, callBack, callBack);
            break;
        case 'create':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.create(options, callBack, callBack);
            break;
        case 'update':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.update(options, callBack, callBack);
            break;
        case 'partialupdate':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.partialUpdate(options, callBack, callBack);
            break;
        case 'delete':
            var dataObject = new kony.sdk.dto.DataObject(objectID);
            var headers = inputParam.httpheaders || {};
            var data = inputParam.options && inputParam.options.data || {};
            var key;
            for (key in data) {
                dataObject.addField(key, data[key]);
            }
            options = {
                "dataObject": dataObject,
                "headers": headers
            };
            serviceObj.deleteRecord(options, callBack, callBack);
            break;
        default:
    }
};

function callAppMenu() {};

function makeCall(eventobject) {
    kony.phone.dial(eventobject.text);
};

function initializeGlobalVariables() {};

function onBreakpointHandler(formModel, width) {
    var flexProps = ['left', 'top', 'right', 'bottom', 'width', 'height', 'minWidth', 'maxWidth', 'minHeight', 'maxHeight', 'zIndex', 'centerX', 'centerY'];
    if (formModel.breakpointData) {
        var width = (width === constants.BREAKPOINT_MAX_VALUE) ? formModel.breakpointData.maxBreakpointWidth : width;
        if (formModel.breakpointData[width]) {
            var bdata = formModel.breakpointData[width];
            for (var widgetId in bdata) {
                var setterBasePath = formModel;
                if (bdata[widgetId].parent) {
                    setterBasePath = formModel[bdata[widgetId].parent];
                }
                var instanceId = bdata[widgetId].instanceId;
                if (instanceId && instanceId !== widgetId) {
                    setterBasePath = setterBasePath[instanceId];
                }
                var setterFinalPath = setterBasePath;
                if (formModel.id !== widgetId) {
                    var splitArr = widgetId.split("."); //For components without contract instance, widget id will have '.'
                    for (var i = 0; i < splitArr.length; i++) {
                        setterFinalPath = setterFinalPath[splitArr[i]];
                    }
                }
                var wdata = bdata[widgetId];
                for (var prop in wdata) {
                    if (prop === 'parent' || prop === 'instanceId') {
                        continue
                    };
                    if (formModel.breakpointResetData && (typeof formModel.breakpointResetData[widgetId] === 'undefined' || typeof formModel.breakpointResetData[widgetId][prop] === 'undefined')) {
                        if (!formModel.breakpointResetData[widgetId]) {
                            formModel.breakpointResetData[widgetId] = {};
                        }
                        if (flexProps.indexOf(prop) > -1) {
                            formModel.breakpointResetData[widgetId][prop] = {};
                            formModel.breakpointResetData[widgetId][prop].value = setterFinalPath[prop];
                        } else {
                            formModel.breakpointResetData[widgetId][prop] = setterFinalPath[prop] || "";
                        }
                        if (wdata.parent) {
                            formModel.breakpointResetData[widgetId].parent = wdata.parent;
                        }
                        if (wdata.instanceId) {
                            formModel.breakpointResetData[widgetId].instanceId = wdata.instanceId;
                        }
                    }
                    //Unlike other flex properties, value of zIndex is a number and not an object
                    if (flexProps.indexOf(prop) > -1 && prop !== 'zIndex') {
                        setterFinalPath[prop] = wdata[prop].value;
                    } else {
                        setterFinalPath[prop] = wdata[prop];
                    }
                }
            }
        }
        //Reset previous breakpoint values
        if (formModel.breakpointResetData) {
            var wdata = null;
            if (formModel.breakpointData[width]) {
                wdata = formModel.breakpointData[width];
            } else {
                wdata = {};
            }
            for (var wgtId in formModel.breakpointResetData) {
                var wgtData = wdata[wgtId] || {};
                var wgtResetData = formModel.breakpointResetData[wgtId];
                var setterBasePath = formModel;
                if (wgtResetData.parent) {
                    setterBasePath = setterBasePath[wgtResetData.parent];
                }
                var instanceId = wgtResetData.instanceId;
                if (instanceId && instanceId !== wgtId) {
                    setterBasePath = setterBasePath[instanceId];
                }
                if (formModel.id !== wgtId) {
                    var splitArr = wgtId.split(".");
                    for (var i = 0; i < splitArr.length; i++) {
                        setterBasePath = setterBasePath[splitArr[i]];
                    }
                }
                for (var prop in wgtResetData) {
                    if (prop === 'parent' || prop === 'instanceId' || wgtData[prop] !== undefined) {
                        continue;
                    }
                    if (flexProps.indexOf(prop) > -1) {
                        setterBasePath[prop] = wgtResetData[prop].value;
                    } else {
                        setterBasePath[prop] = wgtResetData[prop];
                    }
                    delete wgtResetData[prop];
                }
            }
        }
    }
}
kony.visualizer.toBoolean = function(output) {
    try {
        if (typeof output === "string") {
            if (output && output.toLowerCase() === "true") {
                output = true;
            } else {
                output = false;
            }
        } else if (typeof output === "number") {
            output = Boolean(output);
        }
    } catch (e) {
        kony.print('Error while converting the value to boolean datatype: ' + e);
    }
    return output;
};
kony.visualizer.toNumber = function(output) {
    try {
        if (typeof output === "string") {
            if (!output || isNaN(Number(output))) {
                kony.print('The value [' + output + '] after data type conversion is not a number(NaN)');
            } else {
                output = Number(output);
            }
        } else if (typeof output === "boolean") {
            output = Number(output);
        }
    } catch (e) {
        kony.print('Error while converting the value to number datatype: ' + e);
    }
    return output;
};
/**
 * Util to return value of the widget property with the {propertyName}
 * @param {Object/String} output
 * @param {String} propertyName
 * @returns {Object/String} - Returns value of {propertyName} if present, else it returns {output} as it is.
 */
kony.visualizer.getPropertyValue = function(output, propertyName) {
    if (typeof output === "object") {
        if (output.hasOwnProperty(propertyName)) {
            return output[propertyName];
        } else {
            kony.print(JSON.stringify(output) + ' does not have ' + propertyName + ' property');
        }
    }
    return output;
};
/*
	This API is used to merge User controller and controller action of Form.
 */
kony.visualizer.mixinControllerActions = function(controller, controllerActions) {
    for (var i = 0; i < controllerActions.length; i++) {
        var actions = require(controllerActions[i]);
        for (var key in actions) {
            /*If the user has defined action in formController then that takes priority 
            	over the action generated in controllerActions.
            	Example: onNavigate
            */
            if (typeof controller[key] === "undefined") {
                controller[key] = actions[key];
            }
        }
    }
    return controller;
};
kony.visualizer.i18nKeyObject = {
    "text": "i18n_text",
    "placeholder": "i18n_placeholder",
    "tabName": "i18n_tabName",
    "leftSideText": "i18n_leftSideText",
    "rightSideText": "i18n_rightSideText"
};
kony.visualizer.getI18nAttrb = function(property) {
    return kony.visualizer.i18nKeyObject[property];
};
//To set the passthrough properties at constructor level
function extendConfig(config, controllerConfig, id) {
    var __extendOverrides__ = function(config, currentOverrides, isTopLevelSrc) {
        Object.keys(currentOverrides).forEach(function(property) {
            var FLEX_PROPS_SANS_ZINDEX = ["left", "right", "top", "bottom", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "centerX", "centerY"];
            /*If height is preferred,
                For autogrowmode supported widgets, set autogrowmode and delete height from config.
                For other widgets, delete height from config.
            */
            if (property === "autogrowMode" && isTopLevelSrc) {
                delete config["height"];
                config[property] = currentOverrides[property];
            } else if (FLEX_PROPS_SANS_ZINDEX.indexOf(property) !== -1 && isTopLevelSrc) {
                if (currentOverrides[property] == 'viz.val_cleared' || (property === "height" && currentOverrides.hasOwnProperty(property) && currentOverrides[property] == kony.flex.USE_PREFFERED_SIZE)) {
                    delete config[property];
                } else {
                    config[property] = currentOverrides[property];
                }
            } else if (config[kony.visualizer.getI18nAttrb(property)] && isTopLevelSrc) {
                delete config[kony.visualizer.getI18nAttrb(property)];
                config[property] = currentOverrides[property];
            } else {
                config[property] = currentOverrides[property];
            }
        });
    };
    var __parseComponentId__ = function(wgtOverrideId) {
        //sample wgtOverrideId: "comp2.comp1.btnId"
        var parentIdArr = wgtOverrideId.split('.');
        return {
            rootId: parentIdArr.splice(0, 1)[0],
            childId: parentIdArr.join(".")
        };
    };
    var widgetsOverrides = (controllerConfig && controllerConfig.overrides);
    for (var wgtOverrides in widgetsOverrides) {
        var currentOverrides = widgetsOverrides[wgtOverrides];
        var idObj = __parseComponentId__(wgtOverrides);
        var rootId = idObj.rootId;
        var childId = idObj.childId;
        if (rootId === id) {
            if (config.overrides && childId) {
                if (config.overrides[childId]) {
                    __extendOverrides__(config.overrides[childId], currentOverrides);
                } else {
                    config.overrides[childId] = currentOverrides;
                }
            } else {
                //isTopLevelSrc is to indicate that this is the root source widget (without any nesting)
                var isTopLevelSrc = true;
                __extendOverrides__(config, currentOverrides, isTopLevelSrc);
            }
        }
    }
    return config;
};
function skinsInit() {
    defBtnFocus = "defBtnFocus";
    defBtnNormal = "defBtnNormal";
    defLabel = "defLabel";
    defListBoxFocus = "defListBoxFocus";
    defListBoxNormal = "defListBoxNormal";
    seg2Focus = "seg2Focus";
    seg2Normal = "seg2Normal";
    sknLblDescription = "sknLblDescription";
    sknLblRowHeading = "sknLblRowHeading";
    sknLblStrip = "sknLblStrip";
    sknLblTimeStamp = "sknLblTimeStamp";
    sknSampleRowTemplate = "sknSampleRowTemplate";
    sknSampleSectionHeaderTemplate = "sknSampleSectionHeaderTemplate";
    sknSectionHeaderLabelSkin = "sknSectionHeaderLabelSkin";
    slCalendar = "slCalendar";
    slCheckBoxGroup = "slCheckBoxGroup";
    slDynamicNotificationForm = "slDynamicNotificationForm";
    slFbox = "slFbox";
    slForm = "slForm";
    slImage = "slImage";
    sliPhoneSegmentHeader = "sliPhoneSegmentHeader";
    slPopup = "slPopup";
    slStaticNotificationForm = "slStaticNotificationForm";
    slTitleBar = "slTitleBar";
    slWatchForm = "slWatchForm";
};
//GlobalSequences File
function addWidgetsfrmNews() {
    frmNews.setDefaultUnit(kony.flex.DP);
    var segNews = new kony.ui.SegmentedUI2({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "data": [{
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }, {
            "imgNews": "imagedrag.png",
            "lblDescription": "Label",
            "lblTitle": "Label"
        }],
        "groupCells": true,
        "height": "50%",
        "id": "segNews",
        "isVisible": true,
        "left": "0%",
        "needPageIndicator": true,
        "pageOffDotImage": "pageoffdot.png",
        "pageOnDotImage": "pageondot.png",
        "retainSelection": true,
        "rowFocusSkin": "seg2Focus",
        "rowSkin": "seg2Normal",
        "rowTemplate": segNewsFlxContainer,
        "sectionHeaderSkin": "sliPhoneSegmentHeader",
        "selectionBehavior": constants.SEGUI_DEFAULT_BEHAVIOR,
        "separatorColor": "aaaaaa00",
        "separatorRequired": true,
        "separatorThickness": 2,
        "showScrollbars": true,
        "top": "10%",
        "viewType": constants.SEGUI_VIEW_TYPE_TABLEVIEW,
        "widgetDataMap": {
            "imgNews": "imgNews",
            "lblDescription": "lblDescription",
            "lblTitle": "lblTitle",
            "segNewsFlxContainer": "segNewsFlxContainer"
        },
        "width": "100%",
        "zIndex": 1
    }, {
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    frmNews.add(segNews);
};

function frmNewsGlobals() {
    frmNews = new kony.ui.Form2({
        "addWidgets": addWidgetsfrmNews,
        "enabledForIdleTimeout": false,
        "id": "frmNews",
        "layoutType": kony.flex.FREE_FORM,
        "needAppMenu": false,
        "postShow": AS_Form_f457551e7c354cb49cff22d4f0d032aa,
        "preShow": function(eventobject) {
            AS_Form_i741e54bfd644ff7ad50b530ea86e115(eventobject);
        },
        "skin": "slForm",
        "onBreakpointHandler": onBreakpointHandler,
        "breakpoints": [640, 1024, 1200]
    }, {
        "displayOrientation": constants.FORM_DISPLAY_ORIENTATION_PORTRAIT,
        "layoutType": kony.flex.FREE_FORM,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "retainScrollPosition": false
    });
};
function addWidgetsfrmWelcome() {
    frmWelcome.setDefaultUnit(kony.flex.DP);
    var lblState = new kony.ui.Label({
        "height": "5%",
        "id": "lblState",
        "isVisible": true,
        "left": "30%",
        "skin": "defLabel",
        "text": "Select State",
        "top": "30%",
        "width": "15%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lstBoxState = new kony.ui.ListBox({
        "focusSkin": "defListBoxFocus",
        "height": "5%",
        "id": "lstBoxState",
        "isVisible": true,
        "left": "50%",
        "onSelection": AS_ListBox_e8668bbaaaa34d58aabb7bf9745faa49,
        "skin": "defListBoxNormal",
        "top": "30%",
        "width": "30%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [3, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "multiSelect": false
    });
    var lblDate = new kony.ui.Label({
        "height": "5%",
        "id": "lblDate",
        "isVisible": true,
        "left": "30%",
        "skin": "defLabel",
        "text": "Select Date",
        "top": "40%",
        "width": "15%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var calBtn = new kony.ui.Calendar({
        "calendarIcon": "calbtn.png",
        "dateComponents": [12, 6, 2019, 0, 0, 0],
        "dateFormat": "dd/MM/yyyy",
        "day": 12,
        "formattedDate": "12/06/2019",
        "height": "5%",
        "hour": 0,
        "id": "calBtn",
        "isVisible": true,
        "left": "50%",
        "minutes": 0,
        "month": 6,
        "seconds": 0,
        "skin": "slCalendar",
        "top": "40%",
        "viewType": constants.CALENDAR_VIEW_TYPE_DEFAULT,
        "width": "30%",
        "year": 2019,
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "noOfMonths": 1
    });
    var lblNewsType = new kony.ui.Label({
        "height": "10%",
        "id": "lblNewsType",
        "isVisible": true,
        "left": "30%",
        "skin": "defLabel",
        "text": "Select News Type",
        "top": "50%",
        "width": "15%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lstBoxNewsType = new kony.ui.ListBox({
        "focusSkin": "defListBoxFocus",
        "height": "5%",
        "id": "lstBoxNewsType",
        "isVisible": true,
        "left": "50%",
        "masterData": [
            ["type1", "technolgy"],
            ["type2", "sports"]
        ],
        "selectedKey": "type1",
        "selectedKeyValue": ["type1", "technolgy"],
        "skin": "defListBoxNormal",
        "top": "50%",
        "width": "30%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [3, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "multiSelect": false
    });
    var btnFetchNews = new kony.ui.Button({
        "focusSkin": "defBtnFocus",
        "height": "5%",
        "id": "btnFetchNews",
        "isVisible": true,
        "left": "40%",
        "onClick": AS_Button_f18acf7e675b4050b82c7e9c0b0aabfc,
        "skin": "defBtnNormal",
        "text": "Get",
        "top": "65%",
        "width": "30%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var btnCreateNews = new kony.ui.Button({
        "focusSkin": "defBtnFocus",
        "height": "5%",
        "id": "btnCreateNews",
        "isVisible": true,
        "left": "39.97%",
        "onClick": AS_Button_b42b43ee1ee5441d83d8151be33eeee5,
        "skin": "defBtnNormal",
        "text": "CreateNews",
        "top": "72.48%",
        "width": "30%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_CENTER,
        "displayText": true,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    frmWelcome.add(lblState, lstBoxState, lblDate, calBtn, lblNewsType, lstBoxNewsType, btnFetchNews, btnCreateNews);
};

function frmWelcomeGlobals() {
    frmWelcome = new kony.ui.Form2({
        "addWidgets": addWidgetsfrmWelcome,
        "enabledForIdleTimeout": false,
        "id": "frmWelcome",
        "init": AS_Form_bc97732823dc4f9c83c0ca62930bac31,
        "layoutType": kony.flex.FREE_FORM,
        "needAppMenu": false,
        "preShow": function(eventobject) {
            AS_Form_c71e1d5f52fa41b78804badc75da6965(eventobject);
        },
        "skin": "slForm",
        "onBreakpointHandler": onBreakpointHandler,
        "breakpoints": [640, 1024, 1200]
    }, {
        "displayOrientation": constants.FORM_DISPLAY_ORIENTATION_PORTRAIT,
        "layoutType": kony.flex.FREE_FORM,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {
        "retainScrollPosition": false
    });
};
function successCallback(obj) {
    var msg = "success" + JSON.stringify(obj);
    alert(msg);
    kony.print(msg);
}

function failureCallback(err) {
    var msg = "failed" + JSON.stringify(err);
    alert(msg);
    kony.print(msg);
}
kony.globals["appid"] = "breakingNews";
kony.globals["locales"] = [];
 /*
  * kony-sdk-ide Version 8.4.20
  */
 /**
  * Kony namespace
  * @namespace kony
  */
 if (typeof(kony) === "undefined") {
     kony = {};
 }
 /**
  * Constructor for creating the kony client instance.
  * @class
  * @classdesc kony Class
  * @memberof kony
  */
 kony.sdk = function() {
     var currentObj = this;
     this.mainRef = {};
     var clientParams = {};
     this.tokens = {};
     this.currentClaimToken = null;
     this.globalRequestParams = {
         "headers": {},
         "queryparams": {},
         "bodyparams": {}
     };
     var userId = "";
     var integrityCustomSecurityKey = null;
     this.reportingheaders_allowed = false;
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && typeof(kony.setUserID) === 'function') {
         var userIDflagGet = kony.ds.read("userIDFromLicenseFlag");
         if (kony.sdk.isNullOrUndefined(userIDflagGet)) {
             var userIDflagSet = [];
             userIDflagSet.push("false");
             kony.ds.save(userIDflagSet, "userIDFromLicenseFlag");
         }
     }
     if (kony.internal && kony.internal.sdk && kony.internal.sdk.Services) {
         this.internalSdkObject = new kony.internal.sdk.Services();
     }
     this.getUserId = function() {
         return userId;
     };
     this.setCurrentUserId = function(newUserID) {
         userId = newUserID;
     };
     this.getSessionId = function() {
         if (!konyRef.sessionId) {
             var sessionId = kony.ds.read(kony.sdk.constants.KONYUUID);
             if (sessionId) {
                 konyRef.sessionId = sessionId[0];
             } else {
                 kony.sdk.logsdk.error("Session id is not available");
                 konyRef.sessionId = "";
             }
         }
         return konyRef.sessionId;
     };
     this.setSessionId = function(newSessionId) {
         konyRef.sessionId = newSessionId;
     };
     this.setClientParams = function(clientParamsMap) {
         clientParams = clientParamsMap;
     };
     this.getClientParams = function() {
         return clientParams;
     };
     this.globalRequestParamType = {
         headers: "headers",
         queryParams: "queryparams",
         bodyParams: "bodyparams"
     };
     this.getGlobalRequestParams = function(paramType) {
         kony.sdk.logsdk.trace("Entering getGlobalRequestParams");
         if (kony.sdk.isNullOrUndefined(paramType)) {
             return currentObj.globalRequestParams;
         } else if (paramType === currentObj.globalRequestParamType.headers) {
             return currentObj.globalRequestParams.headers;
         } else if (paramType === currentObj.globalRequestParamType.queryParams) {
             return currentObj.globalRequestParams.queryparams;
         } else if (paramType === currentObj.globalRequestParamType.bodyParams) {
             return currentObj.globalRequestParams.bodyparams;
         }
     };
     this.setGlobalRequestParam = function(paramName, paramValue, paramType) {
         kony.sdk.logsdk.trace("Entering setGlobalRequestParam");
         if (typeof(paramName) === 'string' && typeof(paramValue) === 'string' && typeof(paramType) === 'string') {
             if (paramType === currentObj.globalRequestParamType.headers) {
                 currentObj.globalRequestParams.headers[paramName] = paramValue;
             } else if (paramType === currentObj.globalRequestParamType.queryParams) {
                 currentObj.globalRequestParams.queryparams[paramName] = paramValue;
             } else if (paramType === currentObj.globalRequestParamType.bodyParams) {
                 currentObj.globalRequestParams.bodyparams[paramName] = paramValue;
             }
         }
     };
     this.removeGlobalRequestParam = function(paramName, paramType) {
         kony.sdk.logsdk.trace("Entering removeGlobalRequestParam");
         if (typeof(paramName) === 'string' && typeof(paramType) === 'string') {
             if (paramType.toLowerCase() === currentObj.globalRequestParamType.headers && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.headers[paramName])) {
                 delete currentObj.globalRequestParams.headers[paramName];
             } else if (paramType.toLowerCase() === currentObj.globalRequestParamType.queryParams && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.queryparams[paramName])) {
                 delete currentObj.globalRequestParams.queryparams[paramName];
             } else if (paramType.toLowerCase() === currentObj.globalRequestParamType.bodyParams && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.bodyparams[paramName])) {
                 delete currentObj.globalRequestParams.bodyparams[paramName];
             }
         }
     };
     this.resetGlobalRequestParams = function() {
         kony.sdk.logsdk.trace("Entering resetGlobalRequestParams");
         currentObj.globalRequestParams = {
             "headers": {},
             "queryparams": {},
             "bodyparams": {}
         };
     };
     this.appendGlobalHeaders = function(headers) {
         kony.sdk.logsdk.perf("Executing appendGlobalHeaders");
         var globalHeaders = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.headers);
         if (!kony.sdk.isNullOrUndefined(globalHeaders)) {
             if (kony.sdk.isNullOrUndefined(headers)) {
                 headers = {};
             }
             for (var obj in globalHeaders) {
                 if (kony.sdk.isNullOrUndefined(headers[obj])) {
                     headers[obj] = globalHeaders[obj];
                 }
             }
         }
         kony.sdk.logsdk.perf("Executing Finished appendGlobalHeaders");
     };
     this.appendGlobalBodyParams = function(params) {
         kony.sdk.logsdk.perf("Executing appendGlobalBodyParams");
         var globalBodyParams = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.bodyParams);
         if (!kony.sdk.isNullOrUndefined(globalBodyParams)) {
             if (kony.sdk.isNullOrUndefined(params)) {
                 params = {};
             }
             for (var obj in globalBodyParams) {
                 if (kony.sdk.isNullOrUndefined(params[obj])) {
                     params[obj] = globalBodyParams[obj];
                 }
             }
         }
         kony.sdk.logsdk.perf("Executing Finished appendGlobalBodyParams");
     };
     this.appendGlobalQueryParams = function(url) {
         kony.sdk.logsdk.perf("Executing appendGlobalQueryParams");
         var globalQueryParams = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.queryParams);
         if (!kony.sdk.isNullOrUndefined(globalQueryParams) && Object.keys(globalQueryParams).length !== 0) {
             if (url.indexOf("?") < 0) {
                 url = url + "?" + kony.sdk.util.objectToQueryParams(globalQueryParams);
             } else {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(globalQueryParams);
             }
         }
         kony.sdk.logsdk.perf("Executing Finished appendGlobalQueryParams");
         return url;
     };
     this.appendGlobalParams = function(url, headers, params) {
         kony.sdk.logsdk.perf("Executing appendGlobalParams");
         currentObj.appendGlobalHeaders(headers);
         currentObj.appendGlobalBodyParams(params);
         var result = currentObj.appendGlobalQueryParams(url);
         kony.sdk.logsdk.perf("Executing Finished appendGlobalParams");
         return result;
     };
     this.setAppSecurityKey = function(customSalt) {
         kony.sdk.logsdk.perf("Executing setAppSecurityKey");
         if (!kony.sdk.isNullOrUndefined(customSalt) && typeof customSalt === 'string') {
             integrityCustomSecurityKey = customSalt;
             kony.sdk.logsdk.perf("Executing Finished setAppSecurityKey");
             return true;
         } else {
             var errorObj = {};
             errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_security_key;
             errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_security_key;
             kony.sdk.logsdk.error(kony.sdk.errormessages.invalid_security_key);
             kony.sdk.logsdk.perf("Executing Finished setAppSecurityKey");
             return errorObj;
         }
     };
     this.getAppSecurityKey = function() {
         return integrityCustomSecurityKey;
     };
 };
 kony.mbaas = kony.sdk;
 kony.sdk.isDebugEnabled = true;
 kony.sdk.isInitialized = false;
 kony.sdk.currentInstance = null;
 kony.sdk.isLicenseUrlAvailable = true;
 kony.sdk.constants = kony.sdk.constants || {};
 kony.sdk.version = "8.4.20";
 kony.sdk.logsdk = new konySdkLogger();
 kony.sdk.syncService = null;
 kony.sdk.dataStore = kony.sdk.dataStore || new konyDataStore();
 kony.sdk.skipAnonymousCall = false;
 kony.sdk.getDefaultInstance = function() {
     return kony.sdk.currentInstance;
 };
 // This is to be deprecated with getDefaultInstance
 kony.sdk.getCurrentInstance = function() {
     return kony.sdk.currentInstance;
 };
 // This is to be set by client to skip anonymous login calls.
 kony.sdk.skipAnonymousLoginCall = function(state) {
     // If enabled then client can only access public integration services.
     // If disabled then client can access protected integration services.
     // To access private client needs to get authenticated by an identity service.
     kony.sdk.skipAnonymousCall = state;
 };
 kony.sdk.claimsRefresh = function(callback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.claimsRefresh");
     var konyRef = kony.sdk.getCurrentInstance();
     var networkProvider = new konyNetworkProvider();
     var loginWithAnonymousProvider = function(successCallback, failureCallback) {
         var identityObject = konyRef.getIdentityService("$anonymousProvider");
         identityObject.login(null, function(res) {
             successCallback();
         }, function(res) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(res));
         });
     };
     if (konyRef.currentClaimToken === null) {
         kony.sdk.logsdk.warn("claims Token is Unavialable");
         if (konyRef.isAnonymousProvider) {
             loginWithAnonymousProvider(callback, failureCallback);
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
         }
     } else if (konyRef.claimTokenExpiry && new Date().getTime() > konyRef.claimTokenExpiry) {
         if (konyRef.isAnonymousProvider) {
             loginWithAnonymousProvider(callback, failureCallback);
         } else {
             kony.sdk.fetchClaimsTokenFromServer(false, callback, failureCallback);
         }
     } else {
         callback();
     }
 };
 kony.sdk.claimsAndProviderTokenRefresh = function(callback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.claimsAndProviderTokenRefresh");
     kony.sdk.fetchClaimsTokenFromServer(true, callback, failureCallback);
 };
 /**
  * Checks for the etag in the response data. Gets the service doc & caches it if etag is updated.
  * @param data{JSON} response data from claimsRefresh or login.
  * @param callback{function} callback to be invoked.
  */
 function getLatestServiceDocIfAvailable(data, callback) {
     //Disabling this for phonegap and plain-js as there is not concept of auto-init there
     if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_IDE) {
         kony.sdk.verifyAndCallClosure(callback);
         return;
     }
     var currentETag = kony.sdk.dataStore.getItem("etagID");
     var serverETag = data.service_doc_etag;
     if (!kony.sdk.isNullOrUndefined(serverETag) && (kony.sdk.isNullOrUndefined(currentETag) || currentETag != serverETag)) {
         kony.sdk.logsdk.info("Service doc update found.");
         var networkProvider = new konyNetworkProvider();
         var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/") + "/appconfig";
         var headers = {};
         headers[kony.sdk.constants.APP_KEY_HEADER] = konyRef.mainRef.appKey;
         headers[kony.sdk.constants.APP_SECRET_HEADER] = konyRef.mainRef.appSecret;
         headers["X-HTTP-Method-Override"] = "GET";
         populateHeaderWithFabricAppVersion(headers);
         kony.sdk.logsdk.perf("Executing network call for getLatestServiceDocIfAvailable");
         networkProvider.post(_serviceUrl, null, headers, function(successResponse) {
             kony.sdk.dataStore.setItem("etagID", serverETag);
             kony.sdk.logsdk.debug("Update done. Current version = " + currentETag + " Updated to " + serverETag);
             kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(successResponse));
             kony.sdk.logsdk.perf("Executing Finished network call for getLatestServiceDocIfAvailable");
             kony.sdk.verifyAndCallClosure(callback);
         }, function(failureResponse) {
             kony.sdk.logsdk.perf("Executing Finished network call for getLatestServiceDocIfAvailable");
             kony.sdk.logsdk.error("Refresh of serviceDoc failed:" + JSON.stringify(failureResponse));
             kony.sdk.verifyAndCallClosure(callback);
         });
     } else {
         kony.sdk.verifyAndCallClosure(callback);
     }
 }
 kony.sdk.fetchClaimsTokenFromServer = function(isBackendTokenRefreshRequired, callback, failureCallback) {
     kony.sdk.logsdk.perf("Executing kony.sdk.fetchClaimsTokenFromServer");
     var konyRef = kony.sdk.getCurrentInstance();
     var networkProvider = new konyNetworkProvider();
     kony.sdk.logsdk.debug("claims token has expired. fetching new token and isBackendTokenRefreshRequired :", isBackendTokenRefreshRequired);
     var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/");
     var _url = _serviceUrl + "/claims";
     if (isBackendTokenRefreshRequired) {
         _url = _url + "?refresh=true";
     }
     kony.sdk.logsdk.debug("service url is " + _url);
     if (konyRef.currentRefreshToken === null) {
         kony.sdk.logsdk.perf("Executing Finished network call for fetchClaimsTokenFromServer");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullRefreshTokenErrObj());
     } else {
         var headers = {};
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentRefreshToken;
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         kony.sdk.logsdk.perf("Executing network call for fetchClaimsTokenFromServer");
         networkProvider.post(_url, {}, headers, function(tokens) {
             kony.sdk.logsdk.perf("Executing Finished network call for fetchClaimsTokenFromServer");
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.fetchClaimsTokenFromServer : refresh success");
             var response = kony.sdk.processClaimsSuccessResponse(tokens, konyRef, false);

             function serviceDocCallback() {
                 kony.sdk.verifyAndCallClosure(callback, response);
             }
             getLatestServiceDocIfAvailable(tokens, serviceDocCallback);
         }, function(data) {
             kony.sdk.logsdk.perf("Executing Finished network call for fetchClaimsTokenFromServer");
             kony.sdk.logsdk.error("failed to acquire refresh token", data);
             kony.sdk.processClaimsErrorResponse(data, konyRef, true, failureCallback);
         });
     }
 };
 kony.sdk.processClaimsSuccessResponse = function(data, konyRef, isAsync, callBack) {
     kony.sdk.logsdk.trace("Entering kony.sdk.processClaimsSuccessResponse");
     data = kony.sdk.formatSuccessResponse(data);
     konyRef.currentClaimToken = data.claims_token.value;
     konyRef.claimTokenExpiry = data.claims_token.exp;
     konyRef.currentRefreshToken = data.refresh_token;
     kony.logger.setClaimsToken();
     //if offline login enabled then updating the claimstoken in the store
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE && kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS) {
         if (kony.sdk.offline.isOfflineEnabled && kony.sdk.offline.isOfflineEnabled == true) {
             kony.sdk.offline.updateAuthToken(data);
         }
         if (kony.sdk.offline.persistToken || kony.sdk.util.isPersistentLoginResponseEnabled()) {
             kony.sdk.offline.updatePersistedToken(data);
         }
     }
     if (!isAsync) {
         return {
             "message": "success"
         };
     } else if (callBack) {
         callBack();
     }
 };
 kony.sdk.processClaimsErrorResponse = function(data, konyRef, isAsync, callBack) {
     kony.sdk.logsdk.perf("Executing kony.sdk.processClaimsErrorResponse");
     //setting the anonymous provider as true to access the public protected urls without any issue
     konyRef.isAnonymousProvider = true;
     if (!isAsync) {
         var result = kony.sdk.error.getAuthErrObj(data);
         kony.sdk.logsdk.perf("Executing Finished kony.sdk.processClaimsErrorResponse");
         return result;
     } else if (callBack) {
         kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getAuthErrObj(data));
     }
 };
 /**
  * Init success callback method.
  * @callback initSuccessCallback
  * @param {json} mainRef - Application Configuration
  */
 /**
  * Init failure callback method.
  * @callback initFailureCallback
  */
 /**
  * Initialization method for the kony SDK.
  * This method will fetch the app configuration from the kony server and stores in memory.
  * This method has to be invoked before invoking any other SDK methods.
  * @param {string} appKey - Appkey of the kony application
  * @param {string} appSecret - App Secret of the kony application
  * @param {string} serviceUrl - URL of the kony Server
  * @param {initSuccessCallback} successCallback  - Callback method on success
  * @param {initFailureCallback} failureCallback - Callback method on failure
  */
 kony.sdk.prototype.init = function(appKey, appSecret, serviceUrl, successCallback, failureCallback, initOptions) {
     // removing app metadata with key for the latest app metadata
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.init");
     kony.sdk.deleteMetadatafromDs();
     if (!(appKey && appSecret && serviceUrl)) {
         kony.sdk.logsdk.error("### init:: Invalid credentials passed");
         kony.sdk.verifyAndCallClosure(failureCallback, "Invalid initialization parameters passed. Please check appKey, appSecret and ServiceUrl parameters");
         return;
     }
     var networkProvider = new konyNetworkProvider();
     serviceUrl = serviceUrl.trim();
     this.mainRef.serviceUrl = serviceUrl;
     this.mainRef.appSecret = appSecret;
     konyRef = this;
     KNYMobileFabric = this;
     kony.sdk.currentInstance = konyRef;
     var options = {};
     options["ignoreintegrity"] = true;
     setIntegrityParams.call(konyRef);
     kony.sdk.logsdk.trace("### init:: calling GET on appConfig to retrieve servicedoc");
     var headers = {};
     headers[kony.sdk.constants.APP_KEY_HEADER] = appKey;
     headers[kony.sdk.constants.APP_SECRET_HEADER] = appSecret;
     headers["X-HTTP-Method-Override"] = "GET";
     //Resetting the value.
     kony.sdk.setFabricAppVersion(null);
     if (!kony.sdk.isNullOrUndefined(initOptions) && initOptions["MFAppVersion"]) {
         kony.sdk.setFabricAppVersion(initOptions["MFAppVersion"]);
     }
     populateHeaderWithFabricAppVersion(headers);
     kony.sdk.logsdk.perf("Executing network call for fetching servicedoc");
     networkProvider.post(serviceUrl, null, headers, function(data) {
         data = kony.sdk.formatSuccessResponse(data);
         kony.sdk.logsdk.info("### init::_doInit fetched servicedoc successfuly");
         kony.sdk.logsdk.debug("### init:: retrieved data from service doc", data);
         konyRef.mainRef.config = data;
         konyRef.servicedoc = data;
         konyRef.mainRef.appId = data.appId;
         var processServiceDocResult = konyRef.initWithServiceDoc(appKey, appSecret, data);
         if (processServiceDocResult === true) {
             kony.sdk.logsdk.info("### init::_doInit processing service document successful");
             kony.sdk.logsdk.debug("### init::_doInit saving done. Calling success callback", data);
             kony.sdk.initiateSession(konyRef);
             if (typeof(KNYMetricsService) !== "undefined" && kony.sdk.currentInstance.getMetricsService) {
                 KNYMetricsService = kony.sdk.currentInstance.getMetricsService();
                 if (KNYMetricsService && typeof(appConfig) !== "undefined" && kony.sdk.util.isJsonObject(appConfig) && appConfig.hasOwnProperty("eventTypes") && kony.sdk.isArray(appConfig.eventTypes) && appConfig.eventTypes.length !== 0) {
                     KNYMetricsService.setEventTracking(appConfig.eventTypes);
                 }
             }
             if (kony.sdk.skipAnonymousCall) {
                 kony.sdk.logsdk.info("### init::skipping anonymous login call");
                 // Enabling this flag to connect to any protected integration service.
                 konyRef.isAnonymousProvider = true;
                 kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
                 kony.sdk.verifyAndCallClosure(successCallback, konyRef.mainRef);
             } else {
                 var identityObject = kony.sdk.getCurrentInstance().getIdentityService("$anonymousProvider");
                 identityObject.login(null, function(res) {
                     kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
                     kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
                     kony.sdk.verifyAndCallClosure(successCallback, konyRef.mainRef);
                 }, function(res) {
                     kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
                     kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(res));
                 });
             }
         } else {
             kony.sdk.logsdk.error("### init::_doInit processing servicedoc failed. Calling failure callback");
             kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
             kony.sdk.verifyAndCallClosure(failureCallback, JSON.stringify(processServiceDocResult));
         }
     }, function(error) {
         kony.sdk.logsdk.error("### init::_doInit fetching service document from Server failed", error);
         kony.sdk.logsdk.info("### init::_doInit  calling failure callback");
         kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
         kony.sdk.isInitialized = false;
         kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(error));
     }, null, options);
 };
 kony.sdk.prototype.initWithServiceDoc = function(appKey, appSecret, serviceDoc) {
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.initWithServiceDoc");
     konyRef = this;
     KNYMobileFabric = this;
     kony.sdk.currentInstance = this;
     var unprocessedServiceDoc = kony.sdk.cloneObject(serviceDoc);
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
         if (!kony.sdk.isNullOrUndefined(serviceDoc)) {
             if (serviceDoc.hasOwnProperty("integrity_check_required") && serviceDoc.integrity_check_required === true) {
                 //MF server >=8.2
                 konyRef.mainRef.integrityKey = true;
             } else {
                 //MF server < 8.2 and integrity is disabled
                 konyRef.mainRef.integrityKey = false;
             }
         }
     } else {
         //platform phonegap and plain-js doesn't support http integrity
         konyRef.mainRef.integrityKey = false;
     }
     if (serviceDoc instanceof kony.sdk.serviceDoc) {
         var servConfig = serviceDoc.toJSON();
         processServiceDocMap(servConfig);
     } else {
         return processServiceDocMap(serviceDoc);
     }

     function processServiceDocMap(servConfig) {
         for (var item in servConfig) {
             if (kony.sdk.isNullOrUndefined(servConfig[item]) || kony.sdk.isEmptyObject(servConfig[item])) {
                 delete servConfig[item];
             }
         }
         kony.sdk.logsdk.debug("### init::_doInit::_processServiceDoc", servConfig);
         try {
             konyRef.mainRef.appKey = appKey;
             konyRef.mainRef.appSecret = appSecret;
             konyRef.mainRef.appId = servConfig.appId;
             konyRef.mainRef.config = serviceDoc;
             /* if (!servConfig.baseId) {
              throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid baseId " + servConfig.baseId);
              } */
             konyRef.mainRef.baseId = servConfig.baseId;
             /* if (!servConfig.name) {
              throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid name " + servConfig.name);
              } */
             konyRef.mainRef.name = servConfig.name;
             if (servConfig.login) {
                 konyRef.login = servConfig.login;
             } else {
                 konyRef.login = [];
             }
             var url = servConfig.selflink;
             if (url) {
                 var lastPos = url.indexOf("/appconfig");
                 if (lastPos != -1) {
                     url = url.slice(0, lastPos);
                 } else {
                     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid self link");
                 }
                 var anonymousLoginProvider = {};
                 anonymousLoginProvider.type = "anonymous";
                 anonymousLoginProvider.url = url;
                 anonymousLoginProvider.prov = "$anonymousProvider";
                 konyRef.login.push(anonymousLoginProvider);
             }
             if (typeof(servConfig.integsvc) !== 'undefined') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Integration services");
                 konyRef.integsvc = servConfig.integsvc;
                 kony.sdk.logsdk.debug("### init::_doInit::konyRef integration Services", konyRef.integsvc);
             }
             if (typeof(servConfig.services_meta) === 'object') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Object services");
                 kony.sdk.util.populateIndividualServiceLists(servConfig, konyRef);
             }
             if (typeof(servConfig.messagingsvc) !== 'undefined') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Messaging services");
                 konyRef.messagingsvc = servConfig.messagingsvc;
             }
             if (typeof(servConfig.logicsvc) !== 'undefined') {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Logic services");
                 konyRef.logicsvc = servConfig.logicsvc;
             }
             if (typeof(servConfig.sync) !== 'undefined') {
                 konyRef.sync = servConfig.sync;
             }
             if (servConfig.identity_features && servConfig.identity_features.reporting_params_header_allowed) {
                 kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Identity features");
                 konyRef.reportingheaders_allowed = servConfig.identity_features.reporting_params_header_allowed;
             }
             if (kony.sdk.isLicenseUrlAvailable) {
                 if (servConfig.reportingsvc && servConfig.reportingsvc.custom && servConfig.reportingsvc.session) {
                     konyRef.customReportingURL = servConfig.reportingsvc.custom;
                     konyRef.sessionReportingURL = servConfig.reportingsvc.session;
                     if (konyRef.sessionReportingURL && kony.logger.isNativeLoggerAvailable()) {
                         var lastIndex = konyRef.sessionReportingURL.lastIndexOf("/");
                         if (lastIndex !== -1) {
                             var networkUrl = konyRef.sessionReportingURL.substring(0, lastIndex + 1) + kony.logger.networkPersistorUrlEndpoint;
                             var networkPersistor = kony.logger.createNetworkPersistor();
                             networkPersistor.URL = networkUrl;
                             kony.logger.setPersistorConfig(networkPersistor);
                         }
                     }
                 } else {
                     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid url for reporting service");
                 }
             }
             if (konyRef.internalSdkObject) {
                 konyRef.internalSdkObject.initWithServiceDoc(appKey, appSecret, servConfig);
                 if (konyRef.internalSdkObject.setClientParams) {
                     if (appConfig) {
                         konyRef.internalSdkObject.setClientParams({
                             "aid": appConfig.appId,
                             "aname": appConfig.appName
                         });
                     } else {
                         konyRef.internalSdkObject.setClientParams(konyRef.getClientParams());
                     }
                 }
                 kony.sdk.logsdk.info("### init::internal sdk object initialized");
             }
             kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing service document done");
             kony.sdk.isInitialized = true;
             if (kony.sdk.metric && kony.os.deviceInfo().name === kony.sdk.constants.PLATFORM_SPA) {
                 kony.sdk.metric.flushEvents();
             }
             if (!kony.sdk.isNullOrUndefined(servConfig.reportingsvc)) {
                 kony.sdk.saveMetadatainDs(appKey, appSecret, unprocessedServiceDoc);
                 kony.sdk.setLicenseCall(appKey, appSecret, unprocessedServiceDoc);
             }
             //making this check for plain-js and phoneGap in android.
             if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_PLAIN_JS && kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_PHONEGAP) {
                 if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_ANDROID && (appConfig.isSSOEnabled === true || appConfig.isSSOEnabled === "true")) {
                     kony.sdk.util.initializeSSO();
                 }
             }
             var sdkType = kony.sdk.getSdkType();
             var type = kony.sdk.getAType();
             var platformName = kony.sdk.getPlatformName();
             if (sdkType == kony.sdk.constants.SDK_TYPE_IDE && ((type === kony.sdk.constants.SDK_ATYPE_NATIVE) || (type === kony.sdk.constants.SDK_ATYPE_SPA))) {
                 if ((!kony.sdk.isNullOrUndefined(konyRef.offlineObjectsvc)) && !(kony.sdk.isEmptyObject(konyRef.offlineObjectsvc))) {
                     konyRef.OfflineObjects = new kony.sdk.OfflineObjects(konyRef.offlineObjectsvc);
                 }
             }
             if (kony.license) {
                 if (kony.licensevar && kony.licensevar.changeHandlers && kony.licensevar.changeHandlers.length == 0 && kony.license.registerChangeListener) {
                     kony.license.registerChangeListener(konyRef.sessionChangeHandler);
                     konyRef.overrideUserIdFlag = true;
                 }
             }
             if (konyRef.mainRef.integrityKey === true) {
                 setIntegrityParams();
                 try {
                     if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
                         //invoke NFI only for android,ios and FFI for windows 
                         kony.sdk.httpIntegrity.setIntegrityCheck(konyRef.mainRef.integrityParams);
                     }
                 } catch (e) {
                     kony.sdk.logsdk.warn("Invalid Integrity properties received");
                     throw new Exception(kony.sdk.errorConstants.INTEGRITY_FAILURE, "Invalid Integrity properties");
                 }
             } else {
                 resetIntegrityParams();
                 if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
                     //invoke NFI only for android,ios and FFI for windows 
                     kony.sdk.httpIntegrity.removeIntegrityCheck();
                 }
             }
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.initWithServiceDoc");
             return true;
         } catch (err) {
             kony.sdk.logsdk.error("### init::_doInit::_processServiceDoc failed with an exception: ", err);
             return ("processing the ServiceDoc failed with an exception: " + JSON.stringify(err));
         }
     }
 };
 kony.sdk.prototype.sessionChangeHandler = function(changes) {
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.sessionChangeHandler");
     var konyRef = kony.sdk.getCurrentInstance();
     konyRef.getMetricsService();
     var sessionId = null;
     var userId = null;
     if (changes["sessionId"] != undefined) {
         sessionId = changes["sessionId"];
         konyRef.setSessionId(sessionId);
         if (konyRef.internalSdkObject) {
             sessionId = sessionId + "," + kony.sdk.util.getSessionType();
         }
         if (konyRef.metricsServiceObject && konyRef.metricsServiceObject.setSessionId) {
             konyRef.metricsServiceObject.setSessionId(sessionId);
         }
     }
     if (changes["userId"] != undefined) {
         konyRef.overrideUserIdFlag = true;
         userId = changes["userId"];
         konyRef.setCurrentUserId(userId);
         if (konyRef.metricsServiceObject && konyRef.metricsServiceObject.setUserId) {
             konyRef.metricsServiceObject.setUserId(userId);
         }
     }
     kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.sessionChangeHandler");
 };

 function setIntegrityParams() {
     var integrityParams = {
         "algo": kony.sdk.constants.HASHING_ALGORITHM,
         "headerName": kony.sdk.constants.INTEGRITY_HEADER,
         "validateResp": true
     };
     if (!kony.sdk.isNullOrUndefined(konyRef.getAppSecurityKey())) {
         integrityParams["salt"] = konyRef.getAppSecurityKey();
     } else {
         integrityParams["salt"] = konyRef.mainRef.appSecret;
     }
     konyRef.mainRef.integrityKey = true;
     konyRef.mainRef.integrityParams = integrityParams;
 }

 function resetIntegrityParams() {
     konyRef.mainRef.integrityKey = false;
     konyRef.mainRef.integrityParams = {};
 }
 /**
  * MFSDK
  * Created by KH1969 on 18-01-2018.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Constructor for ClientCache service, uses lruCache.js internally to save key, value pairs.
  * This is a singleton class, object gets created for the first time of instantiation and the same object is
  * returned for next initializations.
  *
  * @param size {Number} Maximum size of the cache. It should be non zero positive number.
  * @return {kony.sdk.ClientCache}
  *
  */
 kony.sdk.ClientCache = function(size) {
         if (typeof kony.sdk.ClientCache.instance === 'object') return kony.sdk.ClientCache.instance;
         var lruCacheObj = null;
         if (size === undefined || size === null) lruCacheObj = new lruCache(kony.sdk.constants.DEFAULT_CACHE_SIZE);
         else if (typeof size != 'number' || size <= 0) {
             kony.sdk.logsdk.warn("cache cannot be created of size <= 0");
             return null;
         } else lruCacheObj = new lruCache(size);
         /**
          * Gets the response cached for the key. Returns null if not found.
          * @param key {string}
          * @return {null|object}
          */
         this.get = function(key) {
                 return lruCacheObj.get(key);
             }
             /**
              * Gets the boolean assertion for key existence in the cache.
              * @param key {string}
              * @return {boolean}
              */
         this.has = function(key) {
                 return lruCacheObj.has(key);
             }
             /**
              * Adds the key, value pair to cache.
              * @param key {string}
              * @param value {string}
              * @param expiryTime {number} Expiry time in seconds.
              */
         this.add = function(key, value, expiryTime) {
                 lruCacheObj.add(key, value, expiryTime);
             }
             /**
              * Removes the key, value from cache.
              * @param key {string}
              */
         this.remove = function(key) {
             lruCacheObj.remove(key);
         }
         kony.sdk.ClientCache.instance = this;
     }
     /**
      * MFSDK
      * Created by KH1969 on 18-01-2018.
      * Copyright  2018 Kony. All rights reserved.
      */
     /**
      * Constructor for standalone LRU page replacement implementation.
      * Implementation is done using a double linked list data structure and a hashmap.
      * Upon every insert & get the head gets updated to the newest element.
      * Cached nodes gets removed if size is more than the requested capacity.
      * Default cache size is 100.
      *
      * Should not be called by the developer.
      *
      *  Below is the list structure if elements are inserted in the order A, B, C & D

      *  Head = D, Tail = A
      *  D--(older)-->C--(older)-->B--(older)-->A--(older)-->NULL
      *  NULL<--(newer)--D<--(newer)--C<--(newer)--B<--(newer)--A
      *
      *  Now if B is accessed the list structure will be modified as,
      *  Head = B, Tail = A
      *
      *  B--(older)-->D--(older)-->C--(older)-->A--(older)-->NULL
      *  NULL<--(newer)--B<--(newer)--D<--(newer)--C<--(newer)--A
      */
 lruCache = function(size) {
         var LOG_PREFIX = "SDK_CACHE ";
         if (size === undefined || size === null) this.capacity = kony.sdk.constants.DEFAULT_CACHE_SIZE;
         else if (typeof size != 'number' || size <= 0) {
             kony.sdk.logsdk.warn("cache cannot be created of size <= 0");
             return null;
         } else this.capacity = size;
         this.length = 0;
         this.map = {};
         // save the head and tail so we can update it easily
         this.head = null;
         this.tail = null;
         /**
          * Gets the current time in seconds.
          * @returns {number}
          */
         function getCurrentTimeInSeconds() {
             return Math.floor(new Date().getTime() / 1000);
         }
         /**
          * Double linked list data structure.
          * @param key
          * @param value
          */
         function cacheNode(key, value, expiry) {
             this.key = key;
             this.val = value;
             this.newer = null; // Next newer node
             this.older = null; // Previous older node
             this.expiryTime = 0;
             if (expiry !== undefined && typeof expiry === 'number' && expiry != 0) {
                 this.expiryTime = getCurrentTimeInSeconds() + expiry;
             }
         }
         /**
          * Shuffles the cache by last recently used.
          * @param key
          */
         function shuffleLRUCache(key) {
             var node = this.map[key];
             if (this.head === node) {
                 // No need to shuffle the cache, as the head itself is the recently accessed node.
                 return;
             }
             // Head will not have newer node.
             if (node.newer) {
                 node.newer.older = node.older;
             } else {
                 this.head = node.older;
             }
             // Tail will not have older node.
             if (node.older) {
                 node.older.newer = node.newer;
             } else {
                 this.tail = node.newer;
             }
             // Now node is detached. Place it at head.
             // Updates are done in this way
             // 1: node--(older)-->head
             // 2: null<--(newer)--node
             // 3: node<--(newer)--head
             // 4: node is assigned to head. So current head got updated to node.
             node.older = this.head;
             node.newer = null;
             if (this.head) {
                 this.head.newer = node;
             }
             this.head = node;
         }
         /**
          * Returns the current size of the cache.
          * @returns {number}
          */
         this.getSize = function() {
                 return this.length;
             }
             /**
              * Adds the key value pair to the cache.
              * Key gets removed upon expiry, expiry time is calculated by currentTimeInSeconds + expiryTime.
              * If no expiryTime is specified then key will not expire.
              * @param key {String}
              * @param value {Object}
              * @param expiryTime {Number}
              */
         this.add = function(key, value, expiryTime) {
                 if (key === undefined || value === undefined || key === null || value === null) return;
                 // update the value for existing entries
                 if (this.has(key)) {
                     this.map[key].val = value;
                     kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " updated");
                     shuffleLRUCache.call(this, key);
                     return;
                 }
                 if (this.length >= this.capacity) {
                     // remove the least recently used item
                     this.remove(this.tail.key)
                 }
                 var node = new cacheNode(key, value, expiryTime);
                 // Additions are done in this way
                 // 1: node--(older)-->head
                 // 2: node<--(newer)--head
                 // 3: node is assigned to head. So current head got updated to node.
                 // 4: tail = node, if there is no tail node then current node is tail node. This happens only for the first add.
                 node.older = this.head;
                 // if have head, we need re-connect node with other nodes older than head
                 if (this.head) {
                     this.head.newer = node;
                 }
                 this.head = node;
                 // if no tail which means first insert, set the tail to node too
                 if (!this.tail) {
                     this.tail = node;
                 }
                 this.map[key] = node;
                 this.length++;
                 kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " added");
             }
             /**
              * Gets the cached node by key. Returns null if key is not found.
              * The key is removed if it is expired, returns null here as well.
              * @param key {String}
              * @returns {Object}
              */
         this.get = function(key) {
                 if (this.has(key)) {
                     if (this.map[key].expiryTime != 0 && getCurrentTimeInSeconds() > this.map[key].expiryTime) {
                         this.remove(key);
                         kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " expired");
                         return null;
                     }
                     shuffleLRUCache.call(this, key);
                     return this.map[key].val;
                 } else {
                     return null;
                 }
             }
             /**
              * Removes the key, value from the cache by key.
              * @param key {String} Key to delete from the cache
              */
         this.remove = function(key) {
                 if (this.has(key)) {
                     var node = this.map[key];
                     // Head node will not have newer node.
                     if (node.newer) {
                         node.newer.older = node.older;
                     } else {
                         this.head = node.older;
                     }
                     // Tail node will not have older node.
                     if (node.older) {
                         node.older.newer = node.newer;
                     } else {
                         this.tail = node.newer;
                     }
                     delete this.map[key];
                     node = null;
                     this.length--;
                 }
             }
             /**
              * Clears the cache.
              */
         this.clear = function() {
                 this.map = {};
                 this.length = 0;
             }
             /**
              * Check if key exists.
              * @param key {string} Key to be found in the cache
              * @returns {boolean}
              */
         this.has = function(key) {
                 return this.map.hasOwnProperty(key);
             }
             /**
              * Updates the cache size.
              * @param size {number}
              */
         this.setMaxCacheSize = function(size) {
             //    Todo: If requested size < capacity remove the last (N - size) nodes from tail.
             kony.sdk.logsdk.debug(LOG_PREFIX + "updating cache size from " + this.capacity + " to " + size);
             this.capacity = size;
         }
     }
     /**
      * Method to create the configuration service instance
      * @returns {ConfigurationService} Configuration service instance
      */
 kony.sdk.prototype.getConfigurationService = function() {
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getConfigurationService")
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Configuration service.");
     }
     var configObj = new ConfigurationService(this);
     kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getConfigurationService")
     if (configObj) {
         return configObj;
     } else {
         throw new Exception(kony.sdk.errorConstants.CONFIGURATION_FAILURE, "Error in creating configuration object");
     }
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Configuration service instance for fetching client app properties.
  */
 function ConfigurationService(konyRef) {
     var istUrl = konyRef.mainRef.config.reportingsvc.session.split("/IST")[0];
     kony.sdk.logsdk.debug("IST url fetched from service doc is :" + istUrl);
     var configUrl = istUrl + kony.sdk.constants.GET_CLIENT_PROPERTY_URL;
     kony.sdk.logsdk.debug("Configuration url formed is :" + configUrl);
     var networkProvider = new konyNetworkProvider();
     /**
      * Configuration svc method to get all the client app properties which is configured in admin console.
      * @successCallback this is called on successfull retrieval of properties
      * @failureCallback this is called on failure in retrieving properties
      * @returns {json} key value pair of all client app properties
      */
     this.getAllClientAppProperties = function(successCallback, failureCallback) {
         function fetchClientPropertiesHandler() {
             _getAllClientAppProperties(successCallback, failureCallback);
         }
         kony.sdk.claimsRefresh(fetchClientPropertiesHandler, failureCallback);
     };

     function _getAllClientAppProperties(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering into _getAllClientAppProperties");
         var defaultHeaders = {};
         var token = konyRef.currentClaimToken;
         if (!token) {
             token = kony.sdk.getCurrentInstance().currentClaimToken;
         }
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = token;
         var options = {};
         options["disableIntegrity"] = true;
         networkProvider.get(configUrl, null, defaultHeaders, function(res) {
             kony.sdk.logsdk.trace("Entering Configuration service network success");
             kony.sdk.logsdk.debug("response from server for client properties is :" + JSON.stringify(res));
             var tempArray = ["httpresponse", kony.sdk.constants.MF_OPSTATUS];
             var tempJSON = {};
             for (var key in res) {
                 if (tempArray.indexOf(key.toLowerCase()) > -1) {
                     continue;
                 }
                 tempJSON[key] = res[key];
             }
             kony.sdk.verifyAndCallClosure(successCallback, tempJSON);
         }, function(xhr, status, err) {
             kony.sdk.logsdk.trace("Entering Configuration service network error");
             if (xhr && !(status && err)) {
                 err = xhr;
             }
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
         }, null, options);
     }
 }
 kony.sdk.constants = {
     /**Logger Constants**/
     LOGGER_NAME: "MFSDK",
     SYNC_LOGGER_NAME: "SYNCV1",
     APP_LOGGER_NAME: "KonyLogger",
     /**Network constants**/
     LAUNCHMODE_DEEPLINK: 3,
     DEEPLINK_VALID_PARAM: "code",
     HASHING_ALGORITHM: "SHA256",
     REMOVE_INTEGRITY_CHECK: "removeIntegrityCheck",
     SET_INTEGRITY_CHECK: "setIntegrityCheck",
     DEFAULT_CACHE_SIZE: 100,
     GET_CLIENT_PROPERTY_URL: "/metadata/configurations/client/properties",
     DEFAULT_CACHE_EXPIRY_TIME: 0, //Which means it doesn't expire in the application session.
     QUERY_PARAMS: "queryParams",
     /**Service ID's for Identity Calls**/
     GET_BACKEND_TOKEN: "getBackendToken",
     GET_SECURITY_ATTRIBUTES: "getSecurityAttributes",
     GET_USER_ATTRIBUTES: "getUserAttributes",
     GET_USER_DATA: "getUserData",
     GET_PROFILE: "getProfile",
     /** Identity Options**/
     OAUTH_REDIRECT_SUCCESS_URL: "success_url",
     ETAGID: "etagID",
     /** Multifactor auth related constants**/
     IS_MFA_ENABLED: "is_mfa_enabled",
     MFA_META: "mfa_meta",
     //OAuth for IE11 Workaround Constants, MFSDK-3657
     IE11_CROSS_DOMAIN_OAUTH_BASE_URL: "IE11CrossDomainOAuthBaseUrl",
     KNY_OAUTH_REDIRECT_HTML: "KNYOAuthRedirect.html",
     KNY_OAUTH_CALLBACK_HTML: "KNYOAuthCallback.html",
     KNY_OAUTH_REDIRECT_URL: "kny_oauth_redirect_url",
     /**HttpMethods and header constants**/
     HTTP_METHOD_GET: "GET",
     HTTP_METHOD_POST: "POST",
     HTTP_METHOD_DELETE: "DELETE",
     HTTP_CONTENT_HEADER: "Content-Type",
     HTTP_REQUEST_HEADER_ACCEPT: "Accept",
     /**Content Type Value Constants**/
     CONTENT_TYPE_FORM_URL_ENCODED: "application/x-www-form-urlencoded",
     CONTENT_TYPE_JSON: "application/json",
     //Added a new content-type based on the bug MFSDK-4096
     CONTENT_TYPE_JSON_CHARSET_UTF8: "application/json;charset=utf-8",
     CONTENT_TYPE_OCTET_STREAM: "application/octet-stream",
     CONTENT_TYPE_TEXT_HTML: "text/html",
     CONTENT_TYPE_TEXT_PLAIN: "text/plain",
     /**SDK Plugin Type**/
     SDK_TYPE_IDE: "js",
     SDK_TYPE_PHONEGAP: "phonegap",
     SDK_TYPE_PLAIN_JS: "plain-js",
     /**APP Session Type**/
     APP_SESSION_INTERACTIVE: "I",
     APP_SESSION_NON_INTERACTIVE: "NI",
     /**SDK Architecture Type**/
     SDK_ATYPE_NATIVE: "native",
     SDK_ATYPE_SPA: "spa",
     /**Device platform**/
     PLATFORM_WINDOWS: "windows",
     PLATFORM_ANDROID: "android",
     PLATFORM_IOS: "ios",
     //kony.os.device.info() for SPA returns thinclient
     PLATFORM_SPA: "thinclient",
     /***Metrics Constants**/
     REPORTING_PARAMS: "konyreportingparams",
     KEY_DEVICE_ID: "deviceID",
     /**Headers**/
     APP_KEY_HEADER: "X-Kony-App-Key",
     APP_SECRET_HEADER: "X-Kony-App-Secret",
     KONY_AUTHORIZATION_HEADER: "X-Kony-Authorization",
     AUTHORIZATION_HEADER: "Authorization",
     REPORTING_HEADER: "X-Kony-ReportingParams",
     INTEGRITY_HEADER: "X-Kony-Integrity",
     DEVICEID_HEADER: "X-Kony-DeviceId",
     API_VERSION_HEADER: "X-Kony-API-Version",
     APP_VERSION_HEADER: "X-Kony-App-Version",
     SDK_TYPE_HEADER: "X-Kony-SDK-Type",
     SDK_VERSION_HEADER: "X-Kony-SDK-Version",
     PLATFORM_TYPE_HEADER: "X-Kony-Platform-Type",
     HTTP_OVERRIDE_HEADER: "X-HTTP-Method-Override",
     /**Mobilefabric constants**/
     HTTP_STATUS_CODE: "httpStatusCode",
     MF_OPSTATUS: "opstatus",
     MF_CODE: "mfcode",
     MF_ERROR_MSG: "errmsg",
     MF_ERROR_CODE: "errcode",
     MF_SERVICE: "service",
     /**Engagement service API constants**/
     SUBSCRIBE_AUDIENCE: "/subscribeaudience",
     BEACON_UPDATE: "/beaconupdate",
     RICH_PUSH_MESSAGE: "/messages/rich/",
     LAST_ACTIVE_DATE: "lastActiveDate",
     KSID: "ksid",
     AUTH_TOKEN: "authToken",
     DEVICE_AUTHTOKEN_HEADER: "X-Device-AuthToken",
     /**Parsed Template Constants**/
     PROCESSED_TEMPLATE: "processedTemplate",
     MISSING_VARIABLES: "missingVariables",
     /**Mandatory Binary Params**/
     FILE_PATH: "FilePath",
     RAW_BYTES: "rawBytes",
     FILE_OBJECT: "fileObject",
     FILE_NAME: "fileName",
     /**Miscellaneous**/
     SSO_TOKEN_KEY: "ssoTokenKey",
     KONYUUID: "konyUUID",
     BROWSER_WIDGET: "browserWidget",
     INIT_FAILURE_MESSAGE: "SDK is not initialized, call init before invoking any operation on",
     DISABLE_INTEGRITY: "disableIntegrity",
     PASSTHROUGH: "passthrough",
     BINARY_DATATYPE: "binary",
     JSON_DATA: "jsondata",
     /** License Constants **/
     LICENSE_SESSION_TIMEOUT_IN_MILLIS: 14400000,
     LICENSE_BG_TO_FG_SESSION_TIMEOUT_IN_MILLIS: 1800000,
     LICENSE_KONY_OFFLINE_ACCESS_DATA: "konyOfflineAccessData",
     /** SSO Constants **/
     DW_SSO_TOKEN_KEY: "ssoAuth",
     SSO_TOKEN_KEY: "ssoTokenKey",
     SSO_SECRET_KEY: "ssoSecretKey",
     /** Encryption Constants **/
     ENCRYPTION_ALGO_AES: "aes"
 };
 if (typeof(kony.sdk) === "undefined") {
     kony.sdk = {};
 }
 if (typeof(kony.sdk.error) === "undefined") {
     kony.sdk.error = {};
 }
 kony.sdk.error.getAuthErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getAuthErrObj");
     if (errResponse && errResponse.httpresponse) {
         delete errResponse.httpresponse;
     }
     if (errResponse && errResponse[kony.sdk.constants.MF_ERROR_MSG]) {
         errResponse["message"] = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         delete errResponse.errmsg;
     }
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse["message"];
         var details = errResponse["details"];
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, "");
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getNullClaimsTokenErrObj = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getNullClaimsTokenErrObj");
     var errorObj = {};
     errorObj.opstatus = kony.sdk.errorcodes.cliams_token_null
     errorObj.message = kony.sdk.errormessages.cliams_token_null
     errorObj.details = {};
     errorObj.mfcode = "";
     return errorObj;
 }
 kony.sdk.error.getIdentitySessionInactiveErrObj = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIdentitySessionInactiveErrObj");
     var errorObj = {};
     errorObj.opstatus = kony.sdk.errorcodes.identity_session_inactive
     errorObj.message = kony.sdk.errormessages.identity_session_inactive
     errorObj.details = {};
     errorObj.mfcode = "";
     return errorObj;
 }
 kony.sdk.error.getNullRefreshTokenErrObj = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getNullRefreshTokenErrObj");
     var errorObj = {};
     errorObj.opstatus = kony.sdk.errorcodes.invalid_session_or_token_expiry
     errorObj.message = kony.sdk.errormessages.invalid_session_or_token_expiry
     errorObj.details = {};
     errorObj.mfcode = "";
     return errorObj;
 }
 kony.sdk.error.getIntegrationErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIntegrationErrObj");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForIntegration = "";
         if (service) {
             errorMessagePrefixForIntegration = "Integration Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForIntegration = "Integration Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getLogicErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getLogicErrObj");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForLogic = "";
         if (service) {
             errorMessagePrefixForLogic = "Logic Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForLogic = "Logic Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForLogic);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getMFcodeErrObj = function(mfcode, message, details, errMessagePrefix) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getMFcodeErrObj");
     var errorObj = {};
     errorObj.details = {};
     if (details) {
         errorObj.details = details;
     }
     errorObj.mfcode = mfcode;
     if (mfcode === "Auth-4") {
         if (!message) {
             message = kony.sdk.errormessages.invalid_user_credentials
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_user_credentials
         errorObj.message = errMessagePrefix + message;
     } else if (mfcode === "Auth-9") {
         if (!message) {
             message = kony.sdk.errormessages.invalid_app_credentials
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_app_credentials
         errorObj.message = errMessagePrefix + message;
     } else if (mfcode === "Auth-3") {
         if (!message) {
             message = kony.sdk.errormessages.invalid_user_app_credentials
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_user_app_credentials
         errorObj.message = errMessagePrefix + message;
     } else if ((mfcode === "Auth-5") || (mfcode === "Auth-6") || (mfcode === "Gateway-31") || (mfcode === "Gateway-33") || (mfcode === "Gateway-35") || (mfcode === "Gateway-36") || (mfcode === "Auth-46") || (mfcode === "Auth-55")) {
         errorObj.opstatus = kony.sdk.errorcodes.invalid_session_or_token_expiry
         errorObj.message = errMessagePrefix + kony.sdk.errormessages.invalid_session_or_token_expiry
     } else if (mfcode === "Auth-7" || mfcode === "Auth-27") {
         if (!message) {
             message = errMessagePrefix + kony.sdk.errormessages.invalid_user_app_services
         }
         errorObj.opstatus = kony.sdk.errorcodes.invalid_user_app_services
         errorObj.message = message;
     } else {
         errorObj.opstatus = kony.sdk.errorcodes.default_code
         errorObj.message = errMessagePrefix + kony.sdk.errormessages.default_message
     }
     return errorObj;
 }

 function getAuthErrorMessage(mfcode) {
     kony.sdk.logsdk.trace("Entering into getAuthErrorMessage");
     if (mfcode === "Auth-4") {
         return kony.sdk.errormessages.invalid_user_credentials
     } else if (mfcode === "Auth-9") {
         return kony.sdk.errormessages.invalid_app_credentials
     } else if (mfcode === "Auth-3") {
         return kony.sdk.errormessages.invalid_user_app_credentials
     } else if ((mfcode === "Auth-5") || (mfcode === "Auth-6") || (mfcode === "Gateway-31") || (mfcode === "Gateway-33") || (mfcode === "Gateway-35") || (mfcode === "Gateway-36") || (mfcode === "Auth-46") || (mfcode === "Auth-55")) {
         return kony.sdk.errormessages.invalid_session_or_token_expiry
     } else if (mfcode === "Auth-7" || mfcode === "Auth-27") {
         return kony.sdk.errormessages.invalid_user_app_services
     } else {
         return mfcode + ":" + kony.sdk.errormessages.default_message
     }
 }
 kony.sdk.error.getObjectServiceErrObj = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getObjectServiceErrObj");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForIntegration = "";
         if (service) {
             errorMessagePrefixForIntegration = "Object Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForIntegration = "Object Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 }
 kony.sdk.error.getClientErrObj = function(errCode, errMsg) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getClientErrObj");
     var errObj = new Object();
     errObj.opstatus = kony.sdk.errorcodes.clientvalidation_error_opstatus;
     errObj.errmsg = errMsg;
     errObj.errcode = errCode;
     return errObj;
 }
 kony.sdk.error.getMessagingError = function(errMsg) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getMessagingError");
     var errObj = new Object();
     errObj.opstatus = kony.sdk.errorcodes.messaging_service_fail;
     errObj.errmsg = kony.sdk.errormessages.messaging_service_fail + errMsg;
     errObj.errcode = kony.sdk.errorcodes.messaging_service_fail;
     return errObj;
 }
 kony.sdk.error.getConfigServiceErrObject = function(errResponse) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getConfigServiceErrObject");
     try {
         var mfcode = errResponse[kony.sdk.constants.MF_CODE];
         var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
         var details = errResponse["mferrmsg"];
         var service = errResponse[kony.sdk.constants.MF_SERVICE];
         if (!service) {
             service = "";
         }
         if (!details) {
             details = "";
         }
         var errorMessagePrefixForIntegration = "";
         if (service) {
             errorMessagePrefixForIntegration = "Configuration Service Request Failed for " + service + ":";
         } else {
             errorMessagePrefixForIntegration = "Configuration Service Request Failed:";
         }
         if (mfcode) {
             return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
         }
         return errResponse;
     } catch (err) {
         return errResponse;
     }
 };
 kony.sdk.error.getIntegrityErrorMessage = function(httpRequest, url) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIntegrityErrorMessage");
     var errorMessage = {};
     errorMessage.httpresponse = {};
     errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.integrity_check_failed;
     errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.integrity_check_failed;
     errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.integrity_check_failed;
     errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = httpRequest.status.toString();
     errorMessage.httpresponse["response"] = httpRequest.response;
     errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
     errorMessage.httpresponse.url = url;
     errorMessage.httpresponse.responsecode = httpRequest.status.toString();
     return errorMessage;
 };
 kony.sdk.error.getOperationFailedErrorMessage = function(httpRequest, url) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.error.getOperationFailedErrorMessage");
     var errorMessage = {};
     errorMessage[kony.sdk.constants.MF_OPSTATUS] = httpRequest.response.opstatus;
     errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.server_operation_failed;
     errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.server_operation_failed;
     errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = httpRequest.status.toString();
     var httpResponse = {};
     httpResponse.response = httpRequest.response;
     httpResponse.headers = httpRequest.getAllResponseHeaders();
     httpResponse.responsecode = httpRequest.status.toString();
     httpResponse.url = url;
     errorMessage.httpResponse = httpResponse;
     return errorMessage;
 };
 if (typeof(kony.sdk) === "undefined") {
     kony.sdk = {};
 }
 if (typeof(kony.sdk.errorcodes) === "undefined") {
     kony.sdk.errorcodes = {};
 }
 if (typeof(kony.sdk.errormessages) === "undefined") {
     kony.sdk.errormessages = {};
 }
 kony.sdk.errorcodes.invalid_user_credentials = 101;
 kony.sdk.errormessages.invalid_user_credentials = "Invalid User Credentials.";
 kony.sdk.errorcodes.invalid_app_credentials = 102;
 kony.sdk.errormessages.invalid_app_credentials = "Invalid App Credentials.";
 kony.sdk.errorcodes.invalid_user_app_credentials = 103;
 kony.sdk.errormessages.invalid_user_app_credentials = "Invalid User/App Credentials.";
 kony.sdk.errorcodes.invalid_session_or_token_expiry = 104;
 kony.sdk.errormessages.invalid_session_or_token_expiry = "Session/Token got invalidated in the backend.Please login.";
 kony.sdk.errorcodes.invalid_user_app_services = 105;
 kony.sdk.errormessages.invalid_user_app_services = "Invalid provider in appServices.";
 kony.sdk.errorcodes.cliams_token_null = 106;
 kony.sdk.errormessages.cliams_token_null = "Claims Token is Unavialable";
 kony.sdk.errorcodes.identity_session_inactive = 107;
 kony.sdk.errormessages.identity_session_inactive = "Identity Provider's sessions is not active. Please login";
 kony.sdk.errorcodes.default_code = 100;
 kony.sdk.errormessages.default_message = "UnhandledMFcode";
 kony.sdk.errorcodes.unknown_error_code = 1000;
 kony.sdk.errormessages.unknown_error_message = "An unknown error has occured";
 kony.sdk.errorcodes.connectivity_error_code = 1011;
 kony.sdk.errormessages.connectivity_error_message = "An error occurred while making the request. Please check device connectivity, server url and request parameters";
 kony.sdk.errorcodes.invalid_json_code = 1013;
 kony.sdk.errormessages.invalid_json_message = "Invalid Json response was returned";
 kony.sdk.errorcodes.request_timed_out_code = 1014;
 kony.sdk.errormessages.request_timed_out_message = "Request to server has timed out";
 kony.sdk.errorcodes.offline_auth_failed = 1015;
 kony.sdk.errormessages.offline_auth_failed = "Offline Authentication failed, User should atleast login once when network connectivity is available.";
 kony.sdk.errorcodes.servicedoc_unavailable = 1016;
 kony.sdk.errormessages.servicedoc_unavailable = "MBAAS app is not initialized properly. Service document is unavailable.";
 kony.sdk.errorcodes.transient_login_fail = 1017;
 kony.sdk.errormessages.transient_login_fail = "Transient Login failed, Previous Identity Token expired in backend.";
 kony.sdk.errorcodes.messaging_service_fail = 1018;
 kony.sdk.errormessages.messaging_service_fail = "Failure in Messaging Service. ";
 kony.sdk.errorcodes.integrity_check_failed = 1019;
 kony.sdk.errormessages.integrity_check_failed = "Http message Body Integrity Check failed.";
 kony.sdk.errorcodes.invalid_security_key = 1023;
 kony.sdk.errormessages.invalid_security_key = "Security key should be a non empty string.";
 kony.sdk.errorcodes.server_operation_failed = 1020;
 kony.sdk.errormessages.server_operation_failed = "Operation Failed on server";
 kony.sdk.errorcodes.populating_template_failed = 1021;
 kony.sdk.errormessages.populating_template_failed = "Template population failed, template parameters are invalid or template is malformed";
 kony.sdk.errorcodes.service_unavailable = 1022;
 kony.sdk.errormessages.service_unavailable_message = "Service unavailable or cannot connect to host";
 kony.sdk.errorcodes.connection_timeout = 1023;
 kony.sdk.errormessages.connection_timeout_message = "Network call failed due to connection timeout";
 kony.sdk.errorcodes.clientvalidation_error_opstatus = 112233;
 //Invaild API's for phonegap and plain-js
 kony.sdk.errorcodes.invalid_api = 7000;
 kony.sdk.errormessages.invalid_api = "Invalid Operation name, Operation Failed.";
 //Object Service Error Messages
 kony.sdk.errorcodes.invalid_dataobject_instance = 90001;
 kony.sdk.errormessages.invalid_dataobject_instance = "Provided dataobject is invalid and should be instance of kony.sdk.dto.DataObject";
 kony.sdk.errorcodes.primarykey_unavailable = 90002;
 kony.sdk.errormessages.primarykey_unavailable = "Primary Keys missing, Operation Failed";
 kony.sdk.errorcodes.null_or_undefined = 90003;
 kony.sdk.errormessages.null_or_undefined = " cannot be null or undefined";
 kony.sdk.errorcodes.transaction_failed = 90004;
 kony.sdk.errormessages.transaction_failed = "Some error occurred, Operation Failed";
 kony.sdk.errorcodes.norecords_to_delete = 90005;
 kony.sdk.errormessages.norecords_to_delete = "No records deleted with the specified criteria";
 kony.sdk.errorcodes.invalid_queryparams_instance = 90006;
 kony.sdk.errormessages.invalid_queryparams_instance = "Provided queryParams is invalid and should be a json object";
 kony.sdk.errorcodes.invalid_params_instance = 90007;
 kony.sdk.errormessages.invalid_params_instance = "Provided params are invalid";
 kony.sdk.errorcodes.invalid_object = 90008;
 kony.sdk.errormessages.invalid_object = "Invalid object name, Operation Failed.";
 kony.sdk.errorcodes.invalid_blob = 90009;
 kony.sdk.errormessages.invalid_blob = "Failed to read from binary file, either the file does not exist or invalid";
 kony.sdk.errorConstants = {
     INIT_FAILURE: "INIT_FAILURE",
     DATA_STORE_EXCEPTION: "DATASTORE_FAILURE",
     AUTH_FAILURE: "AUTH_FAILURE",
     INTEGRATION_FAILURE: "INTEGRATION_FAILURE",
     MESSAGING_FAILURE: "MESSAGING_FAILURE",
     SYNC_FAILURE: "SYNC_FAILURE",
     METRICS_FAILURE: "METRICS_FAILURE",
     MISC_FAILURE: "MISCELLANEOUS_FAILURE",
     OBJECT_FAILURE: "OBJECT_FAILURE",
     LOGIC_SERVICE_FAILURE: "LOGIC_SERVICE_FAILURE",
     SYNC_V2_FAILURE: "SYNC_V2_FAILURE",
     CONFIGURATION_URL_FAILURE: "CONFIGURATION_URL_FAILURE",
     CONFIGURATION_FAILURE: "CONFIGURATION_FAILURE",
     INTEGRITY_FAILURE: "INTEGRITY_FAILURE",
     INVALID_API_FAILURE: "INVALID_API_FAILURE"
 };
 /**
  * Method to create the Identity service instance with the provided provider name.
  * @param {string} providerName - Name of the provider
  * @returns {IdentityService} Identity service instance
  */
 kony.sdk.offline = kony.sdk.offline || {};
 kony.sdk.sso = kony.sdk.sso || {};
 kony.sdk.isSSOLoginSuccess = kony.sdk.isSSOLoginSuccess || true;
 kony.sdk.prototype.getIdentityService = function(providerName) {
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getIdentityService");
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Identity service.");
     }
     var provider = null;
     if (providerName) {
         if (this.login != null) {
             for (var i = 0; i < this.login.length; i++) {
                 var rec = this.login[i];
                 if ((rec.alias && rec.alias.toUpperCase() === providerName.toUpperCase()) || (rec.prov.toUpperCase() === providerName.toUpperCase())) {
                     provider = new IdentityService(this, rec);
                     break;
                 }
             }
             if (provider === null) {
                 throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Invalid providerName");
             }
             //TODO: what if the providerName is not passed by the user? 
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getIdentityService");
             kony.sdk.logsdk.debug("### auth:: returning authService for providerName = " + provider.getProviderName());
             return provider;
         }
     } else {
         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Invalid providerName");
     }
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Identity service instance for handling login/logout calls.
  */
 function IdentityService(konyRef, rec) {
     kony.sdk.logsdk.perf("Executing IdentityService");
     var networkProvider = new konyNetworkProvider();
     var dataStore = new konyDataStore();
     var serviceObj = rec;
     konyRef.rec = rec;
     var is_mfa_enabled = false;
     if (!kony.sdk.isNullOrUndefined(rec[kony.sdk.constants.IS_MFA_ENABLED])) {
         is_mfa_enabled = rec[kony.sdk.constants.IS_MFA_ENABLED];
     }
     var mfa_meta = {};
     if (!kony.sdk.isNullOrUndefined(rec[kony.sdk.constants.MFA_META])) {
         mfa_meta = rec[kony.sdk.constants.MFA_META];
     }
     var mainRef = konyRef.mainRef;
     var user_attributes = {};
     var offlineEnabled = false;
     var persistToken = false;
     if (serviceObj === undefined || serviceObj.prov == undefined || serviceObj.type == undefined) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "Invalid service url and service type");
     }
     var _type = serviceObj.type;
     var _serviceUrl = stripTrailingCharacter(serviceObj.url, "/");
     var _providerName = serviceObj.prov;
     kony.sdk.logsdk.debug("### AuthService:: initialized for provider " + _providerName + " with type " + _type);

     function isLoggedIn() {
         if (kony.sdk.getCurrentInstance() && kony.sdk.getCurrentInstance().tokens && kony.sdk.getCurrentInstance().tokens.hasOwnProperty(_providerName) && !kony.sdk.isNullOrUndefined(kony.sdk.getCurrentInstance().tokens[_providerName]) && Object.keys(kony.sdk.getCurrentInstance().tokens[_providerName]).length !== 0) {
             return true;
         }
         return false;
     }
     var dsKey = _serviceUrl + "::" + _providerName + "::" + _type + "::RAW";

     function resetAllCurrentTokens(konyRef, _providerName) {
         kony.sdk.resetProviderKeys(konyRef, _providerName);
     }
     /**
      * Login with the given credentials asynchronously and executes the given callback.
      * @param {object} options - User name and password
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.login = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf("Executing Login");
         var continueOnRefreshError = true;
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
         kony.sdk.logsdk.debug("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);
         if (typeof(options) == 'undefined') {
             throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required number of arguments to login function");
         }
         if (options && options["loginOptions"] && options["loginOptions"]["continueOnRefreshError"] === false) {
             continueOnRefreshError = false;
         }
         if (options && options["loginOptions"]) {
             offlineEnabled = options["loginOptions"]["isOfflineEnabled"] || false;
             kony.sdk.offline.isOfflineEnabled = kony.sdk.offline.isOfflineEnabled || offlineEnabled;
             kony.sdk.sso.isSSOEnabled = options["loginOptions"]["isSSOEnabled"] || false;
         } else {
             kony.sdk.sso.isSSOEnabled = false;
         }

         function invokeAjaxCall(url, params, headers) {
             if (!headers) {
                 headers = {};
             }
             kony.sdk.util.populateAuthorizationHeaderForLogin(headers, _providerName);
             headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
             headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
             headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
             headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             populateHeaderWithFabricAppVersion(headers);
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### login::error while parsing metrics payload" + error);
                     }
                 }
             }
             var endPointUrl = null;
             if (_type === "anonymous") {
                 endPointUrl = _serviceUrl + url;
             } else {
                 endPointUrl = _serviceUrl + url + "?provider=" + _providerName;
                 params["provider"] = _providerName;
             }
             if (options && options["include_profile"]) {
                 params["include_profile"] = params["include_profile"] ? params["include_profile"] : options["include_profile"];
             }
             var networkOptions = {};
             if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
                 networkOptions["httpRequestOptions"] = options["httpRequestOptions"];
             }
             if (options && options["xmlHttpRequestOptions"] && options["xmlHttpRequestOptions"] instanceof Object) {
                 networkOptions["xmlHttpRequestOptions"] = options["xmlHttpRequestOptions"];
             }
             networkProvider.post(endPointUrl, params, headers, function(data) {
                 var response = processLoginSuccessResponse(data, konyRef, false);
                 if (!kony.sdk.isNullOrUndefined(response.mfa_response) && !kony.sdk.isNullOrUndefined(response.mfa_response[kony.sdk.constants.IS_MFA_ENABLED])) {
                     is_mfa_enabled = response.mfa_response[kony.sdk.constants.IS_MFA_ENABLED];
                     mfa_meta = response.mfa_response[kony.sdk.constants.MFA_META];
                     delete response.mfa_response;
                 }

                 function serviceDocCallback() {
                     kony.sdk.verifyAndCallClosure(successCallback, response);
                 }
                 getLatestServiceDocIfAvailable(data, serviceDocCallback);
             }, function(data) {
                 processLoginErrorResponse(data, konyRef, true, failureCallback)
             }, null, networkOptions);
         }

         function loginHelper(url, params, headers, isError) {
             if (isError) {
                 var error = {};
                 err.message = "Login Failed";
                 err.opstatus = kony.sdk.errorcodes.transient_login_fail;
                 err.code = (params && params.error) ? params.error : "";
                 kony.sdk.verifyAndCallClosure(failureCallback, err);
                 return;
             }
             kony.sdk.logsdk.trace("Entering loginHelper");
             if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !konyRef.isAnonymousProvider) {
                 kony.sdk.claimsRefresh(function(res) {
                     invokeAjaxCall(url, params, headers)
                 }, function(err) {
                     if (continueOnRefreshError) {
                         kony.sdk.logsdk.error("### AuthService::login claimsRefresh failed, performing force login");
                         invokeAjaxCall(url, params, headers);
                     } else {
                         kony.sdk.logsdk.error("### AuthService::login claimsRefresh failed, invoking failurecallback");
                         err.message = kony.sdk.errormessages.transient_login_fail;
                         err.opstatus = kony.sdk.errorcodes.transient_login_fail;
                         kony.sdk.verifyAndCallClosure(failureCallback, err);
                     }
                 })
             } else {
                 kony.sdk.logsdk.info("### AuthService::login Claims token unavailable, performing regular login");
                 invokeAjaxCall(url, params, headers);
             }
         }
         /**
          * Login once the deeplink redirection is done. .
          * @param {map} options
          */
         function loginForDeeplink(options) {
             kony.sdk.logsdk.trace("Entering loginForDeeplink");
             if (options) {
                 var code = options[kony.sdk.constants.DEEPLINK_VALID_PARAM];
                 var urlType = options["urlType"];
                 try {
                     kony.sdk.logsdk.debug("### AuthService::login received authorization code");
                     loginHelper("/" + urlType + "/" + "token", {
                         code: code
                     }, {});
                 } catch (err) {
                     kony.sdk.logsdk.error("exception ::" + err);
                     failureCallback();
                 }
             }
         }
         if (_type === "anonymous") {
             konyRef.isAnonymousProvider = true;
             kony.sdk.logsdk.info("### AuthService::login Adapter type is anonymous");
             loginHelper("/login", {}, {});
         } else if (_type == "basic") {
             var mandatory_fields = ["userid", "password"];
             if (kony.sdk.sso.isSSOEnabled === false) {
                 if (serviceObj.mandatory_fields && kony.sdk.isArray(serviceObj.mandatory_fields)) {
                     mandatory_fields = serviceObj.mandatory_fields;
                 }
                 for (var i = 0; i < mandatory_fields.length; ++i) {
                     if (kony.sdk.isNullOrUndefined(options[mandatory_fields[i]])) {
                         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, " Require " + mandatory_fields[i]);
                     }
                 }
             }
             var payload = {};
             var encryptedStorage = {};
             if (options != null && options != undefined) {
                 for (var option in options) {
                     payload[option] = options[option];
                 }
             }
             payload["provider"] = _providerName;
             kony.sdk.logsdk.info("### AuthService::login Adapter type is basic");
             loginHelper("/login", payload, {});
         } else {
             if (options && options.userid && options.password) {
                 var payload = {};
                 for (var option in options) {
                     payload[option] = options[option];
                 }
                 payload["provider"] = _providerName;
                 loginHelper("/login", payload);
             } else {
                 kony.sdk.logsdk.debug("### AuthService::login Adapter type is " + _type);
                 if (kony.sdk.isSSOLoginSuccess && kony.sdk.sso.isSSOEnabled == true && kony.sdk.util.getSSOToken() != null && kony.sdk.util.getSSOToken() != "" && kony.sdk.util.getSSOToken() != undefined) {
                     if (_type === "oauth2") {
                         loginHelper("/oauth2/token", {}, {});
                     } else if (_type === "saml") {
                         loginHelper("/saml/token", {}, {});
                     } else {
                         loginHelper("/login", {}, {});
                     }
                 } else {
                     //To provide backward compatibility, if MF is an older it will not have the changes for blocking the popup or opening the login url in the native browser.
                     //Identity will add a new tuple in the service doc "identity_meta". SDK will validate the compatibility with the existance of serviceDoc["identity_meta"][<priovider_name>]["success_url"]
                     var isMFVersionCompatible = false;
                     var oauthOptions = {};
                     if (options && options["loginOptions"] && options["loginOptions"]["customQueryParamsForOAuth"] && options["loginOptions"]["customQueryParamsForOAuth"] instanceof Object) {
                         oauthOptions["customQueryParamsForOAuth"] = options["loginOptions"]["customQueryParamsForOAuth"];
                     }
                     if (mainRef && mainRef.config && mainRef.config.identity_meta && mainRef.config.identity_meta[_providerName] && mainRef.config.identity_meta[_providerName].success_url) {
                         isMFVersionCompatible = true;
                     }
                     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PLAIN_JS) {
                         //Case to handle plain-js OAuth flow.
                         // Popup needs to be blocked for oauth2 type & redirect to the url "success_url" if provided in query params else the default one declared in the MF application.
                         if (options && options["noPopup"]) {
                             oauthOptions["noPopup"] = true
                         }
                         if (options && options[kony.sdk.constants.DEEPLINK_VALID_PARAM] && options["urlType"]) {
                             //Validating the identity service once after deeplink is redirected. Params "code" & "urlType" are mandatory and are used to distinguish the request.
                             loginForDeeplink(options);
                         } else {
                             oauthOptions["appSecret"] = mainRef.appSecret;
                             oauthOptions["serviceDoc"] = mainRef.config;
                             if (options && options["include_profile"]) {
                                 oauthOptions["include_profile"] = options["include_profile"]
                             }
                             OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, loginHelper, _type, oauthOptions, isMFVersionCompatible);
                         }
                     } else {
                         if (kony.sdk.util.hasBrowserWidget(options)) {
                             //Case to handle OAuth for IDE
                             oauthOptions[kony.sdk.constants.BROWSER_WIDGET] = options[kony.sdk.constants.BROWSER_WIDGET];
                         } else {
                             //Default case if param browserWidget and UseDeviceBrowser not present. We create one browser widget and open the url in it.
                             if (options && options["UseDeviceBrowser"]) {
                                 //Validating to check the existence of param "UseDeviceBrowser".
                                 // if found login url will be opened in device native broser, else in browser widget.
                                 oauthOptions["UseDeviceBrowser"] = options["UseDeviceBrowser"];
                             }
                             if (options && options[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL]) {
                                 //Validating to check the existence of param "success_url".
                                 // if found after login success we will redirect to the url specified in param "success_url".
                                 var success_url = options[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL];
                                 //Encoding is being done specifically for android because, in android kony.application.openUrl is not
                                 // opening the url without encoding where as in ios its encoding and opening.
                                 if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_ANDROID) {
                                     //decoding and encoding, to handle the case where in the user himself is giving us the encoded value.
                                     success_url = encodeURIComponent(decodeURIComponent(options[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL]));
                                 }
                                 oauthOptions[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL] = success_url;
                             }
                         }
                         if (options && kony.sdk.util.isValidString(options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL])) {
                             oauthOptions[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL] = options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL];
                         }
                         OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, loginHelper, _type, oauthOptions, isMFVersionCompatible);
                     }
                 }
             }
         }
     };
     /**
      * validateMfa validates the multi factor authentication parameters
      * @param {object} mfaParams- 2nd factor authentic param
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.validateMfa = function(mfaParams, successCallback, failureCallback, options) {
         kony.sdk.logsdk.debug("AuthService::validateMfa Invoked login for provider " + _providerName + " of type " + _type);

         function performValidateCall(urlMFA, params) {
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
             headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
             headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
             headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
             headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             populateHeaderWithFabricAppVersion(headers);
             if (konyRef.reportingheaders_allowed) {
                 headers[kony.sdk.constants.REPORTING_HEADER] = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
             }
             var endPointUrl = _serviceUrl + urlMFA + "?provider=" + _providerName;
             var networkOptions = kony.sdk.util.checkAndFetchNetworkProviderOptions(options);
             networkProvider.post(endPointUrl, params, headers, function(data) {
                 var response = processLoginSuccessResponse(data, konyRef, false);
                 kony.sdk.verifyAndCallClosure(successCallback, response);
             }, function(data) {
                 processLoginErrorResponse(data, konyRef, true, failureCallback)
             }, null, networkOptions);
         }
         if (kony.sdk.isNullOrUndefined(mfaParams)) {
             throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, " mfaParams are null");
         }
         var payload = {};
         payload["provider"] = _providerName;
         for (var key in mfaParams) {
             payload[key] = mfaParams[key];
         }
         if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !konyRef.isAnonymousProvider) {
             kony.sdk.claimsRefresh(function(res) {
                 performValidateCall("/login/mfa", payload)
             }, function(err) {
                 kony.sdk.logsdk.error("AuthService::validateMfa claimsRefresh failed, invoking failurecallback");
                 err.message = kony.sdk.errormessages.transient_login_fail;
                 err.opstatus = kony.sdk.errorcodes.transient_login_fail;
                 kony.sdk.verifyAndCallClosure(failureCallback, err);
             })
         } else {
             kony.sdk.logsdk.error("AuthService::validateMfa Claims token unavailable, please login");
             err.message = kony.sdk.errormessages.offline_auth_failed;
             err.opstatus = kony.sdk.errorcodes.offline_auth_failedl;
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }
     };
     /**
      * getMfaDetails functions lets the user to know whether 2factor security is enabled
      * @return {boolean}
      **/
     this.getMfaDetails = function() {
         var mfaDetails = {};
         mfaDetails[kony.sdk.constants.IS_MFA_ENABLED] = is_mfa_enabled;
         mfaDetails[kony.sdk.constants.MFA_META] = mfa_meta;
         return mfaDetails;
     };
     var processMultipleProvidersResponse = function(data, providerName) {
         if (data && data.profiles) {
             konyRef.isAnonymousProvider = false;
             for (var provider in data.profiles) {
                 if (!konyRef.tokens[provider]) {
                     konyRef.tokens[provider] = {};
                 }
                 konyRef.tokens[provider].profile = data.profiles[provider];
             }
         } else if (data && providerName && data.profile) {
             konyRef.isAnonymousProvider = false;
             konyRef.tokens[providerName].profile = data.profile;
         }
         if (data && data.provider_tokens) {
             for (var provider in data.provider_tokens) {
                 if (!konyRef.tokens[provider]) {
                     konyRef.tokens[provider] = {};
                 }
                 if (!konyRef.tokens[provider].provider_token) {
                     konyRef.tokens[provider].provider_token = {}
                 }
                 konyRef.tokens[provider].provider_token.value = data.provider_tokens[provider];
             }
         }
         if (data && providerName && data.provider_token) {
             konyRef.tokens[providerName].provider_token = data.provider_token;
         }
         konyRef.currentClaimToken = data.claims_token.value;
         konyRef.claimTokenExpiry = data.claims_token.exp;
         konyRef.currentRefreshToken = data.refresh_token;
         if (!konyRef.isAnonymousProvider && !kony.sdk.isNullOrUndefined(data.claims_token[kony.sdk.constants.IS_MFA_ENABLED])) {
             for (var providerPosition = 0; providerPosition < konyRef.login.length; providerPosition++) {
                 if (konyRef.login[providerPosition].prov === providerName) {
                     //we are doing this so that if user makes anoher identity object with same provider , is_mfa_enabled value can be available
                     konyRef.login[providerPosition][kony.sdk.constants.IS_MFA_ENABLED] = data.claims_token[kony.sdk.constants.IS_MFA_ENABLED];
                     konyRef.login[providerPosition][kony.sdk.constants.MFA_META] = data.claims_token[kony.sdk.constants.MFA_META];
                     var result = {};
                     result[kony.sdk.constants.IS_MFA_ENABLED] = data.claims_token[kony.sdk.constants.IS_MFA_ENABLED];
                     result[kony.sdk.constants.MFA_META] = data.claims_token[kony.sdk.constants.MFA_META];
                     return result;
                 }
             }
         }
     };
     var processLoginSuccessResponse = function(data, konyRef, isAsync, callBack) {
         var response = {};
         kony.sdk.logsdk.perf("Executing processLoginSuccessResponse");
         data = kony.sdk.formatSuccessResponse(data);
         if (_type !== "anonymous" && !konyRef.tokens[_providerName]) {
             konyRef.tokens[_providerName] = {};
         }
         kony.sdk.logsdk.info("### AuthService::login successful. Retrieved Data::");
         var result = processMultipleProvidersResponse(data, _providerName)
         if (!kony.sdk.isNullOrUndefined(result) && !kony.sdk.isNullOrUndefined(result[kony.sdk.constants.IS_MFA_ENABLED])) {
             response.mfa_response = result;
         }
         kony.sdk.logsdk.info("### AuthService::login extracted token. Calling success callback");
         if (kony.sdk.sso.isSSOEnabled === true) {
             if (data.sso_token) {
                 var isSSOSaved = kony.sdk.util.saveSSOToken(kony.sdk.util.addOrUpdateSSOTokenWithProvider(data.sso_token, _providerName));
                 if (isSSOSaved === true) {
                     kony.sdk.isSSOLoginSuccess = true;
                     kony.sdk.logsdk.info("### SSOLoginService::SSOToken being saved successfully.");
                 } else {
                     kony.sdk.logsdk.info("### SSOLoginService::Failed to save SSOToken.This might result in failure of corresponding sso Logins. Please check the configuration params");
                 }
             } else {
                 kony.sdk.logsdk.info("### SSOLoginService::Unable to fetch sso token.");
             }
         }
         if (data.profile && data.profile != undefined && data.profile.user_attributes != undefined) {
             user_attributes = data.profile.user_attributes;
         }
         if (data.profile) {
             kony.sdk.overrideUserId(data.profile.userid);
         }
         if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
             //We store the user credentials and the success auth response only on successful online login.
             if (kony.sdk.offline.isOfflineEnabled === true) {
                 if (kony.sdk.isNetworkAvailable() && offlineEnabled && _type === "basic") {
                     kony.sdk.offline.updateSuccessUserCredentials(_providerName);
                 }
                 kony.sdk.offline.saveUserAuthInformation("authResponse", data);
             }
         }
         kony.logger.setClaimsToken();
         if (!isAsync) {
             return response;
         } else if (callBack) {
             delete response.mfa_response;
             kony.sdk.verifyAndCallClosure(callBack, response);
         }
     };
     var processLoginErrorResponse = function(data, konyRef, isAsync, callBack) {
         kony.sdk.logsdk.perf("Executing processLoginErrorResponse");
         kony.sdk.logsdk.info("### AuthService::login Calling failure callback");
         /*resetting all the token in case of error */
         resetAllCurrentTokens(konyRef, _providerName);
         if (kony.sdk.sso.isSSOEnabled === true) {
             if (data.mfcode == "Auth-55") {
                 kony.sdk.util.deleteSSOToken();
             }
             kony.sdk.isSSOLoginSuccess = false;
         }
         if (!isAsync) {
             return kony.sdk.error.getAuthErrObj(data);
         } else if (callBack) {
             callBack(kony.sdk.error.getAuthErrObj(data));
         }
     };
     /**
      * Login anonymous with the given credentials synchronously and executes the given callback.
      * @param {object} options - User name and password
      */
     this.anonymousLoginSync = function(options) {
         kony.sdk.logsdk.perf("Executing anonymousLoginSync");
         konyRef.isAnonymousProvider = false;
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
         kony.sdk.logsdk.debug("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);
         if (typeof(options) == 'undefined') {
             throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required number of arguments to login function");
         }

         function invokeAjaxCall(url, params, headers) {
             if (!headers) {
                 headers = {};
             }
             headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### anonymousLoginSync::error while parsing metrics payload" + error);
                     }
                 }
             }
             var endPointUrl = null;
             if (_type === "anonymous") {
                 endPointUrl = _serviceUrl + url;
             } else {
                 endPointUrl = _serviceUrl + url + "?provider=" + _providerName;
                 params["provider"] = _providerName;
             }
             var data = networkProvider.postSync(endPointUrl, params, headers);
             if (data.opstatus == 0) {
                 return processLoginSuccessResponse(data, konyRef, false);
             } else {
                 return processLoginErrorResponse(data, konyRef, false);
             }
         }
         konyRef.isAnonymousProvider = true;
         kony.sdk.logsdk.info("### AuthService::login Adapter type is anonymous");
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         var result = invokeAjaxCall("/login", {}, headers);
         kony.sdk.logsdk.perf("Executing Finished anonymousLoginSync");
         return result;
     };
     /**
      * Logout and executes the given callback.
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {object} options - additional options for logout
      */
     this.logout = function(successCallback, failureCallback, options) {
         kony.sdk.logsdk.trace("Entering logout");

         function logoutHandler() {
             _logout(successCallback, failureCallback, options);
         }
         if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS) {
             //if the user logged in using offline logout
             if (offlineEnabled == true && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && _type === "basic" && !kony.sdk.isNetworkAvailable()) {
                 logoutHandler();
             } else {
                 kony.sdk.claimsRefresh(logoutHandler, failureCallback);
             }
         } else {
             kony.sdk.claimsRefresh(logoutHandler, failureCallback);
         }
     };

     function _logout(successCallback, failureCallback, options) {
         function invokeLogoutHelper(formData, invokeLogoutSuccess, invokeLogoutFailure) {
             var claimsTokenValue = null;
             var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("logout_" + _providerName);
             if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
                 claimsTokenValue = konyRef.currentClaimToken;
             }
             formdata.provider = _providerName;
             var url = "";
             if (_type == "oauth2" && kony.sdk.getSdkType() == kony.sdk.constants.SDK_TYPE_IDE) {
                 url = _serviceUrl + "/oauth2/logout?provider=" + _providerName;
             } else {
                 url = _serviceUrl + "/logout?provider=" + _providerName;
             }
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = claimsTokenValue;
             headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = "*/*";
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### login::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.post(url, formdata, headers, function(data) {
                 kony.sdk.logsdk.info("AuthService::logout successfully logged out. Calling success callback");

                 function serviceDocCallback() {
                     logoutSuccess(data);
                     return;
                 }
                 getLatestServiceDocIfAvailable(data, serviceDocCallback);
             }, function(err) {
                 kony.sdk.logsdk.error("### AuthService::logout logged out Failed. Calling failure callback");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(err));
             });
         }

         function logoutSuccess(data) {
             kony.sdk.logsdk.trace("Entering logoutSuccess");
             data = kony.sdk.formatSuccessResponse(data);
             delete konyRef.tokens[_providerName];
             //reset all current keys
             kony.sdk.resetCurrentKeys(konyRef, _providerName);
             //processing multiple profiles
             if (data && data.claims_token) {
                 processMultipleProvidersResponse(data);
                 konyRef.isAnonymousProvider = false;
             }
             // slo : Single Logout out
             //deleting all SSO token as the backend session has expired.
             if (slo === true || slo === "true") {
                 kony.sdk.util.deleteSSOToken();
             } else if (!kony.sdk.util.isNullOrEmptyString(kony.sdk.util.getSSOTokenForProvider(_providerName))) {
                 //removing SSO token for the provider.
                 kony.sdk.util.deleteSSOTokenForProvider(_providerName);
             }
             kony.sdk.verifyAndCallClosure(successCallback, {});
         }
         kony.sdk.logsdk.debug("### AuthService::logout invoked on provider " + _providerName + " of type " + _type);
         var slo = false;
         if (!kony.sdk.isNullOrUndefined(options) && (options["slo"] === true || options["slo"] === false)) {
             slo = options["slo"];
         }
         var formdata = {};
         formdata = {
             "slo": slo
         };
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else if ((_type == "oauth2" || _type == "saml") && kony.sdk.getSdkType() == kony.sdk.constants.SDK_TYPE_IDE) {
             var callback_invoke = true;
             var oauth_status;

             function oAuthCallback(status) {
                 oauth_status = status;
                 //Workaround to get around redirects
                 if (callback_invoke) {
                     callback_invoke = false;
                     kony.timer.schedule("oAuthCallbackHandle", function() {
                         if (oauth_status) invokeLogoutHelper(formdata, logoutSuccess, failureCallback);
                         else kony.sdk.verifyAndCallClosure(failureCallback, {});
                     }, 3, false);
                 }
             }
             var oauthOptions = {};
             oauthOptions["logout"] = true;
             oauthOptions["slo"] = slo;
             if (kony.sdk.util.hasBrowserWidget(options)) {
                 oauthOptions[kony.sdk.constants.BROWSER_WIDGET] = options[kony.sdk.constants.BROWSER_WIDGET];
             }
             OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, oAuthCallback, _type, oauthOptions);
         } else {
             if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS) {
                 //if the user logged in using offline login
                 if (kony.sdk.offline.isOfflineEnabled == true && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && _type === "basic" && !kony.sdk.isNetworkAvailable()) {
                     kony.sdk.logsdk.info("AuthService::offline logout successfully logged out. Calling success callback");
                     logoutSuccess();
                     return;
                 }
             }
             invokeLogoutHelper(formdata, logoutSuccess, failureCallback);
         }
     }
     /**
      * Fetch the backend datasource token.
      * @param {boolean} fromserver - Flag to force fetch from server only.
      * @param {object} options - Options
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.getBackendToken = function(fromserver, options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf("Executing getBackendToken");

         function _claimsRefreshSuccess(token) {
             kony.sdk.logsdk.perf("Executing Finished getBackendToken : status success");
             kony.sdk.logsdk.trace("Entering _claimsRefreshSuccess with valid token");
             processMultipleProvidersResponse(token);
             //konyRef.currentBackEndToken = token.provider_token;
             //if offline login enabled then updating the backend token in the store
             if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_WINDOWS && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
                 if (kony.sdk.offline.isOfflineEnabled && kony.sdk.offline.isOfflineEnabled == true) {
                     kony.sdk.offline.updateAuthToken(token);
                 }
             }
             kony.sdk.verifyAndCallClosure(successCallback, konyRef.tokens[_providerName].provider_token);
         }

         function _claimsRefreshFailure(error) {
             kony.sdk.logsdk.perf("Executing Finished getBackendToken : status failure");
             kony.sdk.logsdk.trace("Entering _claimsRefreshFailure");
             kony.sdk.logsdk.info("### AuthService::getBackendToken fetching refresh failed. Calling failure callback");
             // konyRef.tokens[_providerName] = null;
             // konyRef.currentBackEndToken = null;
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(error));
         }
         kony.sdk.logsdk.debug("### AuthService::getBackendToken called for provider " + _providerName + " of type " + _type);
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         }
         var claimsOptions = null;
         if (options && options.refresh && options.refresh === true) {
             claimsOptions = {
                 "requestParams": {
                     "refresh": "true"
                 }
             };
         }
         if (fromserver != undefined && fromserver === true) {
             kony.sdk.logsdk.info("### AuthService::getBackendToken fromserver is enabled. Trying to login");
             _claimsRefresh(claimsOptions, _claimsRefreshSuccess, _claimsRefreshFailure);
         } else {
             if (konyRef.tokens[_providerName]) {
                 var val = konyRef.tokens[_providerName];
                 var _exp = val.provider_token.exp;
                 kony.sdk.logsdk.debug("token expiry time: " + _exp);
                 kony.sdk.logsdk.debug("Current time: " + (new Date().getTime()));
                 if (_exp && _exp < (new Date().getTime())) {
                     kony.sdk.logsdk.info("### AuthService::getBackendToken Token expired. Fetching refresh from claims api");
                     _claimsRefresh(claimsOptions, _claimsRefreshSuccess, _claimsRefreshFailure);
                 } else {
                     kony.sdk.logsdk.info("### AuthService::getBackendToken present token is valid/doesn't have expiry time. Calling success callback");
                     //konyRef.currentBackEndToken = val.provider_token;
                     kony.sdk.verifyAndCallClosure(successCallback, konyRef.tokens[_providerName].provider_token);
                 }
             } else {
                 kony.sdk.logsdk.info("### AuthService::getBackendToken failed for find info for key " + dsKey + "in database. calling failure callback");
                 kony.sdk.verifyAndCallClosure(failureCallback, null);
             }
         }
     };
     /**
      * Get profile.
      * @param {boolean} fromserver - Flag to force fetch from server only.
      * @param {function} successCallback  - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.getProfile = function(fromserver, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getProfile");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else if (fromserver && fromserver == true) {
             profileRefresh(function(token) {
                 konyRef.tokens[_providerName].profile = token;
                 kony.sdk.verifyAndCallClosure(successCallback, token);
             }, failureCallback)
         } else {
             if (konyRef.tokens[_providerName]) {
                 var val = konyRef.tokens[_providerName];
                 kony.sdk.verifyAndCallClosure(successCallback, val.profile);
             } else {
                 kony.sdk.verifyAndCallClosure(failureCallback, null);
             }
         }
     };
     /**
      * Get the provider name.
      * @returns {string} Provider name.
      */
     this.getProviderName = function() {
         return _providerName;
     };
     /**
      * Get the provider type.
      * @returns {string} Provider type.
      */
     this.getProviderType = function() {
         return _type;
     };
     /**
      * Get the generic session data type.
      * @returns {string} session data.
      */
     this.getUserData = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getUserData (Get the generic session data type)");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else {
             var userDataUrl = _serviceUrl + "/session/user_data";
             var options = {};
             options["invokedFrom"] = kony.sdk.constants.GET_USER_DATA;
             getSessionData(userDataUrl, successCallback, failureCallback, options);
         }
     };
     /**
      * Get the user attributes returned by a provider
      * @returns {string} user attributes.
      */
     this.getUserAttributes = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getUserAttributes");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else if (user_attributes && Object.keys(user_attributes).length === 0) {
             var userAttributesUrl = _serviceUrl + "/session/user_attributes?provider=" + _providerName;
             var options = {};
             options["invokedFrom"] = kony.sdk.constants.GET_USER_ATTRIBUTES;
             getSessionData(userAttributesUrl, function(res) {
                 user_attributes = res;
                 kony.sdk.verifyAndCallClosure(successCallback, user_attributes);
             }, failureCallback, options);
         } else {
             if (konyRef.currentClaimToken === null) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
             } else {
                 kony.sdk.verifyAndCallClosure(successCallback, user_attributes);
             }
         }
     };
     /**
      * Get the security attributes returned by a provider
      * @returns {string} security attributes.
      */
     this.getSecurityAttributes = function(successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering getSecurityAttributes");
         if (!isLoggedIn()) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
         } else {
             var securityAttributesUrl = _serviceUrl + "/session/security_attributes?provider=" + _providerName;
             var options = {};
             options["invokedFrom"] = kony.sdk.constants.GET_SECURITY_ATTRIBUTES;
             getSessionData(securityAttributesUrl, successCallback, failureCallback, options);
         }
     };
     /**
     	utility method to get session data
     	@private
     */
     var getSessionData = function(sessionAttributesEndPointUrl, successCallback, failureCallback, options) {
         var svcid = null;
         if (options["invokedFrom"] == kony.sdk.constants.GET_USER_ATTRIBUTES) {
             svcid = kony.sdk.constants.GET_USER_ATTRIBUTES;
         } else if (options["invokedFrom"] == kony.sdk.constants.GET_SECURITY_ATTRIBUTES) {
             svcid = kony.sdk.constants.GET_SECURITY_ATTRIBUTES;
         } else {
             svcid = kony.sdk.constants.GET_USER_DATA;
         }
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
         if (konyRef.currentClaimToken === null) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
         } else {
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### getSessionData::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.get(sessionAttributesEndPointUrl, {}, headers, function(data) {
                 data = kony.sdk.formatSuccessResponse(data);
                 kony.sdk.verifyAndCallClosure(successCallback, data);
             }, function(err) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(err));
             });
         }
     };
     /**
      * Method to refresh the claims token.
      * @private
      */
     var _claimsRefresh = function(options, success, failure) {
         kony.sdk.logsdk.debug("### AuthService::_claimsRefresh fetching claims from server for provider " + _providerName);
         var refreshToken = null;
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(kony.sdk.constants.GET_BACKEND_TOKEN);
         if (!kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken)) {
             refreshToken = konyRef.currentRefreshToken;
         }
         var _url = _serviceUrl + "/claims";
         if (options && options.requestParams != null) {
             _url = _url + "?";
             for (var i in options.requestParams) {
                 if (options.requestParams.hasOwnProperty(i) && typeof(i) !== 'function') {
                     _url = _url + (i + "=" + options.requestParams[i] + "&");
                 }
             }
             _url = stripTrailingCharacter(_url, "&");
         }
         if (refreshToken) {
             kony.sdk.logsdk.info("### AuthService::_claimsRefresh making POST request to claims endpoint");
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = refreshToken;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### _claimsRefresh::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.post(_url, {}, headers, function(data) {
                 data = kony.sdk.formatSuccessResponse(data);
                 kony.sdk.logsdk.info("### AuthService::_claimsRefresh Fetching claims succcessfull");
                 processMultipleProvidersResponse(data);
                 kony.sdk.logsdk.info("### AuthService::_claimsRefresh saved locally. Calling success callback");
                 kony.sdk.verifyAndCallClosure(success, data);
             }, function(xhr, status, err) {
                 kony.sdk.logsdk.error("### AuthService::_claimsRefresh fetching claims failed. Calling failure callback");
                 kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getAuthErrObj(err));
             });
         } else {
             kony.sdk.logsdk.info("### AuthService::_claimsRefresh no refreshtoken found. calling failure callback");
             kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getNullRefreshTokenErrObj());
         }
     };
     var profileRefresh = function(success, failure) {
         kony.sdk.logsdk.trace("Entering profileRefresh");
         kony.sdk.logsdk.debug("### AuthService::profileRefresh fetching profile from server for provider " + _providerName);
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(kony.sdk.constants.GET_PROFILE);
         var refreshToken = null;
         if (!kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken)) {
             refreshToken = konyRef.currentRefreshToken;
         }
         var _url = _serviceUrl + "/profile?provider=" + _providerName;
         if (refreshToken) {
             kony.sdk.logsdk.info("### AuthService::profileRefresh making POST request to profile endpoint");
             var headers = {};
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = refreshToken;
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
             if (konyRef.reportingheaders_allowed) {
                 if (reportingData != null && reportingData != undefined) {
                     try {
                         headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
                     } catch (error) {
                         kony.sdk.logsdk.error("### profileRefresh::error while parsing metrics payload" + error);
                     }
                 }
             }
             populateHeaderWithFabricAppVersion(headers);
             networkProvider.get(_url, null, headers, function(data) {
                 data = kony.sdk.formatSuccessResponse(data);
                 konyRef.tokens[_providerName].profile = data;
                 kony.sdk.logsdk.info("### AuthService::profileRefresh Fetching profile succcessfull, Calling success callback");
                 kony.sdk.verifyAndCallClosure(success, data);
             }, function(xhr, status, err) {
                 kony.sdk.logsdk.error("### AuthService::profileRefresh fetching profile failed. Calling failure callback");
                 kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getAuthErrObj(err));
             });
         } else {
             kony.sdk.logsdk.info("### AuthService::profileRefresh no refreshtoken found. calling failure callback");
             kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getNullRefreshTokenErrObj());
         }
     };
 }

 function konySdkLogger() {
     this.INDIRECTIONLEVEL = 1;
     this.trace = function(msg, params) {
         this.getInstance().trace(msg, params);
     };
     this.debug = function(msg, params) {
         this.getInstance().debug(msg, params);
     };
     this.info = function(msg, params) {
         this.getInstance().info(msg, params);
     };
     this.perf = function(msg, params) {
         this.getInstance().perf(msg, params);
     };
     this.warn = function(msg, params) {
         this.getInstance().warn(msg, params);
     };
     this.error = function(msg, params) {
         this.getInstance().error(msg, params);
     };
     this.fatal = function(msg, params) {
         this.getInstance().fatal(msg, params);
     };
     this.loggerEngineInit = function() {
         KonySDKLoggerObj = kony.logger.createNewLogger(kony.sdk.constants.LOGGER_NAME, null);
         KonySDKLoggerObj.setIndirectionLevel = this.INDIRECTIONLEVEL;
     };
     this.getInstance = function() {
         if (typeof(KonySDKLoggerObj) === 'undefined') this.loggerEngineInit();
         return KonySDKLoggerObj;
     }
 }
 /**
  * Method to create the logic service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @returns The url to connect to the logic service
  * @throws Exception if the serviceName or access is invalid.
  */
 kony.sdk.prototype.getLogicService = function(serviceName) {
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getLogicService");
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Logic service - " + serviceName);
     }
     if (this.logicsvc != null) {
         if (this.logicsvc[serviceName] != null) {
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getLogicService");
             kony.sdk.logsdk.debug("### getLogicService::found Logic service" + this.logicsvc[serviceName]);
             return new kony.sdk.LogicService(this, serviceName);
         }
     }
     throw new Exception(kony.sdk.errorConstants.LOGIC_SERVICE_FAILURE, "Invalid serviceName:" + serviceName);
 };
 kony.sdk.LogicService = function(konyRef, serviceName) {
     this.konyRef = konyRef;
     this.serviceName = serviceName;
     this.logicServiceUrl = null;
     this.getLogicServiceUrl = function() {
         if (this.logicServiceUrl == null) {
             this.logicServiceUrl = stripTrailingCharacter(konyRef.logicsvc[serviceName], "/");
         }
         return this.logicServiceUrl;
     };
     kony.sdk.logsdk.info(" ###LogicService Created & LogicService Url = " + this.getLogicServiceUrl());
     var networkProvider = new konyNetworkProvider();
     this.invokeOperation = function(serviceName, path, methodType, headers, data, successCallback, failureCallback, options) {
         function invokeOperationHandler() {
             _invokeOperation(serviceName, path, methodType, headers, data, true, successCallback, failureCallback, options);
         }
         kony.sdk.claimsRefresh(invokeOperationHandler, failureCallback);
     };

     function invokeOperationRetry(serviceName, path, methodType, headers, data, successCallback, failureCallback, options) {
         function invokeOperationRetryHandler() {
             _invokeOperation(serviceName, path, methodType, headers, data, false, successCallback, failureCallback, options);
         }
         kony.sdk.claimsAndProviderTokenRefresh(invokeOperationRetryHandler, failureCallback);
     }

     function retryServiceCall(errorResponse) {
         if (errorResponse[kony.sdk.constants.MF_CODE]) {
             // check for the mf code for which,
             // retry should be done.
         } else {
             if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
                 return true;
             }
         }
     }

     function _invokeOperation(serviceName, path, methodType, headers, data, isRetryNeeded, successCallback, failureCallback, options) {
         var requestData = {};
         kony.sdk.logsdk.trace("Executing _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
         var reportingData = kony.sdk.getPayload(konyRef);
         var sessionId = kony.ds.read(kony.sdk.constants.KONYUUID);
         if (sessionId) {
             reportingData.rsid = sessionId[0];
         }
         if (!reportingData.rsid) {
             kony.sdk.logsdk.warn("rsid is either empty,null or undefined");
         }
         if (kony.sdk.metric) {
             if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
                 kony.sdk.metric.readFromDS();
             }
             kony.sdk.metric.pushEventsToBufferArray();
             requestData.events = kony.sdk.metric.reportEventBufferBackupArray;
         }
         for (var key in data) {
             requestData[key] = data[key];
         }
         reportingData.svcid = serviceName;
         requestData[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(reportingData);
         var defaultHeaders = {};
         defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         if (typeof(svcObj) === 'object' && svcObj.version) {
             defaultHeaders[kony.sdk.constants.API_VERSION_HEADER] = svcObj.version;
         }
         // if the user has defined his own headers, use them
         if (headers) {
             for (var header in headers) {
                 defaultHeaders[header] = headers[header];
             }
         }

         function networkSuccessCallback(response) {
             if (kony.sdk.metric) {
                 kony.sdk.metric.clearBufferEvents();
             }
             kony.sdk.logsdk.perf("Executing Finished network operation for methodType : " + methodType);
             kony.sdk.logsdk.trace("Executing Finished _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function networkFailureCallback(xhr, status, err) {
             if (isRetryNeeded === true && retryServiceCall(xhr) === true) {
                 invokeOperationRetry(serviceName, path, methodType, headers, data, successCallback, failureCallback, options);
                 return;
             }
             kony.sdk.logsdk.perf("Executing Finished network operation for methodType : " + methodType);
             kony.sdk.logsdk.trace("Executing Finished _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
             kony.sdk.processLogicErrorResponse(xhr, true, failureCallback);
         }
         kony.sdk.logsdk.perf("Executing network operation for methodType : " + methodType);
         switch (methodType) {
             case "GET":
                 networkProvider.get(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
             case "PUT":
                 networkProvider.put(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
             case "DELETE":
                 networkProvider.invokeDeleteRequest(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
             default:
                 networkProvider.post(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
                 break;
         }
     }
     kony.sdk.processLogicErrorResponse = function(err, isAsync, callBack) {
         if (kony.sdk.metric) {
             if (kony.sdk.metric.errorCodeMap[err.opstatus]) {
                 kony.sdk.metric.saveInDS();
             }
         }
         if (err[kony.sdk.constants.MF_CODE]) {
             var konyRef = kony.sdk.getCurrentInstance();
             //clear the cache if the error code related to session/token expiry
             if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
                 kony.sdk.logsdk.warn("###LogicService::invokeOperationFailure  Session/Token expired. Authenticate and Try again");
                 //kony.sdk.resetCacheKeys(konyRef);
             }
         }
         if (!isAsync) {
             return kony.sdk.error.getLogicErrObj(err);
         } else if (callBack) {
             kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getLogicErrObj(err));
         }
     };
 };
 kony.sdk.prototype.registerObjectService = function(objectServiceType, objectServiceClass) {
     kony.sdk.logsdk.trace("Entering kony.sdk.prototype.registerObjectService");
     kony.sdk.registeredobjsvcs = kony.sdk.registeredobjsvcs || {};
     kony.sdk.registeredobjsvcs[objectServiceType] = objectServiceClass;
 };
 /**
  * Method to create the object service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @param {map} options - Map of key values like {"access":"offline"/"online"/"registered Object Service Name"}
  * @returns {@link kony.sdk.OnlineObjectService / @link kony.sdk.OfflineObjectService} Object service instance
  * @throws Exception if the serviceName or access is invalid.
  */
 kony.sdk.prototype.getObjectService = function(serviceName, options) {
     kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getObjectService");
     if (!kony.sdk.isInitialized) {
         kony.sdk.logsdk.perf("Executing finished kony.sdk.prototype.getObjectService with an exception");
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Object service - " + serviceName);
     }
     var access;
     if (!kony.sdk.isNullOrUndefined(options)) {
         access = options["access"];
     }
     if (this.objectsvc != null && this.objectsvc[serviceName] != null) {
         kony.sdk.logsdk.debug("### getObjectService::found Object service" + this.objectsvc[serviceName]);
         if (kony.sdk.util.isNullOrEmptyString(access) || access.toLowerCase() === "online") {
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
             return new kony.sdk.OnlineObjectService(this, serviceName, this.objectsvc[serviceName]);
         } else if (access.toLowerCase() === "offline") {
             kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
             //This returns SyncV1 object service
             return new kony.sdk.OfflineObjectService(this, serviceName);
         }
     } else if (this.offlineObjectsvc != null) {
         if (this.offlineObjectsvc[serviceName] != null) {
             if (kony.sdk.util.isNullOrEmptyString(access) || access.toLowerCase() === "online") {
                 kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
                 // This returns Online Object Service Instance
                 return new kony.sdk.OnlineObjectService(this, serviceName, this.offlineObjectsvc[serviceName]);
             } else if (access.toLowerCase() === "offline") {
                 kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
                 //This returns Offline Enabled or SyncV2 object service
                 return new kony.sdk.OfflineEnabledObjectService(this, serviceName);
             }
         }
     }
     kony.sdk.registeredobjsvcs = kony.sdk.registeredobjsvcs || {};
     kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
     //verifying if the servicetype available in registeredservices if available initialize and return
     if (kony.sdk.registeredobjsvcs[access] != null && kony.sdk.registeredobjsvcs[access] != undefined) {
         return new kony.sdk.registeredobjsvcs[access](this, serviceName);
     }
     throw new Exception(kony.sdk.errorConstants.OBJECT_FAILURE, "Invalid serviceName:" + serviceName + "or access type:" + access);
 };
 /**
  * Method which returns the online ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OnlineObjectService = function(konyRef, serviceName, serviceInfo) {
     kony.sdk.logsdk.perf("Executing kony.sdk.OnlineObjectService");
     this.konyRef = konyRef;
     this.serviceName = serviceName;
     this.serviceInfo = serviceInfo;
     this.dataUrl = null;
     this.binaryUrl = null;
     this.fileStorageObjectServiceUrl = null;
     this.operationsUrl = null;
     this.metadataUrl = null;
     this.version = null;
     var currentObject = this;
     /**
      * This method is used to create a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.create = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.create");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function createOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _create(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::create Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             createOperationHandler();
         } else {
             kony.sdk.claimsRefresh(createOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to fetch a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.fetch = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.fetch");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function fetchOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _fetch(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::fetch Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             fetchOperationHandler();
         } else {
             kony.sdk.claimsRefresh(fetchOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to update a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.update = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.update");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function updateOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _update(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::update Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             updateOperationHandler();
         } else {
             kony.sdk.claimsRefresh(updateOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to partial update a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.partialUpdate = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.partialUpdate");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function partialUpdateOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _partialUpdate(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::partialUpdate Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             partialUpdateOperationHandler();
         } else {
             kony.sdk.claimsRefresh(partialUpdateOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to delete a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.deleteRecord = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.deleteRecord");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getDataUrl();
         var objName = options["dataObject"].objectName;

         function deleteOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _deleteRecord(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::delete Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             deleteOperationHandler();
         } else {
             kony.sdk.claimsRefresh(deleteOperationHandler, failureCallback);
         }
     };
     /**
      * This method is used to for performing custom operation
      * @param {string} verbName -  custom verb identifier
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.customVerb = function(verbName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.customVerb");
         if (verbName == null || verbName == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "verbName" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var tmpDataUrl = this.getOperationsUrl();
         var objName = options["dataObject"].objectName;

         function customVerbHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(result) {
                 _customverb(verbName, options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::customverb Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             customVerbHandler();
         } else {
             kony.sdk.claimsRefresh(customVerbHandler, failureCallback);
         }
     };
     /**
      * This method is used to retrive metadata of all objects
      * @param {map} options - includes {"getFromServer":boolean,"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getMetadataOfAllObjects");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OnlineObjectService.getMetadataOfAllObjects");
     };
     /**
      * This method is used to retrive metadata of a specific object
      * @param objectName
      * @param {map} options - includes {"getFromServer":boolean,"headers":<map of http headers>}
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getMetadataOfObject");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OnlineObjectService.getMetadataOfObject");
     };
     this.getDataUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.dataUrl)) {
             currentObject.dataUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/objects/", "/"));
         }
         return currentObject.dataUrl;
     };
     this.getFileStorageObjectServiceUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.fileStorageObjectServiceUrl)) {
             currentObject.fileStorageObjectServiceUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"], "/"));
         }
         return currentObject.fileStorageObjectServiceUrl;
     };
     this.getBinaryUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.binaryUrl)) {
             currentObject.binaryUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/binary/", "/"));
         }
         return currentObject.binaryUrl;
     };
     this.getOperationsUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.operationsUrl)) {
             currentObject.operationsUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/operations/", "/"));
         }
         return currentObject.operationsUrl;
     };
     this.getMetadataUrl = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.metadataUrl)) {
             currentObject.metadataUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["metadata_url"], "/"));
         }
         return currentObject.metadataUrl;
     };
     this.getVersion = function() {
         if (kony.sdk.isNullOrUndefined(currentObject.version)) {
             currentObject.version = currentObject.serviceInfo["version"];
         }
         return currentObject.version;
     };
     /*
      *  API for uploading binary data (either file or raw bytes) to backend
      */
     this.uploadBinaryData = function(options, onFileUploadStartedCallback, onChunkUploadCompletedCallback, onFileUploadCompletedCallback, onFileUploadFailureCallback) {
         var fileUploadStartedCallback = null;
         var chunkUploadCompletedCallback = null;
         var fileUploadCompletedCallback = null;
         var fileUploadFailureCallback = null;
         var uploadParams = null;
         /* validations for callbacks */
         // validation for onFileUploadStartedCallback
         if (kony.sdk.isNullOrUndefined(onFileUploadStartedCallback) || (typeof(onFileUploadStartedCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadStartedCallback is null or undefined or not a function");
         } else {
             fileUploadStartedCallback = onFileUploadStartedCallback;
         }
         // validation for onChunkUploadCompletedCallback
         if (kony.sdk.isNullOrUndefined(onChunkUploadCompletedCallback) || (typeof(onChunkUploadCompletedCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onChunkUploadCompletedCallback is null or undefined or not a function");
         } else {
             chunkUploadCompletedCallback = onChunkUploadCompletedCallback;
         }
         // validation for onFileUploadCompletedCallback
         if (kony.sdk.isNullOrUndefined(onFileUploadCompletedCallback) || (typeof(onFileUploadCompletedCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadCompletedCallback is null or undefined or not a function");
         } else {
             fileUploadCompletedCallback = onFileUploadCompletedCallback;
         }
         // validation for onFileUploadFailureCallback
         if (kony.sdk.isNullOrUndefined(onFileUploadFailureCallback) || (typeof(onFileUploadFailureCallback) !== 'function')) {
             kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadFailureCallback is null or undefined or not a function");
         } else {
             fileUploadFailureCallback = onFileUploadFailureCallback;
         }
         // validation for options
         if (kony.sdk.isNullOrUndefined(options)) {
             kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData options is null or undefined");
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options " + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (kony.sdk.isNullOrUndefined(dataObject)) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var objName = dataObject.getObjectName();
         var mfEndpointUrl = this.getDataUrl() + "/" + objName;
         if (kony.sdk.isNullOrUndefined(dataObject.getRecord())) {
             kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData Error: Please provide record to upload Binary content.");
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         uploadParams = dataObject.getRecord();
         var errorObj = kony.sdk.binary.validateUploadParams(uploadParams);
         if (errorObj) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObj);
             return;
         }
         // if rawbytes are provided, converting to base64 string as FFI can only receive base datatypes
         if (!kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.RAW_BYTES])) {
             var base64String = kony.convertToBase64(uploadParams[kony.sdk.constants.RAW_BYTES]);
             uploadParams[kony.sdk.constants.RAW_BYTES] = base64String;
         }

         function uploadBinaryDataOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _uploadBinaryData(mfEndpointUrl, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData Error:", error);
                 kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             uploadBinaryDataOperationHandler();
         } else {
             kony.sdk.claimsRefresh(uploadBinaryDataOperationHandler, fileUploadFailureCallback);
         }
     };
     /*
      * Helper method to perform file upload
      */
     function _uploadBinaryData(mfEndpointUrl, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback) {
         var uploadOptions = {};
         if (uploadParams) {
             //Extracting Mandatory Params from uploadParams before fetching template
             if (uploadParams[kony.sdk.constants.FILE_PATH]) {
                 uploadOptions[kony.sdk.constants.FILE_PATH] = uploadParams[kony.sdk.constants.FILE_PATH];
                 delete uploadParams[kony.sdk.constants.FILE_PATH];
             } else if (uploadParams[kony.sdk.constants.RAW_BYTES]) {
                 uploadOptions[kony.sdk.constants.RAW_BYTES] = uploadParams[kony.sdk.constants.RAW_BYTES];
                 delete uploadParams[kony.sdk.constants.RAW_BYTES];
             } else if (uploadParams[kony.sdk.constants.FILE_OBJECT]) {
                 uploadOptions[kony.sdk.constants.FILE_OBJECT] = uploadParams[kony.sdk.constants.FILE_OBJECT];
                 delete uploadParams[kony.sdk.constants.FILE_OBJECT]
             }
             uploadOptions["uploadParams"] = uploadParams;
         }
         var headers = {};
         if (!kony.sdk.skipAnonymousCall) {
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
         }
         uploadOptions["headers"] = headers;
         uploadOptions["URL"] = mfEndpointUrl;
         kony.sdk.binary.uploadBinaryData(uploadOptions, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback);
     }
     this.getBinaryData = function(options, arg1, arg2, arg3, arg4, arg5) {
         var externalSource = true;
         var fileDownloadStartedCallback = null;
         var chunkDownloadCompletedCallback = null;
         var fileDownloadCompletedCallback = null;
         var downloadFailureCallback = null;
         var binaryAttributeName = null;
         if (kony.sdk.isNullOrUndefined(arg5)) {
             if (kony.sdk.isNullOrUndefined(arg1)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadStartedCallback is null or undefined");
             } else if (typeof(arg1) === 'function') {
                 fileDownloadStartedCallback = arg1;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadStartedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg2)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData chunkDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg2) === 'function') {
                 chunkDownloadCompletedCallback = arg2;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for chunkDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg3)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg3) === 'function') {
                 fileDownloadCompletedCallback = arg3;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg4)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData downloadFailureCallback is null or undefined");
             } else if (typeof(arg4) === 'function') {
                 downloadFailureCallback = arg4;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for downloadFailureCallback");
             }
         } else {
             binaryAttributeName = arg1;
             externalSource = false;
             if (kony.sdk.isNullOrUndefined(arg2)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadStartedCallback is null or undefined");
             } else if (typeof(arg2) === 'function') {
                 fileDownloadStartedCallback = arg2;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadStartedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg3)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData chunkDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg3) === 'function') {
                 chunkDownloadCompletedCallback = arg3;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for chunkDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg4)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadCompletedCallback is null or undefined");
             } else if (typeof(arg4) === 'function') {
                 fileDownloadCompletedCallback = arg4;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadCompletedCallback");
             }
             if (kony.sdk.isNullOrUndefined(arg5)) {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData downloadFailureCallback is null or undefined");
             } else if (typeof(arg5) === 'function') {
                 downloadFailureCallback = arg5;
             } else {
                 kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for downloadFailureCallback");
             }
         }
         if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() !== kony.sdk.constants.SDK_ATYPE_NATIVE) {
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_api, kony.sdk.errormessages.invalid_api + "platform :" + kony.sdk.getSdkType().toString()));
             return;
         }
         if (kony.sdk.isNullOrUndefined(options)) {
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var tmpDataUrl = null;
         if (externalSource) {
             tmpDataUrl = this.getDataUrl();
         } else {
             tmpDataUrl = this.getBinaryUrl();
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(kony.sdk.isNullOrUndefined(options["queryParams"]))) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var streamingFlag = false;
         if (!kony.sdk.isNullOrUndefined(options["streaming"]) && options["streaming"] === true) {
             streamingFlag = true;
         }
         if (!externalSource) {
             if (kony.sdk.isNullOrUndefined(binaryAttributeName) || typeof(binaryAttributeName) !== "string") {
                 kony.sdk.logsdk.error("### OnlineObjectService::getBinaryData Error: Please provide column name to fetch binary content");
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
                 return;
             } else {
                 options["binaryAttrName"] = binaryAttributeName;
             }
         }
         if (kony.sdk.isNullOrUndefined(dataObject.getRecord())) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData Error: Please provide primary key details or fileParams to get Binary content.");
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }

         function getBinaryDataOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _getBinaryData(options, tmpDataUrl, externalSource, streamingFlag, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::getBinaryData Error:", error);
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             getBinaryDataOperationHandler();
         } else {
             kony.sdk.claimsRefresh(getBinaryDataOperationHandler, downloadFailureCallback);
         }
     };
     /**
      * Helps to get the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject":{@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.getBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getBinaryContent");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var tmpDataUrl = this.getBinaryUrl();
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var binaryColName = options["binaryAttrName"];
         if (binaryColName == null || binaryColName == undefined) {
             kony.sdk.logsdk.error("### OnlineObjectService::getBinaryContent Error: Please provide column name to fetch binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
             return;
         }

         function getBinaryContentOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _getBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::getBinaryContent Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             getBinaryContentOperationHandler();
         } else {
             kony.sdk.claimsRefresh(getBinaryContentOperationHandler, failureCallback);
         }
     };
     /**
      * Helps to create the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject": {@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.createBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.createBinaryContent");
         var tmpDataUrl = this.getBinaryUrl();
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var binaryColName = options["binaryAttrName"];
         if (binaryColName == null || binaryColName == undefined) {
             kony.sdk.logsdk.error("### OnlineObjectService::createBinaryContent Error: Please provide column name to create binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("900000", "Please provide column name to create binary content"));
             return;
         }

         function createBinaryContentOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _createBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::createBinaryContent Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             createBinaryContentOperationHandler();
         } else {
             kony.sdk.claimsRefresh(createBinaryContentOperationHandler, failureCallback);
         }
     };
     /**
      * Helps to update the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject": {@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.updateBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.updateBinaryContent");
         var tmpDataUrl = this.getBinaryUrl();
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
             if (!(options["queryParams"] instanceof Object)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
                 return;
             }
         }
         var objName = dataObject.getObjectName();
         var binaryColName = options["binaryAttrName"];
         if (binaryColName == null || binaryColName == undefined) {
             kony.sdk.logsdk.error("### OnlineObjectService::updateBinaryContent Error: Please provide column name to create binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to create binary content"));
             return;
         }

         function updateBinaryContentOperationHandler() {
             currentObject.getMetadataOfObject(objName, {}, function(response) {
                 _updateBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
             }, function(error) {
                 kony.sdk.logsdk.error("### OnlineObjectService::updateBinaryContent Error:", error);
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             });
         }
         if (kony.sdk.skipAnonymousCall) {
             updateBinaryContentOperationHandler();
         } else {
             kony.sdk.claimsRefresh(updateBinaryContentOperationHandler, failureCallback);
         }
     };

     function _getBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             if (pkCount == 0) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             //reading primarykey and framing filter clause
             var pkey = objMetadata.primaryKey[0];
             if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                 kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryContent Error: Please provide primary key details to get Binary content.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             url = url + "?" + pkey + "=" + dataObject.getRecord()[pkey];
             //passing binary column name to server
             if (binaryColName != null && binaryColName != undefined) {
                 url = url + "&fieldName=" + binaryColName;
             }
             if (queryParams != undefined && queryParams != null) {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
             }
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_getBinaryContent::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response["data"]);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryContent::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, dataObject.getObjectName(), headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _getBinaryData(options, tmpDataUrl, externalSource, streamingFlag, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         if (!externalSource) {
             if (!kony.sdk.isNullOrUndefined(objMetadata.primaryKey)) {
                 var pkCount = objMetadata.primaryKey.length;
                 if (pkCount == 0) {
                     kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 //reading primarykey and framing filter clause
                 var pkey = objMetadata.primaryKey[0];
                 if (kony.sdk.isNullOrUndefined(dataObject.getRecord()[pkey])) {
                     kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData Error: Please provide primary key details to get Binary content.");
                     kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 url = url + "?" + pkey + "=" + dataObject.getRecord()[pkey];
                 //passing binary column name to server
                 if (!kony.sdk.isNullOrUndefined(binaryColName)) {
                     url = url + "&fieldName=" + binaryColName;
                 }
                 url = url + "&type=bytes";
                 if (!kony.sdk.isNullOrUndefined(queryParams)) {
                     url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
                 }
             } else {
                 kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var headerKey in headers) {
                 if (!kony.sdk.isNullOrUndefined(headerKey)) {
                     if (headerKey.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) {
                         isKonyApiVersionAvailable = true;
                         headers[kony.sdk.constants.API_VERSION_HEADER] = headers[headerKey];
                     }
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_getBinaryData::invokeSuccessCallback Response:", response);
             var downloadConfig = response["records"][0];
             downloadConfig.httpStatusCode = response.httpStatusCode;
             if (options && options["ChunkSize"]) {
                 downloadConfig.ChunkSize = options["ChunkSize"];
             }
             var fileParams = dataObject.getRecord();
             if (kony.sdk.isNullOrUndefined(fileParams["fileId"])) {
                 fileParams["fileId"] = new Date().getTime().toString();
             }
             kony.sdk.binary.getBinaryData(fileParams, streamingFlag, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(downloadFailureCallback, error);
         }
         if (externalSource) {
             invokeObjectOperation(url, dataObject.getObjectName(), headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
         } else {
             var fileParams = dataObject.getRecord();
             if (kony.sdk.isNullOrUndefined(fileParams["fileId"])) {
                 fileParams["fileId"] = dataObject.getRecord()[pkey];
             }
             if (!kony.sdk.skipAnonymousCall) {
                 headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
             }
             var downloadConfig = {};
             downloadConfig["endpointUrl"] = url;
             downloadConfig["headers"] = headers;
             //for bypasing template call we need to add method and httpstatus code 309
             downloadConfig.method = kony.sdk.constants.HTTP_METHOD_GET;
             downloadConfig.httpStatusCode = kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE;
             if (options && options["ChunkSize"]) {
                 downloadConfig.ChunkSize = options["ChunkSize"];
             }
             kony.sdk.binary.getBinaryData(fileParams, streamingFlag, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
         }
     }

     function _createBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         var jsonPayload = {};
         var pkey;
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             if (pkCount == 0) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             //reading primarykey and framing filter clause
             pkey = objMetadata.primaryKey[0];
             if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                 kony.sdk.logsdk.error("### OnlineObjectService::_createBinaryContent Error: Please provide primary key details to create Binary content.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             jsonPayload[pkey] = dataObject.getRecord()[pkey];
             jsonPayload["data"] = dataObject.getRecord()[binaryColName];
             jsonPayload["fieldName"] = binaryColName;
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(jsonPayload);
         if (!kony.sdk.isNullOrUndefined(queryParams)) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_createBinaryContent::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response[pkey]);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_createBinaryContent::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, dataObject.getObjectName(), headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _updateBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var binaryColName = options["binaryAttrName"];
         var objName = dataObject.getObjectName();
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + objName;
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
         var jsonPayload = {};
         var pkey;
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             if (pkCount == 0) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             //reading primarykey and framing filter clause
             pkey = objMetadata.primaryKey[0];
             if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                 kony.sdk.logsdk.error("### OnlineObjectService::_updateBinaryContent Error: Please provide primary key details to create Binary content.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             jsonPayload[pkey] = dataObject.getRecord()[pkey];
             jsonPayload["data"] = dataObject.getRecord()[binaryColName];
             jsonPayload["fieldName"] = binaryColName;
         } else {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         headers["X-HTTP-Method-Override"] = "PUT";
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(jsonPayload);
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_updateBinaryContent::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response[pkey]);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_updateBinaryContent::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, dataObject.getObjectName(), headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _create(options, tmpDataUrl, successCallback, failureCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var record = dataObject.getRecord();
         var queryParams = options["queryParams"];
         if (record == null || record == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "record " + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(record);
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_create::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_create::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error)
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _fetch(options, tmpDataUrl, successCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var odataqueryStr = dataObject.getOdataUrl();
         var headers = options["headers"];
         var queryParams = options["queryParams"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         if (odataqueryStr != undefined && odataqueryStr != null) {
             url = url + "?" + encodeURI(odataqueryStr);
             if (queryParams != undefined && queryParams != null) {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
             }
         } else if (queryParams != undefined && queryParams != null) {
             url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         // If useCache is enabled and cacheID is present then network call will be skipped and cached response will be returned.
         if (options && options["useCache"] && options["cacheID"]) {
             var cacheResponse = new kony.sdk.ClientCache().get(options["cacheID"]);
             if (cacheResponse) {
                 kony.sdk.logsdk.debug("### OnlineObjectService::_fetch:: key found in cache, invokeSuccessCallback Response:", cacheResponse);
                 kony.sdk.verifyAndCallClosure(successCallback, cacheResponse);
                 return;
             }
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_fetch::invokeSuccessCallback Response:", response);
             // If useCache is enabled then the response is cached and returned.
             if (options && options["useCache"]) {
                 cacheResponseForKey(options, url, {
                     "objectName": dataObject.objectName
                 }, response);
             }
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_fetch::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _update(options, tmpDataUrl, updateServiceCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var queryParams = options["queryParams"];
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         headers["X-HTTP-Method-Override"] = "PUT";
         var formData = new kony.sdk.getFormData(dataObject.getRecord());
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_update::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(updateServiceCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_update::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _partialUpdate(options, tmpDataUrl, partialUpdateServiceCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var queryParams = options["queryParams"];
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         headers["X-HTTP-Method-Override"] = "PATCH";
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(dataObject.getRecord());
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_partialUpdate::invokeSuccessCallback Success Response:", response);
             kony.sdk.verifyAndCallClosure(partialUpdateServiceCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_partialUpdate::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _deleteRecord(options, tmpDataUrl, deleteSuccessCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, dataObject.objectName);
         var url = tmpDataUrl + "/" + dataObject.objectName;
         var queryParams = options["queryParams"];
         var odataUrl = "";
         if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
             var pkCount = objMetadata.primaryKey.length;
             for (var i = 0; i < pkCount; i++) {
                 //reading primarykey and framing filter clause
                 var pkey = objMetadata.primaryKey[i];
                 if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
                     kony.sdk.logsdk.error("### OnlineObjectService::_delete Error: Please provide all primary keys to process the request");
                     kony.sdk.verifyAndCallClosure(serviceErrorCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 if (i == 0) {
                     odataUrl = "?$filter=" + pkey + " eq '" + dataObject.getRecord()[pkey] + "'";
                 } else {
                     //appending the condition incase of composite primary key
                     odataUrl = odataUrl + " and " + pkey + " eq '" + dataObject.getRecord()[pkey] + "'";
                 }
             }
         }
         url = url + encodeURI(odataUrl);
         if (queryParams != undefined && queryParams != null) {
             if (odataUrl && odataUrl.length != 0) {
                 url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
             } else {
                 url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
             }
         }
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         headers["X-HTTP-Method-Override"] = "DELETE";

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_delete::invokeSuccessCallback Response:", response);
             kony.sdk.verifyAndCallClosure(deleteSuccessCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_delete::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }

     function _customverb(verbName, options, tmpDataUrl, customVerbServiceCallback, serviceErrorCallback) {
         var dataObject = options["dataObject"];
         var headers = options["headers"];
         var url = tmpDataUrl + "/" + dataObject.objectName + "/" + verbName;
         var queryParams = options["queryParams"];
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
             }
         }
         var formData = new kony.sdk.getFormData(dataObject.getRecord());
         if (queryParams != undefined && queryParams != null) {
             kony.sdk.updateFormData(formData, "queryparams", queryParams);
         }

         function invokeSuccessCallback(response) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_customverb::invokeSuccessCallback Success Response:", response);
             kony.sdk.verifyAndCallClosure(customVerbServiceCallback, response);
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_customverb::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
         }
         invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }
     this.getFileStorage = function() {
         // TODO : Fix this as there are issues with getMetadataOfAllObjects call - that was hanging	
         return kony.sdk.FileStorageClasses.import(this.getFileStorageObjectServiceUrl());
     };
 };

 function _getMetadataUrl(konyRef, serviceName) {
     var metadataUrl = null;
     if (konyRef.objectsvc[serviceName]) {
         metadataUrl = encodeURI(stripTrailingCharacter(konyRef.objectsvc[serviceName]["metadata_url"], "/"));
     } else if (konyRef.offlineObjectsvc[serviceName]) {
         metadataUrl = encodeURI(stripTrailingCharacter(konyRef.offlineObjectsvc[serviceName]["metadata_url"], "/"));
     }
     return metadataUrl;
 }

 function _getVersion(konyRef, serviceName) {
     var version = null;
     if (konyRef.objectsvc[serviceName]) {
         version = konyRef.objectsvc[serviceName]["version"];
     } else if (konyRef.offlineObjectsvc[serviceName]) {
         version = konyRef.offlineObjectsvc[serviceName]["version"];
     }
     return version;
 }
 /*This method is used to fetch metadata for Object/Objectservice.
  * It is fetched from cache first, if it not available in cache then fetches method data from metadata URL.
  */
 function _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback) {
     var tmpMetadataUrl = _getMetadataUrl(konyRef, serviceName);;
     if (!(kony.sdk.isNullOrUndefined(options)) && !(options["queryParams"] == null || options["queryParams"] == undefined)) {
         if (!(options["queryParams"] instanceof Object)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         }
     }

     function getMetadataOfObjectOperationHandler() {
         _getMetadataForObjectOrService(konyRef, serviceName, objectName, options, tmpMetadataUrl, successCallback, failureCallback);
     }
     if (kony.sdk.skipAnonymousCall) {
         getMetadataOfObjectOperationHandler();
     } else {
         kony.sdk.claimsRefresh(getMetadataOfObjectOperationHandler, failureCallback);
     }
 }

 function _getMetadataForObjectOrService(konyRef, serviceName, objectName, options, tmpMetadataUrl, successCallback, failureCallback) {
     //if the getFromServer flag is true then get metadata from server even though its available in cache
     var getFromServer = false;
     var headers = null;
     var queryParams = null;
     if (options != null && options != undefined) {
         getFromServer = options["getFromServer"];
         headers = options["headers"];
         queryParams = options["queryParams"];
     }
     var tmpObjOrSvcMetadata = null;
     if (objectName) {
         tmpObjOrSvcMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
     } else {
         tmpObjOrSvcMetadata = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
     }
     if (getFromServer != true && tmpObjOrSvcMetadata != null && tmpObjOrSvcMetadata != undefined) {
         kony.sdk.logsdk.debug("### OnlineObjectService::_getMetadataOfObject from KonyStore:", tmpObjOrSvcMetadata);
         kony.sdk.verifyAndCallClosure(successCallback, tmpObjOrSvcMetadata);
     } else {
         if (!headers) {
             //if headers not sent by the deveolper
             headers = {};
         }
         var isKonyApiVersionAvailable = false;
         if (typeof(headers) !== 'undefined' && headers !== null) {
             //check for x-kony-api-version case insensitive
             for (var header in headers) {
                 if (header !== null && header !== 'undefined') {
                     if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
                 }
             }
             if (!isKonyApiVersionAvailable) {
                 headers[kony.sdk.constants.API_VERSION_HEADER] = _getVersion(konyRef, serviceName);
             }
         }
         var url = tmpMetadataUrl;
         var svcid = "metadata";
         if (objectName) {
             url = url + "/" + objectName;
             svcid = svcid + "_" + objectName;
         }
         if (queryParams != undefined && queryParams != null) {
             url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
         }

         function invokeSuccessCallback(result) {
             kony.sdk.logsdk.debug("### OnlineObjectService::_getMetadataForObjectOrService::invokeSuccessCallback Response:", result);
             if (objectName) {
                 var table = result["Metadata"]["table"];
                 kony.sdk.ObjectServiceUtil.cacheObjectMetadata(serviceName, table);
                 var tmpObjMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
                 kony.sdk.verifyAndCallClosure(successCallback, tmpObjMetadata);
             } else {
                 var tableArray = result["Metadata"]["tables"];
                 kony.sdk.ObjectServiceUtil.cacheMetadata(serviceName, tableArray);
                 var tmpMetadata = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
                 kony.sdk.verifyAndCallClosure(successCallback, tmpMetadata);
             }
         }

         function invokeFailureCallback(error) {
             kony.sdk.logsdk.error("### OnlineObjectService::_getMetadataForObjectOrService::invokeFailureCallback Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         invokeObjectOperation(url, svcid, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     }
 }
 //Method is used to send http request for ObjectService operations
 function invokeObjectOperation(url, svcid, headers, formData, httpMethod, successCallback, failureCallback, networkProviderOptions) {
     kony.sdk.logsdk.perf("Executing invokeObjectOperation");
     var networkProvider = new konyNetworkProvider();
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
     var defaultHeaders = {};
     if (!httpMethod) {
         //default http method is post
         httpMethod = "POST";
     }
     if (!kony.sdk.skipAnonymousCall) {
         // Check to find if the service is public or not, in case of public service no token is required.
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     }
     defaultHeaders[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
     defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON;
     var deviceId = kony.sdk.getDeviceId();
     if (!kony.sdk.isNullOrUndefined(deviceId)) {
         defaultHeaders[kony.sdk.constants.DEVICEID_HEADER] = deviceId;
     }
     if (reportingData != null && reportingData != undefined) {
         try {
             defaultHeaders[kony.sdk.constants.REPORTING_HEADER] = reportingData;
         } catch (error) {
             kony.sdk.logsdk.error("### invokeObjectOperation::error while parsing metrics payload" + error);
         }
     }
     // if the user has defined his own headers, use them
     if (headers) {
         var tempHeader = "";
         for (var header in headers) {
             if (kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT.toLowerCase() === header.toLowerCase()) {
                 //Accept can be multiple
                 //Reason being client can be programmed to accept more than one type of content from server.
                 tempHeader = kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT;
                 if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
                     defaultHeaders[header] = defaultHeaders[tempHeader] + "," + headers[header];
                 }
             } else if (kony.sdk.constants.KONY_AUTHORIZATION_HEADER.toLowerCase() === header.toLowerCase()) {
                 tempHeader = kony.sdk.constants.KONY_AUTHORIZATION_HEADER;
                 if (defaultHeaders[tempHeader] !== headers[header]) {
                     defaultHeaders[tempHeader] = headers[header];
                 }
             } else if ("content-type" === header.toLowerCase()) {
                 tempHeader = kony.sdk.constants.HTTP_CONTENT_HEADER;
                 //Content-type can and should be a single value.
                 //Reason being client can only send a single kind of content at a single instance
                 if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
                     defaultHeaders[tempHeader] = headers[header];
                 }
             } else {
                 if (defaultHeaders[header] !== headers[header]) {
                     defaultHeaders[header] = headers[header];
                 }
             }
         }
     }

     function networksuccess(res) {
         kony.sdk.logsdk.perf("Executing Finished invokeObjectOperation");
         kony.sdk.verifyAndCallClosure(successCallback, res);
     }

     function networkerror(xhr, status, err) {
         kony.sdk.logsdk.trace("Entering networkerror");
         if (xhr && !(status && err)) {
             err = xhr;
         }
         if (err[kony.sdk.constants.MF_CODE]) {
             var konyRef = kony.sdk.getCurrentInstance();
             //clear the cache if the error code related to session/token expiry
             if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
                 kony.sdk.logsdk.warn("###ObjectService::invokeObjectOperationFailure  Session/Token expired. Authenticate and Try again");
                 //kony.sdk.resetCacheKeys(konyRef);
             }
         }
         kony.sdk.logsdk.perf("Executing Finished invokeObjectOperation");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
     }
     if (httpMethod === "GET") {
         networkProvider.get(url, null, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
     } else {
         networkProvider.post(url, formData, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
     }
 }
 kony.sdk.util = kony.sdk.util || {};
 kony.sdk.ObjectServiceUtil = kony.sdk.ObjectServiceUtil || {};
 kony.sdk.dto = kony.sdk.dto || {};
 kony.sdk.constants.DateTimeType = {
     TODAY: "TODAY",
     YESTERDAY: "YESTERDAY",
     TOMORROW: "TOMORROW",
     CURRENTWEEK: "CURRENTWEEK",
     LASTWEEK: "LASTWEEK",
     NEXTWEEK: "NEXTWEEK",
     CURRENTMONTH: "CURRENTMONTH",
     LASTMONTH: "LASTMONTH",
     NEXTMONTH: "NEXTMONTH"
 };
 kony.sdk.constants.Aggregation = {
     NONE: "",
     COUNT: "COUNT",
     SUM: "SUM",
     MAX: "MAX",
     MIN: "MIN",
     AVG: "AVG"
 };
 kony.sdk.constants.OrderType = {
     ASCENDING: "ASC",
     DESCENDING: "DESC"
 };
 kony.sdk.constants.MatchType = {
     EQUALS: {
         value: "=",
         name: "EQUALS"
     },
     GREATER: {
         value: ">",
         name: "GREATER"
     },
     GREATEREQUAL: {
         value: ">=",
         name: "GREATEREQUAL"
     },
     LESS: {
         value: "<",
         name: "LESS"
     },
     LESSEQUAL: {
         value: "<=",
         name: "LESSEQUAL"
     },
     STARTSWITH: {
         value: "LIKE",
         name: "STARTSWITH"
     },
     CONTAINS: {
         value: "LIKE",
         name: "CONTAINS"
     },
     LIKE: {
         value: "LIKE",
         name: "LIKE"
     },
     ENDSWITH: {
         value: "LIKE",
         name: "ENDSWITH"
     },
     NOTEQUAL: {
         value: "<>",
         name: "NOTEQUAL"
     },
     ISNULL: {
         value: "IS NULL",
         name: "ISNULL"
     },
     ISNOTNULL: {
         value: "IS NOT NULL",
         name: "ISNOTNULL"
     }
 };
 kony.sdk.constants.JoinType = {
     INNER: "INNER",
     LEFT: "LEFT",
     RIGHT: "RIGHT"
 };
 kony.sdk.constants.Operator = {
     AND: "AND",
     OR: "OR"
 };
 kony.sdk.constants.ObjectServiceConstants = {
     DATAOBJECT: "dataObject",
     QUERYPARAMS: "queryParams"
 };
 /**
  * This is a utility function used to check whether the two strings provided
  * would match with each other.
  * @param string1
  * @param string2
  * @return boolean
  */
 kony.sdk.util.matchIgnoreCase = function(string1, string2) {
     if (string1 === null || string2 === null || string1 === undefined || string2 === undefined) {
         return false;
     }
     return (string1.toUpperCase() === string2.toUpperCase());
 };
 kony.sdk.util.isNull = function(val) {
     if (val === null || val === undefined) return true;
     val = val + "";
     return (kony.sdk.util.matchIgnoreCase(val, "null"));
 };
 kony.sdk.util.isValidNumberType = function(val) {
     if (kony.sdk.util.matchIgnoreCase(typeof val, "number")) return true;
     else if (kony.sdk.util.matchIgnoreCase(typeof val, "string") && null != kony.sdk.util.toNumber(val)) return true;
     else return false;
 };
 kony.sdk.util.toNumber = function(arg) {
     if (arguments.length != 1) {
         throw new Error("Invalid argument to kony.sdk.util.toNumber");
     }
     if (typeof(arg) === "number") {
         return arg;
     } else if (typeof(arg) === "string") {
         var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
         if (str === '') {
             return null;
         } else {
             var num = str - 0;
             return (isNaN(num) ? null : num);
         }
     } else {
         return null;
     }
 };
 kony.sdk.util.validateCriteriaObject = function(criteria) {
     if (criteria !== null && criteria !== undefined) {
         return (criteria instanceof kony.sdk.dto.Criteria || criteria instanceof kony.sdk.dto.Match || criteria instanceof kony.sdk.dto.Between || criteria instanceof kony.sdk.dto.LogicGroup || criteria instanceof kony.sdk.dto.And || criteria instanceof kony.sdk.dto.Or || criteria instanceof kony.sdk.dto.Not || criteria instanceof kony.sdk.dto.Expression || criteria instanceof kony.sdk.dto.InCriteria || criteria instanceof kony.sdk.dto.Exists || criteria instanceof kony.sdk.dto.Join);
     } else {
         return false;
     }
 };
 kony.sdk.util.checkAndFetchNetworkProviderOptions = function(options) {
     var providerOptions = {};
     if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
         providerOptions["httpRequestOptions"] = options["httpRequestOptions"];
     }
     if (options && options["xmlHttpRequestOptions"] && options["xmlHttpRequestOptions"] instanceof Object) {
         providerOptions["xmlHttpRequestOptions"] = options["xmlHttpRequestOptions"];
     }
     return providerOptions;
 };
 kony.sdk.ObjectServiceUtil.cacheMetadata = function(serviceName, objects) {
     if (objects !== undefined && objects !== null) {
         kony.sdk.dataStore.removeItem(serviceName);
         for (var i = 0; i < objects.length; i++) {
             var object = objects[i];
             //clearing the existing metadata of service and updating it with the latest metadata
             kony.sdk.ObjectServiceUtil.cacheObjectMetadata(serviceName, object);
         }
     }
 };
 kony.sdk.ObjectServiceUtil.cacheObjectMetadata = function(serviceName, object) {
     if (object !== undefined && object !== null) {
         //getting metadata of servicename
         var metadataOfAllObjs = kony.sdk.dataStore.getItem(serviceName);
         var jsonObject = JSON.parse('{}');
         //if metadata available get it
         if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
             jsonObject = JSON.parse(metadataOfAllObjs);
         }
         //adding metadata of object to the existing metadata
         jsonObject[object.name] = object;
         var jsonStr = JSON.stringify(jsonObject);
         kony.sdk.dataStore.setItem(serviceName, jsonStr);
     }
 };
 kony.sdk.ObjectServiceUtil.getCachedMetadata = function(serviceName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.ObjectServiceUtil.getCachedMetadata");
     var appMetadata = kony.sdk.util.getPackagedMetadata();
     if (appMetadata != null && appMetadata != undefined) {
         if (serviceName != undefined && serviceName != null) return appMetadata[serviceName];
     } else {
         //reading metadata from the store
         var jsonObject = null;
         var metadataOfAllObjs = kony.sdk.dataStore.getItem(serviceName);
         if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
             jsonObject = JSON.parse(metadataOfAllObjs);
         }
         return jsonObject;
     }
     return null;
 };
 kony.sdk.ObjectServiceUtil.getCachedObjectMetadata = function(serviceName, objectName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.ObjectServiceUtil.getCachedObjectMetadata");
     var objectMetadata;
     if (objectName !== undefined && objectName !== null) {
         var metadataOfAllObjs = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
         var jsonObject = null;
         if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
             jsonObject = metadataOfAllObjs;
             //getting the object's metadata from the stored metadata
             objectMetadata = jsonObject[objectName];
         }
     }
     return objectMetadata;
 };
 /**
  * An object used to perform CRUD operations on objects
  * @param objectName
  * @param record
  * @constructor
  */
 kony.sdk.dto.DataObject = function(objectName, record) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.DataObject");
     this.objectName = objectName;
     if (record != null && record != undefined) {
         this.record = record;
     } else {
         this.record = {};
     }
     this.odataUrl = null;
     this.selectQueryObject = null;
     this.offlineObjectsOptions = {};
     this.setOfflineObjectsOptions = function(offlineObjectsOptions) {
         this.offlineObjectsOptions = offlineObjectsOptions;
     };
     this.getOfflineObjectsOptions = function() {
         return this.offlineObjectsOptions;
     };
     /**
      * This function is used to add fields and their values to the dataobject
      * @param fieldName
      * @param value
      */
     this.addField = function(fieldName, value) {
         this.record[fieldName] = value;
     };
     /**
      * This function is used to set a map of records to the dataobject
      * @param fieldValuesMap
      */
     this.setRecord = function(fieldValuesMap) {
         this.record = fieldValuesMap;
     };
     /**
      * This function is used to get the map of records present in the DataObject
      * @returns {JSON} record
      */
     this.getRecord = function() {
         return this.record;
     };
     /**
      * This function is used to add a child Dataobject into the data object
      * @param  childDataObject {@link kony.sdk.dto.DataObject}
      */
     this.addChildDataObject = function(childDataObject) {
         if (this.record[childDataObject.objectName] == null || this.record[childDataObject.objectName] == undefined) {
             this.record[childDataObject.objectName] = [];
         }
         this.record[childDataObject.objectName].push(childDataObject.getRecord());
     };
     /**
      * This function is used to set the odata url to query
      * @param odataUrl
      */
     this.setOdataUrl = function(odataUrl) {
         this.odataUrl = odataUrl;
     };
     /**
      * This function is used to get the odata url to query
      * @returns {null}
      */
     this.getOdataUrl = function() {
         return this.odataUrl;
     };
     /**
      * This function is used to set a SelectQueryObject {@link kony.sdk.dto.SelectQuery}
      * @param selectQueryObject {@link kony.sdk.dto.SelectQuery}
      */
     this.setSelectQueryObject = function(selectQueryObject) {
         this.selectQueryObject = selectQueryObject;
     };
     /**
      * This function is used to get a SelectQueryObject {@link kony.sdk.dto.SelectQuery}
      * @returns selectQueryObject {@link kony.sdk.dto.SelectQuery}
      */
     this.getSelectQueryObject = function() {
         return this.selectQueryObject;
     };
     /**
      * This function is used to get the object name
      * @returns objectName {string}
      */
     this.getObjectName = function() {
         return this.objectName;
     };
 };
 /**
  * This object is used to define a record object used in Offline CRUD
  * @constructor
  */
 kony.sdk.dto.RecordObject = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.RecordObject");
     this.tableName = "";
     this.columnValues = {};
     this.childRecords = [];
 };
 kony.sdk.util.getSyncDbName = function() {
     return kony.sync.getDBName();
 };
 kony.sdk.util.getPrimarykeysFromMetadata = function(objMetadata) {
     var tmpSrcAttributes = null;
     if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined && objMetadata.primaryKey.length > 0) {
         tmpSrcAttributes = {};
         var pkLen = objMetadata.primaryKey.length;
         for (var indx = 0; indx < pkLen; indx++) {
             var pKey = objMetadata.primaryKey[indx];
             //adding primarykey column names in srcattributes which will be useful while deleting children
             tmpSrcAttributes[pKey] = pKey;
         }
     }
     return tmpSrcAttributes;
 };
 /**
  * This is a replaceAll utility function
  * @param string
  * @param toReplace
  * @param replaceWith
  * @return String temp
  */
 kony.sdk.util.replaceAll = function(string, toReplace, replaceWith) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.replaceAll");
     var temp = string;
     var index = temp.indexOf(toReplace);
     while (index != -1) {
         temp = temp.replace(toReplace, replaceWith);
         index = temp.indexOf(toReplace);
     }
     return temp;
 };
 kony.sdk.util.validateDateTypeInput = function(dateType) {
     return (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TODAY) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TOMORROW) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.YESTERDAY) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTMONTH) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTMONTH) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTMONTH));
 };
 kony.sdk.util.getDateRange = function(dateType) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getDateRange");
     var result = [];
     var currentDate = new Date();
     var formattedDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds());
     var start;
     var end;
     if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TODAY)) {
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TOMORROW)) {
         formattedDate.setDate(formattedDate.getDate() + 1);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.YESTERDAY)) {
         formattedDate.setDate(formattedDate.getDate() - 1);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTWEEK)) {
         var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
         var lastDayofWeek = firstDayofWeek + 6;
         formattedDate.setDate(firstDayofWeek);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
         formattedDate.setDate(lastDayofWeek);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTWEEK)) {
         formattedDate.setDate(formattedDate.getDate() - 7);
         var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
         var lastDayofWeek = firstDayofWeek + 6;
         formattedDate.setDate(firstDayofWeek);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
         formattedDate.setDate(lastDayofWeek);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTWEEK)) {
         formattedDate.setDate(formattedDate.getDate() + 7);
         var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
         var lastDayofWeek = firstDayofWeek + 6;
         formattedDate.setDate(firstDayofWeek);
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
         formattedDate.setDate(lastDayofWeek);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTMONTH)) {
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), 1, 0, 0, 0);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 1, 0, 23, 59, 59);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTMONTH)) {
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth() - 1, 1, 0, 0, 0, 0);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), 0, 23, 59, 59, 999);
     } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTMONTH)) {
         start = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 1, 1, 0, 0, 0, 0);
         end = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 2, 0, 23, 59, 59, 999);
     } else {
         start = 0;
         end = 0;
     }
     result.push(start);
     result.push(end);
     return result;
 };
 //Helps to prepare the primary condition to get binary data
 kony.sdk.util.getPkTableForBinary = function(objMetadata, columnValues, failureCallback) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getPkTableForBinary");
     var pkTable = {};
     var whereClause = [];
     if (!kony.sdk.isNullOrUndefined(objMetadata.primaryKey)) {
         for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
             var pKey = objMetadata.primaryKey[indx];
             var pKeyValue = columnValues[pKey];
             if (kony.sdk.isNullOrUndefined(pKeyValue)) {
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                 return;
             }
             pkTable[pKey] = pKeyValue;
         }
         return pkTable;
     } else {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
     }
 };
 //Helps to provide the Metadata of column in a Object
 kony.sdk.util.getMetadataOfColumn = function(objMetadata, colName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getMetadataOfColumn");
     if (objMetadata != null && objMetadata != undefined) {
         var columns = objMetadata["columns"];
         if (columns != null && columns != undefined) {
             for (var indx in columns) {
                 var colMeta = columns[indx];
                 if (colMeta["name"] == colName) {
                     return colMeta;
                 }
             }
         }
     }
     return null;
 };
 //Helps in generating kony.sdk.dto.RecordObject from a given complex record
 kony.sdk.util.populateColumnValues = function(record, childRecords) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.populateColumnValues");
     var columnValues = {};
     var recordsLength = Object.keys(record).length;
     for (var index = 0; index < recordsLength; index++) {
         var colName = Object.keys(record)[index];
         var colVal = record[colName];
         if (colVal instanceof Array) {
             for (var tempIndex = 0; tempIndex < colVal.length; tempIndex++) {
                 var tempRecord = new kony.sdk.dto.RecordObject();
                 tempRecord.tableName = colName;
                 tempRecord.columnValues = kony.sdk.util.populateColumnValues(record[colName][tempIndex], tempRecord.childRecords);
                 childRecords.push(tempRecord);
             }
         } else {
             columnValues[colName] = colVal;
         }
     }
     return columnValues;
 };
 //Helps in getting the relationship data of an entity from a given relationship list
 kony.sdk.util.getRelationOfEntity = function(relationshipList, entityName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getRelationOfEntity");
     var i = 0;
     for (; i < relationshipList.length; i++) {
         //considering only OneToMany relationships as it will have parent and child hierarchy
         if (relationshipList[i] != null && relationshipList[i]["relationshipType"] == "OneToMany" && relationshipList[i].relatedEntity.localeCompare(entityName) == 0) {
             return relationshipList[i];
         }
     }
     return null;
 };
 //Helps in finding if a given column name is a primary key
 kony.sdk.util.isPrimaryKey = function(primaryKeyList, columnValue) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.isPrimaryKey");
     for (var i = 0; i < primaryKeyList.length; i++) {
         if (primaryKeyList[i] == columnValue) return true;
     }
     return false;
 };
 kony.sdk.util.objectToQueryParams = function(valueObject) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.objectToQueryParams ");
     var queryParams = "";
     if (!kony.sdk.isNullOrUndefined(valueObject) && valueObject instanceof Object && Object.keys(valueObject).length > 0) {
         var objCount = Object.keys(valueObject).length;
         for (var i = 0; i < objCount; i++) {
             var tempKey = Object.keys(valueObject)[i];
             if (queryParams.length === 0) queryParams = encodeURIComponent(tempKey) + "=" + encodeURIComponent(valueObject[tempKey]);
             else queryParams = queryParams + "&" + encodeURIComponent(tempKey) + "=" + encodeURIComponent(valueObject[tempKey]);
         }
     }
     return queryParams;
 };
 kony.sdk.util.getPackagedMetadata = function() {
     kony.sdk.logsdk.trace("Entering into   kony.sdk.util.getPackagedMetadata");
     if (kony.sdk.APP_META === undefined || kony.sdk.APP_META === null) {
         kony.sdk.APP_META = {};
     }
     return kony.sdk.APP_META["objectsvc_meta"];
 };
 /**
  User needs to call this API to prepackage the metadata of the app. The data needs to be passed as json object or a stringified version of json object
  */
 kony.sdk.util.setPackagedMetadata = function(metadataJson) {
     kony.sdk.logsdk.trace("Entering into   kony.sdk.util.setPackagedMetadata");
     try {
         if (typeof metadataJson == "object") {
             kony.sdk.APP_META = metadataJson;
         } else if (typeof metadataJson == "string") {
             var parsedMetadata = JSON.parse(metadataJson);
             kony.sdk.APP_META = parsedMetadata;
         }
     } catch (error) {
         kony.sdk.logsdk.error("### kony.sdk.setPackagedMetadata::error while validating the input packaged metadata", error);
     }
 };
 stripTrailingCharacter = function(str, character) {
     kony.sdk.logsdk.trace("Entering into stripTrailingCharacter");
     if (str.substr(str.length - 1) === character) {
         return str.substr(0, str.length - 1);
     }
     return str;
 };
 kony.sdk.setLogLevelFromServerResponse = function(responseHeaders) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.setLogLevelFromServerResponse");
     var sdkRef = kony.sdk.getCurrentInstance();
     if (responseHeaders && responseHeaders[kony.logger.deviceLogLevelHeader]) {
         logLevel = responseHeaders[kony.logger.deviceLogLevelHeader].toUpperCase();
         if (!logLevel.localeCompare(kony.logger.logLevel.NONE.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.NONE) kony.logger.currentLogLevel = kony.logger.logLevel.NONE;
         else if (!logLevel.localeCompare(kony.logger.logLevel.FATAL.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.FATAL) kony.logger.currentLogLevel = kony.logger.logLevel.FATAL;
         else if (!logLevel.localeCompare(kony.logger.logLevel.ERROR.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.ERROR) kony.logger.currentLogLevel = kony.logger.logLevel.ERROR;
         else if (!logLevel.localeCompare(kony.logger.logLevel.WARN.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.WARN) kony.logger.currentLogLevel = kony.logger.logLevel.WARN;
         else if (!logLevel.localeCompare(kony.logger.logLevel.PERF.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.PERF) kony.logger.currentLogLevel = kony.logger.logLevel.PERF;
         else if (!logLevel.localeCompare(kony.logger.logLevel.INFO.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.INFO) kony.logger.currentLogLevel = kony.logger.logLevel.INFO;
         else if (!logLevel.localeCompare(kony.logger.logLevel.DEBUG.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.DEBUG) kony.logger.currentLogLevel = kony.logger.logLevel.DEBUG;
         else if (!logLevel.localeCompare(kony.logger.logLevel.TRACE.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.TRACE) kony.logger.currentLogLevel = kony.logger.logLevel.TRACE;
         else if (!logLevel.localeCompare(kony.logger.logLevel.ALL.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.ALL) kony.logger.currentLogLevel = kony.logger.logLevel.ALL;
         else if (!logLevel.localeCompare('OFF')) {
             kony.logger.deactivatePersistors(kony.logger.networkPersistor);
             kony.logger.currentLogLevel = kony.logger.logLevel.NONE;
             sdkRef.removeGlobalRequestParam(kony.logger.deviceLogLevelHeader, sdkRef.globalRequestParamType.headers);
             return;
         } else {
             return;
         }
         sdkRef.setGlobalRequestParam(kony.logger.deviceLogLevelHeader, logLevel, sdkRef.globalRequestParamType.headers);
         kony.logger.activatePersistors(kony.logger.networkPersistor);
     }
 };
 kony.sdk.prototype.enableDebug = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.prototype.enableDebug");
     kony.sdk.isDebugEnabled = true;
 };
 kony.sdk.prototype.disableDebug = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.prototype.disableDebug");
     kony.sdk.isDebugEnabled = false;
 };

 function Exception(name, message) {
     kony.sdk.logsdk.error("Exception --> " + name + ": " + message);
     return {
         code: name,
         message: message
     };
 }
 kony.sdk.verifyAndCallClosure = function(closure, params) {
     if (typeof(closure) === 'function') {
         closure(params);
     } else {
         kony.sdk.logsdk.warn("invalid callback", JSON.stringify(closure));
     }
 };
 kony.sdk.overrideUserId = function(userId) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.overrideUserId");
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && typeof(kony.setUserID) === 'function') {
         kony.setUserID(userId, true);
     } else {
         konyRef.setCurrentUserId(userId);
     }
 };
 kony.sdk.formatCurrentDate = function(inputDateString) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.formatCurrentDate");
     var dateObj = new Date(inputDateString);
     var year = dateObj.getUTCFullYear();
     var month = kony.sdk.formatDateComponent(dateObj.getUTCMonth() + 1);
     var date = kony.sdk.formatDateComponent(dateObj.getUTCDate());
     var hours = kony.sdk.formatDateComponent(dateObj.getUTCHours());
     var minutes = kony.sdk.formatDateComponent(dateObj.getUTCMinutes());
     var seconds = kony.sdk.formatDateComponent(dateObj.getUTCSeconds());
     var dateSeparator = "-";
     var timeSeparator = ":";
     var dateString = year + dateSeparator + month + dateSeparator + date + " " + hours + timeSeparator + minutes + timeSeparator + seconds;
     return dateString;
 };
 kony.sdk.formatDateComponent = function(dateComponent) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.formatDateComponent");
     if (dateComponent < 10) {
         dateComponent = "0" + dateComponent;
     }
     return dateComponent;
 };
 kony.sdk.isNullOrUndefined = function(val) {
     if (val === null || val === undefined) {
         return true;
     } else {
         return false;
     }
 };
 kony.sdk.constants.reportingType = {
     session: "session",
     custom: "custom"
 };
 kony.sdk.isEmptyObject = function(obj) {
     if (typeof(obj) === "boolean" || typeof(obj) === "number") {
         return false;
     } else if (typeof(obj) === "string") {
         return obj.trim().length === 0;
     }
     for (var prop in obj) {
         return false;
     }
     return true;
 };
 kony.sdk.util.isNullOrUndefinedOrEmptyObject = function(object) {
     return (kony.sdk.isNullOrUndefined(object) || kony.sdk.isEmptyObject(object));
 };
 kony.sdk.isArray = function(data) {
     if (data && Object.prototype.toString.call(data) === '[object Array]') {
         return true;
     }
     return false;
 };
 kony.sdk.formatSuccessResponse = function(data) {
     if (data && data.httpresponse) {
         delete data.httpresponse;
     }
     return data;
 };
 kony.sdk.isJson = function(str) {
     try {
         JSON.parse(str);
     } catch (e) {
         return false;
     }
     return true;
 };
 kony.sdk.util.getString = function(val) {
     if (!kony.sdk.isNullOrUndefined(val) && (val.toString()).toLocaleLowerCase() !== "null") {
         return val.toString();
     }
     return "";
 };
 //private method to identify whether session/token expired or not based on error code
 kony.sdk.isSessionOrTokenExpired = function(mfcode) {
     if (mfcode && (mfcode === "Auth-5" || mfcode === "Auth-6" || mfcode === "Gateway-31" || mfcode === "Gateway-33" || mfcode === "Gateway-35" || mfcode === "Gateway-36" || mfcode === "Auth-46" || mfcode === "Auth-55")) {
         return true;
     }
     return false;
 };
 //private method to clear cache
 kony.sdk.resetProviderKeys = function(konyRef, _providerName) {
     try {
         if (konyRef) {
             if (_providerName) {
                 if (konyRef.tokens.hasOwnProperty(_providerName)) {
                     konyRef.tokens[_providerName] = null;
                 }
             }
         }
     } catch (e) {
         kony.sdk.logsdk.error("Error while clearing the cache..");
     }
 };
 //private method to clear cache
 kony.sdk.resetCurrentKeys = function(konyRef, _providerName) {
     try {
         if (konyRef) {
             konyRef.currentClaimToken = null;
             konyRef.currentBackEndToken = null;
             konyRef.claimTokenExpiry = null;
             konyRef.currentRefreshToken = null;
             //setting the anonymous provider as true to access the public protected urls without any issue
             konyRef.isAnonymousProvider = true;
             if (_providerName) {
                 if (konyRef.tokens.hasOwnProperty(_providerName)) {
                     konyRef.tokens[_providerName] = null;
                 }
             }
         }
     } catch (e) {
         kony.sdk.logsdk.error("Error while clearing the cache..");
     }
 };
 kony.sdk.util.populateIndividualServiceLists = function(serviceConfig, objectToPopulate) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.populateIndividualServiceLists");
     var svcMeta = serviceConfig["services_meta"];
     if (kony.sdk.isNullOrUndefined(objectToPopulate["objectsvc"])) {
         objectToPopulate["objectsvc"] = {};
     }
     if (kony.sdk.isNullOrUndefined(objectToPopulate["offlineObjectsvc"])) {
         objectToPopulate["offlineObjectsvc"] = {};
     }
     if (svcMeta) {
         for (var svc in svcMeta) {
             if (svcMeta.hasOwnProperty(svc)) {
                 var svcObj = svcMeta[svc];
                 if (svcObj && svcObj["type"] === "objectsvc") {
                     if (!kony.sdk.isNullOrUndefined(svcObj["offline"])) {
                         if (svcObj["offline"] === false) {
                             objectToPopulate["objectsvc"][svc] = svcObj;
                         } else if (svcObj["offline"] === true) {
                             objectToPopulate["offlineObjectsvc"][svc] = svcObj;
                         }
                     } else {
                         objectToPopulate["objectsvc"][svc] = svcObj;
                         objectToPopulate["offlineObjectsvc"][svc] = svcObj;
                     }
                 } else if (svcObj && svcObj["type"] === "integsvc") {
                     objectToPopulate["integsvc"][svc] = svcObj;
                 }
             }
         }
     }
 };
 /**
  * Generates hash code for the URL by sha512 algorithm
  * @param url
  * @param requestParams
  * @return {*}
  */
 kony.sdk.util.generateHashcodeForURL = function(url, requestParams) {
     var concatenatedResult = "";
     var hashID = null;
     if (!kony.sdk.isNullOrUndefined(url)) concatenatedResult += url;
     if (!kony.sdk.isNullOrUndefined(requestParams)) {
         concatenatedResult += JSON.stringify(requestParams);
     }
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && !kony.sdk.util.isNullOrEmptyString(concatenatedResult)) {
         hashID = kony.crypto.createHash("sha512", concatenatedResult);
     }
     return hashID;
 };
 /**
  * Utility function to save the response in the cache.
  * @param options {object} save the response with key options["cacheID"]. If not provided then we will calculate hashcode by url and requestData.
  * @param url {string}
  * @param requestData {object}
  * @param response {object}
  */
 function cacheResponseForKey(options, url, requestData, response) {
     var hashCode = null;
     if (options["cacheID"]) hashCode = options["cacheID"];
     else hashCode = kony.sdk.util.generateHashcodeForURL(url, requestData);
     if (hashCode) {
         if (typeof(hashCode) !== "string") {
             hashCode = hashCode.toString();
         }
         var expiry = options["expiryTime"] ? options["expiryTime"] : kony.sdk.constants.DEFAULT_CACHE_EXPIRY_TIME;
         response["cacheID"] = hashCode;
         new kony.sdk.ClientCache().add(hashCode, response, expiry);
     }
 }
 kony.sdk.util.isNullOrEmptyString = function(val) {
     if (kony.sdk.isNullOrUndefined(val) || (typeof(val) === "string" && val.trim() === "")) {
         return true;
     }
     return false;
 };

 function doesMFSupportsAppversioning() {
     // In case of IDE platforms we will check the existence of appConfig.svcDoc.service_doc_etag for compatibility of app version with the MF.
     // In case of plain-js & phone gap initOptions should not be sent during init call.
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && !kony.sdk.isNullOrUndefined(appConfig) && !kony.sdk.isNullOrUndefined(appConfig.svcDoc) && !kony.sdk.isNullOrUndefined(appConfig.svcDoc.service_doc_etag)) {
         return true;
     } else if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PLAIN_JS || kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PHONEGAP) {
         return true;
     } else {
         return false;
     }
 }

 function populateHeaderWithFabricAppVersion(headers) {
     if (doesMFSupportsAppversioning() && !kony.sdk.isNullOrUndefined(headers) && !kony.sdk.isNullOrUndefined(kony.sdk.getFabricAppVersion())) {
         headers[kony.sdk.constants.APP_VERSION_HEADER] = kony.sdk.getFabricAppVersion();
     }
 }
 /*
  * Utility method to check whether options has browserWidget or not
  * @return true if it supports
  * */
 kony.sdk.util.hasBrowserWidget = function(options) {
     return options && options[kony.sdk.constants.BROWSER_WIDGET] && kony.sdk.util.type(options[kony.sdk.constants.BROWSER_WIDGET]) === "kony.ui.Browser";
 };
 /*
  * Utility method to check whether binary is supported
  * @return true if it supports
  * */
 kony.sdk.util.isBinarySupported = function() {
     return kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE;
 };
 /**
  * Utility method to populate authorization headers for Login
  *
  * @params headers map for adding authorization headers
  * @params _providerName provider name for SSO
  * */
 kony.sdk.util.populateAuthorizationHeaderForLogin = function(headers, _providerName) {
     if (kony.sdk.sso.isSSOEnabled === true) {
         var ssotoken = kony.sdk.util.getSSOTokenForProvider(_providerName);
         if (!kony.sdk.util.isNullOrEmptyString(ssotoken)) {
             headers[kony.sdk.constants.AUTHORIZATION_HEADER] = ssotoken;
         } else {
             kony.sdk.logsdk.warn("SSO Token retrieved is empty.");
         }
     } else if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && (new Date().getTime() < konyRef.claimTokenExpiry)) {
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     }
 };
 /**
  * Returns the SSO token for the provider.
  *
  *@param _providerName provider for which token is to be deleted
  * @return SSO token
  */
 kony.sdk.util.getSSOTokenForProvider = function(_providerName) {
     kony.sdk.logsdk.trace("Entered Method : getSSOTokenForProvider.");
     var tokenString = kony.sdk.util.getSSOToken();
     if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
         kony.sdk.logsdk.warn("SSO token is either empty,null or undefined for provider:" + _providerName);
         return null;
     }
     var tokenJSON = JSON.parse(tokenString);
     return tokenJSON[_providerName.toLowerCase()];
 };
 /**
  * Add/Replace and Returns the stringified SSO JSON with
  * the new token and provider or
  * updates the existing one.
  *
  * @param ssoToken token to be added or updated
  * @param _providerName for which the token has to be added
  *
  * @return  Stringified SSO token JSON"{*}"
  */
 kony.sdk.util.addOrUpdateSSOTokenWithProvider = function(ssoToken, _providerName) {
     kony.sdk.logsdk.trace("Entered Method : addOrUpdateSSOTokenWithProvider.");
     var tokenJSON = {};
     var tokenString = kony.sdk.util.getSSOToken();
     if (!kony.sdk.util.isNullOrEmptyString(tokenString)) {
         tokenJSON = JSON.parse(tokenString);
     }
     tokenJSON[_providerName.toLowerCase()] = ssoToken;
     return JSON.stringify(tokenJSON);
 };
 /**
  * Deletes the SSO Token for the
  *
  * @parmas _providerName for which the token has to be deleted
  */
 kony.sdk.util.deleteSSOTokenForProvider = function(_providerName) {
     kony.sdk.logsdk.trace("Entered Method: deleteSSOTokenForProvider.");
     var tokenString = kony.sdk.util.getSSOToken();
     if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
         kony.sdk.logsdk.warn("SSO token is either empty,null or undefined for provider:" + _providerName);
         return null;
     }
     var tokenJSON = JSON.parse(tokenString);
     delete tokenJSON[_providerName.toLowerCase()];
     kony.sdk.util.saveSSOToken(JSON.stringify(tokenJSON));
 };
 /*
  ** Utility method to clone any object
  *  @return cloned object
  */
 kony.sdk.cloneObject = function(obj) {
     var clonedObject;
     try {
         clonedObject = JSON.parse(JSON.stringify(obj));
     } catch (err) {
         kony.sdk.logsdk.error("cloning object failed, reverting back to copy");
         clonedObject = obj;
     }
     return clonedObject;
 };
 /**
  * Utility method to check if a given variable is JSON Object
  * @param obj
  * @returns {boolean}
  */
 kony.sdk.util.isJsonObject = function(obj) {
     if (obj === null || obj === undefined) {
         return false;
     }
     return obj.constructor === {}.constructor;
 };
 /**
  * Utility method to check whether the given variable is a valid string
  * @param str
  * @returns {boolean}
  */
 kony.sdk.util.isValidString = function(str) {
     if (str === null || str === undefined || str.constructor !== "".constructor) {
         return false;
     }
     return str.trim() !== ""
 };
 /**
  * Utility method to convert JSON object keys to lower case
  * @param obj {Object} - JSON object
  * @returns convertedJSON {Object} - JSON object keys in lower case and values assigned to respective keys.
  */
 kony.sdk.util.convertJsonKeysToLowerCase = function(obj) {
     var convertedJSON = {};
     if (!kony.sdk.util.isJsonObject(obj)) {
         return obj;
     }
     var keys = Object.keys(obj);
     for (var i = 0; i < keys.length; i++) {
         convertedJSON[keys[i].toLowerCase()] = obj[keys[i]];
     }
     return convertedJSON;
 };
 /**
  * Utility method to get JSON property case-insensitively
  * @param {Object} jsonObject
  * @param {String} key
  * @returns {*}
  */
 kony.sdk.util.getValueForKeyAndIgnoreCase = function(jsonObject, key) {
     var keysInJSON = Object.keys(jsonObject);
     var index = 0;
     for (var jsonKey in keysInJSON) {
         if (keysInJSON[jsonKey].toLocaleLowerCase() === key.toLocaleLowerCase()) {
             return Object.values(jsonObject)[index];
         } else {
             index++
         }
     }
     return null;
 };
 /**
  * Utility method to populate JSON Template
  * @param {String} template
  * @param {Object} templateParams : Input Params provided by the User
  * @return Object containing processed template and missing variables
  */
 kony.sdk.util.populateTemplate = function(template, templateParams) {
     if (kony.sdk.util.isNullOrEmptyString(template) || !kony.sdk.util.isJsonObject(templateParams)) {
         kony.sdk.logsdk.error(kony.sdk.errorConstants.populating_template_failed + " " + kony.sdk.errormessages.populating_template_failed);
         return null;
     }
     var DOLLAR_VARIABLE_PATTERN = /(\${)+(\w.*?)+(})/g;
     var templateVariables = [];
     var missingVariables = [];
     var resultSet = {};
     var populatedTemplate = kony.sdk.cloneObject(template);
     var inputTemplateVariables = populatedTemplate.match(DOLLAR_VARIABLE_PATTERN);
     //Match returns Array of all the matches.
     //Iterating over the array and extracting all template variables.
     for (var iteratorVariable in inputTemplateVariables) {
         var inputVariable = inputTemplateVariables[iteratorVariable].toString();
         var templateParameter = inputVariable.slice(2, (inputVariable.length) - 1);
         templateVariables.push(templateParameter);
     }
     //Populating the template with user inputs.
     for (var iterateVariable = 0; iterateVariable < templateVariables.length; iterateVariable++) {
         var inputParameter = templateVariables[iterateVariable];
         if (templateParams.hasOwnProperty(inputParameter)) {
             populatedTemplate = populatedTemplate.replace("${" + inputParameter + "}", templateParams[inputParameter]);
         } else {
             missingVariables.push(inputParameter);
         }
     }
     resultSet[kony.sdk.constants.PROCESSED_TEMPLATE] = populatedTemplate;
     resultSet[kony.sdk.constants.MISSING_VARIABLES] = missingVariables;
     return resultSet;
 };
 /**
  * Checks if the browser is IE11
  * @returns {boolean}
  */
 kony.sdk.util.checkForIE11 = function() {
     //Checking if this is being run in DesktopWeb
     if (typeof(XMLHttpRequest) !== 'undefined') {
         var ua = window.navigator.userAgent;
         var trident = ua.indexOf('Trident/');
         if (trident > 0) {
             // IE 11 => return version number
             var rv = ua.indexOf('rv:');
             return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10) === 11;
         }
     }
     return false;
 };
 /**
  * Utility method to get persistToken flag from data store
  *
  * @returns {boolean}
  */
 kony.sdk.util.isPersistentLoginResponseEnabled = function() {
         var dataStore = new konyDataStore();
         var persistTokenFlag = dataStore.getItem("persistLoginResponseFlag");
         if (!kony.sdk.isNullOrUndefined(persistTokenFlag) && persistTokenFlag === true) {
             return true;
         }
         return false;
     }
     /**
      * Based on interactive or non-interactive session info from license, returning session type
      * @return {string}
      */
 kony.sdk.util.getSessionType = function() {
     var sessionType;
     if (kony.licensevar && kony.licensevar.isInteractive != undefined) {
         sessionType = kony.licensevar.isInteractive ? kony.sdk.constants.APP_SESSION_INTERACTIVE : kony.sdk.constants.APP_SESSION_NON_INTERACTIVE;
     } else {
         /**
          *In case of phonegap and plain js, we are sending interacting session.
          */
         kony.sdk.logsdk.trace("Updating interacting session in kony reporting params by default");
         sessionType = kony.sdk.constants.APP_SESSION_INTERACTIVE;
     }
     return sessionType;
 };
 /**
  * Utility method to get kony reporting params in encoded string
  * @return {string}
  */
 kony.sdk.getEncodedReportingParamsForSvcid = function(svcid) {
     var reportingData = kony.sdk.getPayload(konyRef);
     reportingData.rsid = kony.sdk.currentInstance.getSessionId();
     if (svcid) {
         reportingData.svcid = svcid;
     } else {
         kony.sdk.logsdk.warn("### kony.sdk.getEncodedReportingParamsForSvcid:: svcid is either null or undefined");
     }
     return encodeURI(JSON.stringify(reportingData));
 };
 /**
  * Utility method to know if PWA app's display mode is standalone or fullscreen
  * @returns {boolean}
  */
 kony.sdk.util.isPWAStandaloneOrFullscreen = function() {
         if (!kony.sdk.isNullOrUndefined(window) && window.matchMedia && ((window.matchMedia('(display-mode: standalone)').matches) || (window.matchMedia('(display-mode: fullscreen)').matches) || (window.navigator && window.navigator.standalone))) {
             return true;
         } else {
             return false;
         }
     }
     /**
      * Utility method to know if the device is a mobile device
      * @returns {boolean}
      */
 kony.sdk.util.isMobileDevice = function() {
         if (!kony.sdk.isNullOrUndefined(navigator) && (/mobile/gi).test(navigator.userAgent)) {
             return true;
         } else {
             return false;
         }
     }
     /**
      * Utility method to open a new browser window as popup in the center of device screen
      * @returns {WindowProxyObject on success of window open and null on failure}
      */
 kony.sdk.util.openPopupWindow = function(url, title) {
     var height = (screen.height * 75) / 100;
     var width = (screen.width * 40) / 100;
     var left = (screen.width / 2) - (width / 2);
     var top = (screen.height / 2) - (height / 2);
     return window.open(url, title, 'width=' + width + ', height=' + height + ', top=' + top + ', left=' + left);
 }
 kony.sdk.serviceDoc = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.serviceDoc");
     var appId = "";
     var baseId = "";
     var services_meta = {};
     var name = "";
     var selflink = "";
     var login = null;
     var integsvc = {};
     var reportingsvc = {};
     var messagingsvc = {};
     var sync = {};
     var objectsvc = {};
     var logicsvc = {};
     this.toJSON = function() {
         servConfig = {};
         servConfig.appId = this.getAppId();
         servConfig.baseId = this.getBaseId();
         servConfig.name = this.getAppName();
         servConfig.selflink = this.getSelfLink();
         servConfig.services_meta = this.getServicesMeta();
         servConfig.login = this.getAuthServices();
         servConfig.integsvc = this.getIntegrationServices();
         servConfig.messagingsvc = this.getMessagingServices();
         servConfig.sync = this.getSyncServices();
         servConfig.reportingsvc = this.getReportingServices();
         servConfig.objectsvc = this.getObjectServices();
         servConfig.logicsvc = this.getLogicServices();
         kony.sdk.util.populateIndividualServiceLists(this, servConfig);
         return servConfig;
     }
     this.setAppId = function(appIdStr) {
         appId = appIdStr;
     };
     this.getAppId = function() {
         return appId;
     };
     this.setBaseId = function(baseIdStr) {
         baseId = baseIdStr;
     };
     this.getBaseId = function() {
         return baseId;
     };
     this.setAppName = function(appName) {
         name = appName;
     };
     this.getAppName = function() {
         return name;
     };
     this.setSelfLink = function(selfLinkStr) {
         selflink = selfLinkStr;
     };
     this.getSelfLink = function() {
         return selflink;
     };

     function setEndPoints(providerType, providerValues) {
         for (var provider in providerValues) {
             providerType[provider] = providerValues[provider];
         }
     }
     this.setAuthService = function(loginProvider) {
         if (login === null) {
             login = [];
         }
         login.push(loginProvider);
     };
     //what will this return? name?
     this.getAuthServiceByName = function(authServiceProvider) {
         if (login === null) {
             return null;
         }
         for (var i in login) {
             var provider = login[i];
             if (provider.prov == authServiceProvider) {
                 return provider;
             }
         }
     };
     this.getAuthServices = function() {
         return login;
     };
     this.setIntegrationService = function(providerName, endPointUrl) {
         integsvc[providerName] = endPointUrl;
     };
     this.getIntegrationServiceByName = function(integrationServiceProviderName) {
         return integsvc[integrationServiceProviderName];
     };
     this.getIntegrationServices = function() {
         return integsvc;
     };
     this.setObjectService = function(providerName, endPointUrl) {
         objectsvc[providerName] = endPointUrl;
     };
     this.getObjectServiceByName = function(objectServiceProviderName) {
         return objectsvc[objectServiceProviderName];
     };
     this.getObjectServices = function() {
         return objectsvc;
     };
     this.getLogicServices = function() {
         return logicsvc;
     };
     this.getServicesMeta = function() {
         return services_meta;
     };
     this.setReportingService = function(reportingType, url) {
         if (reportingType == kony.sdk.constants.reportingType.session || reportingType == kony.sdk.constants.reportingType.custom) {
             reportingsvc[reportingType] = url;
         } else {
             throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid reporting type " + reportingType);
         }
     }
     this.getReportingServiceByType = function(reportingServiceProviderType) {
         return reportingsvc[reportingServiceProviderType];
     };
     this.getReportingServices = function() {
         return reportingsvc;
     };
     this.setMessagingService = function(appId, url) {
         messagingsvc[appId] = url;
     };
     this.getMessagingServiceByName = function(messagingServiceProviderName) {
         return messagingsvc[messagingServiceProviderName];
     };
     this.getMessagingServices = function() {
         return messagingsvc;
     }
     this.setSyncService = function(syncServiceProvider) {
         sync = syncServiceProvider;
     };
     this.getSyncServices = function() {
         return sync;
     };
 };
 kony.logger = kony.logger || {};
 kony.logger = {
     // Logger constants
     networkPersistorUrlEndpoint: "deviceLogs",
     deviceLogLevelHeader: "X-KONY-DEVICE-LOG-LEVEL",
     filePersistor: 1,
     consolePersistor: 2,
     networkPersistor: 4,
     // Log Level Block which gives all the handle for setting and getting
     //ALL(0) < TRACE(1) < DEBUG(2) < INFO(4) < PEF(8) < WARN(16) < ERROR(32) < FATAL(64) < NONE(127)
     logLevel: {
         NONE: {
             value: 127,
             name: "none",
             code: "NONE"
         },
         FATAL: {
             value: 64,
             name: "fatal",
             code: "FATAL"
         },
         ERROR: {
             value: 32,
             name: "error",
             code: "ERROR"
         },
         WARN: {
             value: 16,
             name: "warn",
             code: "WARN"
         },
         PERF: {
             value: 8,
             name: "perf",
             code: "PERF"
         },
         INFO: {
             value: 4,
             name: "info",
             code: "INFO"
         },
         DEBUG: {
             value: 2,
             name: "debug",
             code: "DEBUG"
         },
         TRACE: {
             value: 1,
             name: "trace",
             code: "TRACE"
         },
         ALL: {
             value: 0,
             name: "all",
             code: "ALL"
         }
     },
     get currentLogLevel() {
         if (typeof(currentLevel) === 'undefined') currentLevel = kony.logger.logLevel.NONE;
         if (kony.logger.isNativeLoggerAvailable()) {
             var logLevelValue = KonyLogger.getLogLevel();
             for (var key in kony.logger.logLevel) {
                 if (kony.logger.logLevel.hasOwnProperty(key)) {
                     if (kony.logger.logLevel[key].value == logLevelValue) {
                         currentLevel = kony.logger.logLevel[key];
                         break;
                     }
                 }
             }
         }
         return currentLevel;
     },
     set currentLogLevel(level) {
         currentLevel = level;
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.setLogLevel(currentLevel.value);
     },
     isNativeLoggerAvailable: function() {
         if (typeof(KonyLogger) === 'undefined') return false;
         else return true;
     },
     flush: function() {
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.flush();
     },
     // Persister block for activating and deactivating
     activatePersistors: function(activatedList) {
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.activatePersistors(activatedList);
     },
     deactivatePersistors: function(deactivatedList) {
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.deactivatePersistors(deactivatedList);
     },
     //setting claims token after referesh
     setClaimsToken: function() {
         var token = kony.sdk.getCurrentInstance().currentClaimToken;
         if (kony.logger.isNativeLoggerAvailable()) KonyLogger.setClaimsToken(token);
     },
     setConfig: function(loggerConfig) {
         if (kony.logger.isNativeLoggerAvailable()) {
             KonyLogger.setConfig(loggerConfig.getLoggerConfig());
         }
     },
     setPersistorConfig: function(persistor) {
         if (kony.logger.isNativeLoggerAvailable()) {
             KonyLogger.setPersistorConfig(persistor.getPersistorConfig());
         }
     },
     createLoggerObject: function(loggerName, loggerConfig) {
         var loggerObj = {};
         loggerObj.config = parseConfig(loggerConfig);
         loggerObj.trace = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.TRACE, msg, params);
         };
         loggerObj.debug = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.DEBUG, msg, params);
         };
         loggerObj.info = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.INFO, msg, params);
         };
         loggerObj.perf = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.PERF, msg, params);
         };
         loggerObj.warn = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.WARN, msg, params);
         };
         loggerObj.error = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.ERROR, msg, params);
         };
         loggerObj.fatal = function(msg, params) {
             logMessage(loggerObj, kony.logger.logLevel.FATAL, msg, params);
         };
         var indirectionLevel = 0;
         loggerObj.setIndirectionLevel = function(_indirectionLevel) {
             indirectionLevel = _indirectionLevel;
         }
         loggerObj.getIndirectionLevel = function() {
             return indirectionLevel;
         }
         loggerObj.loggerName = loggerName;
         return loggerObj;
     },
     createLoggerConfig: function() {
         var formatC = {};
         var logFilterC = {};
         var accConfig = {};
         var overrideConfig = null;
         var persistorList = [];
         var config = {
             //formatterConfig
             //timeformat
             set timeFormat(val) {
                 formatC.timeFormat = val;
             },
             //timeZone
             set timeZone(val) {
                 formatC.timeZone = val;
             },
             //FilterConfig
             //logLevel
             set logLevel(val) {
                 logFilterC.logLevel = val;
             },
             //accumulatorConfig
             //bytesLimit
             set bytesLimit(val) {
                 accConfig.bytesLimit = val;
             },
             //statementsLimit
             set statementsLimit(val) {
                 accConfig.statementsLimit = val;
             },
             //overrideConfig
             set overrideConfig(val) {
                 overrideConfig = val;
             },
             //peristorList
             get persistorList() {
                 return persistorList;
             },
             addPersistor: function(val) {
                 persistorList.push(val.getPersistorConfig());
             },
             getLoggerConfig: function() {
                 var loggerConfig = {};
                 if (Object.keys(formatC).length > 0) loggerConfig.formatterConfig = formatC;
                 if (Object.keys(logFilterC).length > 0) loggerConfig.logFilterConfig = logFilterC;
                 if (Object.keys(accConfig).length > 0) loggerConfig.accumulatorConfig = accConfig;
                 if (overrideConfig !== null) loggerConfig.overrideConfig = overrideConfig;
                 loggerConfig.persistors = persistorList;
                 return loggerConfig;
             }
         };
         return config;
     },
     createFilePersistor: function() {
         var prop = {};
         var persistorProperties = {
             //Persistor properites
             get persistorType() {
                 return kony.logger.filePersistor;
             },
             //maxNumberOfLogFiles
             set maxNumberOfLogFiles(val) {
                 prop.maxNumberOfLogFiles = val;
             },
             //maxFileSize
             set maxFileSize(val) {
                 prop.maxFileSize = val;
             },
             getPersistorConfig: function() {
                 var perConfig = {};
                 perConfig.type = this.persistorType;
                 if (Object.keys(prop).length > 0) perConfig.properties = prop;
                 return perConfig;
             }
         };
         return persistorProperties;
     },
     createNetworkPersistor: function() {
         var prop = {};
         var persistorProperties = {
             //persistorType
             get persistorType() {
                 return kony.logger.networkPersistor;
             },
             //URL
             set URL(val) {
                 prop.URL = val;
             },
             getPersistorConfig: function() {
                 var perConfig = {};
                 perConfig.type = this.persistorType;
                 if (Object.keys(prop).length > 0) perConfig.properties = prop;
                 return perConfig;
             }
         };
         return persistorProperties;
     },
     appLoggerInitialisation: function() {
         var loggerObj = {};
         loggerObj = new kony.logger.createNewLogger(kony.sdk.constants.APP_LOGGER_NAME, null);
         return loggerObj;
     },
     isValidJSTable: function(inputTable) {
         if (kony.sdk.isNullOrUndefined(inputTable)) {
             return false;
         }
         if (typeof inputTable === "object" || typeof inputTable === "Object" || typeof inputTable === "Array" || typeof inputTable === "array") {
             return true;
         } else {
             return false;
         }
     }
 };
 kony.sdk.FileStorageClasses = (function() {
     var instance = null;
     var LOG_PREFIX = "kony.FileStorageAdapter";
     "use strict";

     function createInstance(url) {
         kony.sdk.logsdk.trace(LOG_PREFIX + ": Creating instance of FileStorageClasses");
         var obj = {};
         obj.listFiles = function(filter, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking list files");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("listFiles : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 //Calling FileStorage listFiles API.
                 kony.sdk.FileStorageClasses.listFiles(url, filter, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("listFiles : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.upload = function(uploadInputType, uploadParams, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking upload");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("upload : Refresh claims token SUCCESS");
                 var headers = uploadParams["headers"];
                 headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 uploadParams["headers"] = headers;
                 //Calling FileStorage upload API.
                 kony.sdk.FileStorageClasses.upload(url, uploadInputType, uploadParams, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("upload : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.download = function(downloadParams, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking downloadFile");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("downloadFile : Refresh claims token SUCCESS");
                 var headers = downloadParams["headers"];
                 headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 downloadParams["headers"] = headers;
                 kony.sdk.FileStorageClasses.download(url, downloadParams, successCallback, failureCallback, options);
             }.bind(this), function(error) { //claims refresh failure callback
                 kony.sdk.logsdk.error("upload : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.deleteById = function(fileId, deleteParams, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking deleteById");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("deleteById : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 kony.sdk.FileStorageClasses.deleteById(url, fileId, deleteParams, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("deleteById : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.deleteByCriteria = function(deleteParams, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking deleteByCriteria");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("deleteByCriteria : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 kony.sdk.FileStorageClasses.deleteByCriteria(url, deleteParams, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("deleteByCriteria : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.update = function(updateParams, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking update");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("update : Refresh claims token SUCCESS");
                 var headers = updateParams["headers"];
                 headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 updateParams["headers"] = headers;
                 kony.sdk.FileStorageClasses.update(url, updateParams, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("deleteByCriteria : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         obj.abort = function(fileId, abortParams, headers, successCallback, failureCallback, options) {
             kony.sdk.logsdk.trace("Invoking abort");
             kony.sdk.claimsRefresh(function() {
                 //claims refresh success callback
                 kony.sdk.logsdk.info("abort : Refresh claims token SUCCESS");
                 var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
                 kony.sdk.FileStorageClasses.abort(url, fileId, abortParams, headers, successCallback, failureCallback, options);
             }.bind(this), function(error) {
                 //claims refresh failure callback
                 kony.sdk.logsdk.error("abort : Refresh claims token FAILED");
                 failureCallback(error);
             });
         };
         return obj;
     }
     return {
         import: function(url) {
             kony.sdk.logsdk.trace(LOG_PREFIX + ": Importing native FileStorageClasses");
             if (instance === null) {
                 instance = createInstance(url);
             }
             return instance;
         }
     };
 })();
 // Add token to headers
 kony.sdk.FileStorageClasses.addTokenToHeaders = function(headers, token) {
     if (kony.sdk.isNullOrUndefined(headers)) {
         headers = {};
     }
     headers["X-Kony-Authorization"] = token;
     return headers;
 };
 kony.sdk.KNYObj = function(name, objectServiceName, namespace) {
     var LOG_PREFIX = "KNYObj";
     kony.sdk.logsdk.info(LOG_PREFIX + ": Creating KNYObj with name " + name);
     var sdkObjectSync = kony.sdk.KNYObj.createSDKObjectSync(name, objectServiceName, namespace);
     this.name = name;
     this.getSdkObjectSync = function() {
         return sdkObjectSync;
     }
     this.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing sync on " + this.name + " object");
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.KNYObj.startSync(this, syncConfig, successCallback, failureCallback, progressCallback)
         }.bind(this), function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED");
             failureCallback(error);
         });
     };
     this.getPendingRecordsForUpload = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Fetching PendingEditSyncRecords in " + this.name + " object");
         kony.sdk.KNYObj.getPendingRecordsForUpload(this, options, successCallback, failureCallback);
     };
     this.create = function(record, options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Create record in " + this.name + " object");
         kony.sdk.KNYObj.create(this, record, options, successCallback, failureCallback);
     };
     this.update = function(record, options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Update record in " + this.name + " object");
         kony.sdk.KNYObj.update(this, record, options, successCallback, failureCallback);
     };
     this.updateByPK = function(record, options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Update record by PK in " + this.name + " object");
         kony.sdk.KNYObj.updateByPK(this, record, options, successCallback, failureCallback);
     };
     this.delete = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Delete record in " + this.name + " object");
         kony.sdk.KNYObj.delete(this, options, successCallback, failureCallback);
     };
     this.deleteByPK = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Delete record by PK in " + this.name + " object");
         kony.sdk.KNYObj.deleteByPK(this, options, successCallback, failureCallback);
     };
     this.get = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Get record from " + this.name + " object");
         kony.sdk.KNYObj.get(this, options, successCallback, failureCallback);
     };
     this.getBinary = function(options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Get binary for " + this.name + " object");
         kony.sdk.KNYObj.getBinary(this, options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
     };
     this.getBinaryStatus = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing getBinaryStatus for " + this.name + " object");
         kony.sdk.KNYObj.getBinaryStatus(this, options, successCallback, failureCallback);
     };
     this.rollback = function(primaryKeyValueMap, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Rollback for " + this.name + " object");
         kony.sdk.KNYObj.rollback(this, primaryKeyValueMap, successCallback, failureCallback);
     };
     this.markForUpload = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing MarkForUpload for " + this.name + " object");
         kony.sdk.KNYObj.markForUpload(this, options, successCallback, failureCallback);
     };
     this.getUploadDeferredRecordKeys = function(successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Get deferred record primary keys in " + this.name + " object");
         kony.sdk.KNYObj.getUploadDeferredRecordKeys(this, successCallback, failureCallback);
     };
     this.cancelSync = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Cancel for " + this.name + " object");
         kony.sdk.KNYObj.cancelSync(this, options, successCallback, failureCallback);
     };
 };
 kony.sdk.KNYObjSvc = function(name) {
     var LOG_PREFIX = "KNYObjSvc";
     kony.sdk.logsdk.debug(LOG_PREFIX + ": Creating KNYObjSvc with name " + name);
     var sdkObjectServiceSync = kony.sdk.KNYObjSvc.createSDKObjectServiceSync(name);
     this.name = name;
     this.getSdkObjectServiceSync = function() {
         return sdkObjectServiceSync;
     }
     this.getSdkObjectByName = function(name) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Creating KNYObj with name " + name + " and objectServiceName " + this.name);
         var result = new kony.sdk.KNYObj(name, this.name);
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing finished for creation of KNYObj with name " + name + " and objectServiceName " + this.name);
         return result;
     }
     this.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Starting sync on " + this.name + " object service");
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.KNYObjSvc.startSync(this, syncConfig, successCallback, failureCallback, progressCallback)
         }.bind(this), function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED");
             failureCallback(error);
         });
     };
     this.rollback = function(successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Rollback on " + this.name + " object service");
         kony.sdk.KNYObjSvc.rollback(this, successCallback, failureCallback)
     }
     this.cancelSync = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Cancel for " + this.name + " object service");
         kony.sdk.KNYObjSvc.cancelSync(this, options, successCallback, failureCallback);
     }
     this.clearOfflineData = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Clearing Offline Data for " + this.name + " object service.");
         kony.sdk.KNYObjSvc.clearOfflineData(this, options, successCallback, failureCallback);
     }
 };
 kony.sdk.OfflineObjects = function(objServiceList) {
     var LOG_PREFIX = "OfflineObjects";
     kony.sdk.logsdk.trace(LOG_PREFIX + ": Creating OfflineObjects");
     this.setup = function(options, successCallback, failureCallback) {
         // This check is required for app upgrade from 8.0 to 8.1
         var argSuccessCallback = successCallback;
         var argFailueCallback = failureCallback;
         var setupOptions = (typeof arguments[0] != "function") ? options : null;
         if (setupOptions === null) {
             argSuccessCallback = options;
             argFailueCallback = successCallback;
         }
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.setup()");
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refreshing claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             //kony.sdk.logsdk.debug(LOG_PREFIX+": Token : "+token);
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.OfflineObjects.setup(objServiceList, setupOptions, argSuccessCallback, argFailueCallback);
         }, function() { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED. Setup offline started.");
             kony.sdk.OfflineObjects.setup(objServiceList, setupOptions, argSuccessCallback, argFailueCallback);
         });
     };
     this.incrementalSetup = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects incrementalSetup");
         if (!options) {
             options = {};
         }
         options.incrementalSetup = true;
         this.setup(options, successCallback, failureCallback);
     }
     this.drop = function(options, successCallback, failureCallback) {
         // This change is required for app upgrade from 8.0 to 8.1
         var argSuccessCallback = successCallback;
         var argFailueCallback = failureCallback;
         var dropOptions = (typeof arguments[0] != "function") ? options : null;
         if (dropOptions === null) {
             argSuccessCallback = options;
             argFailueCallback = successCallback;
         }
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.drop()");
         kony.sdk.OfflineObjects.drop(dropOptions, argSuccessCallback, argFailueCallback);
     }
     this.reset = function(options, successCallback, failureCallback) {
         // This change is required for app upgrade from 8.0 to 8.1
         var argSuccessCallback = successCallback;
         var argFailueCallback = failureCallback;
         var resetOptions = (typeof arguments[0] != "function") ? options : null;
         if (resetOptions === null) {
             argSuccessCallback = options;
             argFailueCallback = successCallback;
         }
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.reset");
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refresh claims token");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             //kony.sdk.logsdk.debug(LOG_PREFIX+": Token : "+token);
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.OfflineObjects.reset(objServiceList, resetOptions, argSuccessCallback, argFailueCallback);
         }, function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED");
             failureCallback(error);
         });
     }
     this.rollback = function(successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.rollback()");
         kony.sdk.OfflineObjects.rollback(successCallback, failureCallback);
     }
     this.executeSelectQuery = function(query, successCallback, failureCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.executeSelectQuery()");
         kony.sdk.OfflineObjects.executeSelectQuery(query, successCallback, failureCallback);
     }
     this.startSync = function(options, successCallback, failureCallback, progressCallback) {
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.startSync");
         kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refresh claims");
         kony.sdk.claimsRefresh(function() { //claims refresh success callback
             kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
             var token = kony.sdk.getCurrentInstance().currentClaimToken;
             kony.sdk.OfflineObjects.setToken(token);
             kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
             kony.sdk.OfflineObjects.startSync(options, successCallback, failureCallback, progressCallback);
         }, function(error) { //claims refresh failure callback
             kony.sdk.logsdk.error(LOG_PREFIX + "Executing Finished Application Sync : Refresh claims token : status FAILED");
             failureCallback(error);
         });
     }
 };
 kony.sdk.OfflineObjects.BinaryStatus = {
         "pending": 2,
         "completed": 4,
         "errored": 8
     }
     //
     //Binary FFI related functions
     //
 if (kony.sdk) {
     kony.sdk.binary = {};
 }
 kony.sdk.binary.constants = {
     ENDPOINT_URL: "endpointUrl",
     DOMAIN: "domain",
     RELATIVE_PATH: "relativepath",
     URL: "URL",
     HEADERS: "headers",
     METHOD: "method",
     UPLOAD_MODE: "uploadMode",
     BLOB: "blob",
     FILE_CONTENT: "${fileContent}",
     FILE: "file",
     HTTP_STATUS_CODE: "httpStatusCode",
     VALID_HTTP_REDIRECT_CODE: "309",
     UPLOAD_MODE_BINARY: "binary",
     UPLOAD_MODE_MULTIPART: "multipart",
     UPLOAD_PARAMS: "uploadParams",
     BLOB_ID: "BlobID",
     CONTEXT: "Context",
     SESSION_ID: "SessionID",
     BLOB_OBJECT: "BlobObject",
     ERROR: "Error",
     FILE_DETAILS: "FileDetails"
 };
 kony.sdk.binary.addMandatoryInternalOptions = function(options) {
     if (kony.sdk.isNullOrUndefined(options)) {
         options = {};
     }
     options[kony.sdk.binary.constants.DOMAIN] = konyRef.sessionReportingURL.split("/IST")[0];
     if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
         options[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     }
     return options;
 };
 kony.sdk.binary.validateUploadParams = function(uploadParams) {
     //Validating user input.
     if (!kony.sdk.util.isJsonObject(uploadParams)) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: Upload params should be supplied as valid JSON object");
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "Invalid datatype of uploadParams " + kony.sdk.util.type(uploadParams) + " " + kony.sdk.errormessages.invalid_params_instance)
     }
     // check for fileName
     if (!kony.sdk.util.isValidString(uploadParams[kony.sdk.constants.FILE_NAME])) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileName : expected string not found");
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "" + "Invalid datatype of fileName " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_NAME]) + " " + kony.sdk.errormessages.invalid_params_instance);
     }
     // Check if fileObject is provided by user
     if (kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.FILE_OBJECT])) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileObject is not provided - please provide");
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "fileObject is not provided " + kony.sdk.errormessages.invalid_params_instance);
     }
     // check if the fileObject provided by user is browser file object
     if (uploadParams[kony.sdk.constants.FILE_OBJECT].constructor !== File) {
         kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileObject : expected File Object and found " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_OBJECT]));
         return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "Invalid datatype of fileObject " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_OBJECT]) + " " + kony.sdk.errormessages.invalid_params_instance);
     }
     return null;
 };
 kony.sdk.binary.networkHandler = function(requestUrl, method, headers, requestBody, successCallback, failureCallback) {
     var xmlHttpRequest = new XMLHttpRequest();
     var successCB = successCallback;
     var failureCB = failureCallback;
     if (kony.sdk.constants.HTTP_METHOD_GET === method) {
         xmlHttpRequest.open(kony.sdk.constants.HTTP_METHOD_GET, requestUrl, true);
         xmlHttpRequest.responseType = kony.sdk.binary.constants.BLOB;
     } else {
         // The responseType for the post request will be undefined hence default, which is "text" will be considered
         xmlHttpRequest.open(kony.sdk.constants.HTTP_METHOD_POST, requestUrl, true);
     }
     for (var header in headers) {
         if (headers.hasOwnProperty(header)) {
             xmlHttpRequest.setRequestHeader(header, headers[header]);
         }
     }

     function localRequestCallback() {
         var readyState = 0;
         var response = "";
         var status = xmlHttpRequest.status;
         switch (xmlHttpRequest.readyState) {
             case 0: // UNINITIALIZED
             case 1: // LOADING
             case 2: // LOADED
             case 3: // INTERACTIVE
                 readyState = xmlHttpRequest.readyState;
                 response = "";
                 break;
             case 4: // COMPLETED
                 readyState = xmlHttpRequest.readyState;
                 //Not using hasOwnProperty because its not available on browser generated objects like XMLHTTPRequest
                 if (xmlHttpRequest.response) {
                     response = xmlHttpRequest.response;
                 } else if (xmlHttpRequest.responseText) {
                     response = xmlHttpRequest.responseText;
                 }
                 if (status >= 200 && status <= 300) {
                     kony.sdk.verifyAndCallClosure(successCB, response);
                 } else {
                     kony.sdk.verifyAndCallClosure(failureCB, response);
                 }
                 break;
             default:
                 kony.sdk.logsdk.error("Unknown Error : XMLHttpRequest Error");
         }
     }
     xmlHttpRequest.onreadystatechange = localRequestCallback;
     xmlHttpRequest.send(requestBody);
 };
 kony.sdk.binary.getRequestParamsFromTemplate = function(template, templateParams, options) {
     var requestParamsForBinaryCall = {};
     var parsedTemplateData = kony.sdk.util.populateTemplate(JSON.stringify(template), templateParams);
     var parsedTemplate = JSON.parse(parsedTemplateData[kony.sdk.constants.PROCESSED_TEMPLATE]);
     requestParamsForBinaryCall[kony.sdk.constants.PROCESSED_TEMPLATE] = parsedTemplateData[kony.sdk.constants.PROCESSED_TEMPLATE];
     // TODO: Validate missing variables
     requestParamsForBinaryCall[kony.sdk.constants.MISSING_VARIABLES] = parsedTemplateData[kony.sdk.constants.MISSING_VARIABLES];
     var additionalParams = kony.sdk.binary.addMandatoryInternalOptions(options);
     //Fetching headers from template
     var headers = {};
     if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.HEADERS) && kony.sdk.util.isJsonObject(parsedTemplate[kony.sdk.binary.constants.HEADERS]) && Object.keys(parsedTemplate[kony.sdk.binary.constants.HEADERS] > 0)) {
         headers = parsedTemplate[kony.sdk.binary.constants.HEADERS];
     }
     //Parsing the Backend Url from template
     var url = "";
     if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.ENDPOINT_URL)) {
         url = parsedTemplate[kony.sdk.binary.constants.ENDPOINT_URL];
     } else if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.DOMAIN) && parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.RELATIVE_PATH)) {
         var domain = "";
         if (parsedTemplate[kony.sdk.binary.constants.DOMAIN] === "#middlewaredomain") {
             headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = additionalParams[kony.sdk.constants.KONY_AUTHORIZATION_HEADER];
             domain = additionalParams[kony.sdk.binary.constants.DOMAIN];
         } else {
             domain = parsedTemplate[kony.sdk.binary.constants.DOMAIN];
         }
         url = domain + parsedTemplate[kony.sdk.binary.constants.RELATIVE_PATH];
     }
     requestParamsForBinaryCall[kony.sdk.binary.constants.URL] = url;
     requestParamsForBinaryCall[kony.sdk.binary.constants.METHOD] = parsedTemplate[kony.sdk.binary.constants.METHOD];
     requestParamsForBinaryCall[kony.sdk.binary.constants.HEADERS] = headers;
     return requestParamsForBinaryCall;
 };
 kony.sdk.binary.getBinaryData = function(inputParams, streaming, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, fileDownloadFailureCallback, options) {
     if (kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.ENDPOINT_URL]) && kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.DOMAIN]) && kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.RELATIVE_PATH])) {
         kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, "endpointUrl or domain and relative path is required in order to download a file");
         return;
     }
     var fileId = new Date().getTime().toString();
     kony.sdk.verifyAndCallClosure(fileDownloadStartedCallback, {
         "BlobID": fileId,
         "Context": inputParams
     });
     var requestParams = kony.sdk.binary.getRequestParamsFromTemplate(downloadConfig, inputParams, options);
     var parsedTemplate = JSON.parse(requestParams[kony.sdk.constants.PROCESSED_TEMPLATE]);
     if (parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE] == kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE) {
         kony.sdk.binary.networkHandler(requestParams[kony.sdk.binary.constants.URL], requestParams[kony.sdk.binary.constants.METHOD].toLocaleUpperCase(), requestParams[kony.sdk.binary.constants.HEADERS], null, function(blobObject) {
             var successObject = {};
             if (kony.sdk.isNullOrUndefined(inputParams["fileId"])) {
                 successObject[kony.sdk.binary.constants.BLOB_ID] = fileId;
             } else {
                 successObject[kony.sdk.binary.constants.BLOB_ID] = inputParams["fileId"];
             }
             successObject[kony.sdk.binary.constants.BLOB_OBJECT] = blobObject;
             successObject[kony.sdk.binary.constants.CONTEXT] = inputParams;
             kony.sdk.verifyAndCallClosure(fileDownloadCompletedCallback, successObject);
         }, function(networkError) {
             var errorObject = {};
             if (kony.sdk.isNullOrUndefined(inputParams["fileId"])) {
                 errorObject[kony.sdk.binary.constants.BLOB_ID] = fileId;
             } else {
                 errorObject[kony.sdk.binary.constants.BLOB_ID] = inputParams["fileId"];
             }
             errorObject[kony.sdk.binary.constants.CONTEXT] = inputParams;
             errorObject[kony.sdk.binary.constants.ERROR] = networkError;
             kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, errorObject);
         });
     } else {
         //TODO: Handle http status which is not 309
         kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, "Unhandled httpStatusCode received: " + parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE]);
     }
 };
 kony.sdk.binary.uploadBinaryData = function(uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options) {
     function templateFetchSuccess(uploadConfig) {
         if (kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.ENDPOINT_URL]) && kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.DOMAIN]) && kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.RELATIVE_PATH])) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "endpointUrl or domain and relative path is required in order to upload a file");
             return;
         }
         var sessionId = new Date().getTime().toString();
         kony.sdk.verifyAndCallClosure(fileUploadStartedCallback, {
             "SessionID": sessionId,
             "Context": uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS]
         });
         var requestParams = kony.sdk.binary.getRequestParamsFromTemplate(uploadConfig, uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS], options);
         var parsedTemplate = JSON.parse(requestParams[kony.sdk.constants.PROCESSED_TEMPLATE]);
         if (parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE] == kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE) {
             var requestBody;
             var fileObject;
             var requestBodyTemplateVariable = kony.sdk.util.getValueForKeyAndIgnoreCase(parsedTemplate, "requestBody");
             if (parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase() === kony.sdk.binary.constants.UPLOAD_MODE_BINARY) {
                 if (requestBodyTemplateVariable === kony.sdk.binary.constants.FILE_CONTENT) {
                     requestBody = uploadParams[kony.sdk.constants.FILE_OBJECT];
                 } else if (kony.sdk.isValidString(requestBodyTemplateVariable) && requestBodyTemplateVariable.indexOf(kony.sdk.binary.constants.FILE_CONTENT) !== -1) {
                     //TODO - handling substituting fileContent in the template variable
                     kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Received request body structure is not supported");
                 } else {
                     kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled request body format received");
                 }
             } else if (parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase() === kony.sdk.binary.constants.UPLOAD_MODE_MULTIPART) {
                 var formData = new FormData();
                 for (var key in requestBodyTemplateVariable) {
                     if (requestBodyTemplateVariable.hasOwnProperty(key) && kony.sdk.util.isJsonObject(requestBodyTemplateVariable)) {
                         if (requestBodyTemplateVariable[key] === kony.sdk.binary.constants.FILE_CONTENT) {
                             fileObject = uploadParams[kony.sdk.constants.FILE_OBJECT];
                         } else if (kony.sdk.util.isJsonObject(requestBodyTemplateVariable[key])) {
                             formData.append(key, JSON.stringify(requestBodyTemplateVariable[key]));
                         } else {
                             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled request body format received");
                         }
                     }
                 }
                 formData.append(kony.sdk.binary.constants.FILE, fileObject);
                 requestBody = formData;
             }
             kony.sdk.binary.networkHandler(requestParams[kony.sdk.binary.constants.URL], requestParams[kony.sdk.binary.constants.METHOD].toLocaleUpperCase(), requestParams[kony.sdk.binary.constants.HEADERS], requestBody, function(networkResponse) {
                 var successObject = {};
                 successObject[kony.sdk.binary.constants.SESSION_ID] = sessionId;
                 successObject[kony.sdk.binary.constants.CONTEXT] = uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS];
                 successObject[kony.sdk.binary.constants.FILE_DETAILS] = networkResponse;
                 kony.sdk.verifyAndCallClosure(fileUploadCompletedCallback, successObject);
             }, function(networkError) {
                 var errorObject = {};
                 errorObject[kony.sdk.binary.constants.SESSION_ID] = sessionId;
                 errorObject[kony.sdk.binary.constants.CONTEXT] = uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS];
                 errorObject[kony.sdk.binary.constants.ERROR] = networkError;
                 kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObject);
             });
         } else {
             //TODO: Handle http status which is not 309
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled httpStatusCode received: " + parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE]);
         }
     }
     //Invoking the template call
     var networkProvider = new konyNetworkProvider();
     networkProvider.post(uploadParams[kony.sdk.binary.constants.URL], uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS], uploadParams[kony.sdk.binary.constants.HEADERS], templateFetchSuccess, fileUploadFailureCallback)
 };
 if (typeof(kony.sdk.metric) === "undefined") {
     kony.sdk.metric = {};
 }
 kony.sdk.metric.eventFlowTag = "";
 kony.sdk.metric.eventConfig = {
     "confType": "BUFFER",
     "eventBufferAutoFlushCount": kony.sdk.metric.eventBufferAutoFlushValue,
     "eventBufferMaxCount": kony.sdk.metric.eventBufferMaxValue
 };
 kony.sdk.metric.eventBufferMaxValue = 1000;
 kony.sdk.metric.eventBufferAutoFlushValue = 15;
 kony.sdk.metric.characterLengthLimit = 256;
 kony.sdk.metric.reportEventBufferArray = [];
 kony.sdk.metric.reportEventBufferBackupArray = [];
 kony.sdk.metric.retrievedDS = false;
 kony.sdk.metric.eventBufferCount = 0;
 kony.sdk.metric.eventTypeMap = {
     "formentry": "FormEntry",
     "touch": "Touch",
     "servicecall": "ServiceCall",
     "gesture": "Gesture",
     "orientation": "Orientation",
     "custom": "Custom"
 };
 kony.sdk.metric.errorCodeMap = {
     "1000": true,
     "1011": true,
     "1012": true,
     "1014": true,
     "1015": true,
     "1016": true
 };
 kony.sdk.metric.setEventFlowTag = function(flowTag) {
     if (kony.sdk.isNullOrUndefined(flowTag)) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event flow tag");
     } else if (flowTag.length <= kony.sdk.metric.characterLengthLimit) {
         kony.sdk.metric.eventFlowTag = flowTag;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
     }
 };
 kony.sdk.metric.clearEventFlowTag = function() {
     kony.sdk.metric.eventFlowTag = "";
 };
 kony.sdk.metric.getEventFlowTag = function() {
     return kony.sdk.metric.eventFlowTag;
 };
 kony.sdk.metric.setEventConfig = function(confType, eventBufferAutoFlushCount, eventBufferMaxCount) {
     if (kony.sdk.isNullOrUndefined(confType)) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Config Type can not be null");
     } else {
         confType = confType.toUpperCase();
     }
     if (confType === "BUFFER") {
         kony.sdk.metric.eventConfig["confType"] = confType;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for config type");
     }
     if (!kony.sdk.isNullOrUndefined(eventBufferMaxCount) && typeof(eventBufferMaxCount) === "number" && eventBufferMaxCount > 0) {
         kony.sdk.metric.eventConfig["eventBufferMaxCount"] = eventBufferMaxCount;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferMaxCount has to be a Number and greater than 0");
     }
     if (!kony.sdk.isNullOrUndefined(eventBufferAutoFlushCount) && typeof(eventBufferAutoFlushCount) === "number" && eventBufferAutoFlushCount > 0 && eventBufferAutoFlushCount <= eventBufferMaxCount) {
         kony.sdk.metric.eventConfig["eventBufferAutoFlushCount"] = eventBufferAutoFlushCount;
     } else if (eventBufferAutoFlushCount >= eventBufferMaxCount) {
         kony.sdk.metric.eventConfig["eventBufferMaxCount"] = 1000;
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount can not be greater than eventBufferMaxCount");
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount has to be a Number and greater than 0");
     }
 };
 kony.sdk.metric.reportEvent = function(evttype, evtSubType, formID, widgetID, flowTag) {
     if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
         kony.sdk.metric.readFromDS();
     }
     kony.sdk.metric.eventBufferCount = kony.sdk.metric.reportEventBufferBackupArray.length + kony.sdk.metric.reportEventBufferArray.length;
     if (kony.sdk.metric.eventBufferCount === kony.sdk.metric.eventConfig["eventBufferMaxCount"]) {
         throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Reached maximum limit to store events");
         return;
     }
     var reportEventMap = {};
     reportEventMap.ts = kony.sdk.formatCurrentDate(new Date());
     evttype = evttype.toLowerCase();
     if (kony.sdk.isNullOrUndefined(kony.sdk.metric.eventTypeMap[evttype])) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event type");
         return;
     } else {
         reportEventMap["evttype"] = kony.sdk.metric.eventTypeMap[evttype];
     }
     if (kony.sdk.isNullOrUndefined(evtSubType)) {
         reportEventMap["evtSubType"] = "";
     } else if (evtSubType.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["evtSubType"] = evtSubType;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     if (kony.sdk.isNullOrUndefined(formID)) {
         reportEventMap["formID"] = kony.application.getCurrentForm().id;
     } else if (formID.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["formID"] = formID;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     if (kony.sdk.isNullOrUndefined(widgetID)) {
         reportEventMap["widgetID"] = "";
     } else if (widgetID.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["widgetID"] = widgetID;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     if (kony.sdk.isNullOrUndefined(flowTag)) {
         reportEventMap["flowTag"] = kony.sdk.metric.getEventFlowTag();
     } else if (flowTag.length <= kony.sdk.metric.characterLengthLimit) {
         reportEventMap["flowTag"] = flowTag;
     } else {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
         return;
     }
     reportEventMap.SID = kony.ds.read(kony.sdk.constants.KONYUUID)[0];
     kony.sdk.metric.reportEventBufferArray.push(reportEventMap);
     if (kony.sdk.metric.reportEventBufferArray.length % kony.sdk.metric.eventConfig["eventBufferAutoFlushCount"] === 0) {
         kony.sdk.metric.flushEvents();
     }
 };
 kony.sdk.metric.flushEvents = function() {
     if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
         kony.sdk.metric.readFromDS();
     }
     if (kony.sdk.metric.reportEventBufferBackupArray.length === 0 && kony.sdk.metric.reportEventBufferArray.length === 0) {
         kony.sdk.logsdk.warn("There are no events to flush");
         return;
     }
     var payload = kony.sdk.getPayload(kony.sdk.getCurrentInstance());
     var params = {};
     if (kony.sdk.metric.reportEventBufferArray.length !== 0) {
         kony.sdk.metric.pushEventsToBufferArray();
     }
     var headers = {};
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     params.httpheaders = headers;
     payload.events = kony.sdk.metric.reportEventBufferBackupArray;
     payload.svcid = "SendEvents";
     payload.rsid = kony.sdk.metric.reportEventBufferBackupArray[0].SID;
     params[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
     kony.net.invokeServiceAsync(kony.sdk.currentInstance.customReportingURL, params, flushCallback);

     function flushCallback(status, response) {
         if (status === 400) {
             if (response.opstatus == 0) {
                 kony.sdk.metric.clearBufferEvents();
             } else if (kony.sdk.metric.errorCodeMap[response.opstatus]) {
                 kony.sdk.metric.saveInDS();
             } else {
                 kony.sdk.metric.clearBufferEvents();
             }
         } else if (status === 300) {
             kony.sdk.metric.saveInDS();
         }
     }
 };
 /*Stores event data in Data Store on failure of service Call*/
 kony.sdk.metric.saveInDS = function() {
     if (!kony.sdk.isNullOrUndefined(kony.sdk.metric.reportEventBufferBackupArray) && kony.sdk.metric.reportEventBufferBackupArray.length > 0) {
         var eventsToSave = [];
         eventsToSave.push(JSON.stringify(kony.sdk.metric.reportEventBufferBackupArray));
         kony.ds.save(eventsToSave, "konyMetricsBuffer");
         kony.sdk.metric.reportEventBufferBackupArray = [];
     }
 };
 /*Clearing events sent to server */
 kony.sdk.metric.clearBufferEvents = function() {
     kony.sdk.metric.reportEventBufferBackupArray = [];
     kony.ds.remove("konyMetricsBuffer");
 };
 /*Reading any pending events from Data Store */
 kony.sdk.metric.readFromDS = function() {
     var eventsFromDS = kony.ds.read("konyMetricsBuffer");
     if (eventsFromDS !== null) {
         var pushToArray = [];
         pushToArray.push(JSON.parse(eventsFromDS[0]));
         kony.sdk.metric.reportEventBufferBackupArray.push.apply(kony.sdk.metric.reportEventBufferBackupArray, pushToArray);
     }
 };
 /*Pushes events received from user to BufferBackupArray which will be flushed to server */
 kony.sdk.metric.pushEventsToBufferArray = function() {
     kony.sdk.metric.reportEventBufferBackupArray.push.apply(kony.sdk.metric.reportEventBufferBackupArray, kony.sdk.metric.reportEventBufferArray);
     kony.sdk.metric.reportEventBufferArray = [];
 };
 kony.sdk.metric.getEventsInBuffer = function() {
     var eventsFromDS = kony.ds.read("konyMetricsBuffer");
     var eventsToReturn = [];
     if (!kony.sdk.isNullOrUndefined(eventsFromDS)) {
         eventsToReturn.push(JSON.parse(eventsFromDS[0]));
     }
     if (kony.sdk.metric.reportEventBufferArray.length !== 0) {
         eventsToReturn.push.apply(eventsToReturn, kony.sdk.metric.reportEventBufferArray);
     }
     if (eventsToReturn.length !== 0) {
         return eventsToReturn;
     } else {
         return null;
     }
 };
 kony.logger = kony.logger || {};
 kony.logger.createNewLogger = function(loggerName, loggerConfig) {
     parseConfig = function(loggerConfig) {
         //private methods
         if (loggerConfig === null || typeof(loggerConfig) === 'undefined') {
             loggerConfig = {};
         } else {
             loggerConfig = loggerConfig.getLoggerConfig();
         }
         if (typeof(appConfig) != 'undefined') {
             appDetails = {
                 appID: appConfig.appId,
                 appVersion: appConfig.appVersion,
                 sessionID: kony.license.getSessionId()
             };
             //appInfo
             loggerConfig.appInfo = appDetails;
         }
         return loggerConfig;
     };
     logMessage = function(loggerObj, logLevel, msg, params) {
         logMessageInFFI = function(NativeLoggerObject, logLevel, message) {
             switch (logLevel) {
                 case kony.logger.logLevel.TRACE:
                     NativeLoggerObject.logTrace(message);
                     break;
                 case kony.logger.logLevel.DEBUG:
                     NativeLoggerObject.logDebug(message);
                     break;
                 case kony.logger.logLevel.INFO:
                     NativeLoggerObject.logInfo(message);
                     break;
                 case kony.logger.logLevel.PERF:
                     NativeLoggerObject.logPerf(message);
                     break;
                 case kony.logger.logLevel.WARN:
                     NativeLoggerObject.logWarning(message);
                     break;
                 case kony.logger.logLevel.ERROR:
                     NativeLoggerObject.logError(message);
                     break;
                 case kony.logger.logLevel.FATAL:
                     NativeLoggerObject.logFatal(message);
                     break;
                 default:
                     kony.print("Implementation not found for the specified log level " + logLevel);
                     return;
             }
         };
         formatLineInfo = function(callerInformation) {
             if (callerInformation.length == 3) {
                 return callerInformation[1];
             }
             // MFSDK-3910
             // Temporary Fix to send line number as null if not present instead of undefined(<null>)
             return "";
         };
         formatFileInfo = function(callerInformation) {
             if (callerInformation.length >= 1) {
                 callerInformation = callerInformation[callerInformation.length - 1];
                 callerInformation = callerInformation.replace("(", "");
                 callerInformation = callerInformation.replace(")", "");
                 callerInformation = callerInformation.split(":");
                 if (callerInformation.length == 3) {
                     return callerInformation[0];
                 }
             }
         };
         formatMethodInformation = function(callerInformation) {
             if (callerInformation.length > 1) return callerInformation[callerInformation.length - 2];
         };
         formatCallerInformation = function(callerInformation) {
             //JSCore syntax: <methodName>@<fileName>:<row>:<col>
             //V8 syntax: at <methodName> (<fileName>:<row>:<col>)
             //Chakra syntax: at (<methodURL> <fileURL>:<row>:<col>)
             if (callerInformation !== null) {
                 var seperator = " ";
                 formattedCallerInformation = callerInformation.split(seperator);
                 return formattedCallerInformation;
             }
             return [];
         };
         getCallerInformationFromCallStack = function(callStack, indirectionLevel) {
             var index = 5;
             index += indirectionLevel;
             if (callStack.length >= index) return callStack[index];
             return null;
         };
         generateCallerInformation = function(indirectionLevel) {
             var errorObject = new Error();
             var callStack;
             // In IE, Error object doesn't contain stack information, hence can't provide caller info
             if (errorObject.hasOwnProperty("stack")) {
                 callStack = errorObject.stack.split("\n");
             } else {
                 callStack = [];
             }
             var callerInformation = getCallerInformationFromCallStack(callStack, indirectionLevel);
             return formatCallerInformation(callerInformation);
         };
         parseMessage = function(loggerObj, logLevel, msg, params) {
             var logLevelVal = (kony.logger.isNativeLoggerAvailable()) ? KonyLogger.getLogLevel() : kony.logger.currentLogLevel.value;
             if (logLevel.value >= logLevelVal) {
                 var metaData = {};
                 params = (typeof(params) === "undefined") ? "" : params;
                 //Stringify object
                 if (kony.logger.isValidJSTable(params)) {
                     params = JSON.stringify(params, null, " ");
                 }
                 metaData.message = msg + params;
                 metaData.callerInformation = generateCallerInformation(loggerObj.getIndirectionLevel());
                 metaData.methodName = formatMethodInformation(metaData.callerInformation);
                 metaData.fileName = formatFileInfo(metaData.callerInformation);
                 metaData.lineNo = formatLineInfo(metaData.callerInformation);
                 if (kony.logger.isNativeLoggerAvailable()) {
                     if (!loggerObj.NativeLoggerObject) {
                         loggerObj.NativeLoggerObject = new KonyLogger.InitializeLogger(loggerObj.loggerName);
                         KonyLogger.setConfig(loggerObj.config);
                     }
                     if (loggerObj.NativeLoggerObject) {
                         logMessageInFFI(loggerObj.NativeLoggerObject, logLevel, metaData);
                     } else {
                         var date = new Date().toLocaleDateString();
                         var time = new Date().toLocaleTimeString();
                         var level = logLevel.code;
                         var formattedMessage = "[" + loggerObj.loggerName + "][" + level + "][" + date + " " + time + "][" + metaData.fileName + "][" + metaData.methodName + "][" + metaData.lineNo + "] : " + metaData.message;
                         kony.print(formattedMessage);
                     }
                 } else {
                     var date = new Date().toLocaleDateString();
                     var time = new Date().toLocaleTimeString();
                     var level = logLevel.code;
                     var formattedMessage = "[" + loggerObj.loggerName + "][" + level + "][" + date + " " + time + "][" + metaData.fileName + "][" + metaData.methodName + "][" + metaData.lineNo + "] : " + metaData.message;
                     kony.print(formattedMessage);
                 }
             }
         };
         parseMessage(loggerObj, logLevel, msg, params);
     };
     //Exposed object and it's methods
     var loggerObj = kony.logger.createLoggerObject(loggerName, loggerConfig);
     //Native object creation
     if (kony.logger.isNativeLoggerAvailable()) {
         loggerObj.NativeLoggerObject = new KonyLogger.InitializeLogger(loggerName);
         KonyLogger.setConfig(loggerObj.config);
     }
     return loggerObj;
 }
 kony.logger["appLogger"] = kony.logger.appLoggerInitialisation();
 /**
  * MFSDK
  * Created by KH2204.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Method to create the integration service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @returns {IntegrationService} Integration service instance
  */
 kony.sdk.prototype.getIntegrationService = function(serviceName) {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "integration service :" + serviceName);
     }
     var konyRef = kony.sdk.getCurrentInstance();
     if (!kony.sdk.skipAnonymousCall && !this.currentClaimToken && !konyRef.isAnonymousProvider) {
         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Valid claims token is not found, login using identity service before performing an operation on this integration service :" + serviceName);
     }
     if (this.integsvc != null) {
         if (this.integsvc[serviceName] != null) {
             kony.sdk.logsdk.debug("found integration service" + this.integsvc[serviceName]);
             return new IntegrationService(this, serviceName);
         }
     }
     throw new Exception(kony.sdk.errorConstants.INTEGRATION_FAILURE, "Integration service is not found or invalid :" + serviceName);
 };
 /**
  * Method should not be called by developer.
  * @class
  * @classdesc Integration service instance for invoking the integration services.
  */
 function IntegrationService(konyRef, serviceName) {
     var serviceUrl = "";
     var svcObj = konyRef.integsvc[serviceName];
     if (typeof(svcObj) === "object") {
         serviceUrl = svcObj["url"];
     } else {
         serviceUrl = svcObj;
     }
     var networkProvider = new konyNetworkProvider();
     if (kony.sdk.util.isNullOrEmptyString(serviceName) || kony.sdk.util.isNullOrEmptyString(serviceUrl)) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "Invalid serviceUrl and serviceName");
     }
     serviceUrl = stripTrailingCharacter(serviceUrl, "/");
     this.getUrl = function() {
         return serviceUrl;
     };
     /**
      * Integration service success callback method.
      * @callback integrationSuccessCallback
      * @param {json} response - Integration service response
      */
     /**
      * Integration service failure callback method.
      * @callback integrationFailureCallback
      * @param {json} error - Error information
      */
     /**
      * invoke the specified operation
      * @param {string} operationName - Name of the operation
      * @param {object} headers - Input headers for the operation
      * @param {object} data - Input data for the operation
      * @param {integrationSuccessCallback} successCallback  - Callback method on success
      * @param {integrationFailureCallback} failureCallback - Callback method on failure
      * @param {object} options - XMLHttpRequest options like withCredentials value.
      */
     this.invokeOperation = function(operationName, headers, data, successCallback, failureCallback, options) {
         function invokeOperationHandler() {
             _invokeOperation(operationName, headers, data, true, successCallback, failureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             invokeOperationHandler();
         } else {
             kony.sdk.claimsRefresh(invokeOperationHandler, failureCallback);
         }
     };
     /**
      * Integration service API to upload binaries based on adapter template
      * @param {string} operationName - Name of the operation
      * @param {Object} uploadParams - InputContext or template variables
      * @param {callback} fileUploadStartedCallback - Callback which is invoked on start of file upload
      * @param {callback} chunkUploadCompletedCallback - Callback which is invoked on chunk upload
      * @param {callback} fileUploadCompletedCallback - Callback which is invoked on complete of file upload
      * @param {callback} fileUploadFailureCallback - Callback which is invoked in case of error during upload
      * @param {Object} options - Provision for user to send additional options
      */
     this.uploadBinaryData = function(operationName, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options) {
         var errorObj = kony.sdk.binary.validateUploadParams(uploadParams);
         if (errorObj) {
             kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObj);
             return;
         }
         // if rawbytes are provided, converting to base64 string as can only receive base datatypes
         if (!kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.RAW_BYTES])) {
             var base64String = kony.convertToBase64(uploadParams[kony.sdk.constants.RAW_BYTES]);
             uploadParams[kony.sdk.constants.RAW_BYTES] = base64String;
         }

         function uploadBinaryDataHandler() {
             var uploadOptions = {};
             uploadOptions["URL"] = serviceUrl + "/" + operationName;
             var headers = {};
             if (!kony.sdk.skipAnonymousCall) {
                 headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
             }
             uploadOptions["headers"] = headers;
             //Extracting Mandatory Params from uploadParams before fetching template
             if (uploadParams[kony.sdk.constants.FILE_PATH]) {
                 uploadOptions[kony.sdk.constants.FILE_PATH] = uploadParams[kony.sdk.constants.FILE_PATH];
                 delete uploadParams[kony.sdk.constants.FILE_PATH];
             } else if (uploadParams[kony.sdk.constants.RAW_BYTES]) {
                 uploadOptions[kony.sdk.constants.RAW_BYTES] = uploadParams[kony.sdk.constants.RAW_BYTES];
                 delete uploadParams[kony.sdk.constants.RAW_BYTES];
             } else if (uploadParams[kony.sdk.constants.FILE_OBJECT]) {
                 uploadOptions[kony.sdk.constants.FILE_OBJECT] = uploadParams[kony.sdk.constants.FILE_OBJECT];
                 delete uploadParams[kony.sdk.constants.FILE_OBJECT]
             }
             uploadOptions["uploadParams"] = uploadParams;
             kony.sdk.binary.uploadBinaryData(uploadOptions, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             uploadBinaryDataHandler();
         } else {
             kony.sdk.claimsRefresh(uploadBinaryDataHandler, fileUploadFailureCallback);
         }
     };
     /**
      * Integration service API to download binaries based on adapter template
      * @param {string} operationName - Name of the operation
      * @param {Object} fileparams - InputContext or template variables
      * @param {boolean} streaming - Boolean value to determine, whether chunks need to be saved to file or sent in callbacks
      * @param {Object} headers - Provision for custom headers
      * @param {callback} fileDownloadStartedCallback - Callback which is invoked on start of file download
      * @param {callback} chunkDownloadCompletedCallback - Callback which is invoked on stream/chunk download
      * @param {callback} fileDownloadCompletedCallback - Callback which is invoked on complete of file download
      * @param {callback} downloadFailureCallback - Callback which is invoked in case of error during download
      * @param {Object} options - Provision for user to send additional options
      */
     this.getBinaryData = function(operationName, fileparams, streaming, headers, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback, options) {
         function getBinaryDataHandler() {
             _invokeOperation(operationName, headers, fileparams, true, function(downloadConfig) {
                 if (kony.sdk.isNullOrUndefined(downloadConfig)) {
                     downloadConfig = {};
                 }
                 if (options && options["ChunkSize"]) {
                     downloadConfig.ChunkSize = options["ChunkSize"];
                 }
                 if (headers) {
                     if (kony.sdk.isNullOrUndefined(downloadConfig.headers)) {
                         downloadConfig.headers = {};
                     }
                     for (var header in headers) {
                         if (headers.hasOwnProperty(header)) {
                             downloadConfig.headers[header] = headers[header];
                         }
                     }
                 }
                 kony.sdk.binary.getBinaryData(fileparams, streaming, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback, options);
             }, downloadFailureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             // Check to find if the service is public or not, in case of public service anonymous login is not required.
             getBinaryDataHandler();
         } else {
             kony.sdk.claimsRefresh(getBinaryDataHandler, downloadFailureCallback);
         }
     };

     function invokeOperationRetry(operationName, headers, data, successCallback, failureCallback, options) {
         function invokeOperationRetryHandler() {
             _invokeOperation(operationName, headers, data, false, successCallback, failureCallback, options);
         }
         if (kony.sdk.skipAnonymousCall) {
             invokeOperationRetryHandler();
         } else {
             kony.sdk.claimsAndProviderTokenRefresh(invokeOperationRetryHandler, failureCallback);
         }
     }

     function retryServiceCall(errorResponse) {
         if (errorResponse[kony.sdk.constants.MF_CODE]) {
             // check for the mfcode for which,
             // retry should be done.
         } else {
             if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
                 kony.sdk.logsdk.debug("### IntegrationService::retryServiceCall received 401 from fabric, trying to refresh backend token");
                 return true;
             }
         }
     }

     function _invokeOperation(operationName, headers, data, isRetryNeeded, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing _invokeOperation : " + operationName);
         var requestData = kony.sdk.getEncodedReportingParamsForSvcid(operationName);
         var dataToSend = {};
         for (var key in data) {
             if (data.hasOwnProperty(key)) {
                 dataToSend[key] = data[key];
             }
         }
         var defaultHeaders = {};
         defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         defaultHeaders["X-Kony-ReportingParams"] = requestData;
         if (!kony.sdk.skipAnonymousCall) {
             // Check to find if the service is public or not, in case of public service no token is required.
             var token = konyRef.currentClaimToken;
             if (!token) {
                 token = kony.sdk.getCurrentInstance().currentClaimToken;
             }
             defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = token;
         }
         var deviceId = kony.sdk.getDeviceId();
         if (!kony.sdk.isNullOrUndefined(deviceId)) {
             defaultHeaders["X-Kony-DeviceId"] = deviceId;
         }
         if (typeof(svcObj) === 'object' && svcObj.version) {
             defaultHeaders["X-Kony-API-Version"] = svcObj.version;
         }
         // if the user has defined his own headers, use them
         if (!kony.sdk.isNullOrUndefined(headers)) {
             if ((Object.keys(headers)).length !== 0 && typeof(headers) === "object") {
                 var defaultKeys = Object.keys(defaultHeaders);
                 var lowerCaseHeaders = defaultKeys.map(function(x) {
                     return x.toLowerCase()
                 });
                 for (var header in headers) {
                     var headerConst = header;
                     if (lowerCaseHeaders.indexOf(headerConst.toLowerCase()) !== -1) {
                         for (var i = 0; i < defaultKeys.length; i++) {
                             var tempKey = defaultKeys[i];
                             if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
                                 defaultHeaders[tempKey] = headers[header];
                             }
                         }
                     } else {
                         defaultHeaders[header] = headers[header];
                     }
                 }
             }
         }
         // If useCache is enabled and cacheID is present then network call will be skipped and cached response will be returned.
         if (options && options["useCache"] && options["cacheID"]) {
             var cacheResponse = new kony.sdk.ClientCache().get(options["cacheID"]);
             if (cacheResponse) {
                 kony.sdk.logsdk.debug("Key found in hash, returning cached response.");
                 kony.sdk.verifyAndCallClosure(successCallback, cacheResponse);
                 return;
             }
         }

         function networkSuccessCallback(res) {
             // If useCache is enabled then the response is cached and returned.
             if (options && options["useCache"]) {
                 cacheResponseForKey(options, serviceUrl + "/" + operationName, requestData, res);
             }
             kony.sdk.logsdk.perf("Executing Finished network call for _invokeOperation : " + operationName);
             kony.sdk.logsdk.perf("Executing Finished _invokeOperation : " + operationName);
             kony.sdk.verifyAndCallClosure(successCallback, res);
         }

         function networkFailureCallback(xhr, status, err) {
             if (xhr && !(status && err)) {
                 err = xhr;
             }
             if (isRetryNeeded === true && retryServiceCall(err) === true) {
                 kony.sdk.logsdk.debug("errorCallback, retrying the operation: " + operationName);
                 invokeOperationRetry(operationName, headers, data, successCallback, failureCallback);
                 return;
             }
             kony.sdk.logsdk.perf("Executing Finished network call for _invokeOperation : " + operationName);
             kony.sdk.logsdk.perf("Executing Finished _invokeOperation : " + operationName);
             kony.sdk.processIntegrationErrorResponse(err, true, failureCallback);
         }
         kony.sdk.logsdk.perf("Executing network call for _invokeOperation : " + operationName);
         networkProvider.post(serviceUrl + "/" + operationName, dataToSend, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
     }
     kony.sdk.processIntegrationErrorResponse = function(err, isAsync, callBack) {
         if (err[kony.sdk.constants.MF_CODE]) {
             //clear the cache if the error code related to session/token expiry
             if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
                 kony.sdk.logsdk.info("###IntegrationService::invokeOperationFailure  Session/Token expired. Authenticate and Try again");
                 //TODO: Start a conversation with Suhas and Krishna regarding the scenario wherein one auth session expired and other is still valid.
             }
         }
         if (!isAsync) {
             return kony.sdk.error.getIntegrationErrObj(err);
         } else if (callBack) {
             kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getIntegrationErrObj(err));
         }
     };
     //This is an internal api to invoke an service synchronously
     this.invokeOperationSync = function(operationName, headers, data) {
         var res = null;
         res = kony.sdk.claimsRefreshSync();
         if (res && res.message && res.message === "success") {
             return _invokeOperationSync(operationName, headers, data);
         } else {
             return res;
         }
     };

     function _invokeOperationSync(operationName, headers, data) {
         var requestData = {};
         var konyRef = kony.sdk.getCurrentInstance();
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(operationName);
         for (var key in data) {
             if (data.hasOwnProperty(key)) {
                 requestData[key] = data[key];
             }
         }
         var token;
         for (var tempToken in konyRef.tokens) {
             if (konyRef.tokens.hasOwnProperty(tempToken) && typeof(tempToken) !== 'function') {
                 token = konyRef.tokens[tempToken];
                 break;
             }
         }
         requestData[kony.sdk.constants.REPORTING_PARAMS] = reportingData;
         var defaultHeaders = {}
         defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         if (typeof(svcObj) === 'object' && svcObj.version) {
             defaultHeaders["X-Kony-API-Version"] = svcObj.version;
         }
         // if the user has defined his own headers, use them
         if ((Object.keys(headers)).length !== 0) {
             var defaultKeys = [];
             defaultKeys = Object.keys(defaultHeaders);
             var defaultkeyLower = {};
             defaultkeyLower = defaultKeys.map(function(x) {
                 return x.toLowerCase()
             });
             for (var header in headers) {
                 var headerConst = header;
                 if (defaultkeyLower.indexOf(headerConst.toLowerCase()) !== -1) {
                     for (var i = 0; i < defaultKeys.length; i++) {
                         var tempKey = defaultKeys[i];
                         if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
                             defaultHeaders[tempKey] = headers[header];
                         }
                     }
                 } else {
                     defaultHeaders[header] = headers[header];
                 }
             }
         }
         var res = null;
         res = networkProvider.postSync(serviceUrl + "/" + operationName, requestData, defaultHeaders);
         if (res.opstatus == 0) {
             return res;
         } else {
             return kony.sdk.processIntegrationErrorResponse(res, false);
         }
     }
 }
 kony.sdk.claimsRefreshSync = function() {
     var konyRef = kony.sdk.getCurrentInstance();
     var networkProvider = new konyNetworkProvider();
     var loginWithAnonymousProvider = function() {
         var identityObject = konyRef.getIdentityService("$anonymousProvider");
         var res = identityObject.anonymousLoginSync(null);
         if (res && JSON.stringify(res) == "{}") {
             return {
                 "message": "success"
             };
         } else {
             return kony.sdk.error.getAuthErrObj(res);
         }
     };
     if (konyRef.currentClaimToken === null) {
         kony.sdk.logsdk.info("claims Token is Unavialable");
         if (konyRef.isAnonymousProvider) {
             return loginWithAnonymousProvider();
         } else {
             return kony.sdk.error.getNullClaimsTokenErrObj();
         }
     } else if (konyRef.claimTokenExpiry && new Date().getTime() > konyRef.claimTokenExpiry) {
         if (konyRef.isAnonymousProvider) {
             return loginWithAnonymousProvider();
         } else {
             kony.sdk.logsdk.info("claims token has expired. fetching new token..");
             var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/");
             var _url = _serviceUrl + "/claims";
             kony.sdk.logsdk.debug("service url is " + _url);
             if (konyRef.currentRefreshToken === null) {
                 return kony.sdk.error.getNullRefreshTokenErrObj();
             } else {
                 var headers = {};
                 headers[kony.sdk.constants.AUTHORIZATION_HEADER] = konyRef.currentRefreshToken;
                 headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
                 var data = networkProvider.postSync(_url, {}, headers);
                 if (data.opstatus == 0) {
                     kony.sdk.logsdk.info("refresh success..acquiring new tokens");
                     return kony.sdk.processClaimsSuccessResponse(data, konyRef, false);
                 } else {
                     kony.sdk.logsdk.info("failed to acquire refresh token");
                     return kony.sdk.processClaimsErrorResponse(data, konyRef, false);
                 }
             }
         }
     } else {
         return {
             "message": "success"
         };
     }
 };
 /**
  * Method to create the messaging service instance.
  * @returns {MessagingService} Messaging service instance
  */
 kony.sdk.prototype.getMessagingService = function() {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Messaging service.");
     }
     return new MessagingService(this);
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Messaging service instance for invoking the Messaging services.
  * @param konyRef - reference to kony object
  */
 function MessagingService(konyRef) {
     var homeUrl = konyRef.messagingsvc.url;
     var appId = konyRef.messagingsvc.appId;
     var networkProvider = new konyNetworkProvider();
     var dsKey_KSID = appId + "_KSID";
     var dsKey_authToken = appId + "_AUTHTOKEN";
     var currentObject = this;
     var geoBoundaryData;
     var KSID;
     var AUTHTOKEN;
     this.getUrl = function() {
         return homeUrl;
     };
     this.setKSID = function(ksid) {
         kony.sdk.dataStore.setItem(dsKey_KSID, ksid);
         KSID = ksid;
     };
     this.getKSID = function() {
         if (!KSID) {
             KSID = kony.sdk.dataStore.getItem(dsKey_KSID);
         }
         return KSID;
     };
     this.setAuthToken = function(authToken) {
         kony.sdk.dataStore.setItem(dsKey_authToken, authToken);
         AUTHTOKEN = authToken
     };
     this.getAuthToken = function(options) {
         if (options && options[kony.sdk.constants.AUTH_TOKEN]) {
             AUTHTOKEN = options[kony.sdk.constants.AUTH_TOKEN];
         } else {
             //retrieving from local store if user given token is null
             AUTHTOKEN = kony.sdk.dataStore.getItem(dsKey_authToken);
         }
         return AUTHTOKEN;
     };
     var setGeoBoundaryData = function(data) {
         kony.sdk.dataStore.setItem("geoBoundaryData", data);
         geoBoundaryData = data;
     };
     var getGeoBoundaryDataForBoundaryId = function(boundaryId) {
         if (!geoBoundaryData) {
             geoBoundaryData = kony.sdk.dataStore.getItem("geoBoundaryData")
         }
         return geoBoundaryData[boundaryId];
     };
     this.setKmsAppId = function(id) {
         appId = id;
     };
     this.getKmsAppId = function() {
         return appId;
     };
     KSID = currentObject.getKSID();
     AUTHTOKEN = currentObject.getAuthToken();
     var registerForMessagingService = function(osType, deviceId, pnsToken, email, authToken, successCallback, failureCallback) {
         var uri = homeUrl + "/subscribers";
         var subscribeParamsJson = {
             "sid": pnsToken,
             "appId": appId,
             "ufid": email,
             "osType": osType,
             "deviceId": deviceId
         };
         if (authToken != undefined && authToken != null) {
             subscribeParamsJson[kony.sdk.constants.AUTH_TOKEN] = authToken;
         }
         var jsonParam = {
             "subscriptionService": {
                 "subscribe": subscribeParamsJson
             }
         };
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(jsonParam)
         };
         var networkOptions = {};
         networkOptions["disableIntegrity"] = true;
         kony.sdk.logsdk.perf("Executing registerForMessagingService's network call");
         networkProvider.post(uri, payload, headers, function(data) {
             kony.sdk.logsdk.perf("Executing finished registerForMessagingService's network success");
             currentObject.setKSID(data.id);
             currentObject.setAuthToken(authToken);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(data, status, error) {
             kony.sdk.logsdk.perf("Executing finished registerForMessagingService's network failure");
             kony.sdk.logsdk.error("ERROR: Failed to register device for KMS");
             var errorObj = {};
             errorObj.data = data;
             errorObj.status = status;
             errorObj.error = error;
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     var subscribeAudienceOrUpdate = function(firstName, lastName, emailId, mobileNumber, country, state, options, successCallback, failureCallback) {
         var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE;
         var subscribeAudienceJson = {
             "ksid": KSID,
             "firstName": firstName,
             "lastName": lastName,
             "email": emailId,
             "mobileNumber": mobileNumber,
             "country": country,
             "state": state
         };
         var currentdate = new Date();
         //toLocaleString gives current time in below format
         //6/25/2018, 12:38:21 PM
         var datetime = currentdate.toLocaleString('en-US', {
             timeZone: 'UTC'
         });
         //remove , in the current UTC time
         datetime = datetime.replace(",", "");
         //removing some extra special characters added by chakra JS engine(used for windows), refer - MFSDK-3667
         datetime = datetime.replace(/[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g, '');
         subscribeAudienceJson[kony.sdk.constants.LAST_ACTIVE_DATE] = datetime;
         if (!kony.sdk.isNullOrUndefined(options)) {
             for (var key in options) {
                 if (options.hasOwnProperty(key)) {
                     if (key === kony.sdk.constants.AUTH_TOKEN) {
                         subscribeAudienceJson[key] = currentObject.getAuthToken(options);
                     } else {
                         subscribeAudienceJson[key] = options[key];
                     }
                 }
             }
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(subscribeAudienceJson)
         };
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing subscribeAudienceOrUpdate's network call");
         networkProvider.post(uri, payload, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished subscribeAudienceOrUpdate's network success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(data, status, error) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudienceOrUpdate's network failure");
             kony.sdk.logsdk.error("ERROR: Failed to create or update audience", errorObj);
             var errorObj = {};
             errorObj.data = data;
             errorObj.status = status;
             errorObj.error = error;
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
     * register to messaging service
     * @param {string} osType - Type of the operating system
     * @param {string} deviceId - Device Id
     * @param {string} pnsToken - Token value
     * @param {string} ufid - UFID can be email-id,mobile number or
	 						any dynamic attribute configured as reconciliation key in Engagement console
     * @param {function} successCallback - Callback method on success
     * @param {function} failureCallback - Callback method on failure
     * @param {dictionary} options - {authToken: <Auth Token>}
     */
     this.register = function(osType, deviceId, pnsToken, ufid, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing register");
         var authToken = null;
         if (kony.sdk.isNullOrUndefined(pnsToken)) {
             kony.sdk.logsdk.perf("Executing finished register finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid pnsToken/sId, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(osType)) {
             kony.sdk.logsdk.perf("Executing finished register finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid osType, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(deviceId)) {
             kony.sdk.logsdk.perf("Executing finished register finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid deviceId, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(ufid)) {
             kony.sdk.logsdk.perf("Executing finished register finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email, it cannot be null");
         }
         authToken = currentObject.getAuthToken(options);
         registerForMessagingService(osType, deviceId, pnsToken, ufid, authToken, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished register finished with success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.perf("Executing finished register finished with failure");
             kony.sdk.logsdk.error("Register :: Register for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         });
     };
     /**
      * register to messaging service
      * @param {string} osType - Type of the operating system
      * @param {string} deviceId - Device Id
      * @param {string} authToken - Authorization Token
      * @param {string} pnsToken - Token value
      * @param {string} email - email
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     /**
      * @deprecated This method is deprecated because authToken can be given as input through options param of
      * register method.
      */
     this.registerWithAuthToken = function(osType, deviceId, pnsToken, email, authToken, successCallback, failureCallback) {
         kony.sdk.logsdk.perf("Executing registerWithAuthToken");
         if (kony.sdk.isNullOrUndefined(pnsToken)) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid pnsToken/sId,it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(osType)) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid osType, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(deviceId)) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid deviceId, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(email)) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(authToken)) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken, it cannot be null");
         }
         registerForMessagingService(osType, deviceId, pnsToken, email, authToken, function(data) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with success");
             kony.sdk.verifyAndCallClosure(successCallback, data)
         }, function(errorObj) {
             kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with failure");
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         });
     };
     var unregisterFromMessagingService = function(authToken, successCallback, failureCallback) {
         var uri = homeUrl + "/subscribers";
         var unsubscribeObj = {
             "ksid": currentObject.getKSID()
         };
         if (authToken != undefined && authToken != null) {
             unsubscribeObj[kony.sdk.constants.AUTH_TOKEN] = authToken;
         }
         var inp = {
             "subscriptionService": {
                 "unsubscribe": unsubscribeObj
             }
         };
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(inp)
         };
         kony.sdk.logsdk.info("unsubscribe uri:" + uri);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing unregisterFromMessagingService's network call");
         networkProvider.post(uri, payload, headers, function(data) {
             kony.sdk.logsdk.perf("Executing finished unregisterFromMessagingService's network success");
             kony.sdk.dataStore.removeItem(dsKey_KSID);
             kony.sdk.dataStore.removeItem(dsKey_authToken);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(data, status, error) {
             kony.sdk.logsdk.perf("Executing finished unregisterFromMessagingService's network failure");
             kony.sdk.logsdk.error("ERROR: Failed to unregister device for KMS");
             var errorObj = {};
             errorObj.data = data;
             errorObj.status = status;
             errorObj.error = error;
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * unregister to messaging service
      * @param {dictionary} options - {authToken: <Auth Token>}
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.unregister = function(successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing unregister");
         var tempKSID = currentObject.getKSID();
         var authToken = null;
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             kony.sdk.logsdk.perf("Executing finished unregister with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         authToken = currentObject.getAuthToken(options);
         unregisterFromMessagingService(authToken, function(res) {
             kony.sdk.logsdk.perf("Executing finished unregister with success");
             successCallback(res);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished unregister with failure");
             failureCallback(err);
         });
     };
     /**
      * unregister to messaging service
      * @param {string} authToken - Authorization Token
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     /**
      * @deprecated This method is deprecated because authToken can be given as input through options param of
      * unregister method.
      */
     this.unregisterWithAuthToken = function(authToken, successCallback, failureCallback) {
         kony.sdk.logsdk.perf("Executing unregisterWithAuthToken");
         var tempKSID = currentObject.getKSID();
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with execption");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         if (typeof(authToken) === 'undefined' || authToken === null) {
             kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with execption");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken.");
         }
         unregisterFromMessagingService(authToken, function(res) {
             kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with success");
             successCallback(res);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with failure");
             failureCallback(err);
         });
     };
     /**
      * Fetch all messages
      * @param {number} startIndex - starting index
      * @param {number} pageSize - page size
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.fetchAllMessages = function(startIndex, pageSize, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing fetchAllMessages");
         var tempKSID = currentObject.getKSID();
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         var uri = homeUrl + "/messages/fetch";
         var data = {
             "ksid": tempKSID,
             "startElement": startIndex,
             "elementsPerPage": pageSize
         };
         data[kony.sdk.constants.AUTH_TOKEN] = currentObject.getAuthToken(options);
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(data)
         };
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing fetchAllMessages's network call");
         networkProvider.post(uri, payload, headers, function(data) {
             kony.sdk.logsdk.perf("Executing finished fetchAllMessages's network call with success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.perf("Executing finished fetchAllMessages's network call with failure");
             kony.sdk.logsdk.error("FetchAllMessages :: FetchAllMessages for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     var updateGeoLocationForMessagingService = function(latitude, longitude, locationName, authToken, successCallback, failureCallback) {
         kony.sdk.logsdk.perf("Executing updateGeoLocationForMessagingService");
         var uri = homeUrl + "/location";
         var data = {
             "ksid": currentObject.getKSID(),
             "latitude": latitude,
             "longitude": longitude
         };
         if (typeof(locationName) === "string") {
             data["locname"] = locationName;
         }
         if (authToken != null && authToken != undefined) {
             data[kony.sdk.constants.AUTH_TOKEN] = authToken;
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var payload = {
             postdata: JSON.stringify(data)
         };
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing updateGeoLocationForMessagingService's network call");
         networkProvider.post(uri, payload, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished updateGeoLocationForMessagingService with network success");
             currentObject.setAuthToken(authToken);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocationForMessagingService with network failure");
             kony.sdk.logsdk.error("UpdateGeoLocation :: UpdateGeoLocation for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * Update the location
      * @param {string} latitude - Latitude value
      * @param {string} longitude - Longitude value
      * @param {string} locationName - Location name
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.updateGeoLocation = function(latitude, longitude, locationName, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing updateGeoLocation");
         var tempKSID = currentObject.getKSID();
         var authToken = null;
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocation with execption");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         if (typeof(latitude) === 'undefined' || latitude === null) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocation with execption");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid latitude.");
         }
         if (typeof(longitude) === 'undefined' || longitude === null) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocation with execption");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid longitude.");
         }
         authToken = currentObject.getAuthToken(options);
         updateGeoLocationForMessagingService(latitude, longitude, locationName, authToken, function(res) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocation with success");
             successCallback(res);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocation with failure");
             failureCallback(err);
         });
     };
     /**
      * Update the location
      * @param {string} latitude - Latitude value
      * @param {string} longitude - Longitude value
      * @param {string} locationName - Location name
      * @param {string} authToken - Authorization Token
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     /**
      * @deprecated This method is deprecated because authToken can be given as a input through options param of
      * updateGeoLocation method
      */
     this.updateGeoLocationWithAuthToken = function(latitude, longitude, locationName, authToken, successCallback, failureCallback) {
         kony.sdk.logsdk.perf("Executing updateGeoLocationWithAuthToken");
         var tempKSID = currentObject.getKSID();
         if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
             kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
         }
         if (typeof(latitude) === 'undefined' || latitude === null) {
             kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid latitude.");
         }
         if (typeof(longitude) === 'undefined' || longitude === null) {
             kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid longitude.");
         }
         if (typeof(authToken) === 'undefined' || authToken === null) {
             kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken.");
         }
         updateGeoLocationForMessagingService(latitude, longitude, locationName, authToken, function(res) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocationWithAuthToken with success");
             successCallback(res);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished updateGeoLocationWithAuthToken with failure");
             failureCallback(err);
         });
     };
     /**
      * Mark the message as read for a given message id
      * @param {string} fetchId - Message id
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.markMessageRead = function(fetchId, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing markMessageRead");
         if (typeof(fetchId) === 'undefined' || fetchId === null) {
             kony.sdk.logsdk.perf("Executing finshed markMessageRead with exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid FetchId, it cannot be null");
         }
         var headers = {};
         headers["X-HTTP-Method-Override"] = "get";
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var uri = homeUrl + "/messages/open/" + fetchId;
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing markMessageRead's network call");
         networkProvider.get(uri, null, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished markMessageRead with network success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.perf("Executing finished markMessageRead with network failure");
             kony.sdk.logsdk.error("MarkMessageRead :: MarkMessageRead for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * Fetches the message conetent for a given message id
      * @param {string} fetchId - Message id
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.fetchMessageContent = function(fetchId, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing fetchMessageContent");
         if (typeof(fetchId) === 'undefined' || fetchId === null) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid FetchId, it cannot be null");
         }
         var uri = homeUrl + "/messages/content/" + fetchId;
         var headers = {};
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing fetchMessageContent's network call");
         networkProvider.get(uri, null, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished fetchMessageContent with network success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(errorObj) {
             kony.sdk.logsdk.perf("Executing finished fetchMessageContent with network failure");
             kony.sdk.logsdk.error("FetchMessageContent :: FetchMessageContent for messaging service failed with error", errorObj);
             kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
         }, null, networkOptions);
     };
     /**
      * subscribeAudience to create a audience for subscribed device
      * @param {string} firstName - audience firstName
      * @param {string} lastName - audience lastName
      * @param {string} emailId - audience emailId
      * @param {string} mobileNumber - audience mobileNumber
      * @param {string} country - country
      * @param {string} state - state
      * @param {Object] options - {authToken: <Auth Token>} and user defined attributes like PAN no,SSN.
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      */
     this.subscribeAudience = function(firstName, lastName, emailId, mobileNumber, country, state, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing subscribeAudience");
         if (kony.sdk.isNullOrUndefined(KSID)) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before creating or updating");
         }
         if (kony.sdk.isNullOrUndefined(firstName)) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid first name, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(lastName)) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid last name, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(mobileNumber)) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid mobile number, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(emailId)) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email Id, it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(country)) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid country, it cannot be null");
         }
         subscribeAudienceOrUpdate(firstName, lastName, emailId, mobileNumber, country, state, options, function(res) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience with success");
             successCallback(res);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished subscribeAudience with failure");
             failureCallback(err);
         });
     };
     /**
      * delete subscribed audience
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      **/
     this.unSubscribeAudience = function(successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing unSubscribeAudience");
         if (kony.sdk.isNullOrUndefined(KSID)) {
             kony.sdk.logsdk.perf("Executing finished unSubscribeAudience with an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before unsubscribe audience");
         }
         var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE + "/" + KSID;
         var headers = {};
         headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_DELETE;
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing unSubscribeAudience's network call");
         networkProvider.post(uri, null, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished unSubscribeAudience with network success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished unSubscribeAudience with network failure");
             kony.sdk.logsdk.error("### MessagingService::unSubscribeAudience failed to unsubscribe audience", err);
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }, null, networkOptions);
     };
     /*
      * get subscribed audience details
      * @param {function} successCallback - Callback method on success
      * @param {function} failureCallback - Callback method on failure
      * @param {dictionary} options - {authToken: <Auth Token>}
      */
     this.getSubscribedAudienceDetails = function(successCallback, failureCallback, options) {
             kony.sdk.logsdk.perf("Executing getSubscribedAudienceDetails");
             if (kony.sdk.isNullOrUndefined(KSID)) {
                 kony.sdk.logsdk.perf("Executing finished getSubscribedAudienceDetails with an exception");
                 throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before get subscribed audience details");
             }
             var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE + "/" + KSID;
             var headers = {};
             headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_GET;
             headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
             var networkOptions = {};
             networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
             kony.sdk.logsdk.perf("Executing getSubscribedAudienceDetails's network call");
             networkProvider.get(uri, null, headers, function(data) {
                 //override data store auth token with user given token
                 kony.sdk.logsdk.perf("Executing finished getSubscribedAudienceDetails with network success");
                 overrideAuthToken(options);
                 kony.sdk.verifyAndCallClosure(successCallback, data);
             }, function(err) {
                 kony.sdk.logsdk.perf("Executing finished getSubscribedAudienceDetails with network failure");
                 kony.sdk.logsdk.error("### MessagingService::getSubscribedAudienceDetails failed to get audience details", err);
                 kony.sdk.verifyAndCallClosure(failureCallback, err);
             }, null, networkOptions);
         }
         /*
          * get rich push content
          * @param pushId {string} - pushId for getting rich push content.Which we get after registering
          * for push notifications.
          * @param {function} successCallback - Callback method on success
          * @param {function} failureCallback - Callback method on failure
          * @param {dictionary} options - {authToken: <Auth Token>}
          */
     this.getRichPushContent = function(pushId, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing getRichPushContent");
         if (kony.sdk.isNullOrUndefined(KSID)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service to get rich push content");
         }
         if (kony.sdk.isNullOrUndefined(pushId)) {
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid PushId,it cannot be null");
         }
         var uri = homeUrl + kony.sdk.constants.RICH_PUSH_MESSAGE + pushId;
         var headers = {};
         headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_GET;
         headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing getRichPushContent's network call");
         networkProvider.get(uri, null, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished getRichPushContent with network success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished getRichPushContent with network failure");
             kony.sdk.logsdk.error("MESSAGING SERVICE :: getRichPushContent failed to get rich content with error", err);
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }, null, networkOptions);
     };
     /*
      * Update the list of beacons
      * @param {string} uuId - Universally Unique Identifier to identify a beacon in a network
      * @param {string} major - major id to identity and distinguish a group
      * @param {string} minor - distinguishing individual beacons within a group of beacons assigned a major value.
      * @param {function} successCallback - Callback method called on success.
      * @param {function} failureCallback - Callback method called on failure.
      * @param {object} options - options which accepts optional parameters such as ufid,appid and {authToken: <Auth Token>}
      */
     this.updateListOfBeacons = function(uuId, major, minor, successCallback, failureCallback, options) {
         kony.sdk.logsdk.perf("Executing updateListOfBeacons");
         if (kony.sdk.isNullOrUndefined(KSID)) {
             kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before updating list of beacons");
         }
         if (kony.sdk.isNullOrUndefined(uuId)) {
             kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid UUID,it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(major)) {
             kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid major,it cannot be null");
         }
         if (kony.sdk.isNullOrUndefined(minor)) {
             kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
             throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid minor,it cannot be null");
         }
         var uri = homeUrl + kony.sdk.constants.BEACON_UPDATE;
         var payload = {};
         payload[kony.sdk.constants.KSID] = KSID;
         var beaconsList = {};
         //beacon object has beacon details like uuid,major and minor
         var beacon = {};
         beacon["uuid"] = uuId;
         beacon["major"] = major;
         beacon["minor"] = minor;
         beaconsList["beacon"] = beacon;
         payload["beacons"] = beaconsList;
         payload[kony.sdk.constants.AUTH_TOKEN] = currentObject.getAuthToken(options);
         //appid and ufid are optional
         if (options && options["ufid"]) {
             payload["ufid"] = options["ufid"];
         }
         if (options && options["appid"]) {
             payload["appid"] = options["appid"];
         }
         var payload = {
             postdata: JSON.stringify(payload)
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
         var networkOptions = {};
         networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
         kony.sdk.logsdk.perf("Executing updateListOfBeacons's network call");
         networkProvider.post(uri, payload, headers, function(data) {
             //override data store auth token with user given token
             kony.sdk.logsdk.perf("Executing finished updateListOfBeacons with network success");
             overrideAuthToken(options);
             kony.sdk.verifyAndCallClosure(successCallback, data);
         }, function(err) {
             kony.sdk.logsdk.perf("Executing finished updateListOfBeacons with network failure");
             kony.sdk.logsdk.error("MESSAGING SERVICE :: updateListOfBeacons failed to update with error", err);
             kony.sdk.verifyAndCallClosure(failureCallback, err);
         }, null, networkOptions);
     };
     /*
      * Utility method to override datastore authtoken with user given auth token.
      */
     var overrideAuthToken = function(options) {
         var authToken;
         if (options && options[kony.sdk.constants.AUTH_TOKEN]) {
             currentObject.setAuthToken(options[kony.sdk.constants.AUTH_TOKEN]);
         }
     };
 }
 /**
  * Method to create the Metrics service instance with the provided service name.
  * @returns {MetricsService} Metrics service instance
  */
 kony.sdk.prototype.getMetricsService = function() {
     if (!kony.sdk.isInitialized) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Metrics service.");
     }
     if (!kony.sdk.isLicenseUrlAvailable) {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "metrics is not enabled");
     }
     //var metricsServiceObject = null;
     if (this.metricsServiceObject) {
         return this.metricsServiceObject;
     }
     if (this.internalSdkObject) {
         //framework implementation
         this.metricsServiceObject = this.internalSdkObject.getMetricsService();
     } else {
         //sdk local implementation
         this.metricsServiceObject = new MetricsService(this);
     }
     return this.metricsServiceObject;
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Metrics service instance for invoking the Metrics services.
  */
 function MetricsService(konyRef) {
     var url = konyRef.customReportingURL;
     if (typeof(url) === 'undefined') {
         throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "reporting url is undefined");
     }
     var networkProvider = new konyNetworkProvider();
     /**
      * invoke the getUserId operation
      */
     this.getUserId = function() {
         return konyRef.getUserId();
     };
     //start of event api
     var eventFlowTag = "";
     var eventBufferMaxValue = 1000;
     var eventBufferAutoFlushValue = 15;
     var characterLengthLimit = 256;
     var eventConfig = {
         "confType": "BUFFER",
         "eventBufferAutoFlushCount": eventBufferAutoFlushValue,
         "eventBufferMaxCount": eventBufferMaxValue
     };
     var reportEventBufferArray = [];
     var reportEventBufferBackupArray = [];
     var retrievedDS = false;
     var eventBufferCount = 0;
     var eventTypeMap = {
         "formentry": "FormEntry",
         "formexit": "FormExit",
         "touch": "Touch",
         "servicerequest": "ServiceRequest",
         "serviceresponse": "ServiceResponse",
         "gesture": "Gesture",
         "orientation": "Orientation",
         "error": "Error",
         "exception": "Exception",
         "crash": "Crash",
         "custom": "Custom",
         "servicecall": "ServiceCall",
         "apptransition": "AppTransition",
         "appload": "AppLoad",
         "component": "Component"
     };
     var errorCodeMap = {
         "1000": true,
         "1011": true,
         "1012": true,
         "1014": true,
         "1015": true,
         "1016": true
     };
     /**
      * This method will take the a String to set a Flow Tag for the reported events.
      * @param {string} flowTag - sets flow tag for reporting the events.
      */
     this.setFlowTag = function(flowTag) {
         if (kony.sdk.isNullOrUndefined(flowTag)) {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event flow tag");
         } else if (flowTag.length <= characterLengthLimit) {
             eventFlowTag = flowTag;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + characterLengthLimit + " characters");
         }
     };
     /**
      * This method will clear the flow tag set by the user previously.
      */
     this.clearFlowTag = function() {
         eventFlowTag = "";
     };
     /**
      * This method will return the a String to set a Flow Tag for the reported events.
      * @return {string} flowTag - flow tag set by the user for reporting the events.
      */
     this.getFlowTag = function() {
         return eventFlowTag;
     };
     /**
      * This method will take the required values to set the event Configuration values.
      * @param {string} confType - sets the Current Configuration Type
      * 					possible values BUFFER or INSTANT.
      * @param {number} eventBufferAutoFlushCount - event buffer count to auto flush the events
      * 								possible values any positive integer
      * 								Default value 15
      * @param {number} eventBufferMaxCount - Maximum event buffer count to store the events
      * 								possible values any positive integer
      * 								Default value 1000
      */
     this.setEventConfig = function(confType, eventBufferAutoFlushCount, eventBufferMaxCount) {
         if (kony.sdk.isNullOrUndefined(confType)) {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Config Type can not be null");
         } else {
             confType = confType.toUpperCase();
         }
         if (confType === "BUFFER") {
             eventConfig["confType"] = confType;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for config type");
         }
         if (!kony.sdk.isNullOrUndefined(eventBufferMaxCount) && typeof(eventBufferMaxCount) === "number" && eventBufferMaxCount > 0) {
             eventConfig["eventBufferMaxCount"] = eventBufferMaxCount;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferMaxCount has to be a Number and greater than 0");
         }
         if (!kony.sdk.isNullOrUndefined(eventBufferAutoFlushCount) && typeof(eventBufferAutoFlushCount) === "number" && eventBufferAutoFlushCount > 0 && eventBufferAutoFlushCount <= eventBufferMaxCount) {
             eventConfig["eventBufferAutoFlushCount"] = eventBufferAutoFlushCount;
         } else if (eventBufferAutoFlushCount >= eventBufferMaxCount) {
             eventConfig["eventBufferMaxCount"] = 1000;
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount can not be greater than eventBufferMaxCount");
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount has to be a Number and greater than 0");
         }
     };
     /**
      * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
      * @param {string} evttype - Event Type for the reported event.
      * @param {string} evtSubType - string literal for eventSubType(max 256 Chars)
      * @param {string} formID -   string literal for formID(max 256 Chars)
      * @param {string} widgetID - string literal for widgetID(max 256 Chars)
      * @param {string} flowTag - string literal to override flow tag (max 256 Chars)
      * @param {string} metaData - string to describe metaData
      * @throws Exception
      */
     this.sendEvent = function(evttype, evtSubType, formID, widgetID, flowTag, metaData) {
         if (reportEventBufferBackupArray.length === 0) {
             this.readFromDS();
         }
         eventBufferCount = reportEventBufferBackupArray.length + reportEventBufferArray.length;
         if (eventBufferCount === eventConfig["eventBufferMaxCount"]) {
             kony.sdk.logsdk.warn("Reached maximum limit of '" + eventBufferCount + "' events in buffer, No more events will be stored");
             return;
         }
         var reportEventMap = {};
         reportEventMap.ts = kony.sdk.formatCurrentDate(new Date());
         evttype = evttype.toLowerCase();
         if (kony.sdk.isNullOrUndefined(eventTypeMap[evttype])) {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event type");
         } else {
             reportEventMap["evttype"] = eventTypeMap[evttype];
         }
         if (kony.sdk.isNullOrUndefined(evtSubType)) {
             reportEventMap["evtSubType"] = "";
         } else if (evtSubType.length <= characterLengthLimit) {
             reportEventMap["evtSubType"] = evtSubType;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event evtSubType is " + characterLengthLimit + " characters");
         }
         if (kony.sdk.isNullOrUndefined(formID)) {
             reportEventMap["formID"] = kony.application.getCurrentForm().id;
         } else if (formID.length <= characterLengthLimit) {
             reportEventMap["formID"] = formID;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event formID is " + characterLengthLimit + " characters");
         }
         if (kony.sdk.isNullOrUndefined(widgetID)) {
             reportEventMap["widgetID"] = "";
         } else if (widgetID.length <= characterLengthLimit) {
             reportEventMap["widgetID"] = widgetID;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event widgetID is " + characterLengthLimit + " characters");
         }
         if (kony.sdk.isNullOrUndefined(flowTag)) {
             reportEventMap["flowTag"] = this.getFlowTag();
         } else if (flowTag.length <= characterLengthLimit) {
             reportEventMap["flowTag"] = flowTag;
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flowTag is " + characterLengthLimit + " characters");
         }
         reportEventMap.SID = this.getSessionId();
         reportEventMap.metaData = metaData;
         //checking each event data is a proper json or not
         // 	throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for events data");
         // }
         reportEventBufferArray.push(reportEventMap);
         if (reportEventBufferArray.length % eventConfig["eventBufferAutoFlushCount"] === 0) {
             this.flushEvents();
         }
     };
     /**
      * This method will send the buffered events to the server at once.
      */
     this.flushEvents = function() {
         var url = kony.sdk.currentInstance.customReportingURL;
         var ref = this;
         if (reportEventBufferBackupArray.length === 0) {
             ref.readFromDS();
         }
         if (reportEventBufferBackupArray.length === 0 && reportEventBufferArray.length === 0) {
             kony.sdk.logsdk.warn("There are no events to flush");
             return;
         }
         var payload = kony.sdk.getPayload(kony.sdk.getCurrentInstance());
         var params = {};
         if (reportEventBufferArray.length !== 0) {
             ref.pushEventsToBufferArray();
         }
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         payload.events = reportEventBufferBackupArray;
         payload.svcid = "SendEvents";
         payload.rsid = this.getSessionId();
         params[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
         var options = {};
         options["disableIntegrity"] = true;
         networkProvider.post(url, params, headers, flushSuccessCallback, flushErrorCallback, null, options);

         function flushSuccessCallback(response) {
             if (response.opstatus == 0) {
                 ref.clearBufferEvents();
             } else if (errorCodeMap[response.opstatus]) {
                 ref.saveInDS();
             } else {
                 ref.clearBufferEvents();
             }
         }

         function flushErrorCallback(response) {
             kony.sdk.logsdk.error("Unable to flush events");
             ref.saveInDS();
         }
     };
     /*Stores event data in Data Store on failure of service Call*/
     this.saveInDS = function() {
         var eventsToSave = [];
         eventsToSave.push(JSON.stringify(reportEventBufferBackupArray));
         kony.ds.save(eventsToSave, "konyMetricsBuffer");
         reportEventBufferBackupArray = [];
     };
     /*Clearing events sent to server */
     this.clearBufferEvents = function() {
         reportEventBufferBackupArray = [];
         kony.ds.remove("konyMetricsBuffer");
     };
     /*Reading any pending events from Data Store */
     this.readFromDS = function() {
         var eventsFromDS = kony.ds.read("konyMetricsBuffer");
         if (eventsFromDS !== null) {
             var pushToArray = [];
             pushToArray.push(JSON.parse(eventsFromDS[0]));
             reportEventBufferBackupArray.push.apply(reportEventBufferBackupArray, pushToArray);
         }
     };
     /*Pushes events received from user to BufferBackupArray which will be flushed to server */
     this.pushEventsToBufferArray = function() {
         reportEventBufferBackupArray.push.apply(reportEventBufferBackupArray, reportEventBufferArray);
         reportEventBufferArray = [];
     };
     /**
      * This method will return the a List of the buffered events.
      * @return {object} events - list of events stored in buffer.
      */
     this.getEventsInBuffer = function() {
         var eventsFromDS = kony.ds.read("konyMetricsBuffer");
         var eventsToReturn = [];
         if (!kony.sdk.isNullOrUndefined(eventsFromDS)) {
             eventsToReturn.push(JSON.parse(eventsFromDS[0]));
         }
         if (reportEventBufferArray.length !== 0) {
             eventsToReturn.push.apply(eventsToReturn, reportEventBufferArray);
         }
         if (eventsToReturn.length !== 0) {
             return eventsToReturn;
         } else {
             return null;
         }
     };
     /**
      * invoke the sendCustomMetrics operation
      * @param {string} reportingGroupID - reporting Group ID
      * @param {object} metrics - metrics being reported
      */
     this.sendCustomMetrics = function(reportingGroupID, metrics) {
         if (typeof(metrics) !== "object") {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid type for metrics data.");
         }
         var reportData = kony.sdk.dataStore.getItem("konyCustomReportData");
         if (!reportData) {
             reportData = [];
         } else {
             reportData = JSON.parse(reportData);
         }
         kony.sdk.dataStore.removeItem("konyCustomReportData");
         var currentData = {};
         currentData.ts = kony.sdk.formatCurrentDate(new Date().toString());
         currentData.fid = reportingGroupID;
         currentData.metrics = metrics;
         currentData.rsid = this.getSessionId();
         reportData.push(currentData);
         //nyRef.getDataStore().setItem("konyCustomReportData",JSON.stringify(reportData));
         var payload = kony.sdk.getPayload(konyRef);
         if (kony.sdk.metric) {
             if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
                 kony.sdk.metric.readFromDS();
             }
             kony.sdk.metric.pushEventsToBufferArray();
             payload.events = kony.sdk.metric.reportEventBufferBackupArray;
         }
         payload.reportData = reportData;
         payload.rsid = this.getSessionId();
         payload.svcid = "CaptureKonyCustomMetrics";
         var newData = {};
         newData[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
         var options = {};
         options["disableIntegrity"] = true;
         var headers = {};
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         networkProvider.post(url, newData, headers, function(res) {
             //successcallback
             //konyRef.getDataStore().removeItem("konyCustomReportData");
             if (kony.sdk.metric) {
                 kony.sdk.metric.clearBufferEvents();
             }
             kony.sdk.logsdk.info("metric data successfully sent" + JSON.stringify(res));
         }, function(res) {
             var storeData = kony.sdk.dataStore.getItem("konyCustomReportData");
             if (!storeData) {
                 storeData = reportData;
             } else {
                 storeData = JSON.parse(storeData);
                 reportData.forEach(function(e) {
                     storeData.push(e);
                 });
             }
             if (kony.sdk.metric) {
                 if (kony.sdk.metric.errorCodeMap[res.opstatus]) {
                     kony.sdk.metric.saveInDS();
                 }
             }
             kony.sdk.dataStore.setItem("konyCustomReportData", JSON.stringify(storeData));
             kony.sdk.logsdk.error("Unable to send metric report" + JSON.stringify(res));
         }, true, options);
     };
     /**
      * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
      * @param {string} errorCode - errorCode of the reported error. Can be empty if not applicable
      * @param {string} errorType -   errorType of the reported error. Can be empty if not applicable
      * @param {string} errorMessage - errorMessage of the reported error. Can be empty if not applicable
      * @param {json} errorDetails - errorDetails of the reported error as a json string that can have key-value pairs for the following
     				keys errfile, errmethod, errline, errstacktrace, formID, widgetID, flowTag.
      * @throws Exception
      */
     this.reportError = function(errorCode, errorType, errorMessage, errorDetails) {
         var metaData = {};
         metaData.errcode = errorCode ? errorCode : "";
         metaData.errmsg = errorMessage ? errorMessage : "";
         if (errorDetails && kony.sdk.isJson(errorDetails)) {
             metaData.errfile = errorDetails.errfile ? errorDetails.errfile : "";
             metaData.errmethod = errorDetails.errmethod ? errorDetails.errmethod : "";
             metaData.errline = errorDetails.errline ? errorDetails.errline : "";
             metaData.errstacktrace = errorDetails.errstacktrace ? errorDetails.errstacktrace : "";
             metaData.errcustommsg = errorDetails.errcustommsg ? errorDetails.errcustommsg : "";
             var formID = errorDetails.formID ? errorDetails.formID : "";
             var widgetID = errorDetails.widgetID ? errorDetails.widgetID : "";
             var flowTag = errorDetails.flowTag ? errorDetails.flowTag : "";
             var evtSubType = errorType ? errorType : "";
             this.sendEvent("Error", evtSubType, formID, widgetID, flowTag, JSON.stringify(metaData));
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for error details.");
         }
     };
     /**
      * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
      * @param {string} exceptionCode - Code for the reported exception. Can be empty if not applicable
      * @param {string} exceptionType -   Type of the reported exception. Can be empty if not applicable
      * @param {string} exceptionMessage - Message of the reported exception. Can be empty if not applicable
      * @param {json}   exceptionDetails - Details of the reported exception as a JSON string that can have key-value pairs for the
     				following keys exceptioncode, exceptionfile, exceptionmethod, exceptionline,
     				exceptionstacktrace, formID, widgetID, flowTag.
      * @throws Exception
      */
     this.reportHandledException = function(exceptionCode, exceptionType, exceptionMessage, exceptionDetails) {
         var metaData = {};
         metaData.exceptioncode = exceptionCode ? exceptionCode : "";
         metaData.exceptionmsg = exceptionMessage ? exceptionMessage : "";
         if (exceptionDetails && kony.sdk.isJson(exceptionDetails)) {
             metaData.exceptionfile = exceptionDetails.errfile ? exceptionDetails.errfile : "";
             metaData.exceptionmethod = exceptionDetails.errmethod ? exceptionDetails.errmethod : "";
             metaData.exceptionline = exceptionDetails.errline ? exceptionDetails.errline : "";
             metaData.exceptionstacktrace = exceptionDetails.errstacktrace ? exceptionDetails.errstacktrace : "";
             metaData.exceptioncustommsg = exceptionDetails.errcustommsg ? exceptionDetails.errcustommsg : "";
             var formID = exceptionDetails.formID ? exceptionDetails.formID : "";
             var widgetID = exceptionDetails.widgetID ? exceptionDetails.widgetID : "";
             var flowTag = exceptionDetails.flowTag ? exceptionDetails.flowTag : "";
             var evtSubType = exceptionType ? exceptionType : "";
             this.sendEvent("Exception", evtSubType, formID, widgetID, flowTag, JSON.stringify(metaData));
         } else {
             throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for exception details.");
         }
     };
     /**
      * sets the current sessionId
      * @param {string} sessionId
      */
     this.setSessionId = function(sessionId) {
         if (sessionId) {
             kony.sdk.currentInstance.setSessionId(sessionId);
         }
     };
     /**
      * get the current sessionID
      *
      */
     this.getSessionId = function() {
         return kony.sdk.currentInstance.getSessionId();
     };
     /**
      * stub method used for event tracking
      *
      */
     this.setEventTracking = function(eventTypes) {
         // Stub.  This is implemented in native->js binding
     }
 }
 kony.sdk.initiateSession = function() {};
 /**
  * Method which returns the offline enabled ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OfflineEnabledObjectService = function(konyRef, serviceName) {
     this.serviceName = serviceName;
     this.konyRef = konyRef;
     /**
      * This method is used to fetch records on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.fetch = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.fetch");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();

             function fetchHandler(objMetadata) {
                 var obj = new kony.sdk.KNYObj(objectName);
                 var readOptions = dataObject.getOfflineObjectsOptions();
                 /* If read options are not supplied, caller such as fetchDataForColumns model API would provide a select query object and some callers provide query params.
                  *  We parse the select query or queryParams to suite offline objects read API.
                  */
                 if (!readOptions || Object.keys(readOptions).length == 0) {
                     var selectQueryObject = dataObject.getSelectQueryObject();
                     var queryParams = options[kony.sdk.constants.ObjectServiceConstants.QUERYPARAMS];
                     if (selectQueryObject) {
                         readOptions.projectionColumns = [];
                         var columns = selectQueryObject.getColumns();
                         for (var column in columns) {
                             readOptions.projectionColumns.push(columns[column].getName());
                         }
                         var criteriaList = selectQueryObject.getCriterias();
                         var primaryKeys = {};
                         for (var criteria in criteriaList) {
                             var colObj = criteriaList[criteria].getColumn();
                             if (colObj) {
                                 primaryKeys[colObj.getName()] = criteriaList[criteria].getValue();
                             }
                         }
                         readOptions.primaryKeys = primaryKeys;
                     } else if (queryParams) {
                         var primaryKeys = {};
                         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
                             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                                 var pKey = objMetadata.primaryKey[indx];
                                 var pKeyValue = queryParams[pKey];
                                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                                     kony.sdk.logsdk.error("### OfflineEnabledObjectService:: fetch Error: Primarykey details missing so unable to fetch");
                                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                                     return;
                                 }
                                 primaryKeys[pKey] = pKeyValue;
                             }
                             readOptions.primaryKeys = primaryKeys;
                         } else {
                             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: fetch Error: Primarykey details missing so unable to fetch");
                             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                             return;
                         }
                     }
                 }

                 function fetchSuccessHandler(res) {
                     var response = {};
                     response.records = res;
                     successCallback(response);
                 }
                 obj.get(readOptions, fetchSuccessHandler, failureCallback);
             }
             this.getMetadataOfObject(objectName, {}, fetchHandler, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Fetch on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to create a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.create = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.create");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();
             var obj = new kony.sdk.KNYObj(objectName);
             var createOptions = dataObject.getOfflineObjectsOptions();
             var records = dataObject.getRecord();
             obj.create(records, createOptions, successCallback, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Create on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to update a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.update = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.update");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();

             function updateHandler(objMetadata) {
                 var obj = new kony.sdk.KNYObj(objectName);
                 var updateOptions = dataObject.getOfflineObjectsOptions();
                 var records = dataObject.getRecord();
                 // If primary keys are not supplied through options, they are picked from the user supplied record.
                 if (!updateOptions || Object.keys(updateOptions).length == 0 || !updateOptions['primaryKeys']) {
                     if (records) {
                         var primaryKeys = {};
                         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
                             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                                 var pKey = objMetadata.primaryKey[indx];
                                 var pKeyValue = records[pKey];
                                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                                     kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Update Error: Primarykey details missing so unable to update");
                                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                                     return;
                                 }
                                 primaryKeys[pKey] = pKeyValue;
                                 delete records[pKey];
                             }
                             updateOptions.primaryKeys = primaryKeys;
                         } else {
                             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Update Error: Primarykey details missing so unable to update");
                             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                             return;
                         }
                     } else {
                         kony.sdk.logsdk.error("Update Failed: primaryKeys key missing. Please use dataObject setOfflineObjectsOptions to set primaryKeys for update operation.");
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                         return;
                     }
                 }
                 obj.updateByPK(records, updateOptions, successCallback, failureCallback);
             }
             this.getMetadataOfObject(objectName, {}, updateHandler, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Update on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to delete a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.deleteRecord = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.deleteRecord");
         if (!areOptionsValid(options, failureCallback)) {
             return;
         }
         try {
             var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
             var objectName = dataObject.getObjectName();

             function deleteHandler(objMetadata) {
                 var obj = new kony.sdk.KNYObj(objectName);
                 var deleteOptions = dataObject.getOfflineObjectsOptions();
                 // If primary keys are not supplied through options, they are picked from the user supplied record
                 if (!deleteOptions || Object.keys(deleteOptions).length == 0 || !deleteOptions['primaryKeys']) {
                     var records = dataObject.getRecord();
                     if (records) {
                         var primaryKeys = {};
                         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
                             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                                 var pKey = objMetadata.primaryKey[indx];
                                 var pKeyValue = records[pKey];
                                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                                     kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Delete Error: Primarykey details missing so unable to delete");
                                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                                     return;
                                 }
                                 primaryKeys[pKey] = pKeyValue;
                             }
                             deleteOptions.primaryKeys = primaryKeys;
                         } else {
                             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Delete Error: Primarykey details missing so unable to delete");
                             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                             return;
                         }
                     } else {
                         kony.sdk.logsdk.error("Delete Failed: primaryKeys key missing. Please use dataObject setOfflineObjectsOptions to set primaryKeys for delte operation.");
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                         return;
                     }
                 }
                 obj.deleteByPK(deleteOptions, successCallback, failureCallback);
             }
             this.getMetadataOfObject(objectName, {}, deleteHandler, failureCallback);
         } catch (error) {
             kony.sdk.logsdk.error("Delete on offline enabled object failed with error: " + error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
     };
     /**
      * This method is used to retrieve metadata of all objects
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.getMetadataOfAllObjects");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("EXiting kony.sdk.OfflineEnabledObjectService.getMetadataOfAllObjects");
     };
     /**
      * This method is used to retrive metadata of a specific object
      * @param objectName
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.getMetadataOfObject");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineEnabledObjectService.getMetadataOfObject");
     };
     /**
      * This method is used to validate options
      * @param options
      * @param failureCallback
      */
     function areOptionsValid(options, failureCallback) {
         if (options == null || options == undefined) {
             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: options null or undefined");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return false;
         }
         if (!(options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: invalid data object");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return false;
         }
         var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
         var objectName = dataObject.getObjectName();
         if (objectName == null || objectName == undefined) {
             kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: objectname null or undefined");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "objectName" + kony.sdk.errormessages.null_or_undefined));
             return false;
         }
         return true;
     };
 };
 /**
  * Method which returns the offline ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OfflineObjectService = function(konyRef, serviceName) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService");
     this.konyRef = konyRef;
     this.serviceName = serviceName;
     /**
      * This method is used to create a record on the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.create = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.create");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var dataObject = options["dataObject"];

         function createHandler(objMetadata) {
             _invokeOfflineCreate(dataObject, successCallback, failureCallback, options);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, createHandler, failureCallback);
     };
     /**
      * This method is used to fetch records from the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.fetch = function(options, successCallback, failureCallback) {
         throw "This method is not implemented.Instead use executeSelectQuery";
     };
     /**
      * This method is used to update a record in the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.update = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.update");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var dataObject = options["dataObject"];

         function updateHandler(objMetadata) {
             function updateSuccessCallback(response) {
                 kony.sdk.verifyAndCallClosure(successCallback, response);
             }

             function updateFailureCallback(error) {
                 if (error != null && error != undefined) {
                     //if the errorcode is equivalent to transaction failed then giving some generic error message to the client.
                     if (error["errorCode"] == 7010) {
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.transaction_failed, kony.sdk.errormessages.transaction_failed));
                         return;
                     }
                 }
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             }
             _invokeOfflineUpdate(dataObject, updateSuccessCallback, updateFailureCallback, options);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, updateHandler, failureCallback);
     };
     /**
      * This method is used to delete a record in the object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
      * @param successCallback
      * @param failureCallback
      */
     this.deleteRecord = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.deleteRecord");
         if (options == null || options == undefined) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var dataObject = options["dataObject"];

         function deleteHandler(objMetadata) {
             function deleteSuccessCallback(response) {
                 //verifying delete response contains deleted records count as 0
                 if (response != null && response != undefined) {
                     if (response["rowsdeleted"] == 0) {
                         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.norecords_to_delete, kony.sdk.errormessages.norecords_to_delete));
                         return;
                     }
                 }
                 kony.sdk.verifyAndCallClosure(successCallback, response);
             }

             function deleteFailureCallback(error) {
                 kony.sdk.verifyAndCallClosure(failureCallback, error);
             }
             _invokeOfflineDelete(dataObject, deleteSuccessCallback, deleteFailureCallback, options);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, deleteHandler, failureCallback);
     };
     /**
      * This method is used to retrieve metadata of all objects
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getMetadataOfAllObjects");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineObjectService.getMetadataOfAllObjects");
     };
     /**
      * This method is used to retrive metadata of a specific object
      * @param objectName
      * @param options
      * @param successCallback
      * @param failureCallback
      */
     this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getMetadataOfObject");
         _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
         kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineObjectService.getMetadataOfObject");
     };
     /**
      * This method is used to execute an sql query
      * @param queryStr
      * @param successCallback
      * @param failureCallback
      */
     this.executeSelectQuery = function(queryStr, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.executeSelectQuery");

         function selctSuccess(response) {
             kony.sdk.logsdk.debug("### OfflineObjectService::executeSelectQuery::selectSuccess Response:", response);
             kony.sdk.verifyAndCallClosure(successCallback, response);
         }

         function selectError(error) {
             kony.sdk.logsdk.error("### OfflineObjectService::executeSelectQuery::selectError Error:", error);
             kony.sdk.verifyAndCallClosure(failureCallback, error);
         }
         kony.sync.single_select_execute(kony.sdk.util.getSyncDbName(), queryStr, null, selctSuccess, selectError);
     };
     /**
      * Helps to get the binary content of the specified column on the Object
      * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject), "responsetype":"base64string/filepath(Default)", "binaryAttrName":columnName}
      * @param successCallback
      * @param failureCallback
      */
     this.getBinaryContent = function(options, successCallback, failureCallback) {
         kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getBinaryContenttion");
         if (kony.sdk.isNullOrUndefined(options)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
             return;
         }
         var dataObject = options["dataObject"];
         if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
             return;
         }
         var binaryColName = options["binaryAttrName"];
         if (kony.sdk.isNullOrUndefined(binaryColName)) {
             kony.sdk.logsdk.error("### OfflineObjectService::getBinaryContent Error: Please provide column name to fetch binary content");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
             return;
         }
         var getBase64 = options["responsetype"] === "base64string" ? true : false;
         var config = options["config"];

         function getBinaryDataHandler(objMetadata) {
             function selectSuccessCallback(response) {
                 kony.sdk.logsdk.debug("### OfflineObjectService::getBinaryContent::selectSuccessCallback Response", response);
                 var filePath = response["FilePath"];
                 if (getBase64) {
                     getBase64BasedOnFileType(filePath, successCallback, failureCallback);
                 } else {
                     //get filepath from response
                     kony.sdk.verifyAndCallClosure(successCallback, filePath);
                 }
             }

             function selectErrorCallback(error) {
                 kony.sdk.logsdk.error("### OfflineObjectService::getBinaryContent::selectErrorCallback Error:", error);
                 _invokeOfflineErrorCallback(failureCallback, error);
             }

             function getBase64BasedOnFileType(filePath, successCallback, failureCallback) {
                 var id = filePath.substring(filePath.lastIndexOf("/") + 1, filePath.length);
                 var query = "Select type from " + kony.sync.blobStoreManagerTable + " where id = " + id;
                 sync.executeSelectQuery(query, function(res) {
                     var base64String;
                     try {
                         if (res[0].type && res[0].type === kony.sync.blobTypeBase64) {
                             //get base64 from base64 file using SDK's FFI BlobStoreUtil
                             base64String = binary.util.getBase64FromFile(filePath);
                         } else {
                             //get base64 from binary file using FW APIs
                             var tempFile = new kony.io.File(filePath);
                             if (!kony.sdk.isNullOrUndefined(tempFile) && tempFile.exists() && tempFile.readable) {
                                 var tempRawBytes = tempFile.read();
                                 base64String = kony.convertToBase64(tempRawBytes);
                             } else {
                                 invokeFailureCallbackForGetBinaryContent(filePath, failureCallback);
                             }
                         }
                     } catch (ex) {
                         invokeFailureCallbackForGetBinaryContent(JSON.stringify(ex), failureCallback);
                     }
                     kony.sdk.verifyAndCallClosure(successCallback, base64String);
                 }, function(err) {
                     invokeFailureCallbackForGetBinaryContent(JSON.stringify(err), failureCallback);
                 });
             }

             function invokeFailureCallbackForGetBinaryContent(msg, failureCallback) {
                 kony.sdk.logsdk.error("Error in creating base64 string from local file : ", msg);
                 var errorCode = kony.sdk.errorcodes.invalid_blob;
                 var errorMessage = kony.sdk.errormessages.invalid_blob;
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(errorCode, errorMessage));
             }
             var dbName = kony.sdk.util.getSyncDbName();
             var objName = dataObject.getObjectName();
             var columnValues = kony.sdk.util.populateColumnValues(dataObject.getRecord(), null);
             var colMeta = kony.sdk.util.getMetadataOfColumn(objMetadata, binaryColName);
             if (kony.sdk.isNullOrUndefined(colMeta)) {
                 kony.sdk.logsdk.warn("### OfflineObjectService::getBinaryContent Error: Invalid binary attribute name.");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Invalid binary attribute name."));
                 return;
             }
             if (colMeta["datatype"] !== kony.sdk.constants.BINARY_DATATYPE) {
                 kony.sdk.logsdk.warn("### OfflineObjectService::getBinaryContent Error: Datatype is not binary for the specified binary attribute name");
                 kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Datatype is not binary for the specified binary attribute name"));
                 return;
             }
             var pkTable = kony.sdk.util.getPkTableForBinary(objMetadata, columnValues, failureCallback);
             kony.sync.getBinary(dbName, objName, binaryColName, pkTable, config, selectSuccessCallback, selectErrorCallback);
         }
         this.getMetadataOfObject(dataObject.getObjectName(), {}, getBinaryDataHandler, failureCallback);
     };

     function _invokeOfflineErrorCallback(failureCallback, errorObject) {
         //call the failureCallback after adding opstatus to the errorObject.
         var errorCode, errorMessage;
         if (errorObject) {
             errorCode = (errorObject.hasOwnProperty("errorCode")) ? errorObject["errorCode"] : kony.sdk.errorcodes.transaction_failed;
             errorMessage = (errorObject.hasOwnProperty("errorMessage")) ? errorObject["errorMessage"] : kony.sdk.errormessages.transaction_failed;
         } else {
             errorCode = kony.sdk.errorcodes.transaction_failed;
             errorMessage = kony.sdk.errormessages.transaction_failed;
         }
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(errorCode, errorMessage));
     }

     function _invokeOfflineCreate(dataObject, successCallback, failureCallback, options) {
         var dbname = kony.sdk.util.getSyncDbName();
         kony.sync.single_insert_execute(dbname, dataObject.getObjectName(), dataObject.getRecord(), successCallback, function(err) {
             _invokeOfflineErrorCallback(failureCallback, err);
         }, true, options);
     }

     function _invokeOfflineUpdate(dataObject, successCallback, failureCallback, options) {
         var objectName = dataObject.getObjectName();
         var columnValues = dataObject.getRecord();
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
         var pkTable = {};
         var whereClause = [];
         if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
             for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                 var pKey = objMetadata.primaryKey[indx];
                 var pKeyValue = columnValues[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                     //TODO change to error object
                     kony.sdk.logsdk.error("### OfflineObjectService::_invokeOfflineUpdate Error: Primarykey details missing so unable to update");
                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 pkTable.pKey = {
                     "key": pKey,
                     "value": pKeyValue
                 };
                 var condition = {};
                 condition.key = pKey;
                 condition.value = pKeyValue;
                 whereClause.push(condition);
             }
         } else {
             //TODO change to error object
             kony.sdk.logsdk.error("### OfflineObjectService::_invokeOfflineUpdate Error: Primarykey details missing so unable to update");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         var dbName = kony.sdk.util.getSyncDbName();
         kony.sync.single_update_execute(dbName, objectName, columnValues, whereClause, successCallback, function(err) {
             _invokeOfflineErrorCallback(failureCallback, err);
         }, false, true, null, options);
     }

     function _invokeOfflineDelete(dataObject, successCallback, failureCallback, options) {
         var isError = false;
         var markForUpload = false;
         var tbname = dataObject.getObjectName();
         var errMsg = null;
         var wcs = [];
         var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, dataObject.getObjectName());
         var dbName = kony.sdk.util.getSyncDbName();
         var srcAttributes = kony.sdk.util.getPrimarykeysFromMetadata(objMetadata);
         if (srcAttributes != null && srcAttributes != undefined) {
             var pkLen = Object.keys(srcAttributes).length;
             for (var indx = 0; indx < pkLen; indx++) {
                 var pKey = Object.keys(srcAttributes)[indx];
                 var pKeyValue = dataObject.getRecord()[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                     //TODO
                     //throw error
                     kony.sdk.logsdk.error("### _invokeOfflineDelete:: Error Primarykey details missing so unable to delete");
                     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                     return;
                 }
                 var whereClause = {};
                 whereClause.key = pKey;
                 whereClause.value = pKeyValue;
                 kony.table.insert(wcs, whereClause);
             }
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### _invokeOfflineDelete:: Error Primarykey details missing so unable to delete");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
         }
         kony.sync.single_delete_execute(dbName, tbname, wcs, successCallback, function(err) {
             _invokeOfflineErrorCallback(failureCallback, err);
         }, false, false, true, options);
     }
 };
 //Utils specific to MVVM/MDA/MVC SDK
 // This function is responsible for checking if the array contains the object based on object's name property.
 // returns the array element if the object matches
 kony.sdk.util.getExtendedFieldsFromArray = function(array, object) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.getExtendedFieldsFromArray");
     if (array instanceof Array) {
         for (var i = 0; i < array.length; i++) {
             if (array[i] instanceof kony.sdk.dto.FieldMetadata && object instanceof kony.sdk.dto.Column) {
                 if (kony.sdk.util.matchIgnoreCase(array[i].name, object.getName()) && kony.sdk.util.matchIgnoreCase(array[i].type, "extendedfield")) {
                     return array[i];
                 }
             }
         }
         return null;
     }
 };
 /**
  * This Object represent picklist values
  * @constructor
  */
 kony.sdk.dto.PickList = function() {
         kony.sdk.logsdk.trace("Entering into kony.sdk.dto.PickList");
         this.id = null;
         this.active = null;
         this.label = null;
         this.value = null;
         this.validFor = null;
         this.defaultValue = null;
         this.fieldMappingId = null;
         this.setId = function(id) {
             this.id = id;
         }
         this.getId = function() {
             return this.id;
         }
         this.setActive = function(active) {
             this.active = active;
         }
         this.isActive = function() {
             return this.active;
         }
         this.setLabel = function(label) {
             this.label = label;
         }
         this.getLabel = function() {
             return this.label;
         }
         this.setValue = function(value) {
             this.value = value;
         }
         this.getValue = function() {
             return this.value;
         }
         this.setValidFor = function(validFor) {
             this.validFor = validFor;
         }
         this.getValidFor = function() {
             return this.validFor;
         }
         this.setDefaultValue = function(defaultValue) {
             this.defaultValue = defaultValue;
         }
         this.getDefaultValue = function() {
             return this.defaultValue;
         }
         this.setFieldMappingId = function(fieldMappingId) {
             this.fieldMappingId = fieldMappingId;
         }
         this.getFieldMappingId = function() {
             return this.fieldMappingId;
         }
     }
     /**
      * The structure of Object Metadata obtained from server
      * @constructor
      */
 kony.sdk.dto.ObjectMetadata = function() {
         //variables to store metadata of the object.
         this.custom;
         this.customizable;
         this.displayName;
         this.entityTypeID;
         this.columns;
         this.junction;
         this.name;
         this.primaryKey;
         this.relationshipList;
         this.sourceEntityName;
         this.updateable;
         this.uniqueKeys;
     }
     /**
      * The structure of Field Metadata obtained from server
      * @constructor
      */
 kony.sdk.dto.FieldMetadata = function() {
         this.auditColumn;
         this.createable;
         this.custom;
         this.customizable;
         this.type;
         this.defaultValue;
         this.displayName;
         this.fieldMappingId;
         this.hasIndex;
         this.name;
         this.nameField;
         this.nullable;
         this.primaryKey;
         this.sourceFieldName;
         this.table;
         this.updateable;
         // array of picklistValueDto objects to hold the pick list values. This will be populated only when the data type is of picklist type
         this.pickListValues;
     }
     /**
      * The structure of Object Relationship in metadata obtained from server
      * @constructor
      */
 kony.sdk.dto.ObjectRelationship = function() {
         this.entityName;
         this.entityPageTemplateId;
         this.id;
         this.junctionTableName;
         this.operationType;
         this.relatedEntity;
         this.relationshipFields;
         this.relationshipName;
         this.relationshipType;
         this.custom;
     }
     /**
      * The Object used to define select query object, in order to fetch data
      * @param serviceName
      * @param tableObj {@link kony.sdk.dto.Table}
      * @constructor
      */
 kony.sdk.dto.SelectQuery = function(serviceName, tableObj) {
     this.tables = [];
     this.columnList = [];
     this.criteriaList = [];
     this.isDistinct = false;
     this.orderList = [];
     this.joinList = [];
     this.groupList = [];
     this.limit = null;
     this.skip = null;
     this.oDataURL = null;
     if (tableObj instanceof kony.sdk.dto.Table) {
         this.tables.push(tableObj);
     }
     /**
      * This function is used to set Limit value
      * @param val
      */
     this.setLimit = function(val) {
         this.limit = val;
     };
     /**
      * This function is used to set Skip value
      * @param val
      */
     this.setSkip = function(val) {
         this.skip = val;
     };
     /**
      * This function is used to get the Limit Value
      * @returns {integer} limit
      */
     this.getLimit = function() {
         return this.limit;
     };
     /**
      * This function is used to get the Skip Value
      * @returns {integer} skip
      */
     this.getSkip = function() {
         return this.skip;
     };
     /**
      * This function is used to add a column object into the select query
      * @param columnObj {@Link kony.sdk.dto.Column}
      * @returns {Array}
      */
     this.addColumn = function(columnObj) {
         if (columnObj instanceof kony.sdk.dto.Column) {
             this.columnList.push(columnObj);
             return this.columnList;
         }
     };
     /**
      * This function is used to add a criteria object to the select query
      * @param criteriaObj
      * @returns {Array}
      */
     this.addCriteria = function(criteriaObj) {
         if (kony.sdk.util.validateCriteriaObject(criteriaObj)) {
             this.criteriaList.push(criteriaObj);
             return this.criteriaList;
         }
     };
     /**
      * This function is used to add a group object to select query
      * @param groupObj
      */
     this.addGroup = function(groupObj) {
         if (groupObj instanceof kony.sdk.dto.Group) {
             this.groupList.push(groupObj);
             for (var i = 0; i < this.tables.length; i++) {
                 if (this.tables[i].getName().toUpperCase() === groupObj.getColumn().getTable().getName().toUpperCase()) {
                     return;
                 }
             }
             this.tables.push(groupObj.getColumn().getTable());
         }
     };
     /**
      * This function is used to add a join object
      * @param joinObj
      */
     this.addJoin = function(joinObj) {
         if (joinObj instanceof kony.sdk.dto.Join) {
             this.joinList.push(joinObj);
             for (var i = 0; i < this.tables.length; i++) {
                 if (this.tables[i].getName().toUpperCase() === joinObj.getTable().getName().toUpperCase()) {
                     if (this.tables[i].getAlias() != null || joinObj.getTable().getAlias() != null || this.tables[i].getAlias() != undefined || joinObj.getTable().getAlias() != undefined) {
                         if (this.tables[i].getAlias().toUpperCase() === joinObj.getTable().getAlias().toUpperCase()) {
                             return;
                         } else {
                             this.tables.push(joinObj.getTable());
                             return;
                         }
                     } else {
                         return;
                     }
                 }
             }
             this.tables.push(joinObj.getTable());
         }
     };
     /**
      * This function is used to add order object to a select query
      * @param orderObj
      */
     this.addOrder = function(orderObj) {
         var currentobject = this;
         if (orderObj instanceof kony.sdk.dto.Order) {
             this.orderList.push(arguments[0]);
             for (var i = 0; i < this.tables.length; i++) {
                 if (this.tables[i].getName().toUpperCase() === arguments[0].getColumn().getTable().getName().toUpperCase()) {
                     return;
                 }
             }
             this.tables.push(orderObj.getColumn().getTable());
         }
     };
     /**
      * This function is used to return tables in select query
      * @returns {Array} Tables
      */
     this.getTables = function() {
         return this.tables;
     };
     /**
      * This function is used to get isDistinct flag
      * @returns {boolean}
      */
     this.getDistinct = function() {
         return this.isDistinct;
     };
     /**
      * This function is used to return columns in select query
      * @returns {Array} Columns
      */
     this.getColumns = function() {
         return this.columnList;
     };
     /**
      * This function is used to get criteria objects in the select query
      * @returns {Array} Criterias
      */
     this.getCriterias = function() {
         return this.criteriaList;
     };
     /**
      * This function is used to get the group objects in the select query
      * @returns {Array} GroupObjs
      */
     this.getGroups = function() {
         return this.groupList;
     };
     /**
      * This function is used to get the Join objects in the select query
      * @returns {Array} Joins
      */
     this.getJoins = function() {
         return this.joinList;
     };
     /**
      * This function is used to get the Order Objects in the select query
      * @returns {Array} OrderObjs
      */
     this.getOrders = function() {
         return this.orderList;
     };
     /**
      * This function is used to remove columnobject set in select query
      * @param columnObj {@link kony.sdk.dto.Column}
      */
     this.removeColumn = function(columnObj) {
         if (columnObj instanceof kony.sdk.dto.Column) {
             this.columnList.splice(this.columnList.indexOf(columnObj), 1);
         }
     };
     /**
      * This function is used to remove criteriaObject from select query
      * @param criteriaObj
      */
     this.removeCriteria = function(criteriaObj) {
         if (criteriaObj instanceof Criteria) {
             this.criteriaList.splice(this.criteriaList.indexOf(criteriaObj), 1);
         }
     };
     /**
      * This function is used to remove group set from select query
      * @param groupObj
      */
     this.removeGroup = function(groupObj) {
         if (groupObj instanceof kony.sdk.dto.Group) {
             this.groupList.splice(this.groupList.indexOf(groupObj), 1);
         }
     };
     /**
      * This function is used to remove Join set in select query
      * @param joinObj
      */
     this.removeJoin = function(joinObj) {
         if (joinObj instanceof kony.sdk.dto.Criteria) {
             this.joinList.splice(this.joinList.indexOf(joinObj), 1);
         }
     };
     /**
      * This function is used to remove OrderObj set in SelectQuery
      * @param orderObj
      */
     this.removeOrder = function(orderObj) {
         if (orderObj instanceof kony.sdk.dto.Order) {
             this.orderList.splice(this.orderList.indexOf(orderObj), 1);
         }
     };
     /**
      * This function is used to set isDistinct
      * @param isDistinct
      */
     this.setDistinct = function(isDistinct) {
         this.isDistinct = isDistinct;
     };
     /**
      * This function is used to get the select query in the form of a string
      * @returns {string}
      */
     this.toString = function() {
         var selectQueryDto = this;
         var query = "";
         query = query + "SELECT ";
         if (this.getDistinct() == true || this.getDistinct() == "true") {
             query = query + " DISTINCT ";
         }
         // Fetch the metadata for the base table and see if there are any extended fields associated with it
         // If there are any, create a join between the base table and the corresponding parent table and fetch it
         var columns = this.columnList;
         var extendedFields = [];
         var columnsArr = [];
         var extendedJoins = [];
         var baseTable = this.getTables()[0];
         var objectMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, baseTable.getName());
         if (columns.length !== 0) {
             var field = null;
             for (var colIndex = 0; colIndex < columns.length; colIndex++) {
                 field = kony.sdk.util.getExtendedFieldsFromArray(objectMetadata.columns, columns[colIndex]);
                 if (field !== null && field !== undefined) {
                     selectQueryDto.columnList[colIndex].dataType = field.type;
                     selectQueryDto.columnList[colIndex].parentFieldName = field.parentFieldName;
                     extendedFields.push(field);
                     field = null;
                 } else {
                     columnsArr.push(columns[colIndex]);
                 }
             }
         } else {
             var col = null;
             var field = null;
             for (var colIndex = 0; colIndex < objectMetadata.columns.length; colIndex++) {
                 field = objectMetadata.columns[colIndex];
                 col = new kony.sdk.dto.Column(baseTable, field.name);
                 col.dataType = field.type;
                 col.parentFieldName = field.parentFieldName;
                 selectQueryDto.columnList.push(col);
                 if (field !== null && field !== undefined && kony.sdk.util.matchIgnoreCase(field.type, "extendedfield")) {
                     extendedFields.push(field);
                     field = null;
                 } else {
                     columnsArr.push(columns[colIndex]);
                 }
             }
         }
         var columnStr = selectQueryDto.appendListToQuery(columnsArr, ", ", 0);
         if (columnStr !== null && columnStr !== "") {
             query = query + columnStr;
         }
         //TODO have to modify the code based on latest metadata
         if (extendedFields !== null && extendedFields !== undefined && extendedFields.length !== 0) {
             var join = null;
             var table = null;
             var srcCol = null;
             var destCol = null;
             var joinType = kony.sdk.constants.JoinType.LEFT;
             var col = null;
             var colList = [];
             var extendedTablesAdded = {};
             for (var extIndex = 0; extIndex < extendedFields.length; extIndex++) {
                 if (extendedTablesAdded !== null && extendedTablesAdded.hasOwnProperty(extendedFields[extIndex].parentTableName)) {
                     extendedTablesAdded["" + extendedFields[extIndex].parentTableName] = ++extendedTablesAdded["" + extendedFields[extIndex].parentTableName];
                 } else {
                     extendedTablesAdded["" + extendedFields[extIndex].parentTableName] = 0;
                 }
                 table = new kony.sdk.dto.Table(extendedFields[extIndex].parentTableName);
                 // Now add all extended field columns to the query
                 col = new kony.sdk.dto.Column(table, extendedFields[extIndex].parentFieldName);
                 colList.push(col);
                 // Need to fetch the source table's primary key name from the metadata. For now hard coding it to 'id'
                 //TODO
                 srcCol = new kony.sdk.dto.Column(baseTable, extendedFields[extIndex].foreignKeyFieldName);
                 destCol = new kony.sdk.dto.Column(table, extendedFields[extIndex].referencedField || "id");
                 join = new kony.sdk.dto.Join(table, srcCol, destCol, joinType);
                 if (join !== null && join !== undefined && extendedTablesAdded["" + extendedFields[extIndex].parentTableName] === 0) {
                     extendedJoins.push(join);
                 }
             }
             var extColStr = "";
             for (var i = 0; i < colList.length; i++) {
                 extColStr = extColStr + colList[i].toString();
                 if (i < colList.length - 1) {
                     extColStr = extColStr + ",";
                 }
             }
             if (extColStr !== null && extColStr !== "") {
                 query = query + "," + extColStr;
             }
             if (extendedJoins !== null && extendedJoins !== undefined) {
                 for (var joinIndex = 0; joinIndex < extendedJoins.length; joinIndex++) {
                     selectQueryDto.addJoin(extendedJoins[joinIndex]);
                 }
             }
         }
         query = query + " FROM ";
         query = query + selectQueryDto.getTables()[0].toString();
         if (selectQueryDto.getJoins().length !== 0) {
             var joinStr = selectQueryDto.appendListToQuery(selectQueryDto.joinList, " ", -1);
             query = query + joinStr;
         }
         if (!(selectQueryDto.criteriaList.length == 0)) {
             query = query + " WHERE ";
             query = query + selectQueryDto.appendListToQuery(selectQueryDto.criteriaList, " AND ", -1);
         }
         if (!(selectQueryDto.groupList.length == 0)) {
             query = query + " GROUP BY ";
             query = query + selectQueryDto.appendListToQuery(selectQueryDto.groupList, ", ", -1);
         }
         if (!(selectQueryDto.orderList.length == 0)) {
             query = query + " ORDER BY ";
             query = query + selectQueryDto.appendListToQuery(selectQueryDto.orderList, " ,", -1);
         }
         if (selectQueryDto.limit !== null && selectQueryDto.limit !== undefined && kony.sdk.util.isValidNumberType(selectQueryDto.limit) && selectQueryDto.limit !== 0) {
             query = query + " LIMIT " + selectQueryDto.limit;
         }
         if (selectQueryDto.skip !== null && selectQueryDto.skip !== undefined && kony.sdk.util.isValidNumberType(selectQueryDto.skip) && selectQueryDto.skip !== 0) {
             query = query + " OFFSET " + selectQueryDto.skip;
         }
         return query;
     };
     this.appendListToQuery = function(objectList, seperator, mode) {
         kony.sdk.logsdk.trace("Entering into kony.sdk.dto.appendListToQuery");
         var listBuffer = "";
         for (var i = 0; i < objectList.length; i++) {
             var obj = objectList[i];
             if (mode > -1) {
                 if (obj !== null) {
                     if (obj instanceof kony.sdk.dto.Column) {
                         listBuffer = listBuffer.concat(obj.toString());
                     } else {
                         listBuffer = listBuffer.concat(obj.toString());
                     }
                 }
             } else if (obj !== null && obj !== undefined) {
                 listBuffer = listBuffer.concat(obj.toString());
             }
             if (i < objectList.length - 1) {
                 listBuffer = listBuffer.concat(seperator);
             }
         }
         return listBuffer;
     };
 };
 /**
  * This function is the Table constructor.
  * @param tableName
  * @param tableAlias
  * @param junctionType
  * @constructor
  */
 kony.sdk.dto.Table = function(tableName, tableAlias, junctionType) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Table");
     this.name = tableName;
     this.alias = tableAlias;
     this.isjunction = junctionType;
     this.getAlias = function() {
         return this.alias;
     };
     /**
      * This function is used to set alias.
      *
      * @param alias
      */
     this.setAlias = function(alias) {
         this.alias = alias;
     };
     this.getName = function() {
         return this.name;
     };
     /**
      * This function is used to set name.
      *
      * @param name
      */
     this.setName = function(name) {
         this.name = name;
     };
     /**
      * This function is used to check object equality.
      *
      * @param obj
      * @return Boolean
      */
     this.equals = function(obj) {
         var areObjectsEqual = false;
         if (obj === null || obj === undefined) {
             areObjectsEqual = false;
         } else if (typeof(this) === typeof(obj)) {
             areObjectsEqual = true;
             if (this.hasAlias() && obj.hasAlias()) {
                 areObjectsEqual = this.getAlias() === obj.getAlias();
             } else {
                 areObjectsEqual = this.getName() === obj.getName();
             }
         } else {
             areObjectsEqual = false;
         }
         return areObjectsEqual;
     };
     this.getColumn = function(columnName) {
         return new kony.sdk.dto.Column(this, columnName);
     };
     /**
      * This function is used to check if alias is present or not.
      *
      * @return Boolean
      */
     this.hasAlias = function() {
         return (this.alias !== null && this.alias !== undefined);
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         return this.getName() + (this.hasAlias() ? " " + this.getAlias() : "");
     };
     /**
      * This function is used to return if the table is a junction table.
      *
      * @return boolean
      */
     this.isJunction = function() {
         return (this.isjunction && this.isjunction == true);
     };
     /**
      * This function is used to set the type of table junction/non-junction table.
      *
      * @param junctionType
      */
     this.setJunction = function(junctionType) {
         this.isjunction = junctionType;
     };
 };
 /**
  * This function is a Column constructor
  * @param tableObj {@link kony.sdk.dto.Table}
  * @param colName
  * @constructor
  */
 kony.sdk.dto.Column = function(tableObj, colName) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Column");
     if (tableObj instanceof kony.sdk.dto.Table) {
         this.aggregation = null;
         this.alias = null;
         this.dataType = null;
         this.name = null;
         this.table = null;
         if (colName !== undefined && colName !== null && typeof(colName) === "string") {
             this.name = colName;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: colName is undefined");
         }
         this.table = tableObj;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: tableObj is not an instance of kony.sdk.dto.Table");
     }
     this.getAggregation = function() {
         return this.aggregation;
     };
     this.setAggregation = function(aggregation) {
         this.aggregation = aggregation;
     };
     this.getAlias = function() {
         return this.alias;
     };
     this.setAlias = function(alias) {
         this.alias = alias;
     };
     this.getDataType = function() {
         return this.dataType;
     };
     this.setDataType = function(dataType) {
         this.dataType = dataType;
     };
     this.isComputedField = function() {
         return this.fieldComputed;
     };
     this.setComputedField = function(fieldComputed) {
         this.fieldComputed = fieldComputed;
     };
     this.getName = function() {
         return this.name;
     };
     this.setName = function(name) {
         if (name !== undefined && name !== null && typeof(name) === "string") {
             this.name = name;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Column::setName:: Error: name is undefined");
         }
     };
     this.getTable = function() {
         return this.table;
     };
     this.setTable = function(table) {
         if (table instanceof kony.sdk.dto.Table) {
             this.table = table;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: setTable is undefined");
         }
     };
     this.toStringByMode = function(mode) {
         var tableName = (this.getTable().getAlias() !== null && this.getTable().getAlias() !== undefined) ? this.getTable().getAlias() : this.getTable().getName();
         var constructedColumn = null;
         var constructDataType = null;
         var constructAlias = null;
         var constructAggregation = null;
         switch (mode) {
             case 0:
                 if (this.getDataType() !== null && this.getDataType() !== undefined) {
                     if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Integer")) {
                         constructDataType = "CAST (" + tableName + "." + this.getName() + " AS INTEGER)";
                     } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Numeric")) {
                         constructDataType = "CAST (" + tableName + "." + this.getName() + " AS NUMERIC)";
                     } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Date")) {
                         constructDataType = "date(" + tableName + "." + this.getName() + ")";
                     } else {
                         constructDataType = tableName + "." + this.getName();
                     }
                 } else {
                     constructDataType = tableName + "." + this.getName();
                 }
                 constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined && this.getAlias() !== "") ? " AS " + this.getAlias() : "";
                 constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
                 constructedColumn = constructAggregation + constructAlias;
                 break;
             case 1:
                 if (this.getDataType() !== null && this.getDataType() !== undefined) {
                     if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) this.setDataType("text");
                 }
                 constructDataType = (this.getDataType() !== null && this.getDataType() !== undefined) ? "CAST (" + tableName + "." + this.getName() + " AS " + this.getDataType() + ")" : tableName + "." + this.getName();
                 constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
                 constructedColumn = constructAggregation;
                 break;
             case 2:
                 constructedColumn = this.getName();
                 break;
             case 3:
                 constructedColumn = this.getName();
                 break;
             default:
                 if (this.getDataType() !== null && this.getDataType() !== undefined) {
                     if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) this.setDataType("text");
                 }
                 constructDataType = (this.getDataType() !== null && this.getDataType() !== undefined) ? "CAST (" + tableName + "." + this.getName() + " AS " + this.getDataType() + ")" : tableName + "." + this.getName();
                 constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined) ? " AS " + this.getAlias() : "";
                 constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
                 constructedColumn = constructAggregation + constructAlias;
                 break;
         }
         return constructedColumn;
     };
     this.toString = function() {
         // To be removed later from here
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
             if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) dataType = "text";
         }
         var tableName = (this.getTable().getAlias() !== null && this.getTable().getAlias() !== undefined && this.getTable().getAlias() !== "") ? this.getTable().getAlias() : this.getTable().getName();
         var constructedColumn = null;
         var constructDataType = null;
         var constructAggregation = null;
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
             if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Integer")) {
                 constructDataType = "CAST (" + tableName + "." + this.getName() + " AS INTEGER)";
             } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Numeric")) {
                 constructDataType = "CAST (" + tableName + "." + this.getName() + " AS NUMERIC)";
             } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Date")) {
                 constructDataType = "date(" + tableName + "." + this.getName() + ")";
             } else {
                 if (!this.isComputedField()) constructDataType = tableName + "." + this.getName();
             }
         } else {
             if (!this.isComputedField()) constructDataType = tableName + "." + this.getName();
         }
         var constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined && this.getAlias() !== "") ? " AS " + this.getAlias() : "";
         constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
         constructedColumn = constructAggregation + constructAlias;
         return constructedColumn;
     };
     this.toStringByTablePrefix = function(includeTablePrefix) {
         if (includeTablePrefix) {
             return this.toString();
         } else {
             return this.getName();
         }
     }
 };
 /**
  * This Object represents a groupby clause in select query
  * @param columnObj {@link kony.sdk.dto.Column}
  * @constructor
  */
 kony.sdk.dto.Group = function(columnObj) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Group");
     if (columnObj instanceof kony.sdk.dto.Column) {
         this.column = columnObj;
     }
     this.getColumn = function() {
         return this.column;
     };
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         }
     };
     this.toString = function() {
         var tableName = (this.column.getTable().getAlias() !== null && this.column.getTable().getAlias() !== undefined) ? this.column.getTable().getAlias() : this.column.getTable().getName();
         return tableName + "." + this.column.getName();
     };
 };
 /**
  * This Object represents JOINS used in kony.sdk.dto.SelectQuery
  * @constructor
  */
 kony.sdk.dto.Join = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Join");
     this.criteria;
     this.table;
     this.joinType;
     var currentObject = this;
     if (arguments.length === 3) {
         getJoinByTableCriteriaAndJoinType(arguments[0], arguments[1], arguments[2]);
     } else if (arguments.length === 4) {
         getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType(arguments[0], arguments[1], arguments[2], arguments[3]);
     }
     /**
      * This function is the Join constructor which has 3 arguments.
      *
      * @param table
      * @param criteria
      * @param joinType
      */
     function getJoinByTableCriteriaAndJoinType(table, criteria, joinType) {
         kony.sdk.logsdk.trace("Entering into getJoinByTableCriteriaAndJoinType");
         if (table instanceof kony.sdk.dto.Table && kony.sdk.util.validateCriteriaObject(criteria) && joinType !== null && joinType !== undefined && (joinType === kony.sdk.constants.JoinType.INNER || joinType === kony.sdk.constants.JoinType.LEFT)) {
             currentObject.table = table;
             currentObject.joinType = joinType;
             currentObject.criteria = criteria;
             return currentObject;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Join::getJoinByTableCriteriaAndJoinType:: Error: Validation error at getJoinByTableCriteriaAndJoinType");
         }
     }
     /**
      * This function is the Join constructor which has 4 arguments.
      *
      * @param destTable
      * @param srcColumn
      * @param destColumn
      * @param joinTypeObj
      */
     function getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType(destTable, srcColumn, destColumn, joinTypeObj) {
         kony.sdk.logsdk.trace("Entering into getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType");
         if (destTable instanceof kony.sdk.dto.Table && srcColumn instanceof kony.sdk.dto.Column && destColumn instanceof kony.sdk.dto.Column && joinTypeObj !== null && joinTypeObj !== undefined && joinTypeObj !== '' && (joinTypeObj === kony.sdk.constants.JoinType.INNER || joinTypeObj === kony.sdk.constants.JoinType.LEFT)) {
             currentObject.table = destTable;
             currentObject.joinType = joinTypeObj;
             var criteria = new kony.sdk.dto.Match(srcColumn, kony.sdk.constants.MatchType.EQUALS, destColumn);
             currentObject.criteria = criteria;
             return currentObject;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Join::getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType:: Error: Validation error at getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType");
         }
     }
     this.getCriteria = function() {
         return this.criteria;
     };
     this.setCriteria = function(criteria) {
         if (kony.sdk.util.validateCriteriaObject(criteria)) {
             this.criteria = criteria;
         }
     };
     this.getTable = function() {
         return this.table;
     };
     this.setTable = function(table) {
         if (table instanceof kony.sdk.dto.Table) {
             this.table = table;
         }
     };
     this.getJoinType = function() {
         return this.joinType;
     };
     this.setJoinType = function(joinType) {
         if (joinType !== null) {
             this.joinType = joinType;
         }
     };
     this.initCriteria = function(srcColumn, destColumn) {
         if ((srcColumn instanceof kony.sdk.dto.Column) && (destColumn instanceof kony.sdk.dto.Column)) {
             var criteria = new kony.sdk.dto.Match(srcColumn, kony.sdk.constants.MatchType.EQUALS, destColumn);
             this.setCriteria(criteria);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Join::initCriteria:: Error: srcColumn or destColumn is not an isntanceof kony.sdk.dto.Column");
         }
     };
     this.toString = function() {
         var returnString = null;
         var temp = null;
         var join;
         if (kony.sdk.constants.JoinType.INNER == this.getJoinType()) {
             join = "INNER";
         } else if (kony.sdk.constants.JoinType.LEFT == this.getJoinType()) {
             join = "LEFT";
         } else if (kony.sdk.constants.JoinType.RIGHT == this.getJoinType()) {
             join = "RIGHT";
         }
         returnString = " " + join + " JOIN " + this.getTable().toString() + " ON ";
         temp = this.getCriteria().toString();
         returnString = returnString + temp;
         return returnString;
     };
 };
 /**
  * This function is the Order constructor.
  * @param columnObj
  * @param orderTypeObj
  */
 kony.sdk.dto.Order = function(columnObj, orderTypeObj) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Order");
     if ((columnObj instanceof kony.sdk.dto.Column) && (orderTypeObj == kony.sdk.constants.OrderType.ASCENDING || orderTypeObj == kony.sdk.constants.OrderType.DESCENDING)) {
         this.column = columnObj;
         this.type = orderTypeObj;
         return this;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Order:: Error: Validation error")
     }
     this.getColumn = function() {
         return this.column;
     };
     /**
      * This function is used to set column.
      *
      * @param column
      */
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Order::setColumn: Error: column is not an instance of kony.sdk.dto.Column");
         }
     };
     this.getType = function() {
         return this.type;
     };
     /**
      * This function is used to set type.
      *
      * @param type
      */
     this.setType = function(type) {
         this.type = type;
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         return this.column.toString() + " " + (this.type);
     };
 };
 /**
  * This function is used to check the range of values of columnObj
  * @param columnObj {@link kony.sdk.dto.Column}
  * @param colRange
  * @constructor
  */
 kony.sdk.dto.Between = function(columnObj, colRange) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Between");
     this.column;
     this.range;
     if (columnObj instanceof kony.sdk.dto.Column && (colRange instanceof kony.sdk.dto.DateRange || colRange instanceof kony.sdk.dto.StringRange || colRange instanceof kony.sdk.dto.IntegerRange || colRange instanceof kony.sdk.dto.FloatRange)) {
         this.column = columnObj;
         this.range = colRange;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Between:: Error: Vaildation error");
     }
     this.quote = function(str) {
         if (kony.sdk.util.isNull(str)) {
             return "null";
         }
         // var str1 = new String(str);
         var strBuf = [];
         strBuf.push('\'');
         for (var index = 0; index < str.length; index++) {
             var charItem = str.charAt(index);
             if (charItem == '\\' || charItem == '\"' || charItem == '\'') {
                 // strBuf.concat('\\');
                 strBuf.push('\\');
             }
             strBuf.push(charItem);
         }
         strBuf.push('\'');
         return strBuf.join("");
     };
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Between::setColumn: Error:column is not an instance of kony.sdk.dto.Column");
         }
     };
     this.setRange = function(range) {
         if (range instanceof kony.sdk.dto.DateRange || range instanceof kony.sdk.dto.StringRange || range instanceof kony.sdk.dto.IntegerRange || range instanceof kony.sdk.dto.FloatRange) {
             this.range = range;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Between::setRange: Error: Validation Error");
         }
     };
     this.getColumn = function() {
         return this.column;
     };
     this.getRange = function() {
         return this.range;
     };
     this.toString = function() {
         var returnStr = "";
         returnStr = this.getColumn().toString() + " Between " + this.getRange().toString();
         return returnStr;
     };
 };
 /**
  * This function is the DateRange constructor.
  * @param startDate
  * @param endDate
  */
 kony.sdk.dto.DateRange = function() {
     this.end;
     this.start;
     if (arguments.length === 2) {
         var startDate = arguments[0];
         var endDate = arguments[1];
         if (startDate instanceof Date && endDate instanceof Date) {
             this.start = startDate;
             this.end = endDate;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DataRange:: Error: startDate or endDate is not an instance of Date");
         }
     } else if (arguments.length === 1) {
         var dateType = arguments[0];
         if (kony.sdk.util.validateDateTypeInput(dateType)) {
             var range = kony.sdk.util.getDateRange(dateType);
             if (range.length !== 2 || range[0] === 0 || range[1] === 0) {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.DateRange:: Error: Validation Error");
             } else {
                 this.start = range[0];
                 this.end = range[1];
             }
         }
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end instanceof Date) {
             var month = end.getMonth() + 1;
             var date = end.getDate();
             var hr = end.getHours();
             var min = end.getMinutes();
             var sec = end.getSeconds();
             if (month < 10) {
                 month = "0" + month;
             }
             if (date < 10) {
                 date = "0" + date;
             }
             if (hr < 10) {
                 hr = "0" + hr;
             }
             if (min < 10) {
                 min = "0" + min;
             }
             if (sec < 10) {
                 sec = "0" + sec;
             }
             var endDate = end.getFullYear() + "-" + month + "-" + date + " " + hr + ":" + min + ":" + sec;
             this.end = endDate;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DateRange::setEnd:: Error: end is not an instance of Date");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start instanceof Date) {
             var month = start.getMonth() + 1;
             var date = start.getDate();
             var hr = start.getHours();
             var min = start.getMinutes();
             var sec = start.getSeconds();
             if (month < 10) {
                 month = "0" + month;
             }
             if (date < 10) {
                 date = "0" + date;
             }
             if (hr < 10) {
                 hr = "0" + hr;
             }
             if (min < 10) {
                 min = "0" + min;
             }
             if (sec < 10) {
                 sec = "0" + sec;
             }
             var startDate = start.getFullYear() + "-" + month + "-" + date + " " + hr + ":" + min + ":" + sec;
             this.start = startDate;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DateRange::setStart:: Error: start is not an instance of Date");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = "'" + this.start + "'" + " AND " + "'" + this.end + "'";
         return returnString;
     };
 };
 /**
  * This function is the DecimalRange constructor.
  * @param startDecimal
  * @param endDecimal
  */
 kony.sdk.dto.DecimalRange = function(startDecimal, endDecimal) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.DecimalRange");
     if ((endDecimal !== null && endDecimal !== undefined && typeof endDecimal === 'number') && (startDecimal !== null && startDecimal !== undefined && typeof startDecimal === 'number')) {
         this.end = endDecimal;
         this.start = startDecimal;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange:: Error: Validation Error");
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'number') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'number') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = this.start + " AND " + this.end;
         return returnString;
     };
 };
 /**
  * This function is the FloatRange constructor.
  * @param startFloat
  * @param endFloat
  */
 kony.sdk.dto.FloatRange = function(startFloat, endFloat) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.FloatRange");
     this.end = endFloat;
     this.start = startFloat;
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'number') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.FloatRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'number') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.FloatRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = this.start + " AND " + this.end;
         return returnString;
     };
 };
 /**
  * This function is the IntegerRange constructor.
  * @param startInt
  * @param endInt
  */
 kony.sdk.dto.IntegerRange = function(startInt, endInt) {
     if ((endInt !== null && endInt !== undefined && typeof endInt === 'number') && (startInt !== null && startInt !== undefined && typeof startInt === 'number')) {
         this.end = endInt;
         this.start = startInt;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange:: Error: Validation Error");
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'number') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'number') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         returnString = this.start.toFixed() + " AND " + this.end.toFixed();
         return returnString;
     };
 };
 /**
  * This function is the StringRange constructor.
  * @param startString
  * @param endString
  */
 kony.sdk.dto.StringRange = function(startString, endString) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.StringRange");
     if ((endString !== null && endString !== undefined && typeof endString === 'string') && (startString !== null && startString !== undefined && typeof startString === 'string')) {
         this.end = endString;
         this.start = startString;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.StringRange:: Error: Validation Error");
     }
     this.getEnd = function() {
         return this.end;
     };
     /**
      * This function is used to set End value.
      *
      * @param end
      */
     this.setEnd = function(end) {
         if (end !== null && end !== undefined && typeof end === 'string') {
             this.end = end;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.StringRange::setEnd:: Error: Validation Error");
         }
     };
     this.getStart = function() {
         return this.start;
     };
     /**
      * This function is used to set start value.
      *
      * @param start
      */
     this.setStart = function(start) {
         if (start !== null && start !== undefined && typeof start === 'string') {
             this.start = start;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.StringRange::setStart:: Error: Validation Error");
         }
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var returnString = null;
         var crit = new kony.sdk.dto.Criteria();
         returnString = crit.quote(this.start) + " AND " + crit.quote(this.end);
         return returnString;
     };
 };
 /**
  * This function helps in preparing And {@link kony.sdk.dto.And} and Or {@Link kony.sdk.dto.Or} clauses
  * @param operatorLg
  * @param leftOp
  * @param rightOp
  * @constructor
  */
 kony.sdk.dto.LogicGroup = function(operatorLg, leftOp, rightOp) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.LogicGroup");
     this.left = leftOp;
     this.operator = operatorLg;
     this.right = rightOp;
     /**
      * This function is used to initialize LogicGroup.
      *
      * @param operator
      * @param left
      * @param right
      */
     this.initializeLogicGroup = function(operator, left, right) {
         this.left = left;
         this.operator = operator;
         this.right = right;
     };
     this.getLeft = function() {
         return this.left;
     };
     /**
      * This function is used to set left.
      *
      * @param val
      */
     this.setLeft = function(val) {
         this.val = val;
     };
     this.getOperator = function() {
         return this.operator;
     };
     /**
      * This function is used to set Operator.
      *
      * @param val
      */
     this.setOperator = function(val) {
         this.operator = val;
     };
     this.getRight = function() {
         return this.right;
     };
     /**
      * This function is used to set Right.
      *
      * @param val
      */
     this.setRight = function(val) {
         this.right = val;
     };
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         var leftOperator = (this.getLeft() !== null && this.getLeft !== undefined) ? this.getLeft().toString() : "";
         var rightOperator = (this.getRight() !== null && this.getRight() !== undefined) ? this.getRight().toString() : "";
         return "(" + leftOperator + " " + this.getOperator() + " " + rightOperator + ")";
     };
 };
 /**
  * This function is the And constructor.
  *
  * @param left
  * @param right
  */
 kony.sdk.dto.And = function(left, right) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.And");
     if (arguments.length !== 2) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.And:: Error: invalid number of arguments, expected are left and right");
     }
     if ((right !== null && left !== null && right !== undefined && left !== undefined && kony.sdk.util.validateCriteriaObject(left) && kony.sdk.util.validateCriteriaObject(right))) {
         kony.sdk.dto.LogicGroup.call(this, 'AND', left, right);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.And:: Error: Validation Error");
     }
     this.initializeAnd = function(left, right) {
         kony.sdk.dto.LogicGroup.call(this, 'AND', left, right);
     };
 };
 /**
  * This function is the Or constructor.
  *
  * @param left
  * @param right
  */
 kony.sdk.dto.Or = function(left, right) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Or");
     if (arguments.length !== 2) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Or:: Error: invalid number of arguments, expected are left and right");
     }
     if ((right !== null && left !== null && right !== undefined && left !== undefined && kony.sdk.util.validateCriteriaObject(left) && kony.sdk.util.validateCriteriaObject(right))) {
         kony.sdk.dto.LogicGroup.call(this, 'OR', left, right);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Or:: Error: Validation Error");
     }
     this.initializeOr = function(left, right) {
         kony.sdk.dto.LogicGroup.call(this, 'OR', left, right);
     };
 };
 /**
  * This function is the Not constructor.
  *
  * @param right
  */
 kony.sdk.dto.Not = function(right) {
     if (arguments.length !== 1) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Not:: Error: invalid number of arguments, expected right");
     }
     if (right !== null && right !== undefined && kony.sdk.util.validateCriteriaObject(right)) {
         kony.sdk.dto.LogicGroup.call(this, 'NOT', null, right);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Not:: Error: Validation Error");
     }
     this.initializeNot = function(right) {
         kony.sdk.dto.LogicGroup.call(this, 'NOT', null, right);
     };
 };
 /**
  * This function is a constructor for Expression Object
  * @constructor
  */
 kony.sdk.dto.Expression = function() {
     this.term;
     this.operator;
     this.expression;
     var currentExpObj = this;
     if (arguments.length === 1) {
         if (kony.sdk.util.validateCriteriaObject(arguments[0])) {
             setTerm(arguments[0]);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression:: Error: Validation Error");
         }
     } else if (arguments.length === 2) {
         initExpression(arguments[0], arguments[1]);
     } else if (arguments.length === 3) {
         initExpressionByExpression(arguments[0], arguments[1], arguments[2]);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Expression:: Error: invalid number of arguments, atleast 'term' is expected");
     }
     /**
      * Recursively generates a Expression from a given list of
      * criteria and an infix operator to join each criteria with the
      * next in the list. Operator AND or Operator OR that joins each
      * criteria term with the next in the list.
      *
      * @param criterias
      *            the list of criteria terms from which the
      *            constructor generates the new criteria expression.
      * @param operator
      *            the infix operator
      */
     function initExpression(criterias, operator) {
         if (operator === kony.sdk.constants.Operator.OR) {
             setOperator(kony.sdk.constants.Operator.OR);
         } else if (operator === kony.sdk.constants.Operator.AND) {
             setOperator(kony.sdk.constants.Operator.AND);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpression:: Error: Invalid Operator");
         }
         if (criterias !== null && criterias !== undefined && criterias instanceof Array && criterias.length > 0) {
             if (kony.sdk.util.validateCriteriaObject(criterias[0])) {
                 setTerm(criterias[0]);
             }
             if (criterias.length > 1) {
                 var tmpOperator = operator;
                 criterias.shift();
                 setExpression(new kony.sdk.dto.Expression(criterias, tmpOperator));
             }
         } else {
             if (kony.sdk.util.validateCriteriaObject(criterias)) {
                 setTerm(criterias);
                 // return currentExpObj;
             } else {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpression:: Error: Validation Error");
             }
         }
     }

     function setExpression(expression) {
         if (expression instanceof kony.sdk.dto.Expression) {
             currentExpObj.expression = expression;
             // return currentExpObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::setExpression:: Error: expression not an instance of kony.sdk.do.Expression");
         }
     }

     function setTerm(term) {
         if (kony.sdk.util.validateCriteriaObject(term)) {
             currentExpObj.term = term;
             // return currentExpObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::setTerm:: Error: Validation Error");
         }
     }
     /**
      * Initializes a Expression with an initial criteria term, an
      * operator, and a another trailing criteria expression.
      *
      * @param criterias
      *            the starting criteria to assign to the new
      *            criteria expression.
      * @param operator
      *            the infix operator
      * @param expression
      *            the trailing expression to assign to the new
      *            criteria expression.
      */
     function initExpressionByExpression(criterias, operator, expression) {
         if (operator === kony.sdk.constants.Operator.OR) {
             initExpression(criterias, kony.sdk.constants.Operator.OR);
         } else if (operator === kony.sdk.constants.Operator.AND) {
             initExpression(criterias, kony.sdk.constants.Operator.AND);
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpressionByExpression:: Error: Invalid Operator");
         }
         setExpression(expression);
         // return currentExpObj;
     }

     function setOperator(operator) {
         currentExpObj.operator = operator;
     }
     this.getTerm = function() {
         return this.term;
     };
     this.getOperator = function() {
         return this.operator;
     };
     this.getExpression = function() {
         return this.expression;
     };
     this.toString = function() {
         var returnString = null;
         if ((this.getTerm() === null || this.getTerm() === undefined) && (this.getExpression() === null || this.getExpression() === undefined)) {
             returnString = "";
         } else if (this.getExpression() === null || this.getExpression() === undefined) {
             returnString = this.getTerm().toString();
         } else if (this.getOperator() === kony.sdk.constants.Operator.AND) {
             returnString = (new kony.sdk.dto.And(this.getTerm(), this.getExpression())).toString();
         } else if (this.getOperator() === kony.sdk.constants.Operator.OR) {
             returnString = (new kony.sdk.dto.Or(this.getTerm(), this.getExpression())).toString();
         }
         return returnString;
     }
 };
 /**
  * This function is a constructor for InCriteria Object
  * @constructor
  */
 kony.sdk.dto.InCriteria = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.InCriteria");
     this.column;
     this.values;
     var currentInCriteriaObj = this;
     if (arguments.length === 2) {
         getInCriteriaByColumnAndCollection(arguments[0], arguments[1]);
     } else if (arguments.length === 3) {
         getInCriteriaByTableAndCollection(arguments[0], arguments[1], arguments[2]);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria:: Error: invalid number of arguments, atleast column,values are expected");
     }
     /**
      * This function is the InCriteria constructor which has 3
      * arguments.
      *
      * @param table
      * @param columnname
      * @param values
      */
     function getInCriteriaByTableAndCollection(table, columnname, values) {
         kony.sdk.logsdk.trace("Entering into getInCriteriaByTableAndCollection");
         if (table instanceof kony.sdk.dto.Table) {
             currentInCriteriaObj.column = new kony.sdk.dto.Column(table, columnname);
             currentInCriteriaObj.values = values;
             return currentInCriteriaObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getInCriteriaByTableAndCollection:: Error: table is not an instance of kony.sdk.dto.Table");
         }
     }
     /**
      * This function is the InCriteria constructor which has 2
      * arguments.
      *
      * @param column
      * @param values
      */
     function getInCriteriaByColumnAndCollection(column, values) {
         kony.sdk.logsdk.trace("Entering into getInCriteriaByColumnAndCollection");
         if (column instanceof kony.sdk.dto.Column && values instanceof Array && values.length > 0) {
             currentInCriteriaObj.column = column;
             currentInCriteriaObj.values = values;
             return currentInCriteriaObj;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getInCriteriaByColumnAndCollection:: Error: Validation Error");
         }
     }
     this.getColumnForTable = function(table, columnName) {
         if (table instanceof kony.sdk.dto.Table) {
             var column = new kony.sdk.dto.Column(table, columnName);
             return column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getColumnForTable:: Error: table not an instance of kony.sdk.dto.Table");
         }
     };
     this.getColumn = function() {
         return this.column;
     };
     this.setColumn = function(column) {
         if (column instanceof kony.sdk.dto.Column) {
             this.column = column;
         }
     };
     this.setValues = function(valuesCollection) {
         this.values = valuesCollection;
     };
     this.getValues = function() {
         return this.values;
     };
     this.toString = function() {
         var result = "";
         result = this.column.toString() + " IN (";
         if (this.values !== null && this.values !== undefined && this.values.length > 0) {
             for (var index = 0; index < this.values.length; index++) {
                 var value;
                 var criteria = new kony.sdk.dto.Criteria();
                 if (typeof(this.values[index]) === "string") {
                     value = criteria.quote(this.values[index]);
                 } else {
                     value = this.values[index];
                 }
                 result = result + value;
                 if (index !== (this.values.length - 1)) {
                     result = result + ", ";
                 }
             }
         }
         /*
          * else if (this.subSelect !== null && this.subSelect !==
          * undefined) { result = result + this.subSelect; }
          */
         result = result + ")";
         return result;
     };
 };
 /**
  * This function is used to in set Exists param in select query
  * @param subSelectQuery {@link kony.sdk.dto.SelectQuery}
  * @constructor
  */
 kony.sdk.dto.Exists = function(subSelectQuery) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Exists");
     if (subSelectQuery instanceof kony.sdk.dto.SelectQuery) {
         this.subSelect = subSelectQuery;
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Exists:: Error: subSelectQuery is not an instance of kony.sdk.dto.SelectQuery");
     }
     this.getSubSelect = function() {
         return this.subSelect;
     };
     this.setSubSelect = function(subSelect) {
         if (subSelect instanceof kony.sdk.dto.SelectQuery) {
             this.subSelect = subSelect;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Exists::subSelectQuery:: Error: subSelectQuery is not an instance of kony.sdk.dto.SelectQuery");
         }
     };
     this.toString = function() {
         return "EXISTS ( " + this.subSelect.toString() + " )";
     };
 };
 /**
  * This is Interface to define where clauses
  * @constructor
  */
 kony.sdk.dto.Criteria = function() {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Criteria");
     this.quote = function(str) {
         if (str === null || str === undefined) {
             return "null";
         }
         // var str1 = new String(str);
         var strBuf = [];
         strBuf.push('\'');
         for (var index = 0; index < str.length; index++) {
             var charItem = str.charAt(index);
             if (charItem == '\\' || charItem == '\"' || charItem == '\'') {
                 // strBuf.concat('\\');
                 strBuf.push('\\');
             }
             strBuf.push(charItem);
         }
         strBuf.push('\'');
         return strBuf.join("");
     };
 };
 /**
  * This function is used to define where clause
  * @constructor
  */
 kony.sdk.dto.Match = function() {
     this.column;
     this.matchType;
     this.value;
     var currentMatchObj = this;
     if (arguments.length === 3) {
         initMatchByColumn(arguments[0], arguments[1], arguments[2]);
     } else if (arguments.length === 4) {
         initMatchByTableAndColName(arguments[0], arguments[1], arguments[2], arguments[3]);
     } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Match:: Error: Invalid number of arguments, atleast columnObj,matchType,value is required")
     }
     /**
      * This function is the Match constructor which has 3 arguments.
      *
      * @param columnObj
      * @param matchType
      * @param value
      */
     function initMatchByColumn(columnObj, matchType, value) {
         if (columnObj instanceof kony.sdk.dto.Column) {
             currentMatchObj.column = columnObj;
             if (matchType !== kony.sdk.constants.MatchType.EQUALS && matchType !== kony.sdk.constants.MatchType.GREATER && matchType !== kony.sdk.constants.MatchType.GREATEREQUAL && matchType !== kony.sdk.constants.MatchType.LESS && matchType !== kony.sdk.constants.MatchType.LESSEQUAL && matchType !== kony.sdk.constants.MatchType.STARTSWITH && matchType !== kony.sdk.constants.MatchType.CONTAINS && matchType !== kony.sdk.constants.MatchType.LIKE && matchType !== kony.sdk.constants.MatchType.ENDSWITH && matchType !== kony.sdk.constants.MatchType.NOTEQUAL && matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: Invalid MatchType");
             } else {
                 if (matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                     // check if the value is passed or not except
                     // for NULL and NOT NULL cases.
                     if (value !== null && value !== undefined) {
                         if (value instanceof Array && value.length <= 0) {
                             //TODO
                             //throw error
                             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: value is undefined ,null or empty object");
                         }
                         currentMatchObj.value = value;
                     } else {
                         //TODO
                         //throw error
                         kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: Invalid MatchType");
                     }
                 }
                 currentMatchObj.matchType = matchType;
                 return currentMatchObj;
             }
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: columnObj is not an instance of kony.sdk.dto.Column");
         }
     }
     /**
      * This function is the Match constructor which has 4 arguments.
      *
      * @param tableObj
      * @param columnName
      * @param matchType
      * @param value
      */
     function initMatchByTableAndColName(tableObj, columnName, matchType, value) {
         // check for validity of tableObj
         if (tableObj instanceof kony.sdk.dto.Table) {
             // columnName should not empty or null or undefined.
             if (columnName !== null && columnName !== undefined && typeof(columnName) === 'string' && columnName.trim().length > 0) {
                 currentMatchObj.column = tableObj.getColumn(columnName);
                 if (matchType !== kony.sdk.constants.MatchType.EQUALS && matchType !== kony.sdk.constants.MatchType.GREATER && matchType !== kony.sdk.constants.MatchType.GREATEREQUAL && matchType !== kony.sdk.constants.MatchType.LESS && matchType !== kony.sdk.constants.MatchType.LESSEQUAL && matchType !== kony.sdk.constants.MatchType.STARTSWITH && matchType !== kony.sdk.constants.MatchType.CONTAINS && matchType !== kony.sdk.constants.MatchType.LIKE && matchType !== kony.sdk.constants.MatchType.ENDSWITH && matchType !== kony.sdk.constants.MatchType.NOTEQUAL && matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                     //TODO
                     //throw error
                     kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: Invalid MatchType");
                 } else {
                     if (matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
                         // check if the value is passed or not
                         // except for NULL and NOT NULL cases.
                         if (value !== null && value !== undefined) {
                             currentMatchObj.value = value;
                         } else {
                             //TODO
                             //throw error
                             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: value is undefined ,null or empty object");
                         }
                     }
                     currentMatchObj.matchType = matchType;
                 }
                 return currentMatchObj;
             } else {
                 //TODO
                 //throw error
                 kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: Invalid MatchType");
             }
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match:: Error: columnObj is not an instance of kony.sdk.dto.Column");
         }
     }
     this.getColumn = function() {
         if (this.column !== null && this.column !== undefined) {
             return this.column;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::getColumn:: Error: column is null or undefined");
         }
     };
     this.getMatchType = function() {
         if (this.matchType !== null && this.matchType !== undefined) {
             return this.matchType;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::getMatchType:: Error: matchType is null or undefined");
         }
     };
     /**
      * This function is used to set match type.
      *
      * @param matchType
      */
     this.setMatchType = function(matchType) {
         this.matchType = matchType;
     };
     this.getValue = function() {
         return this.value;
     };
     /*
      * quote=function(value){ return "'"+value+"'"; }
      */
     /**
      * This function is used to convert to String.
      *
      * @return string
      */
     this.toString = function() {
         if (this.matchType !== null && this.matchType !== undefined && this.column !== null && this.column !== undefined) {
             var constructedMatch = null;
             var constructedValue = null;
             var type = this.matchType;
             var val = this.matchType.name;
             if (this.value instanceof Date) {
                 var dateStr = "";
                 var month = this.getValue().getMonth() + 1;
                 var date = this.getValue().getDate();
                 if (month < 10) {
                     month = "0" + month;
                 }
                 if (date < 10) {
                     date = "0" + date;
                 }
                 dateStr = this.getValue().getFullYear() + "-" + month + "-" + date;
                 constructedMatch = "date(substr(" + this.getColumn().toString() + ",0,11)) " + this.getMatchType().value + "'" + dateStr + "'";
                 return constructedMatch;
             }
             if (typeof(this.getValue()) === 'boolean') {
                 if (this.getValue() === true) {
                     return "(" + this.getColumn().toString() + " = 'true' OR " + this.getColumn().toString() + " = 1)";
                 } else if (this.getValue() === false) {
                     return "(" + this.getColumn().toString() + " = 'false' OR " + this.getColumn().toString() + " = 0)";
                 } else {
                     this.value = "'" + this.value + "'";
                 }
             }
             constructedMatch = this.getColumn().toString() + " " + this.getMatchType().value + " ";
             if (typeof(this.getValue()) === 'string') {
                 constructedValue = kony.sdk.util.replaceAll(this.getValue(), "'", "");
                 if (kony.sdk.util.matchIgnoreCase(type.name, "STARTSWITH")) {
                     constructedValue = constructedValue + "%";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "CONTAINS")) {
                     constructedValue = "%" + constructedValue + "%";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ENDSWITH")) {
                     constructedValue = "%" + constructedValue;
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") = 'null' OR " + this.getColumn().toString() + " IS NULL)";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") != 'null' OR " + this.getColumn().toString() + " IS NOT NULL)";
                 }
                 constructedValue = new kony.sdk.dto.Criteria().quote(constructedValue);
             } else {
                 if (kony.sdk.util.matchIgnoreCase(type.name, "ISNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") = 'null' OR " + this.getColumn().toString() + " IS NULL)";
                 } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL")) {
                     return "(lower(" + this.getColumn().toString() + ") != 'null' OR " + this.getColumn().toString() + " IS NOT NULL)";
                 }
                 constructedValue = this.getValue().toString();
             }
             if (!(kony.sdk.util.matchIgnoreCase(type.name, "ISNULL") || kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL"))) {
                 constructedMatch = constructedMatch + constructedValue;
             }
             return constructedMatch;
         } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::toString:: Error: matchType is undefined");
         }
     }
 };

 function OAuthHandler(serviceUrl, providerName, appkey, callback, type, options, isMFVersionCompatible) {
     var urlType = "/" + type + "/";
     var isSuccess = true;
     var isLogout = false;
     // This will make sure the scheduler to request tokens will be instantiated only once in the method handleRequestCallback.
     // In case of Google OAuth changes Identity returns the success_url, so page gets refreshed twice which will fail in instantiating the scheduler twice.
     var isLoginCallbackInvoked = false;
     if (options && options.hasOwnProperty("logout") && options["logout"] === true) {
         isLogout = true;
     }
     var slo = false;
     if (options && options.hasOwnProperty("slo") && options["slo"] === true) {
         slo = options["slo"];
     }
     var customQueryParamsForOAuth;
     if (options && options.hasOwnProperty("customQueryParamsForOAuth")) {
         customQueryParamsForOAuth = kony.sdk.util.objectToQueryParams(options["customQueryParamsForOAuth"]);
     }
     var requestUrl;

     function appendCustomOAuthParamsToURL(url) {
         if (!kony.sdk.util.isNullOrEmptyString(customQueryParamsForOAuth)) {
             url = url + "&" + customQueryParamsForOAuth;
         }
         return url;
     }

     function constructURLIE11(crossPlatformBaseURL, identityOAuthUrl) {
         //Identity Server will route the final result be it success or error to Injected callback page
         identityOAuthUrl = identityOAuthUrl + "&" + kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL + "=" + encodeURIComponent(crossPlatformBaseURL + "/" + kony.sdk.constants.KNY_OAUTH_CALLBACK_HTML);
         //Invoking the identity through the injected Redirect Page to overcome IE imposed cross domain security restrictions.
         var finalRequestUrl = crossPlatformBaseURL + "/" + kony.sdk.constants.KNY_OAUTH_REDIRECT_HTML + "?" + kony.sdk.constants.KNY_OAUTH_REDIRECT_URL + "=" + encodeURIComponent(identityOAuthUrl);
         return finalRequestUrl;
     }
     if (typeof(XMLHttpRequest) !== 'undefined') {
         var _window = window;
         var _popup = null;
         var _listener = function(event) {
             var _contents = event.data;
             /**
              MFSDK-3431 - Recieving post message event from other endpoints.
              This is a short term fix. Currently Identity sends us only string in post message event, later on they have to
              send json with some more keys giving us the knowledge of source
              */
             if (kony.sdk.util.isValidString(_contents) && !kony.sdk.isJson(_contents)) {
                 _popup.close();
                 _detachEvent();
                 try {
                     kony.sdk.logsdk.debug("### OAuthHandler::_listener received authorization code as " + _contents);
                     var headers = {};
                     if (type === "oauth2" || type === "saml") {
                         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED
                     }
                     callback(urlType + "token", {
                         code: _contents
                     }, headers);
                 } catch (err) {
                     kony.sdk.logsdk.error("exception ::" + err);
                     failureCallback();
                 }
             } else if (kony.sdk.isJson(_contents) || kony.sdk.util.isJsonObject(_contents)) {
                 kony.sdk.logsdk.debug("### OAuthHandler::_listener received event.data in unknown format as " + JSON.stringify(_contents));
                 //TODO - After Identity changes check for desired key in the json.
             }
         };
         var _attachEvent = function() {
             if (_window.addEventListener) {
                 _window.addEventListener('message', _listener, false);
             } else if (_window.attachEvent) {
                 _window.attachEvent('message', _listener);
             } else {
                 throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "environment doesn't support event attaching");
             }
         };
         var _detachEvent = function() {
             if (_window.detachEvent) {
                 _window.detachEvent('message', _listener);
             } else if (_window.removeEventListener) {
                 _window.removeEventListener('message', _listener);
             } else {
                 throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "environment doesn't support detaching an event");
             }
         };
         _attachEvent();
         if (isLogout) {
             requestUrl = serviceUrl + urlType + "logout?provider=" + providerName + "&appkey=" + appkey + "&slo=" + slo;

             function handleLogoutInSPA() {
                 callback(1);
                 _popup.close();
             }
             kony.timer.schedule("SPALogout", handleLogoutInSPA, 3, false);
         } else {
             requestUrl = serviceUrl + urlType + "login?provider=" + providerName + "&appkey=" + appkey;
             requestUrl = appendCustomOAuthParamsToURL(requestUrl);
             //Checking whether server is compatable to redirect to user defined callback url
             //Changes to support OAuth on IE11, MFSDK-3657
             if (kony.sdk.util.checkForIE11() && kony.sdk.util.isJsonObject(options) && options.hasOwnProperty(kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL)) {
                 requestUrl = constructURLIE11(stripTrailingCharacter(options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL], "/"), requestUrl);
             }
         }
         if (kony.os.deviceInfo().name === kony.sdk.constants.PLATFORM_SPA && !kony.sdk.util.isMobileDevice() && kony.sdk.util.isPWAStandaloneOrFullscreen()) {
             _popup = kony.sdk.util.openPopupWindow(requestUrl, "");
         } else {
             _popup = _window.open(requestUrl);
         }
     } else {
         var browserSF = null;
         var userDefined = false;
         if (kony.sdk.util.hasBrowserWidget(options)) {
             browserSF = options[kony.sdk.constants.BROWSER_WIDGET];
             userDefined = true;
         } else if (options && options["UseDeviceBrowser"] && isMFVersionCompatible) {
             kony.sdk.util.OAuthCallback = callback;
             kony.sdk.util.OAuthType = type;
         } else {
             var formBasic = {
                 id: "popUp",
                 skin: null,
                 isModal: false,
                 transparencyBehindThePopup: 80,
                 "needAppMenu": false
             };
             var formLayout = {
                 containerWeight: 100,
                 padding: [5, 5, 5, 5],
                 "paddingInPixel": true
             };
             var formPSP = {
                 "titleBar": true,
                 "titleBarConfig": {
                     "renderTitleText": true,
                     "prevFormTitle": false,
                     "titleBarLeftSideView": "button",
                     "labelLeftSideView": "Back",
                     "titleBarRightSideView": "none"
                 },
                 "titleBarSkin": "slTitleBar"
             };
             //to do.. this is a workaround for android browser issue.. need to refactor this code
             browserSF = new kony.ui.Browser({
                 "id": "browserSF",
                 "text": "Browser",
                 "isVisible": true,
                 "detectTelNumber": true,
                 "screenLevelWidget": true,
                 "enableZoom": false
             }, {
                 "margin": [0, 0, 0, 0],
                 "marginInPixel": true,
                 "paddingInPixel": true,
                 "containerWeight": 100
             }, {});
             var prevForm = kony.application.getCurrentForm();
             var oauthForm = new kony.ui.Form2(formBasic, formLayout, formPSP);
             oauthForm.add(browserSF);
             oauthForm.show();
         }
         var urlConf;
         var headersConf = {};
         if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
             headersConf[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         }
         konyRef.appendGlobalHeaders(headersConf);
         requestUrl = serviceUrl + urlType;
         if (isLogout) {
             requestUrl += "logout?provider=" + providerName + "&appkey=" + appkey + "&slo=" + slo;
         } else {
             requestUrl += "login?provider=" + providerName + "&appkey=" + appkey;
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.getFabricAppVersion())) {
             requestUrl += "&app_version=" + kony.sdk.getFabricAppVersion();
         }
         if (isLogout) {
             browserSF.onSuccess = handleOAuthLogoutSuccessCallback;
             browserSF.onFailure = handleOAuthLogoutFailureCallback;
         } else {
             if (options && options["success_url"] && isMFVersionCompatible) requestUrl += "&success_url=" + options["success_url"];
             if (options && options["UseDeviceBrowser"] && isMFVersionCompatible) {
                 kony.application.openURL(requestUrl);
                 return;
             } else {
                 isLoginCallbackInvoked = false;
                 browserSF.handleRequest = handleRequestCallback;
                 requestUrl = appendCustomOAuthParamsToURL(requestUrl);
             }
         }
         urlConf = {
             URL: requestUrl,
             requestMethod: constants.BROWSER_REQUEST_METHOD_GET
         };
         if (Object.keys(headersConf).length > 0) {
             urlConf["headers"] = headersConf;
         }
         browserSF.requestURLConfig = urlConf;

         function handleOAuthLogoutSuccessCallback() {
             if (!userDefined) {
                 var prevFormPostShow = prevForm.postShow;

                 function postShowOverride() {
                     oauthForm.destroy();
                     if (prevFormPostShow) {
                         prevFormPostShow();
                     }
                     prevForm.postShow = prevFormPostShow;
                 }
                 prevForm.postShow = postShowOverride;
                 prevForm.show();
             }
             callback(isSuccess);
         }

         function handleOAuthLogoutFailureCallback() {
             isSuccess = false;
         }

         function handleRequestCallback(browserWidget, params) {
             var originalUrl = params["originalURL"];
             if (!isLoginCallbackInvoked && typeof(params.queryParams) !== "undefined" && typeof(params.queryParams.code) !== "undefined") {
                 if (!userDefined) {
                     var prevFormPostShow = prevForm.postShow;
                     prevForm.postShow = postShowOverride;

                     function postShowOverride() {
                         oauthForm.destroy();
                         if (prevFormPostShow) {
                             prevFormPostShow();
                         }
                         prevForm.postShow = prevFormPostShow;
                     }
                     prevForm.show();
                 }
                 var headers = {};
                 if (type === "oauth2" || type === "saml") {
                     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
                 }
                 if (!isLoginCallbackInvoked) {
                     // make request for tokens
                     kony.timer.schedule(new Date().getTime().toString(), function(url, callback, code, headers) {
                         return function() {
                             callback(url, {
                                 code: code
                             }, headers);
                         };
                     }(urlType + "token", callback, decodeURIComponent(params.queryParams.code), headers), 1, false);
                     isLoginCallbackInvoked = true;
                 }
             }
             return false;
         }
     }
 }
 /**
  * Handles the deeplink callback, this needs to be called once deep link redirection is done.
  * @param {json} params parameters from Identity service - "code": HashValue
  */
 function handleDeeplinkCallback(params) {
     if (params && kony.sdk.isValidDeeplinkCallback(params)) {
         var headers = {};
         var requestUrl;
         if (kony.sdk.util.OAuthType === "oauth2" || kony.sdk.util.OAuthType === "saml") {
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         }
         if (kony.sdk.util.OAuthType === "oauth2") {
             requestUrl = "/oauth2/token";
         } else if (kony.sdk.util.OAuthType === "saml") {
             requestUrl = "/saml/token";
         } else {
             requestUrl = "/login";
         }
         // make request for tokens
         kony.sdk.util.OAuthCallback(requestUrl, {
             code: decodeURIComponent(params.launchparams.code)
         }, headers);
     }
 }
 if (kony.sdk) {
     kony.sdk.offline = {};
 }
 /**
  * Created by Tharalika Palakurthy
  */
 /**
  * Created by Chirag Mantri
  */
 /**
  * Save the SSO Token in storage
  */
 kony.sdk.util.saveSSOToken = function(SSOToken) {
     kony.sdk.logsdk.trace("Entered Method : saveSSOToken.");
     if (!kony.sdk.isNullOrUndefined(SSOToken)) {
         kony.sdk.util.saveSSOTokenInLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY, kony.sdk.util.encryptSSOToken(SSOToken));
         return true;
     } else {
         kony.sdk.logsdk.warn("SSO token is either empty, null or undefined to save");
         return false;
     }
 };
 /**
  * Get the SSO Token from storage
  */
 kony.sdk.util.getSSOToken = function() {
     kony.sdk.logsdk.trace("Entered Method : getSSOToken.");
     var tokenString = kony.sdk.util.getSSOTokenFromLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY);
     if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
         return null;
     }
     var decryptedToken = kony.sdk.util.decryptSSOToken(tokenString);
     if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(decryptedToken)) {
         return decryptedToken;
     } else {
         return null;
     }
 };
 /**
  * Delete all SSO Tokens in storage
  */
 kony.sdk.util.deleteSSOToken = function() {
     kony.sdk.logsdk.trace("Entered Method : deleteSSOToken.");
     var tokenString = kony.sdk.util.getSSOTokenFromLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY);
     if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
         kony.sdk.logsdk.debug("SSO token found to be empty.");
         return;
     }
     kony.sdk.util.saveSSOToken("");
     kony.sdk.logsdk.trace("All SSO tokens deleted.");
 };
 /**
  * Wrapper to save SSO token via localstorage API
  *
  * @param key
  * @param value
  */
 kony.sdk.util.saveSSOTokenInLocalStorage = function(key, value) {
     if (!kony.sdk.isNullOrUndefined(key)) {
         if (!kony.sdk.isNullOrUndefined(value)) {
             localStorage.setItem(key, value);
         } else {
             kony.sdk.logsdk.warn("value passed cannot be null or undefined.");
         }
     } else {
         kony.sdk.logsdk.warn("key passed cannot be null or undefined.");
     }
 };
 /**
  * Wrapper to get SSO token via localstorage API
  *
  * @param key
  */
 kony.sdk.util.getSSOTokenFromLocalStorage = function(key) {
     if (!kony.sdk.isNullOrUndefined(key)) {
         return localStorage.getItem(key);
     } else {
         kony.sdk.logsdk.warn("key passed cannot be null or undefined.");
     }
 };
 /**
  * Returns a unique identifier for device to encrypt/decrypt sso token.
  * Android & iOS SDK is generating a UUID if not exist and share accross multiple applications.
  * This UUID is used as a secure key for encrypting/decrypting tokens.
  * @return {string}
  * @private
  */
 kony.sdk.util.getAndSaveUUIDforSSO = function() {
     var deviceUUID = kony.sdk.util.getSSOTokenFromLocalStorage(kony.sdk.constants.SSO_SECRET_KEY);
     if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(deviceUUID)) {
         deviceUUID = kony.license.generateUUID().toString();
         kony.sdk.util.saveSSOTokenInLocalStorage(kony.sdk.constants.SSO_SECRET_KEY, deviceUUID);
     }
     return deviceUUID;
 };
 var KNYMobileFabric = null;
 var KNYMetricsService = null;
 kony.setupsdks = function(initConfig, successCallBack, errorCallBack) {
     var dsAppMetaData = null;
     var AppServiceDoc = null;
     var dsAppData;
     var dsAppServiceDoc;
     var serviceDocTimerId = null;
     var getServiceDocNonMFApp = function(initConfig) {
         var serviceDoc = new kony.sdk.serviceDoc();
         serviceDoc.setAppId(initConfig.appConfig.appId);
         serviceDoc.setBaseId(initConfig.appConfig.appId);
         serviceDoc.setAppName(initConfig.appConfig.appName);
         serviceDoc.setReportingService(kony.sdk.constants.reportingType.session, getLicenseUrl(initConfig.appConfig));
         serviceDoc.setReportingService(kony.sdk.constants.reportingType.custom, getMetricsUrl(initConfig.appConfig));
         return serviceDoc.toJSON();
     };
     // Comparing the older etag vs current etag sent by tools, if mismatch considering the service doc from tools is latest.
     if (initConfig.appConfig.svcDoc && initConfig.appConfig.svcDoc.service_doc_etag) {
         var currentToolsEtag = initConfig.appConfig.svcDoc.service_doc_etag;
         var cachedToolsEtag = kony.sdk.dataStore.getItem("tools_etagID");
         if (currentToolsEtag !== cachedToolsEtag) {
             kony.print("New etag set from the app/visulizer");
             kony.sdk.dataStore.setItem("tools_etagID", currentToolsEtag);
             kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(initConfig.appConfig.svcDoc));
         }
     }
     dsAppData = kony.sdk.dataStore.getItem(appConfig.appId);
     if (!kony.sdk.isNullOrUndefined(dsAppData)) {
         dsAppMetaData = JSON.parse(dsAppData);
     }
     dsAppServiceDoc = kony.sdk.dataStore.getItem(appConfig.appId + "_mobileFabricServiceDoc");
     if (!kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
         AppServiceDoc = JSON.parse(dsAppServiceDoc);
     }
     var getLicenseUrl = function(appConfig) {
         var url = "";
         if (appConfig.isturlbase) {
             url = appConfig.isturlbase + "/IST";
         } else if (appConfig.secureurl) {
             url = getFromServerUrl(appConfig.secureurl, "IST");
         } else if (appConfig.url) {
             url = getFromServerUrl(appConfig.url, "IST");
         }
         return url;
     };
     var getMetricsUrl = function(appConfig) {
         var url = "";
         if (appConfig.isturlbase) {
             url = appConfig.isturlbase + "/CMS";
         } else if (appConfig.secureurl) {
             url = getFromServerUrl(appConfig.secureurl, "CMS");
         } else if (appConfig.url) {
             url = getFromServerUrl(appConfig.url, "CMS");
         }
         return url;
     };
     var getFromServerUrl = function(url, path) {
         // ServerURL for non-mf has /mwservlet appended after the context path.
         // We need to remove it to get the base server url
         //url = url.replace(/mwservlet\/*$/i, "");
         //return url + path;
         var newUrl = "";
         var exactSubString = url.match(/mwservlet/i);
         if (exactSubString) {
             var exactSubStringLength = "mwservlet".length;
             var lastSubStringIndex = url.lastIndexOf(exactSubString);
             var subString = url.slice(0, lastSubStringIndex);
             var index = (lastSubStringIndex + exactSubStringLength);
             var subString2 = url.slice(index, url.length);
             var has = /[a-zA-Z0-9]/.test(subString2);
             if (!has) {
                 newUrl = subString;
             } else {
                 newUrl = url;
             }
         } else {
             newUrl = url;
         }
         return newUrl + path;
     };
     var konyAPMSuccessCallBack = function(metricsObject, initConfig) {
         kony.print("Initializing event tracking");
         KNYMetricsService = metricsObject;
         if (KNYMetricsService) {
             KNYMetricsService.setEventTracking(initConfig.eventTypes);
         }
     };
     var initKNYMobileFabric = function(initConfig) {
         KNYMobileFabric = new kony.sdk();
         clientParams = {};
         clientParams.aid = appConfig.appId;
         clientParams.aname = appConfig.appName;
         KNYMobileFabric.setClientParams(clientParams);
     };
     var sdkInit = function(initConfig, successcallback, failurecallback) {
         var isInvalidConfig = false;
         var networkProvider = new konyNetworkProvider();
         if (!kony.sdk.isNullOrUndefined(dsAppMetaData) && !kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
             if (!kony.sdk.isNullOrUndefined(appConfig.svcDoc.service_doc_etag)) {
                 if (!kony.sdk.isNullOrUndefined(kony.sdk.dataStore.getItem(kony.sdk.constants.ETAGID)) && kony.sdk.dataStore.getItem(kony.sdk.constants.ETAGID) !== appConfig.svcDoc.service_doc_etag) {
                     kony.sdk.updateAppConfigWithDsAppMetaData(dsAppMetaData, dsAppServiceDoc);
                 }
             }
         }
         var refreshServiceDoc = function() {
             var networkProvider = new konyNetworkProvider();
             if (!kony.sdk.isNullOrUndefined(dsAppMetaData) && !kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
                 if (dsAppMetaData.appId === appConfig.appId && dsAppMetaData.appVersion === appConfig.appVersion) {
                     initConfig.appKey = dsAppMetaData.appKey;
                     initConfig.appSecret = dsAppMetaData.appSecret;
                     initConfig.serviceUrl = dsAppMetaData.serviceUrl;
                 }
             }
             var headers = {};
             headers[kony.sdk.constants.APP_KEY_HEADER] = initConfig.appKey;
             headers[kony.sdk.constants.APP_SECRET_HEADER] = initConfig.appSecret;
             networkProvider.get(initConfig.serviceUrl, null, headers, function(data) {
                 kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(data));
             }, function(data) {
                 kony.sdk.logsdk.warn("Refresh of serviceDoc failed:" + data);
             });
         };
         if (KNYMobileFabric == null) {
             initKNYMobileFabric(initConfig);
         }
         if (initConfig && initConfig.appConfig && (getLicenseUrl(initConfig.appConfig) === "")) {
             if (kony.license && kony.license.setIsLicenseUrlAvailable) {
                 kony.license.setIsLicenseUrlAvailable(false);
                 kony.sdk.isLicenseUrlAvailable = false;
             }
         }
         if (kony.sdk.isLicenseUrlAvailable && kony.license && kony.license.createSession) {
             kony.license.createSession();
         }
         if (!initConfig.isMFApp) {
             initWithServiceDocHelper(initConfig, successcallback, failurecallback, getServiceDocNonMFApp(initConfig));
         } else {
             if (!initConfig.appConfig.svcDocRefresh) {
                 if (initConfig.appConfig.svcDoc) {
                     initWithServiceDocHelper(initConfig, successcallback, failurecallback, initConfig.appConfig.svcDoc);
                 } else {
                     isInvalidConfig = true;
                 }
             }
             if (isInvalidConfig || initConfig.appConfig.svcDocRefresh) {
                 var cachedServiceDoc = kony.sdk.dataStore.getItem(appConfig.appId + "_mobileFabricServiceDoc");
                 if (cachedServiceDoc) {
                     try {
                         cachedServiceDoc = JSON.parse(cachedServiceDoc);
                     } catch (err) {
                         cachedServiceDoc = "";
                         kony.sdk.logsdk.error("cached service doc corrupted:" + err);
                     }
                 }
                 //Todo: Dead code, remove this refresh service doc logic. (MFSDK-2084)
                 var headers = {};
                 headers[kony.sdk.constants.APP_KEY_HEADER] = initConfig.appKey;
                 headers[kony.sdk.constants.APP_SECRET_HEADER] = initConfig.appSecret;
                 if (initConfig.appConfig.svcDocRefreshTimeSecs && !isInvalidConfig) {
                     if (cachedServiceDoc || initConfig.appConfig.svcDoc) {
                         var offlineServiceDoc = cachedServiceDoc ? cachedServiceDoc : initConfig.appConfig.svcDoc;
                         initWithServiceDocHelper(initConfig, successcallback, failurecallback, offlineServiceDoc);
                         serviceDocTimerId = Date.now().toString();
                         kony.timer.schedule(serviceDocTimerId, refreshServiceDoc, initConfig.appConfig.svcDocRefreshTimeSecs, true);
                     } else {
                         networkProvider.get(initConfig.serviceUrl, null, headers, function(res) {
                             res = kony.sdk.formatSuccessResponse(res);
                             initWithServiceDocHelper(initConfig, successcallback, failurecallback, res);
                         }, function(res) {
                             failurecallback(res);
                         });
                     }
                 } else {
                     networkProvider.get(initConfig.serviceUrl, null, headers, function(res) {
                         res = kony.sdk.formatSuccessResponse(res);
                         initWithServiceDocHelper(initConfig, successcallback, failurecallback, res);
                     }, function(res) {
                         if (cachedServiceDoc || initConfig.appConfig.svcDoc) {
                             var offlineServiceDoc = cachedServiceDoc ? cachedServiceDoc : initConfig.appConfig.svcDoc;
                             initWithServiceDocHelper(initConfig, successcallback, failurecallback, offlineServiceDoc);
                         } else {
                             failurecallback(res);
                         }
                     });
                 }
             }
         }
     };
     var initWithServiceDocHelper = function(initConfig, successcallback, failurecallback, serviceDoc) {
         try {
             if (!kony.sdk.isNullOrUndefined(initConfig) && !kony.sdk.isNullOrUndefined(initConfig["appMetadata"])) {
                 kony.sdk.util.setPackagedMetadata(initConfig["appMetadata"]);
             }
             KNYMobileFabric.initWithServiceDoc(initConfig.appKey, initConfig.appSecret, serviceDoc);
             var MetricsService = null;
             if (kony.sdk.isLicenseUrlAvailable) {
                 MetricsService = KNYMobileFabric.getMetricsService();
             }
             if (initConfig.isMFApp) {
                 konyRef.isAnonymousProvider = true;
             }
             if (successcallback) {
                 successcallback(MetricsService, initConfig);
             }
         } catch (error) {
             if (failurecallback) failurecallback(error);
         }
     };
     /*
      * isMFApp -- boolean to indicate app is being built for MFapp as backend or plain Konyserver
      * appConfig -- set to appConfig of startup.js
      *
      * --MF Parameters--
      * serviceUrl -- mf appconfig url
      * appKey -- set to App Key for MF app scenario
      * appSecret -- set to App Secret for MF app scenario
      *
      * -- For APM --
      * eventTypes -- This should be set to comma separated values chosen in the IDE for events chosen for automatic tracking
      *
      * Examples
      * var sdkInitConfigForMF = {
      *    "isMFApp": true,
           "appConfig" : appconfig,

           "appKey" :"<appkey fetched from MF>",
           "appSecret":"<appsecret fetched from MF>",
           "serviceUrl" : "<appconfig url of the form https://100000013.auth.sit2-konycloud.com/appconfig>",
           "eventTypes" :   ["FormEntry","FormExit","Touch","ServiceRequest","ServiceResponse","Gesture","Orientation","Error","Crash"]
           }
      * var sdkInitConfigForNonMF = {
           "isMFApp": false,
           "appConfig" : appconfig

           "eventTypes" :   ["FormEntry","FormExit","Touch","ServiceRequest","ServiceResponse","Gesture","Orientation","Error","Crash"]
           }
      */
     sdkInit(initConfig, function(metricsObject, initConfig) {
         kony.print("sdk initialization done");
         konyAPMSuccessCallBack(metricsObject, initConfig);
         if (successCallBack) successCallBack(KNYMobileFabric);
     }, function(errorObj) {
         var errorMsg = errorObj ? errorObj.toString() : "";
         kony.print("Error in setup " + errorMsg);
         if (errorCallBack) errorCallBack(errorObj);
     });
 };
 kony.sdk.util = kony.sdk.util || {};

 function konyLogger() {
     this.log = function(text) {
         if (kony.sdk.isDebugEnabled) {
             kony.print(text);
         }
     }
 }
 /**
  * Flag used to override the network availability api for automation testing.
  * @type {boolean}
  */
 overrideNetworkFlag = false;
 /**
  *	Utility Method for the application to check the network availability.
  */
 kony.sdk.isNetworkAvailable = function() {
     //Check the network flag if set for testing. This would mandate the application to be offline if device has network connectivity.
     if (overrideNetworkFlag !== undefined && overrideNetworkFlag !== null && overrideNetworkFlag && overrideNetworkFlag === true) return false;
     return kony.net.isNetworkAvailable(constants.NETWORK_TYPE_ANY);
 };
 /**
  *	Utility method to set the network flag for offline testing.
  */
 kony.sdk.overrideNetworkFlag = function() {
     overrideNetworkFlag = true;
 };
 /**
  *	Utility method to reset the network flag set for offline testing.
  */
 kony.sdk.resetNetworkFlag = function() {
     overrideNetworkFlag = false;
     overrideNetworkFlag = undefined;
 };
 kony.sdk.overrideAnonymousLoginFlag = function() {
     kony.sdk.skipAnonymousCall = true;
 };
 kony.sdk.resetAnonymousLoginFlag = function() {
     kony.sdk.skipAnonymousCall = false;
 };

 function konyNetworkProvider() {
     this.post = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, params, headers, "POST", konyContentType, successCallback, failureCallback, options);
     };
     this.put = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, params, headers, "PUT", konyContentType, successCallback, failureCallback, options);
     };
     this.invokeDeleteRequest = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, params, headers, "DELETE", konyContentType, successCallback, failureCallback, options);
     };
     //postSync will only work for Richclients like Android,IOS
     this.postSync = function(url, params, headers) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         return konyNetHttpRequestSync(url, params, headers);
     };
     this.get = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
         if (kony.sdk.util.isNullOrEmptyString(url)) {
             kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
             return;
         }
         //Appending global params
         if (kony.sdk.isNullOrUndefined(params)) {
             params = {};
         }
         if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
             url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
         }
         konyNetHttpRequest(url, null, headers, "GET", konyContentType, successCallback, failureCallback, options);
     }
 }

 function konyNetHttpRequest(url, params, headers, httpMethod, konyContentType, successCallback, failureCallback, options) {
     var paramsTable = null;
     var httpRequest;
     if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
         httpRequest = new kony.net.HttpRequest(options["httpRequestOptions"]);
     } else {
         httpRequest = new kony.net.HttpRequest();
     }
     if (options && options["queryParams"] && options["queryParams"] instanceof Object) {
         url = addQueryParamsToURL(url, options["queryParams"]);
     }
     if (options && options["responseType"]) {
         httpRequest.responseType = options["responseType"];
     }
     // check for the deprecated property if set in appmiddlewaresecureinvokerasync() API
     if (options && options["httpconfig_old"]) {
         if (options["httpconfig_old"]["timeout"]) {
             httpRequest.timeout = options["httpconfig_old"]["timeout"] * 1000;
         }
     }
     if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object && options["httpRequestOptions"]["timeoutIntervalForRequest"]) {
         httpRequest.timeout = options["httpRequestOptions"]["timeoutIntervalForRequest"] * 1000;
     }
     // As older versions of IE doesn't have xmlHttpRequest2, and it doesn't support "withCredentials" property
     // We put a check to handle a crash. Cookies will not be transferred in CORS request for IE due to this restriction
     if (typeof(XMLHttpRequest) !== "undefined" && "withCredentials" in (new XMLHttpRequest()) && options && options["xmlHttpRequestOptions"] && options["xmlHttpRequestOptions"]["enableWithCredentials"] === true) {
         httpRequest.enableWithCredentials = true;
     }
     var isInvalidResponse = false;
     //if httpmethod is not provided falling back to POST
     if (!httpMethod) {
         httpMethod = constants.HTTP_METHOD_POST;
     }
     httpRequest.open(httpMethod, url);

     function localRequestCallback(result) {
         var readyState = Number(httpRequest.readyState.toString());
         var status = Number(httpRequest.status.toString());
         var response = {};
         if (readyState === 4) {
             //If option "passthrough" is enabled then SDK will not parse the result from backend.
             if (options && options[kony.sdk.constants.PASSTHROUGH]) {
                 response.rawResponse = result.response;
             } else {
                 //parseHttpResponse parse response based on the content-type response header
                 var parsedResp = parseHttpResponse(httpRequest);
                 if (parsedResp.isRawResponse) {
                     response.rawResponse = parsedResp.response;
                 } else {
                     response = parsedResp.response;
                 }
                 isInvalidResponse = parsedResp.isInvalidResponse;
             }
             kony.sdk.setLogLevelFromServerResponse(httpRequest.getAllResponseHeaders());
             if (response && !isInvalidResponse) {
                 response.httpresponse = {};
                 response.httpresponse.headers = httpRequest.getAllResponseHeaders();
                 response.httpresponse.url = url;
                 response.httpresponse.responsecode = status;
             }
             if (isInvalidResponse || (!response && status >= 200 && status < 300)) {
                 var errorMessage = {};
                 errorMessage.httpresponse = {};
                 errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_json_code;
                 errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_json_message;
                 errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_json_code;
                 errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = status;
                 errorMessage.httpresponse["response"] = parsedResp.response;
                 errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
                 errorMessage.httpresponse.url = url;
                 errorMessage.httpresponse.responsecode = status;
                 failureCallback(errorMessage);
             } else if (status >= 200 && status < 300) {
                 if (!response.opstatus) {
                     response.opstatus = 0;
                 }
                 if (response.opstatus == 0 || (response.opstatus >= 500100 && response.opstatus <= 500200)) {
                     if (options && (options[kony.sdk.constants.DISABLE_INTEGRITY] || options[kony.sdk.constants.PASSTHROUGH])) {
                         successCallback(response);
                     } else {
                         if (typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === true) {
                             if (response.httpresponse.headers.hasOwnProperty(kony.sdk.constants.INTEGRITY_HEADER) || response.httpresponse.headers.hasOwnProperty(kony.sdk.constants.INTEGRITY_HEADER.toLowerCase())) {
                                 if (!(kony.sdk.isNullOrUndefined(httpRequest.integrityStatus))) {
                                     var integrityStatus = parseInt(httpRequest["integrityStatus"].toString());
                                     switch (integrityStatus) {
                                         case constants.HTTP_INTEGRITY_CHECK_NOT_DONE:
                                             failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                                             break;
                                         case constants.HTTP_INTEGRITY_CHECK_SUCCESSFUL:
                                             successCallback(response);
                                             break;
                                         case constants.HTTP_INTEGRITY_CHECK_FAILED:
                                             failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                                             break;
                                     }
                                 } else {
                                     failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                                 }
                             } else if (options && options != null && options["ignoreintegrity"]) {
                                 successCallback(response);
                             } else {
                                 failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                             }
                         } else {
                             successCallback(response);
                         }
                     }
                 } else {
                     failureCallback(response);
                 }
             } else {
                 invokeNetworkErrorCallback(url, httpRequest, response, status);
             }

             function invokeNetworkErrorCallback(url, httpRequest, response, status) {
                 var errorObj = {};
                 errorObj.httpresponse = {};
                 if (status == 408) {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.request_timed_out_code;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.request_timed_out_code;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.request_timed_out_message;
                 } else if (status == 503) {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.service_unavailable;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.service_unavailable;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.service_unavailable_message;
                 } else if (status == 504) {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connection_timeout;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connection_timeout;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connection_timeout_message;
                 } else if ((status > 99) && (!kony.sdk.isNullOrUndefined(response))) {
                     errorObj = response;
                 } else {
                     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
                     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
                     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
                 }
                 errorObj[kony.sdk.constants.HTTP_STATUS_CODE] = status;
                 errorObj.httpresponse.headers = httpRequest.getAllResponseHeaders();
                 errorObj.httpresponse.url = url;
                 failureCallback(errorObj);
             }
         }
     }
     if (konyContentType === "application/json") {
         if (params) {
             paramsTable = JSON.stringify(params);
         }
     } else if (konyContentType == undefined || konyContentType == null || konyContentType != 'formdata') {
         //preparing params for other than object services
         var firstKey = true;
         for (var key in params) {
             if (firstKey) {
                 paramsTable = new kony.net.FormData();
                 firstKey = false;
             }
             if (typeof(params[key]) != "undefined") {
                 if (typeof(params[key]) !== "string") {
                     params[key] = JSON.stringify(params[key]);
                 }
                 paramsTable.append((key), (params[key]));
             }
         }
     } else if (konyContentType == "formdata") {
         //for specific requests like object services we will send formdata through form encoding mechanism.
         if (params) {
             //for object services we are getting kony.net.FormData so using the same.
             paramsTable = params;
         }
     }
     if (headers) {
         for (var key in headers) {
             httpRequest.setRequestHeader(key, headers[key]);
         }
     } else {
         httpRequest.setRequestHeader(kony.sdk.constants.HTTP_CONTENT_HEADER, kony.sdk.constants.CONTENT_TYPE_JSON);
     }
     httpRequest.onReadyStateChange = localRequestCallback;
     if (options && (options[kony.sdk.constants.DISABLE_INTEGRITY] || options[kony.sdk.constants.PASSTHROUGH])) {
         //mesasging service and pass through enabled integration svc doesn't support http message body integrity
         //if integrity is enabled earlier,remove integrity
         //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
         if (kony.sdk.constants.REMOVE_INTEGRITY_CHECK in kony.net) {
             kony.net.removeIntegrityCheck();
         }
         if (paramsTable) {
             httpRequest.send(paramsTable);
         } else {
             httpRequest.send();
         }
     } else {
         if (typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === true) {
             var properties = konyRef.mainRef.integrityParams;
             try {
                 //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
                 if (kony.sdk.constants.SET_INTEGRITY_CHECK in kony.net) {
                     kony.net.setIntegrityCheck(properties);
                 }
             } catch (e) {
                 kony.sdk.logsdk.warn("Invalid Integrity properties received");
                 throw "Invalid Integrity properties received";
             }
         } else {
             //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
             if (kony.sdk.constants.REMOVE_INTEGRITY_CHECK in kony.net) {
                 kony.net.removeIntegrityCheck();
             }
         }
         if (paramsTable) {
             httpRequest.send(paramsTable);
         } else {
             httpRequest.send();
         }
     }
     /**
      * copied from spa_offlineobjects/KSUtils/KSNetworkUtils.js
      * Method to add the query parameters after URI encoding to the URL.
      * @param {string} url URL to which the query params are to be appended.
      * @param {Object} queryParams JSON object containing the query parameters.
      */
     function addQueryParamsToURL(url, queryParams) {
         if (queryParams && Object.keys(queryParams).length > 0) {
             var encodedQueryParams = "";
             var ampersandSubstring = "&";
             for (var key in queryParams) {
                 encodedQueryParams += key + "=" + encodeURIComponent(queryParams[key]) + ampersandSubstring;
             }
             //Remove the trailing ampersand for the last key-value pair..
             encodedQueryParams = encodedQueryParams.slice(0, -1);
             //Check if the URL has query params already..
             if (url.indexOf('?') > -1) {
                 url += "&" + encodedQueryParams;
             } else {
                 url += "?" + encodedQueryParams;
             }
         }
         return url;
     }
 }

 function konyNetHttpRequestSync(url, params, headers) {
     var paramsTable = null;
     var httpRequest = new kony.net.HttpRequest();
     var isInvalidJSON = false;
     httpRequest.open(constants.HTTP_METHOD_POST, url, false);
     var firstKey = true;
     for (var key in params) {
         if (firstKey) {
             paramsTable = new kony.net.FormData();
             firstKey = false;
         }
         if (typeof(params[key]) != "undefined") {
             if (typeof(params[key]) !== "string") {
                 params[key] = JSON.stringify(params[key]);
             }
             paramsTable.append((key), (params[key]));
         }
     }
     if (headers) {
         for (var key in headers) {
             httpRequest.setRequestHeader(key, headers[key]);
         }
     } else {
         httpRequest.setRequestHeader(kony.sdk.constants.HTTP_CONTENT_HEADER, kony.sdk.constants.CONTENT_TYPE_JSON);
     }
     //httpRequest.onReadyStateChange = localRequestCallback;
     httpRequest.send(paramsTable);
     var response = null;
     var status = Number(httpRequest.status.toString());
     kony.sdk.setLogLevelFromServerResponse(httpRequest.getAllResponseHeaders());
     if (httpRequest.response) {
         response = httpRequest.response;
     }
     if (response && typeof(response) === 'string') {
         if (kony.sdk.isJson(response)) {
             response = JSON.parse(response);
         } else {
             isInvalidJSON = true;
         }
     }
     if (response && !(isInvalidJSON)) {
         response.httpresponse = {};
         response.httpresponse.headers = httpRequest.getAllResponseHeaders();
         response.httpresponse.url = url;
         response.httpresponse.responsecode = status;
     }
     if (isInvalidJSON || (!response && status >= 200 && status < 300)) {
         var errorMessage = {};
         errorMessage.httpresponse = {};
         errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_json_code;
         errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_json_message;
         errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_json_code;
         errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = status;
         errorMessage.httpresponse["response"] = response;
         errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
         errorMessage.httpresponse.url = url;
         errorMessage.httpresponse.responsecode = status;
         return errorMessage;
     } else if (status >= 200 && status < 300) {
         if (!response.opstatus) {
             response.opstatus = 0;
         }
         return response;
     } else {
         var resultTable = {};
         if (response) {
             resultTable = response;
             resultTable.httpStatusCode = httpRequest.status.toString();
         } else {
             resultTable[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
             resultTable[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
             resultTable[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
         }
         return resultTable;
     }
 }

 function konyDataStore() {
     //kony.sdk.logsdk.trace("Setting konyDataStore");
     this.setItem = function(key, value) {
         if (typeof(key) !== "string") {
             throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Invalid Key");
         } else {
             try {
                 key = key.replace(/\//gi, "");
                 kony.store.setItem(key, value);
             } catch (e) {
                 kony.sdk.logsdk.error("Failed to set item in dtastore:" + e);
             }
         }
     };
     this.getItem = function(key) {
         kony.sdk.logsdk.debug("Getting item for key:" + key);
         if (typeof(key) !== "string") {
             throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION);
         } else {
             key = key.replace(/\//gi, "");
             var value = kony.store.getItem(key);
             if (value === null || value === undefined) {
                 kony.sdk.logsdk.debug("No value found with key:" + key);
                 return null;
             } else {
                 return value;
             }
         }
     };
     this.removeItem = function(key) {
         kony.sdk.logsdk.debug("Removing item for key:" + key);
         if (typeof(key) !== "string") {
             throw new Exception(Error.DATA_STORE_EXCEPTION);
         } else {
             key = key.replace(/\//gi, "");
             kony.store.removeItem(key); //If no item with that key exists, the method does not perform any action. Thus no need to check for key availablity.
         }
     };
     this.destroy = function() {
         kony.sdk.logsdk.info("Destroying data store for this app");
         kony.store.clear();
     };
     this.getAllItems = function() {
         kony.sdk.logsdk.info("Getting all item from data store");
         var items = {};
         var len = kony.store.length(); //get key length
         for (var i = 0; i < len; i++) {
             var key = kony.store.key(i); //get ith key
             var value = kony.store.getItem(key); //get value
             items[key] = value; //prepare itemset
         }
         return items;
     }
 }

 function parseHttpResponse(httpRequest) {
     var isInvalidResponse = false;
     var isJsonResponse = false;
     var parsedResponse = {};
     parsedResponse.isRawResponse = false;
     var value = "";
     var response = null;
     if (kony.sdk.isNullOrUndefined(httpRequest) || kony.sdk.isNullOrUndefined(httpRequest.response)) {
         kony.sdk.logsdk.warn("parseHttpResponse :: Null or Invalid response received");
     } else if (httpRequest.responseType && httpRequest.responseType === "blob") {
         parsedResponse.response = httpRequest.response;
         parsedResponse.isRawResponse = true;
     } else {
         response = kony.sdk.cloneObject(httpRequest.response);
         kony.sdk.logsdk.debug("parseHttpResponse :: Network response :", response);
         //Defaulting to JSON format
         if (kony.sdk.util.isJsonObject(response)) {
             parsedResponse.response = response;
             isJsonResponse = true;
         } else if (kony.sdk.util.isValidString(response)) {
             if (kony.sdk.isJson(response)) {
                 parsedResponse.response = JSON.parse(response);
                 isJsonResponse = true;
             }
         }
         //Handling when response is not json
         if (!isJsonResponse) {
             if (kony.sdk.util.isValidString(httpRequest.response)) {
                 parsedResponse.response = response;
             } else {
                 parsedResponse.response = httpRequest.response;
             }
             var lowerCaseHeaders = kony.sdk.util.convertJsonKeysToLowerCase(httpRequest.getAllResponseHeaders());
             //value variable contains response header in lower case
             if (!kony.sdk.isNullOrUndefined(lowerCaseHeaders)) {
                 value = lowerCaseHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER.trim().toLowerCase()];
             } else {
                 kony.sdk.logsdk.warn("parseHttpResponse :: received null response headers  " + lowerCaseHeaders);
             }
             kony.sdk.logsdk.warn("parseHttpResponse :: content-type of response " + value);
             //MFSDK-3525 Adding an additional check to see if content type is present.
             if (kony.sdk.util.isValidString(value) && value.startsWith(kony.sdk.constants.CONTENT_TYPE_JSON)) {
                 kony.sdk.logsdk.warn("parseHttpResponse :: Unhandled content received for content-type application/json");
                 isInvalidResponse = true;
             } else {
                 parsedResponse.isRawResponse = true;
             }
         }
     }
     parsedResponse.isInvalidResponse = isInvalidResponse;
     return parsedResponse;
 }
 kony.sdk.getSdkType = function() {
     return kony.sdk.constants.SDK_TYPE_IDE;
 };
 kony.sdk.getPayload = function(konyRef) {
     var payload = {};
     payload.os = kony.os.deviceInfo().version + "";
     payload.dm = kony.os.deviceInfo().model;
     payload.did = kony.sdk.getDeviceId();
     payload.ua = kony.os.userAgent();
     if (appConfig) {
         payload.aid = appConfig.appId;
         payload.aname = appConfig.appName;
     } else {
         var clientParams = konyRef.getClientParams();
         payload.aid = clientParams.aid ? clientParams.aid : konyRef.mainRef.baseId;
         payload.aname = clientParams.aname ? clientParams.aname : konyRef.mainRef.name;
     }
     payload.chnl = kony.sdk.getChannelType();
     payload.plat = kony.sdk.getPlatformName();
     if (payload.plat === kony.sdk.constants.PLATFORM_IOS && kony.os.deviceInfo().name !== kony.sdk.constants.PLATFORM_SPA) {
         payload.did = getDeviceIdForIOSPlatform();
     }
     if (payload.plat === kony.sdk.constants.PLATFORM_IOS && payload.dm.toLowerCase().indexOf("ipod") !== -1) {
         payload.chnl = "ipod";
     }
     payload.aver = appConfig.appVersion;
     payload.atype = kony.sdk.getAType();
     payload.stype = "b2c";
     payload.kuid = konyRef.getUserId();
     payload.mfaid = konyRef.mainRef.appId;
     payload.mfbaseid = konyRef.mainRef.baseId;
     payload.mfaname = konyRef.mainRef.name;
     payload.sdkversion = kony.sdk.version;
     payload.sdktype = kony.sdk.getSdkType();
     if (kony.application.getCurrentForm()) {
         var fid = kony.application.getCurrentForm().id;
         if (fid) {
             payload.fid = fid;
         }
     }
     payload.sessiontype = kony.sdk.util.getSessionType();
     return payload;
 };
 /**
  * Returns unique identifier for a device.
  * In case of Android & Windows the API kony.os.deviceInfo().deviceid is guaranteed to provide unique identifier for a device.
  * In case of iOS the API kony.os.deviceInfo().identifierForVendor is guaranteed to provide unique key per vendor.
  * A different value is returned for apps on the same device that come from different vendors, and for apps on different devices regardless of vendor
  * @return {string}
  */
 kony.sdk.getDeviceId = function() {
     // For Android, SPA & Windows platforms.
     return kony.os.deviceInfo().deviceid;
 };
 kony.sdk.getChannelType = function() {
     var returnVal = "";
     returnVal = "desktop";
     return returnVal;
 };
 kony.sdk.getPlatformName = function() {
     var returnVal = "";
     returnVal = kony.sdk.constants.PLATFORM_WINDOWS;
     return returnVal;
 };
 kony.sdk.util.createSessionAndSendIST = function() {
     kony.license.createSession();
     kony.license.captureKonyLicenseUsage(true);
 }
 kony.mbaas.invokeMbaasServiceFromKonyStudio = function(url, inputParam, serviceID, operationID, callBack, infoObject) {
     var currentInstance = kony.sdk.getCurrentInstance();
     if (!currentInstance) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "this service.");
     }
     var integrationService = currentInstance.getIntegrationService(serviceID);
     var options = {};
     if (inputParam && inputParam["httpconfig"]) {
         options["httpconfig_old"] = inputParam["httpconfig"];
         delete inputParam["httpconfig"];
     }
     if (inputParam && inputParam["httpRequestOptions"] && inputParam["httpRequestOptions"] instanceof Object) {
         options["httpRequestOptions"] = inputParam["httpRequestOptions"];
         delete inputParam["httpRequestOptions"];
     }
     if (inputParam && inputParam["xmlHttpRequestOptions"] && inputParam["xmlHttpRequestOptions"] instanceof Object) {
         options["xmlHttpRequestOptions"] = inputParam["xmlHttpRequestOptions"];
         delete inputParam["xmlHttpRequestOptions"];
     }
     var headers = null;
     if (inputParam && inputParam["httpheaders"]) {
         headers = inputParam["httpheaders"];
         delete inputParam["httpheaders"];
     }
     integrationService.invokeOperation(operationID, headers, inputParam, function(res) {
         if (typeof(callBack) === 'function') {
             callBack(400, res, infoObject);
         }
     }, function(res) {
         if (typeof(callBack) === 'function') {
             callBack(400, res, infoObject);
         }
     }, options);
 };
 kony.mbaas.invokeMbaasServiceFromKonyStudioSync = function(url, inputParam, serviceID, operationID) {
     var currentInstance = kony.sdk.getCurrentInstance();
     if (!currentInstance) {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "this service.");
     }
     var integrationService = currentInstance.getIntegrationService(serviceID);
     var headers = null;
     if (inputParam && inputParam["httpheaders"]) {
         headers = inputParam["httpheaders"];
         delete inputParam["httpheaders"];
     }
     return integrationService.invokeOperationSync(operationID, headers, inputParam);
 };
 kony.mbaas.invokeMbaasServiceFromKonyStudioAsync = function(url, inputParam, serviceID, operationID, callBack, info) {
     kony.mbaas.invokeMbaasServiceFromKonyStudio(url, inputParam, serviceID, operationID, callBack, info);
 };

 function getDeviceIdForIOSPlatform() {
     if (kony.os.deviceInfo().osversion >= 6.0) {
         return kony.os.deviceInfo().identifierForVendor;
     }
     return kony.os.deviceInfo().customdeviceid;
 }
 //Helps to prepare the input wrapped into kony.net.FormData
 kony.sdk.getFormData = function(payload) {
     var formData = new kony.net.FormData();
     formData.append(kony.sdk.constants.JSON_DATA, JSON.stringify(payload));
     return formData;
 };
 //Helps to update prepare the input wrapped into kony.net.FormData
 kony.sdk.updateFormData = function(formData, key, value) {
     formData.append(key, JSON.stringify(value));
     return formData;
 };
 //Helps to get the atype for Spa and DesktopWeb applications it would be kony.sdk.constants.SDK_ATYPE_SPA ,for android wear applications it would be "watch" and remaining it would be "native"
 kony.sdk.getAType = function() {
     var returnVal = kony.sdk.constants.SDK_ATYPE_NATIVE;
     returnVal = kony.sdk.constants.SDK_ATYPE_SPA;
     return returnVal;
 };
 kony.sdk.setLicenseCall = function(appKey, appSecret, data) {
     //checking if new MF app is connected
     var reportingServiceUrl = data.reportingsvc.session;
     if (typeof(appConfig) != "undefined") {
         if ((appKey === appConfig.appKey) && (appSecret === appConfig.appSecret) && (typeof(appConfig.svcDoc) !== "undefined" && reportingServiceUrl === appConfig.svcDoc.reportingsvc.session)) {
             return; //user is doing init on same environment and same MF-app
         } else {
             appConfig.isturlbase = reportingServiceUrl.replace("/IST", "");
             appConfig.appKey = appKey;
             appConfig.appSecret = appSecret;
             appConfig.serviceUrl = data.selflink;
             appConfig.svcDoc = data;
             // IST is triggered with new sid and new MF app on the same or different IST server based on how isturlbase is populated
             kony.sdk.util.createSessionAndSendIST();
         }
     }
 };
 kony.sdk.saveMetadatainDs = function(appKey, appSecret, servConfig) {
     // Saving App metadata in storage for Persistence.
     kony.sdk.isLicenseUrlAvailable = true;
     var appId = {
         "appKey": appKey,
         "appSecret": appSecret,
         "serviceUrl": servConfig.selflink,
         "appVersion": appConfig.appVersion,
         "licenseUrl": servConfig.reportingsvc.session
     };
     if (servConfig.service_doc_etag) {
         appId.service_doc_etag = servConfig.service_doc_etag;
         kony.sdk.dataStore.setItem(kony.sdk.constants.ETAGID, servConfig.service_doc_etag);
     }
     if (typeof(sdkInitConfig) !== "undefined") {
         sdkInitConfig.appKey = appKey;
         sdkInitConfig.appSecret = appSecret;
         sdkInitConfig.serviceUrl = servConfig.selflink;
     }
     kony.sdk.dataStore.setItem(appConfig.appId + "_mobileFabricServiceDoc", JSON.stringify(servConfig));
     kony.sdk.dataStore.setItem(appConfig.appId, JSON.stringify(appId));
 };
 kony.sdk.deleteMetadatafromDs = function() {
     kony.sdk.dataStore.removeItem(appConfig.appId);
 };
 kony.sdk.updateAppConfigWithDsAppMetaData = function(dsAppMetaData, dsAppServiceDoc) {
     appConfig.appKey = dsAppMetaData.appKey;
     appConfig.appSecret = dsAppMetaData.appSecret;
     appConfig.serviceUrl = dsAppMetaData.serviceUrl;
     var reportingServiceUrl = dsAppMetaData.licenseUrl;
     appConfig.isturlbase = reportingServiceUrl.replace("/IST", "");
     appConfig.svcDoc = JSON.parse(dsAppServiceDoc);
     sdkInitConfig.appKey = dsAppMetaData.appKey;
     sdkInitConfig.appSecret = dsAppMetaData.appSecret;
     sdkInitConfig.serviceUrl = dsAppMetaData.serviceUrl;
 };
 /**
  * Validates the deeplink params. A valid deeplink redirection will contain params "code" & "launchmode" is 3.
  * @param {map} params  - query parameters from the deeplink redirection
  */
 kony.sdk.isValidDeeplinkCallback = function(params) {
     if (params && params.launchmode == kony.sdk.constants.LAUNCHMODE_DEEPLINK && params.launchparams.code) return true;
     else return false;
 };
 kony.sdk.getReportingParamsForOfflineObjects = function() {
     var reportingData = kony.sdk.getPayload(konyRef);
     reportingData.xmode = "offline";
     reportingData.rsid = kony.sdk.currentInstance.getSessionId();
     return JSON.stringify(reportingData);
 };
 var MFAppVersion;
 kony.sdk.setFabricAppVersion = function(version) {
     MFAppVersion = version;
 };
 /**
  * Returns the default fabric application version. For auto init app version will be available in appConfig,
  * for manual init developer has to send fabric version explicitly.
  *
  * Fabric version in manual init has more priority over one specified in visualizer.
  * @return {*}
  */
 kony.sdk.getFabricAppVersion = function() {
     if (!kony.sdk.isNullOrUndefined(MFAppVersion)) {
         return MFAppVersion;
     } else if (!kony.sdk.isNullOrUndefined(appConfig) && !kony.sdk.isNullOrUndefined(appConfig.runtimeAppVersion)) {
         return appConfig.runtimeAppVersion;
     }
 };
 /**
  * Encrypt given SSO token
  *
  * @param ssotoken token to be encrypted.
  * @return encrypted SSO token
  */
 kony.sdk.util.encryptSSOToken = function(ssotoken) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.encryptSSOToken");
     return kony.sdk.util.encryptText(ssotoken, [kony.sdk.util.getAndSaveUUIDforSSO()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
 };
 /**
  * Decrypt given encrypted_token
  *
  * @param token to be decrypted
  * @return decrypted token
  */
 kony.sdk.util.decryptSSOToken = function(encryptedtoken) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.util.decryptSSOToken");
     if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(encryptedtoken)) {
         return encryptedtoken;
     }
     var decryptedToken = kony.sdk.util.decryptText(encryptedtoken, [kony.sdk.util.getAndSaveUUIDforSSO()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
     if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(decryptedToken)) {
         // Backward compatibility. Since we didnt encrypt with deviceID decryption will fail. Decrypt with old key "ssoencryption". Encrypting with deviceID & persisting response.
         decryptedToken = kony.sdk.util.decryptText(encryptedtoken, ["ssoencryption"], kony.sdk.constants.ENCRYPTION_ALGO_AES);
         if (!kony.sdk.isNullOrUndefined(decryptedToken) && decryptedToken !== '') {
             kony.sdk.util.saveSSOToken(decryptedToken);
         }
     }
     return decryptedToken;
 };
 /**
  * Generates key to encrypt/decrypt any text.
  * @param salt {Array}
  * @returns string
  */
 kony.sdk.util.generateSecureKeyFromText = function(salt) {
     var secureKey = "";
     if (!kony.sdk.isNullOrUndefined(salt) && kony.sdk.isArray(salt)) {
         var params = {};
         params["passphrasetext"] = salt;
         params["subalgo"] = kony.sdk.constants.ENCRYPTION_ALGO_AES;
         params["passphrasehashalgo"] = "md5";
         secureKey = kony.crypto.newKey("passphrase", 128, params);
     } else {
         throw new Exception(kony.sdk.errorConstants.CONFIGURATION_FAILURE, "Invalid param. salt cannot be null, should be of type Array");
     }
     return secureKey;
 };
 /**
  * Encrypts text with the given salt and encryptionAlgo.
  * @param text to be encrypted
  * @param salt additional input to a one-way function that "hashes" data
  * @param encryptionAlgo algo to be used to decrypt
  * @returns decrypted string
  */
 kony.sdk.util.encryptText = function(text, salt, encryptionAlgo) {
     var encryptionKey = kony.sdk.util.generateSecureKeyFromText(salt);
     var encryptedText = kony.crypto.encrypt(encryptionAlgo, encryptionKey, text, {});
     return kony.convertToBase64(encryptedText);
 };
 /**
  * Decrypts text with the given salt and encryptionAlgo.
  * @param text to be decrypted
  * @param salt additional input to a one-way function that "hashes" data
  * @param encryptionAlgo algo to be used to decrypt
  * @returns decrypted string
  */
 kony.sdk.util.decryptText = function(text, salt, decryptionAlgo) {
     var decryptionKey = kony.sdk.util.generateSecureKeyFromText(salt);
     // convert base64 to rawbytes
     try {
         var raw_text = kony.sdk.util.convertBase64ToRawBytes(text);
     } catch (exception) {
         kony.sdk.logsdk.error("exception occurred while converting to raw text, exception :", exception);
     }
     return kony.crypto.decrypt(decryptionAlgo, decryptionKey, raw_text, {});
 };
 /**
  * Converts base64String to raw bytes using atob JS function for SPA and DW platforms
  */
 kony.sdk.util.convertBase64ToRawBytes = function(base64String) {
     return atob(base64String);
 };
 /**
  * Returns type of object
  * framework api kony.type is not supported by Phonegap and plain-js platforms
  * @return {*}
  */
 kony.sdk.util.type = function(objectVar) {
     if (kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE) {
         return kony.type(objectVar)
     } else {
         return typeof(objectVar)
     }
 };
/**
 * kony-spa-filestorage version 8.4.20
 * This file is intended for desktopWeb/SPA only.
 */
if (typeof(kony) === "undefined") {
    kony = {};
}
if (typeof(kony.sdk) === "undefined") {
    kony.sdk = {};
}
if (typeof(kony.sdk.FileStorageClasses) === "undefined") {
    kony.sdk.FileStorageClasses = {};
}
/**
 * Callbacks for Binary SPA.
 * Created by Rakesh Gyanchandani on 28-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBCallbacks", ["exports"], function(exports) {
    "use strict";
    var LOG_PREFIX = "KBCallbacks : ";
    exports._esModule = true;
    /**
     * Binary Callbacks.
     * @param successCallback  Callback to be called on succcess.
     * @param failureCallback  Callback to be called on failure.
     * @constructor
     */
    function KBCallbacks(successCallback, failureCallback) {
        this.successCallback = function(res) {
            if (successCallback && typeof(successCallback) === "function") {
                successCallback(res);
            }
        };
        this.failureCallback = function(err) {
            if (failureCallback && typeof(failureCallback) === "function") {
                failureCallback(err);
            }
        };
    }
    exports.KBCallbacks = KBCallbacks;
});
/**
 * Object defining the constants for internal use.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
kony.sdk.binary.KBConstants = Object.freeze({
    //FileStorageManagerConstants
    URL: "url",
    CALLBACK: "Callback",
    CRITERIA: "criteria",
    HEADERS: "headers",
    ERROR: "Error",
    RECORDS: "records",
    OP_STATUS: "opstatus",
    HTTP_STATUS_CODE: "httpStatusCode",
    METADATA: "metadata",
    FILE_ID: "file_id",
    FILTER: "filter",
    DOLLAR_FILTER: "$filter",
    FILE_NAME: "file_name",
    DOWNLOAD_TEMPLATE: "download_template",
    RELATIVE_PATH: "relativepath",
    SERVICES: "services",
    METADATA_URL_SUFFIX: "/objects/File",
    BLOB: "blob",
    DATA: "data",
    RAW_RESPONSE: "rawResponse",
    TYPE: "type",
    BYTES: "bytes",
    FILE: "file",
    FILE_OBJECT: "fileObject",
    UPLOAD_PARAMS: "uploadParams",
    UPDATE_PARAMS: "updateParams",
    DOWNLOAD_PARAMS: "downloadParams",
    DELETE_PARAMS: "deleteParams",
    OPTIONS: "options",
    COMMIT_URL: "commitUrl",
    UPLOAD_TEMPLATE: "upload_template",
    CHUNK_SEQUENCE: "chunk_sequence",
    FILE_NAMESPACE: "file_namespace",
    SECURITY_KEY: "security_key",
    PATCH: "PATCH",
    COMMIT_PROPERTIES: "commit_properties",
    HTTP_RESPONSE: "httpresponse",
    RESPONSE_TYPE: "responseType",
    TAGS: "tags",
    DESCRIPTION: "description",
    REQUEST_CONTEXT: "requestContext",
    USER_INFO: "userInfo",
    // Constants for polling
    POLLING_RETRY_INTERVAL_MILLISECONDS: 1000,
    POLLING_RETRY_ATTEMPTS: 5,
    POLLING_STATUS: "pollingStatus",
    POLLING_SUCCESS_INDICATORS: "pollingSuccessIndicators",
    CURRENT_ITERATION: "currentIteration",
    POLLING_URL: "pollingUrl",
    POLL_API: "poll_api",
    POLL_STATUS: "poll_status",
    HTTP_POLLING_CODE: 202,
    POLLING_TIMEOUT_ERROR_MESSAGE: "Exceeded number of retries, the current operation is taking longer time, status is not available yet",
    //Network constants.
    BODY: "body",
    HTTP_METHOD_GET: "GET",
    HTTP_METHOD_POST: "POST",
    QUERY_PARAMS: "queryParams",
    CONTENT_TYPE: "Content-Type",
    X_KONY_SERVICE_VERSION_VALUE: "2.0",
    APPLICATION_JSON: "application/json",
    X_KONY_API_VERSION: "X-Kony-API-Version",
    X_KONY_AUTHORIZATION: "X-Kony-Authorization",
    X_KONY_REPORTINGPARAMS: "X-Kony-ReportingParams",
    X_HTTP_METHOD_OVERRIDE: "X-Http-Method-Override",
    X_KONY_SERVICE_VERSION: "X-Kony-Service-Version",
    SKIP_MESSAGE_INTEGRITY: "skipMessageIntegrity",
    X_FABRIC_IGNORE_MAPPER_RESPONSE_FILTERING: "X-Fabric-Ignore-Mapper-Response-Filtering",
    APPLICATION_OCTET: "application/octet-stream",
    MULTIPART: "multipart/form-data",
    PARTCONTENT: "partContent",
    PARTNAME: "name"
});
/**
 * Object defining Error constants for file storage.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
kony.sdk.binary.KBErrorConstants = function() {
    function Error(code, message) {
        this.code = code;
        this.message = message;
        this.domain = "FileStorageError";
    }
    var KBErrorConstants = {};
    //------------------------------------------------
    // Error codes for Binary Errors
    //------------------------------------------------
    KBErrorConstants.CODE_INVALID_STATE_FOR_BINARY_OPERATION = new Error("5001", "Binary record is in invalid state to perform the operation.");
    KBErrorConstants.CODE_BINARY_RECORD_DOES_NOT_EXIST = new Error("5004", "Binary record doesn't exist for the given primary keys ");
    KBErrorConstants.CODE_MISSING_SERVER_URL = new Error("6005", "Missing server Url.");
    KBErrorConstants.CODE_HTTP_REQUEST_FAILED = new Error("6003", "Network operation failed. ");
    KBErrorConstants.CODE_UPLOAD_FAILURE = new Error("6006", "Upload error");
    KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER = new Error("6010", "Unable to upload file - Missing parameter");
    KBErrorConstants.CODE_UPLOAD_INVALID_PARAMETER_DATA_TYPE = new Error("6011", "Unable to upload file - Invalid data type of parameter");
    KBErrorConstants.CODE_UPLOAD_INVALID_PARAMETER_VALUE = new Error("6012", "Unable to upload file - Invalid parameter value");
    KBErrorConstants.CODE_DOWNLOAD_MISSING_PARAMETER = new Error("6015", "Unable to download file - Missing parameter");
    KBErrorConstants.CODE_DOWNLOAD_INVALID_PARAMETER_TYPE = new Error("6016", "Unable to download file - Invalid data type of parameter");
    KBErrorConstants.CODE_DOWNLOAD_INVALID_PARAMETER_VALUE = new Error("6017", "Unable to download file - Invalid parameter value");
    KBErrorConstants.CODE_MALFORMED_URL = new Error("6018", "URL is not in proper format");
    KBErrorConstants.CODE_UNEXPECTED_HTTP_RESPONSE_CODE = new Error("6019", "Unexpected HTTP response code during template parsing");
    KBErrorConstants.CODE_DOWNLOAD_FAILURE = new Error("6020", "Unable to download file, please refer exception details");
    KBErrorConstants.CODE_UPDATE_MISSING_PARAMETER = new Error("6021", "Unable to perform update - missing parameter");
    KBErrorConstants.CODE_UPDATE_INVALID_PARAMETER_DATA_TYPE = new Error("6022", "Unable to perform update - Invalid data type of parameter");
    KBErrorConstants.CODE_UPDATE_INVALID_PARAMETER_VALUE = new Error("6023", "Unable to perform update - Invalid parameter value");
    KBErrorConstants.CODE_DELETE_INVALID_PARAMETER = new Error("6027", "Unable to perform Delete - unexpected parameter found");
    KBErrorConstants.CODE_DOWNLOAD_NOT_STARTED_ALREADY_EXISTS_IN_QUEUE = new Error("10002", "File download already in progress");
    KBErrorConstants.CODE_TEMPLATE_PARSING = new Error("10003", "Template Parsing error");
    //------------------------------------------------
    // Error codes for Network Errors - (2030 to 2099)
    //------------------------------------------------
    KBErrorConstants.GENERIC_NETWORK_ERROR = new Error(2030, "An error occurred in the Network Layer.");
    KBErrorConstants.NW_CONNECTION_TIMEOUT_ERROR = new Error(2031, "Unable to connect to host.");
    KBErrorConstants.NW_INVALID_RESPONSE_OBJECT = new Error(2037, "Network response is either null or invalid JSON.");
    KBErrorConstants.NW_INVALID_OPSTATUS_FROM_SERVER = new Error(2038, "Server responded with error opstatus.");
    KBErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE = new Error(2043, "HTTP message integrity check failed.");
    KBErrorConstants.NW_REQUEST_ALREADY_IN_PROGRESS = new Error(2044, "The upload request is already in progress.");
    return KBErrorConstants;
}();
/**
 * Object defining the constants for Binary upload type
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
kony.sdk.binary.FileUploadType = Object.freeze({
    UploadInputTypeLocalFilePath: 0,
    UploadInputTypeRawBytes: 1
});
/**
 * Error object for error handling in Binary.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBError", ["exports"], function(exports) {
    "use strict";
    exports._esModule = true;
    exports.KBError = (function() {
        function KBError(errObj, userInfo) {
            if (errObj) {
                this.code = errObj.code;
                this.message = errObj.message;
            }
            this.userInfo = userInfo;
        }
        return KBError;
    }());
});
/**
 * KBFileStorageManager APIs.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBFileStorageManager", ["exports", "BinaryListTask", "BinaryUploaderTask", "BinaryDownloaderTask", "BinaryUpdaterTask", "BinaryDeleteTask", "BinaryAbortTask", "KBValidationUtils", "KBError", "KBCommonUtils"], function(exports, _BinaryListTask, _BinaryUploaderTask, _BinaryDownloaderTask, _BinaryUpdaterTask, _BinaryDeleteTask, _BinaryAbortTask, ValidationUtils, _KBError, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var LOG_PREFIX = "KBFileStorageManager : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    var KBErrorConstants = kony.sdk.binary.KBErrorConstants;
    var BinaryListTask = _BinaryListTask.BinaryListTask;
    var BinaryDownloaderTask = _BinaryDownloaderTask.BinaryDownloaderTask;
    var BinaryUploaderTask = _BinaryUploaderTask.BinaryUploaderTask;
    var BinaryUpdaterTask = _BinaryUpdaterTask.BinaryUpdaterTask;
    var BinaryDeleteTask = _BinaryDeleteTask.BinaryDeleteTask;
    var binaryLogger = kony.sdk.logsdk;
    var KBError = _KBError.KBError;
    var downloadTaskMap = {};
    var instance = null;
    /**
     * returns instance of KBFileStorageManager.
     * @constructor
     */
    var KBFileStorageManager = function() {};
    /**
     * Internal call to force for single instance creation.
     * @returns {*}
     */
    KBFileStorageManager.getInstance = function() {
        if (instance == null) {
            instance = new KBFileStorageManager();
        }
        return instance;
    };
    /**
     * Returns List of files matching the specified parameters.
     * @param url               URL to be accessed for getting metadata of files
     * @param criteria          Filter string
     * @param headers           Map of headers
     * @param binaryCallback    Callback to be invoked at various stages of the operation being performed
     * @param options           Additional options
     * @returns {Error}
     */
    KBFileStorageManager.prototype.listFiles = function(url, criteria, headers, binaryCallback, options) {
        try {
            //Validating and creating callback.
            binaryCallback = ValidationUtils.validateAndCreateBinaryCallbackIfNotProvided(binaryCallback);
            ValidationUtils.validateUrl(url);
            //Generating input context..
            var inputContext = ValidationUtils.generateCommonInputContext(url, headers, options);
            //Validating criteria.
            if (!ValidationUtils.isNullOrEmptyObject(criteria)) {
                inputContext[BinaryConstants.FILTER] = criteria;
            } else {
                binaryLogger.warn("No criteria is defined..");
            }
            //Binary List task.
            var binaryListTask = new BinaryListTask();
            binaryListTask.setInputContext(inputContext);
            binaryListTask.execute().then(binaryCallback.successCallback).catch(errorObj => {
                binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(errorObj, criteria));
            });
        } catch (e) {
            binaryLogger.error("Unexpected Exceptions", e);
            binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(e, criteria));
        }
    };
    /**
     * Uploads raw data to backend
     * @param url                   URL for uploading file
     * @param uploadInputType       Type of upload operation - rawBytes or localFilePath
     * @param uploadParams          Parameters for performing upload.
     * @param binaryCallback        Callback to be invoked at various stages of the operation being performed.
     * @param options               Additional options
     * @returns {Error}
     */
    KBFileStorageManager.prototype.upload = function(url, uploadInputType, uploadParams, binaryCallback, options) {
        try {
            //Validating and creating callback.
            binaryCallback = ValidationUtils.validateAndCreateBinaryCallbackIfNotProvided(binaryCallback);
            ValidationUtils.validateUrl(url);
            ValidationUtils.validateUploadParams(uploadParams);
            //Generating input context..
            var inputContext = ValidationUtils.generateCommonInputContext(url, uploadParams[BinaryConstants.HEADERS], options);
            inputContext[BinaryConstants.UPLOAD_PARAMS] = uploadParams;
            inputContext[BinaryConstants.SKIP_MESSAGE_INTEGRITY] = ValidationUtils.disableIntegrityCheck(options);
            //BinaryUploaderTask call.
            var binaryUploaderTask = new BinaryUploaderTask();
            binaryUploaderTask.setInputContext(inputContext);
            binaryUploaderTask.execute().then(binaryCallback.successCallback).catch(errorObj => {
                binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(errorObj, uploadParams[BinaryConstants.METADATA]));
            });
        } catch (e) {
            binaryLogger.error("Unexpected Exceptions in upload flow", e);
            binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(e, uploadParams[BinaryConstants.METADATA]));
        }
    };
    /**
     * Downloads a file.
     * @param url                  URL for downloading file
     * @param downloadParams       Parameters for performing download.
     * @param binaryCallback       Callback to be invoked at various stages of the operation being performed.
     * @param options              Additional options.
     * @returns {Error}
     */
    KBFileStorageManager.prototype.download = function(url, downloadParams, binaryCallback, options) {
        try {
            //Validating and creating callback.
            binaryCallback = ValidationUtils.validateAndCreateBinaryCallbackIfNotProvided(binaryCallback);
            ValidationUtils.validateUrl(url);
            ValidationUtils.validateDownloadParams(downloadParams);
            var metadata = downloadParams[BinaryConstants.METADATA];
            var headers = downloadParams[BinaryConstants.HEADERS];
            var fileId = metadata[BinaryConstants.FILE_ID];
            if (!ValidationUtils.isNullOrEmptyObject(downloadTaskMap[fileId])) {
                binaryLogger.error(LOG_PREFIX + "Download for file " + fileId + " is already in progress");
                binaryCallback.failureCallback(new KBError(KBErrorConstants.CODE_DOWNLOAD_NOT_STARTED_ALREADY_EXISTS_IN_QUEUE, "Download for file " + downloadTaskMap[fileId] + " is already in progress"));
            } else {
                var binaryDownloaderTask = new BinaryDownloaderTask();
                //Generating input context..
                var inputContext = ValidationUtils.generateCommonInputContext(url, headers, options);
                inputContext[BinaryConstants.DOWNLOAD_PARAMS] = downloadParams;
                inputContext[BinaryConstants.METADATA] = downloadParams[BinaryConstants.METADATA];
                inputContext[BinaryConstants.FILE_ID] = fileId;
                binaryDownloaderTask.setInputContext(inputContext);
                downloadTaskMap[fileId] = binaryDownloaderTask;

                function onDownloadSuccess(res) {
                    //deleting file id from download task map on success.
                    delete downloadTaskMap[res.fileId];
                    //delete file id from response.
                    delete res.fileId;
                    //send blob object as response.
                    if (!((res[BinaryConstants.RAW_RESPONSE] instanceof File) || (res[BinaryConstants.RAW_RESPONSE] instanceof File))) {
                        res[BinaryConstants.RAW_RESPONSE] = new Blob([res[BinaryConstants.RAW_RESPONSE]]);
                    }
                    res[BinaryConstants.FILE_OBJECT] = res[BinaryConstants.RAW_RESPONSE];
                    delete res[BinaryConstants.RAW_RESPONSE];
                    binaryCallback.successCallback(res);
                }

                function onDownloadFailure(err) {
                    //deleting file id from download task map on failure.
                    delete downloadTaskMap[err.fileId];
                    //delete file id from err obj.
                    delete err.fileId;
                    binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(err, downloadParams[BinaryConstants.METADATA]));
                }
                binaryDownloaderTask.execute().then(onDownloadSuccess, onDownloadFailure);
            }
        } catch (e) {
            binaryLogger.error("Unexpected Exceptions in download flow", e);
            binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(e, downloadParams[BinaryConstants.METADATA]));
        }
    };
    /**
     * Updates metadata of a file.
     * @param url                   URL for performing update
     * @param updateParams          Parameters for performing update.
     * @param binaryCallback        Callback to be invoked at various stages of the operation being performed.
     * @param options               Additional options.
     * @returns {Error}
     */
    KBFileStorageManager.prototype.update = function(url, updateParams, binaryCallback, options) {
        try {
            //Validating and creating callback.
            binaryCallback = ValidationUtils.validateAndCreateBinaryCallbackIfNotProvided(binaryCallback);
            ValidationUtils.validateUrl(url);
            ValidationUtils.validateUpdateParams(updateParams);
            //Generating input context..
            var inputContext = ValidationUtils.generateCommonInputContext(url, updateParams[BinaryConstants.HEADERS], options);
            inputContext[BinaryConstants.METADATA] = updateParams[BinaryConstants.METADATA];
            //Binary Updater Task
            var binaryUpdaterTask = new BinaryUpdaterTask();
            binaryUpdaterTask.setInputContext(inputContext);
            binaryUpdaterTask.execute().then(binaryCallback.successCallback).catch(errorObj => {
                binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(errorObj, updateParams[BinaryConstants.METADATA]));
            });
        } catch (e) {
            binaryLogger.error("Unexpected Exceptions in update flow", e);
            e[BinaryConstants.REQUEST_CONTEXT] = updateParams[BinaryConstants.METADATA];
            binaryCallback.failureCallback(e);
        }
    };
    /**
     * Deletes a file by its ID.
     * @param url                    URL for deleting file
     * @param fileId                 ID of the file to be deleted
     * @param deleteParams           Parameters for performing deletion.
     * @param headers                heeders for delete call.
     * @param binaryCallback         Callback to be invoked at various stages of the operation being performed.
     * @param options                Additional options.
     * @returns {Error}
     */
    KBFileStorageManager.prototype.deleteById = function(url, fileId, deleteParams, headers, binaryCallback, options) {
        try {
            if (kony.sdk.isNullOrUndefined(deleteParams)) {
                deleteParams = {};
            }
            deleteParams[BinaryConstants.FILE_ID] = fileId;
            _delete(url, fileId, deleteParams, headers, binaryCallback, options, true);
        } catch (e) {
            binaryLogger.error("Unexpected Exceptions in deleteByID flow", e);
            binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(e, deleteParams));
        }
    };
    /**
     * Deletes a set of files based on deletion parameters.
     * @param url                    URL for deleting file
     * @param deleteParams           Parameters for performing deletion.
     * @param headers                headers for delete call.
     * @param binaryCallback         Callback to be invoked at various stages of the operation being performed.
     * @param options                Additional options.
     * @returns {Error}
     */
    KBFileStorageManager.prototype.deleteByCriteria = function(url, deleteParams, headers, binaryCallback, options) {
        try {
            _delete(url, null, deleteParams, headers, binaryCallback, options, false);
        } catch (e) {
            binaryLogger.error("Unexpected Exceptions in deleteByCriteria flow", e);
            binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(e, deleteParams));
        }
    };
    /**
     * Utility method for delete by ID and deleteByCriteria.
     * @param url                    URL for deleting file
     * @param fileId                 ID of the file to be deleted
     * @param deleteParams           Parameters for performing deletion.
     * @param headers                heeders for delete call.
     * @param binaryCallback         Callback to be invoked at various stages of the operation being performed.
     * @param options                Additional options.
     * @param isdeleteById           true for deleteByID and false for deleteByCriteria
     * @private
     */
    function _delete(url, fileId, deleteParams, headers, binaryCallback, options, isdeleteById) {
        //Validating and creating callback.
        binaryCallback = ValidationUtils.validateAndCreateBinaryCallbackIfNotProvided(binaryCallback);
        ValidationUtils.validateUrl(url);
        ValidationUtils.validateDeleteParams(deleteParams);
        if (isdeleteById) {
            ValidationUtils.validObjectForNullOREmptyValue(fileId, KBErrorConstants.CODE_DELETE_INVALID_PARAMETER, " Null or empty value found for fileId");
        }
        //Generating input context..
        var inputContext = ValidationUtils.generateCommonInputContext(url, headers, options);
        inputContext[BinaryConstants.DELETE_PARAMS] = deleteParams;
        inputContext[BinaryConstants.FILTER] = KBCommonUtils.createFilterString(deleteParams);
        //Binary Deletion task.
        var binaryDeleteTask = new BinaryDeleteTask();
        binaryDeleteTask.setInputContext(inputContext);
        binaryDeleteTask.execute().then(binaryCallback.successCallback).catch(errorObj => {
            binaryCallback.failureCallback(KBCommonUtils.getformattedResponseWithCommonParameters(errorObj, deleteParams));
        });
    }
    /**
     * Best effort to abort failed operation
     * @param attachmentId           ID of the file to be aborted.
     * @param binaryCallback         Callback to be invoked at various stages of the operation being performed.
     * @returns {Error}
     */
    KBFileStorageManager.prototype.abort = function(attachmentId, binaryCallback) {
        return new Error("Abort operation not implemented");
    };
    exports.getInstance = KBFileStorageManager.getInstance;
});
/**
 * Downloads file from server.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("ChunkFileDownloaderTask", ["exports", "KBValidationUtils", "KBError", "KBResponseParser", "KBNetworkUtils", "KBCommonUtils"], function(exports, ValidationUtils, _KBError, ResponseParser, KBNetworkUtils, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "ChunkFileDownloaderTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    var KBError = _KBError.KBError;
    var KBErrorConstants = kony.sdk.binary.KBErrorConstants;
    /**
     *  Creates ChunkFileDownloaderTask Instance
     * @constructor
     */
    function ChunkFileDownloaderTask() {
        this.inputContext = {};
        this.url = null;
        this.fileName = null;
        this.filter = "";
        this.headers = null;
        this.fileId = null;
    };
    /**
     *
     */
    function unpackInputContext() {
        this.fileId = this.inputContext[BinaryConstants.FILE_ID];
        var records = this.inputContext[BinaryConstants.RECORDS];
        if (ValidationUtils.isNullOrEmptyObject(records)) {
            var errMsg = " File " + this.fileId + " doesn't exists";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_BINARY_RECORD_DOES_NOT_EXIST, errMsg);
        }
        if (records.length > 1) {
            var errMsg = " More than one file exists with file_id: " + this.fileId;
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_INVALID_STATE_FOR_BINARY_OPERATION, errMsg);
        }
        var firstRecord = records[0];
        this.fileName = firstRecord[BinaryConstants.FILE_NAME];
        var downloadTemplate = firstRecord[BinaryConstants.DOWNLOAD_TEMPLATE];
        this.url = ResponseParser.extractFileOperationUrl(downloadTemplate, this.inputContext[BinaryConstants.URL], this.fileId);
        if (this.inputContext[BinaryConstants.FILTER]) {
            this.filter = this.inputContext[BinaryConstants.FILTER];
        }
        if (this.inputContext[BinaryConstants.METADATA]) {
            if (!this.inputContext[BinaryConstants.METADATA][BinaryConstants.TYPE]) {
                this.inputContext[BinaryConstants.METADATA][BinaryConstants.TYPE] = BinaryConstants.BYTES;
            }
            this.filter += KBCommonUtils.createFilterStringFromMetadataAsQueryParams(this.inputContext[BinaryConstants.METADATA]);
            delete this.inputContext[BinaryConstants.METADATA][BinaryConstants.TYPE];
        }
        if (this.inputContext[BinaryConstants.HEADERS]) {
            this.headers = this.inputContext[BinaryConstants.HEADERS];
        }
    };
    /**
     * appends filter to url.
     */
    function appendFilterToUrl() {
        if (this.url.includes("?")) {
            this.url += "&" + this.filter;
        } else {
            this.url += "?" + this.filter;
        }
    }
    /**
     * sets the input context for BinaryDownloaderTask.
     * @param inputContext input context for BinaryDownloaderTask.
     */
    ChunkFileDownloaderTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the ChunkFileDownloaderTask
     * @returns {Promise<void>}
     */
    ChunkFileDownloaderTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        appendFilterToUrl.call(this);
        var options = KBCommonUtils.getNetworkOptions(this.inputContext);
        options[BinaryConstants.RESPONSE_TYPE] = "blob";
        var response = await KBNetworkUtils.get(this.url, null, this.headers, options);
        response.fileId = this.inputContext[BinaryConstants.FILE_ID];
        response[BinaryConstants.FILE_NAME] = this.fileName;
        return response;
    };
    exports.ChunkFileDownloaderTask = ChunkFileDownloaderTask;
});
/**
 * Task to upload file.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("ChunkedFileUploaderTask", ["exports", "KBNetworkUtils", "KBCommonUtils"], function(exports, KBNetworkUtils, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "ChunkedFileUploaderTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates ChunkedFileUploaderTask Instance
     * @constructor
     */
    function ChunkedFileUploaderTask() {
        this.inputContext = {};
        this.url = null;
        this.headers = null;
        this.fileId = null;
        this.fileObject = null;
        this.queryParams = {};
        this.chunkId = "1";
    }
    /**
     * unpacks input context..
     */
    function unpackInputContext() {
        this.url = this.inputContext[BinaryConstants.URL];
        this.headers = this.inputContext[BinaryConstants.HEADERS];
        delete this.headers[BinaryConstants.CONTENT_TYPE];
        this.metadata = this.inputContext[BinaryConstants.UPLOAD_PARAMS][BinaryConstants.METADATA];
        this.fileId = this.inputContext[BinaryConstants.FILE_ID];
        this.metadata[BinaryConstants.FILE_ID] = this.fileId;
        this.options = this.inputContext[BinaryConstants.OPTIONS];
        this.fileObject = this.inputContext[BinaryConstants.UPLOAD_PARAMS][BinaryConstants.FILE_OBJECT];
    }
    /**
     * Generates the query params for current chunk
     */
    function generateQueryParamsForCurrentChunk() {
        this.queryParams[BinaryConstants.FILE_ID] = this.metadata[BinaryConstants.FILE_ID];
        this.queryParams[BinaryConstants.CHUNK_SEQUENCE] = this.chunkId;
        if (this.metadata[BinaryConstants.FILE_NAMESPACE]) {
            this.queryParams[BinaryConstants.FILE_NAMESPACE] = this.metadata[BinaryConstants.FILE_NAMESPACE];
        }
        if (this.metadata[BinaryConstants.SECURITY_KEY]) {
            this.queryParams[BinaryConstants.SECURITY_KEY] = this.metadata[BinaryConstants.SECURITY_KEY];
        }
    }
    /**
     * sets the input context for ChunkedFileUploaderTask.
     * @param inputContext input context for ChunkedFileUploaderTask.
     */
    ChunkedFileUploaderTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the ChunkedFileUploaderTask
     * @returns {Promise<void>}
     */
    ChunkedFileUploaderTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        generateQueryParamsForCurrentChunk.call(this);
        //sending file object provided by user to server in form data.
        var body = new FormData();
        body.append(BinaryConstants.DATA, this.fileObject);
        return (await KBNetworkUtils.post(this.url, this.queryParams, this.headers, body, KBCommonUtils.getNetworkOptions(this.inputContext), "multipart/form-data"));
    };
    exports.ChunkedFileUploaderTask = ChunkedFileUploaderTask;
});
/**
 * Task to create FileMetadataCreatorTaskmetadata for a  file.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("FileMetadataCreatorTask", ["exports", "KBNetworkUtils", "KBCommonUtils"], function(exports, KBNetworkUtils, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "FileMetadataCreatorTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates FileMetadataCreatorTask Instance
     * @constructor
     */
    function FileMetadataCreatorTask() {
        this.inputContext = {};
        this.url = null;
        this.metadata = null;
        this.headers = null;
        this.fileName = null;
    }
    /**
     * unpacks input context..
     */
    function unpackInputContext() {
        this.url = this.inputContext[BinaryConstants.URL] + BinaryConstants.METADATA_URL_SUFFIX;
        var uploadParams = this.inputContext[BinaryConstants.UPLOAD_PARAMS];
        this.headers = uploadParams[BinaryConstants.HEADERS];
        this.headers[BinaryConstants.CONTENT_TYPE] = BinaryConstants.APPLICATION_JSON;
        this.headers[BinaryConstants.X_FABRIC_IGNORE_MAPPER_RESPONSE_FILTERING] = "true";
        this.metadata = uploadParams[BinaryConstants.METADATA];
        this.fileName = this.metadata[BinaryConstants.FILE_NAME];
        this.options = this.inputContext[BinaryConstants.OPTIONS];
    }
    /**
     * sets the input context for FileMetadataCreatorTask.
     * @param inputContext input context for FileMetadataCreatorTask.
     */
    FileMetadataCreatorTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the FileMetadataCreatorTask
     * @returns {Promise<void>}
     */
    FileMetadataCreatorTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        return (await KBNetworkUtils.post(this.url, null, this.headers, this.metadata, KBCommonUtils.getNetworkOptions(this.inputContext)));
    };
    exports.FileMetadataCreatorTask = FileMetadataCreatorTask;
});
/**
 * Task to perform polling and check the status of task
 * Uses exponential backoff mechanism
 * Created by ambuj.kumar@kony.com on 3/12/2019.
 * <p>
 * Design Idea : PollingTask is a looping task which loops multiple times with exponential backoff strategy
 * to poll a specific url and check if desired result is achieved or not.
 * <p>
 * Input context will have pollingUrl, queryParams (if any), headers (if any) and a HashMap<String, Object> pollingSuccessIndicators
 * pollingSuccessIndicators need to be constructed based on server side input.
 * which will have the set of key-vslue pairs to be checked for in the output obtained on doing a HTTP GET on
 * the pollingUrl.
 * <p>
 * ASSUMPTION : HTTP GET on pollingUrl will always return a valid JSON response.
 * The JSON response will be parsed to check whether ALL key-value pairs specified in pollingSuccessIndicators are present and exactly
 * matching or not in the received json response.
 * <p>
 * Keep retrying for a specified hardcoded number of times with exponential backoff intervals between 2 retries.
 * Classical definition of exponential backoff has been implemented.
 * <p>
 * If desired response not received even after timeout elapses, then simply error out with TimeoutException.
 * Created by Ambuj Kumar on 19-03-2019.
 * Copyright  2019 Kony. All rights reserved.
 */
define("PollingTask", ["exports", "KBNetworkUtils", "KBCommonUtils"], function(exports, KBNetworkUtils, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "PollingTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    var _statusCheckerTask = require("StatusCheckerTask");
    /**
     * Creates an instance of PollingTask
     * @constructor
     */
    function PollingTask() {
        this.inputContext = {};
        this.retryIndex = 1;
        this.statusChecker = new _statusCheckerTask.StatusCheckerTask();
    }
    /**
     * sets the input context for PollingTask.
     * @param inputContext input context for PollingTask.
     */
    PollingTask.prototype.setInputContext = function(inputContext) {
            this.inputContext = inputContext;
        }
        /**
         *  Executes the PollingTask
         * @returns {Promise<void>}
         */
    PollingTask.prototype.execute = async function() {
            try {
                this.statusChecker.setInputContext(this.inputContext);
                this.output = null;
                do {
                    this.output = await this.statusChecker.execute();
                    // polling is successful - stop looping
                    if (this.output[BinaryConstants.POLLING_STATUS] === true) {
                        return this.output;
                    }
                    await exponentialBackoffDelay(this.retryIndex);
                    ++this.retryIndex;
                    this.inputContext[BinaryConstants.CURRENT_ITERATION] = this.retryIndex;
                    this.statusChecker.setInputContext(this.inputContext);
                } while (this.retryIndex <= BinaryConstants.POLLING_RETRY_ATTEMPTS);
            } catch (err) {
                binaryLogger.error(LOG_PREFIX + "Unexpected error " + err);
                throw err;
            }
        }
        /**
         * Induce a delay for exponential backoff
         */
    function exponentialBackoffDelay(currentIndex) {
        // Classical definition of exponential backoff
        // For failed attempt number k, select a random integer M in the range
        // 0 to (2^k - 1)
        // Wait for M*T units of time
        // T = BinaryConstants.POLLING_RETRY_INTERVAL_MILLISECONDS
        var multiplier = Math.round((1 << currentIndex) * Math.random());
        return new Promise(resolve => setTimeout(resolve, multiplier * BinaryConstants.POLLING_RETRY_INTERVAL_MILLISECONDS));
    }
    exports.PollingTask = PollingTask;
});
/**
 * Task to hit the polling url and check the status
 * Created by Ambuj Kumar on 19-03-2019.
 * Copyright  2019 Kony. All rights reserved.
 */
define("StatusCheckerTask", ["exports", "KBNetworkUtils", "KBCommonUtils"], function(exports, KBNetworkUtils, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "StatusCheckerTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates an instance of StatusCheckerTask
     * @constructor
     */
    function StatusCheckerTask() {
        this.inputContext = {};
        this.pollingUrl = null;
        this.headers = null;
        this.queryParams = null;
        this.pollingSuccessIndicators = null;
        this.currentIteration = -1;
    }
    /**
     * sets the input context for StatusCheckerTask.
     * @param inputContext input context for StatusCheckerTask.
     */
    StatusCheckerTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     * unpacks input context..
     */
    function unpackInputContext() {
        this.pollingUrl = this.inputContext[BinaryConstants.POLLING_URL];
        this.headers = this.inputContext[BinaryConstants.HEADERS];
        if (this.headers == null) {
            this.headers = {};
        }
        this.headers[BinaryConstants.CONTENT_TYPE] = BinaryConstants.APPLICATION_JSON;
        this.headers[BinaryConstants.X_FABRIC_IGNORE_MAPPER_RESPONSE_FILTERING] = true;
        this.queryParams = this.inputContext[BinaryConstants.QUERY_PARAMS];
        this.pollingSuccessIndicators = this.inputContext[BinaryConstants.POLLING_SUCCESS_INDICATORS];
        if (BinaryConstants.CURRENT_ITERATION in this.inputContext) {
            this.currentIteration = this.inputContext[BinaryConstants.CURRENT_ITERATION];
        } else {
            this.currentIteration = 1;
        }
        this.inputContext.xmlHttpRequestOptions = {};
        this.inputContext.xmlHttpRequestOptions.enableWithCredentials = true;
    };
    /**
     *  Executes the StatusCheckerTask
     * @returns {Promise<void>}
     */
    StatusCheckerTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        var response = await KBNetworkUtils.get(this.pollingUrl, this.queryParams, this.headers, KBCommonUtils.getNetworkOptions(this.inputContext));
        var successfulResponse = true;
        if (this.pollingSuccessIndicators !== null) {
            for (var key in this.pollingSuccessIndicators) {
                if (key in response) {
                    if (response[key] !== this.pollingSuccessIndicators[key]) {
                        successfulResponse = false;
                        break;
                    }
                } else {
                    successfulResponse = false;
                    break;
                }
            }
        }
        var output = {};
        output[BinaryConstants.POLLING_STATUS] = successfulResponse;
        for (var key in response) {
            output[key] = response[key];
        }
        binaryLogger.debug(LOG_PREFIX + "Polling result computed " + successfulResponse);
        if (this.currentIteration === BinaryConstants.POLLING_RETRY_ATTEMPTS) {
            if (!successfulResponse) {
                // last polling and successful status still not seen - hence error
                binaryLogger.error(LOG_PREFIX + BinaryConstants.POLLING_TIMEOUT_ERROR_MESSAGE);
                throw BinaryConstants.POLLING_TIMEOUT_ERROR_MESSAGE;
            }
        }
        return output;
    };
    exports.StatusCheckerTask = StatusCheckerTask;
});
/**
 * Task to commit uploaded file.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("UploadCommitterTask", ["exports", "KBCommonUtils", "KBNetworkUtils"], function(exports, KBCommonUtils, KBNetworkUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "UploadCommitterTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates UploadCommitterTask Instance
     * @constructor
     */
    function UploadCommitterTask() {
        this.inputContext = {};
        this.url = null;
        this.headers = null;
        this.metadata = null;
        this.fileId = null;
    }
    /**
     * unpacks input context..
     */
    function unpackInputContext() {
        this.url = this.inputContext[BinaryConstants.COMMIT_URL] + BinaryConstants.METADATA_URL_SUFFIX;
        var uploadParams = this.inputContext[BinaryConstants.UPLOAD_PARAMS];
        this.headers = this.inputContext[BinaryConstants.HEADERS];
        this.headers[BinaryConstants.X_HTTP_METHOD_OVERRIDE] = BinaryConstants.PATCH;
        this.headers[BinaryConstants.CONTENT_TYPE] = BinaryConstants.APPLICATION_JSON;
        this.metadata = uploadParams[BinaryConstants.METADATA];
        delete this.metadata[BinaryConstants.FILE_NAME];
        if (!this.metadata[BinaryConstants.COMMIT_PROPERTIES]) {
            this.metadata[BinaryConstants.COMMIT_PROPERTIES] = "{}";
        }
    }
    /**
     * sets the input context for UploadCommitterTask.
     * @param inputContext input context for UploadCommitterTask.
     */
    UploadCommitterTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the UploadCommitterTask
     * @returns {Promise<void>}
     */
    UploadCommitterTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        return await KBNetworkUtils.put(this.url, null, this.headers, this.metadata, KBCommonUtils.getNetworkOptions(this.inputContext));
    };
    exports.UploadCommitterTask = UploadCommitterTask;
});
/**
 * Module to Abort file operation.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("BinaryAbortTask", ["exports"], function(exports) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "BinaryAbortTask : ";
    /**
     *  Creates BinaryAbortTask Instance
     * @constructor
     */
    function BinaryAbortTask() {}
    /**
     *  Executes the BinaryAbortTask
     * @returns {Promise<void>}
     */
    BinaryAbortTask.prototype.execute = async function() {
        //Abort file operation.
    };
    exports.BinaryAbortTask = BinaryAbortTask;
});
/**
 * Module to delete file on server.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("BinaryDeleteTask", ["exports", "KBValidationUtils", "KBCommonUtils", "KBNetworkUtils", "KBResponseParser"], function(exports, ValidationUtils, KBCommonUtils, KBNetworkUtils, KBResponseParser) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "BinaryDeleteTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    var _pollingTask = require("PollingTask");
    /**
     *  Creates BinaryDeleteTask Instance
     * @constructor
     */
    function BinaryDeleteTask() {
        this.inputContext = {};
        this.headers = null;
        this.url = null;
        this.filter = null;
        this.queryParams = {};
    }
    /**
     * sets the input context for BinaryDeleteTask.
     * @param inputContext input context for BinaryDeleteTask.
     */
    BinaryDeleteTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     * unpacks input context..
     */
    function unpackInputContext() {
        this.url = this.inputContext[BinaryConstants.URL] + BinaryConstants.METADATA_URL_SUFFIX;
        this.headers = this.inputContext[BinaryConstants.HEADERS];
        if (this.headers == null) {
            this.headers = {};
        }
        this.headers[BinaryConstants.X_FABRIC_IGNORE_MAPPER_RESPONSE_FILTERING] = true;
        if (!ValidationUtils.isNullOrEmptyObject(this.inputContext[BinaryConstants.FILTER])) {
            this.filter = this.inputContext[BinaryConstants.FILTER];
            this.queryParams[BinaryConstants.DOLLAR_FILTER] = this.filter;
        }
        this.inputContext.xmlHttpRequestOptions = {};
        this.inputContext.xmlHttpRequestOptions.enableWithCredentials = true;
    }
    /**
     *  Executes the BinaryDeleteTask
     * @returns {Promise<void>}
     */
    BinaryDeleteTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        var response = await KBNetworkUtils.invokeDeleteRequest(this.url, this.queryParams, this.headers, null, KBCommonUtils.getNetworkOptions(this.inputContext));
        if (response[BinaryConstants.HTTP_STATUS_CODE] == BinaryConstants.HTTP_POLLING_CODE) {
            // Operation taking longer time on fabric server, poll for the result
            var pollingUrl = this.url + "/" + response[BinaryConstants.POLL_API].split("?")[0];
            var queryParamsForPolling = KBResponseParser.extractQueryParams(response[BinaryConstants.POLL_API]);
            var successIndicator = {};
            successIndicator[BinaryConstants.POLL_STATUS] = "false";
            var pollingInputContext = {};
            pollingInputContext[BinaryConstants.POLLING_URL] = pollingUrl;
            pollingInputContext[BinaryConstants.QUERY_PARAMS] = queryParamsForPolling;
            pollingInputContext[BinaryConstants.POLLING_SUCCESS_INDICATORS] = successIndicator;
            pollingInputContext[BinaryConstants.HEADERS] = this.headers;
            var pollingTask = new _pollingTask.PollingTask();
            pollingTask.setInputContext(pollingInputContext);
            var pollingResult = await pollingTask.execute();
            for (var key in pollingResult) {
                response[key] = pollingResult[key];
            }
        }
        return KBCommonUtils.getformattedResponseWithCommonParameters(response, this.inputContext[BinaryConstants.DELETE_PARAMS]);
    };
    exports.BinaryDeleteTask = BinaryDeleteTask;
});
/**
 * Module to download file from server.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("BinaryDownloaderTask", ["exports", "KBValidationUtils", "KBCommonUtils", "BinaryListTask", "ChunkFileDownloaderTask"], function(exports, ValidationUtils, KBCommonUtils, _BinaryListTask, _ChunkFileDownloaderTask) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var BinaryListTask = _BinaryListTask.BinaryListTask;
    var ChunkFileDownloaderTask = _ChunkFileDownloaderTask.ChunkFileDownloaderTask;
    var LOG_PREFIX = "BinaryDownloaderTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates BinaryDownloaderTask Instance
     * @constructor
     */
    function BinaryDownloaderTask() {
        this.inputContext = {};
        this.url = null;
        this.filter = "";
        this.headers = null;
    }
    /**
     * sets the input context for BinaryDownloaderTask.
     * @param inputContext input context for BinaryDownloaderTask.
     */
    BinaryDownloaderTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the BinaryDownloaderTask
     * @returns {Promise<void>}
     */
    BinaryDownloaderTask.prototype.execute = async function() {
        try {
            //Fetch meta data for file.
            var fileMetadataDownloaderTask = new BinaryListTask();
            fileMetadataDownloaderTask.setInputContext(this.inputContext);
            var fileMetaData = await fileMetadataDownloaderTask.execute();
            //Fetches raw bytes for file.
            this.inputContext[BinaryConstants.RECORDS] = fileMetaData[BinaryConstants.RECORDS];
            var chunkFileDownloaderTask = new ChunkFileDownloaderTask();
            chunkFileDownloaderTask.setInputContext(this.inputContext);
            var response = await chunkFileDownloaderTask.execute();
            return KBCommonUtils.getformattedResponseWithCommonParameters(response, this.inputContext[BinaryConstants.DOWNLOAD_PARAMS][BinaryConstants.METADATA]);
        } catch (e) {
            e.fileId = this.inputContext[BinaryConstants.FILE_ID];
            binaryLogger.error("Unexpected Exception in BinaryDownloader Task " + e);
            throw e;
        }
    };
    exports.BinaryDownloaderTask = BinaryDownloaderTask;
});
/**
 * Module to List files uploaded on server.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("BinaryListTask", ["exports", "KBValidationUtils", "KBCommonUtils", "KBNetworkUtils"], function(exports, ValidationUtils, KBCommonUtils, KBNetworkUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var LOG_PREFIX = "BinaryListTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates BinaryListTask Instance
     * @constructor
     */
    function BinaryListTask() {
        this.inputContext = {};
        this.url = null;
        this.headers = null;
        this.filter = "";
        this.queryParams = {};
    }
    /**
     * sets the input context for BinaryListTask.
     * @param inputContext input context for BinaryListTask.
     */
    BinaryListTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     * Unpacks input context to BinaryListTask state.
     */
    function unpackInputContext() {
        this.url = this.inputContext[BinaryConstants.URL] + BinaryConstants.METADATA_URL_SUFFIX;
        if (this.inputContext[BinaryConstants.FILTER]) {
            this.filter = this.inputContext[BinaryConstants.FILTER];
        }
        if (this.inputContext[BinaryConstants.METADATA]) {
            this.filter += KBCommonUtils.createFilterString(this.inputContext[BinaryConstants.METADATA]);
        }
        if (this.inputContext[BinaryConstants.HEADERS]) {
            this.headers = this.inputContext[BinaryConstants.HEADERS];
        }
        this.headers[BinaryConstants.CONTENT_TYPE] = BinaryConstants.APPLICATION_JSON;
        this.queryParams[BinaryConstants.DOLLAR_FILTER] = this.filter;
    };
    /**
     *  Executes the BinaryListTask
     * @returns {Promise<void>}
     */
    BinaryListTask.prototype.execute = async function() {
        try {
            unpackInputContext.call(this);
            var response = await KBNetworkUtils.get(this.url, this.queryParams, this.headers, KBCommonUtils.getNetworkOptions(this.inputContext));
            return KBCommonUtils.getformattedResponseWithCommonParameters(response, this.inputContext[BinaryConstants.FILTER]);
        } catch (e) {
            binaryLogger.error("Unexpected Exception" + e);
            throw e;
        }
    };
    exports.BinaryListTask = BinaryListTask;
});
/**
 * Module to update file on server.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("BinaryUpdaterTask", ["exports", "KBNetworkUtils", "KBCommonUtils"], function(exports, KBNetworkUtils, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "BinaryUpdaterTask : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates BinaryUpdaterTask Instance
     * @constructor
     */
    function BinaryUpdaterTask() {
        this.inputContext = {};
        this.url = null;
        this.metadata = null;
        this.headers = null;
        this.fileId = null;
    }
    /**
     *  Creates BinaryUpdaterTask Instance
     * @constructor
     */
    function unpackInputContext() {
        this.url = this.inputContext[BinaryConstants.URL] + BinaryConstants.METADATA_URL_SUFFIX;
        this.headers = this.inputContext[BinaryConstants.HEADERS];
        this.headers[BinaryConstants.CONTENT_TYPE] = BinaryConstants.APPLICATION_JSON;
        this.metadata = this.inputContext[BinaryConstants.METADATA];
        this.fileId = this.metadata[BinaryConstants.FILE_ID];
    }
    /**
     * sets the input context for BinaryUpdaterTask.
     * @param inputContext input context for BinaryUpdaterTask.
     */
    BinaryUpdaterTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the BinaryUpdaterTask
     * @returns {Promise<void>}
     */
    BinaryUpdaterTask.prototype.execute = async function() {
        unpackInputContext.call(this);
        var response = await KBNetworkUtils.put(this.url, null, this.headers, this.metadata, KBCommonUtils.getNetworkOptions(this.inputContext));
        return KBCommonUtils.getformattedResponseWithCommonParameters(response, this.metadata);
    };
    exports.BinaryUpdaterTask = BinaryUpdaterTask;
});
/**
 * Module to upload file on server.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("BinaryUploaderTask", ["exports", "FileMetadataCreatorTask", "KBResponseParser", "ChunkedFileUploaderTask", "UploadCommitterTask", "KBCommonUtils"], function(exports, _FileMetadataCreatorTask, KBResponseParser, _ChunkedFileUploaderTask, _UploadCommitterTask, KBCommonUtils) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "BinaryUploaderTask : ";
    var FileMetadataCreatorTask = _FileMetadataCreatorTask.FileMetadataCreatorTask;
    var ChunkedFileUploaderTask = _ChunkedFileUploaderTask.ChunkedFileUploaderTask;
    var UploadCommitterTask = _UploadCommitterTask.UploadCommitterTask;
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     *  Creates BinaryUploaderTask Instance
     * @constructor
     */
    function BinaryUploaderTask() {
        this.inputContext = {};
    }
    /**
     * sets the input context for BinaryUploaderTask.
     * @param inputContext input context for BinaryUploaderTask.
     */
    BinaryUploaderTask.prototype.setInputContext = function(inputContext) {
        this.inputContext = inputContext;
    };
    /**
     *  Executes the BinaryUploaderTask
     * @returns {Promise<void>}
     */
    BinaryUploaderTask.prototype.execute = async function() {
        //Creates metadata for file
        var fileMetadataCreatorTask = new FileMetadataCreatorTask();
        fileMetadataCreatorTask.setInputContext(this.inputContext);
        var fileMetaData = await fileMetadataCreatorTask.execute();
        //Preparing input context for ChunkUploader task..
        //Commit URL.
        this.inputContext[BinaryConstants.COMMIT_URL] = this.inputContext[BinaryConstants.URL];
        Object.assign(this.inputContext, fileMetaData);
        var uploadTemplate = fileMetaData[BinaryConstants.UPLOAD_TEMPLATE];
        this.inputContext[BinaryConstants.URL] = KBResponseParser.extractFileOperationUrl(uploadTemplate, this.inputContext[BinaryConstants.URL], fileMetaData[BinaryConstants.FILE_ID]);
        //Upload raw bytes to server.
        var fileUploader = new ChunkedFileUploaderTask();
        fileUploader.setInputContext(this.inputContext);
        var fileuploaded = await fileUploader.execute();
        //Commit uploaded file.
        var fileCommitter = new UploadCommitterTask();
        fileCommitter.setInputContext(this.inputContext);
        var response = (await fileCommitter.execute());
        return KBCommonUtils.getformattedResponseWithCommonParameters(response, this.inputContext[BinaryConstants.UPLOAD_PARAMS][BinaryConstants.METADATA]);
    };
    exports.BinaryUploaderTask = BinaryUploaderTask;
});
/**
 * CommonUtils for Binary SPA.
 * Created by Rakesh Gyanchandani on 28-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBCommonUtils", ["exports"], function(exports) {
    "use strict";
    var LOG_PREFIX = "KBCommonUtils : ";
    var binaryConstants = kony.sdk.binary.KBConstants;
    /**
     * Get Network Options.
     * @param inputContext of type JSON
     * @returns object of type json
     */
    function getNetworkOptions(inputContext) {
        var options = {};
        options[binaryConstants.SKIP_MESSAGE_INTEGRITY] = inputContext[binaryConstants.SKIP_MESSAGE_INTEGRITY];
        if (inputContext["xmlHttpRequestOptions"]) {
            options["xmlHttpRequestOptions"] = inputContext["xmlHttpRequestOptions"];
        }
        return options;
    }
    /**
     * creates valid odata query string from json object.
     * @param metadata
     * @returns {string}
     */
    function createFilterString(map) {
        var filterString = "";
        for (var key in map) {
            if (filterString.length != 0) {
                filterString += " and ";
            }
            filterString += key + " eq '" + map[key] + "'";
        }
        return filterString;
    }
    /**
     *creates valid query string from metadata.
     * @param metadata
     * @returns {string}
     */
    function createFilterStringFromMetadataAsQueryParams(metadata) {
        var filterString = "";
        for (var key in metadata) {
            if (filterString.length != 0) {
                filterString += "&";
            }
            filterString += key + "=" + metadata[key];
        }
        return filterString;
    }
    /**
     * append suffix to url.
     * @param url       url for binary
     * @param suffix    url to suffix.
     * @returns {*}
     */
    function appendSuffixtoUrl(url, suffix) {
        var result = url;
        if (url.includes("?")) {
            result += "&" + suffix;
        } else {
            result += "?" + suffix;
        }
        return result;
    }
    /**
     * formatting response like deleting headers and appending common info to response
     * @param response        response from server
     * @param requestParams   request inputs
     * @returns {json}        response from server with request params
     */
    function getformattedResponseWithCommonParameters(response, requestParams) {
        //Using kony.net.HttpRequest also provides headers in httpresponse as header could contain sensitive information,
        // therefore removing headers from response
        if (response[binaryConstants.HTTP_RESPONSE]) {
            delete response[binaryConstants.HTTP_RESPONSE];
        }
        if (response[binaryConstants.USER_INFO] && response[binaryConstants.USER_INFO][binaryConstants.HTTP_RESPONSE]) {
            delete response[binaryConstants.USER_INFO][binaryConstants.HTTP_RESPONSE];
        }
        response[binaryConstants.REQUEST_CONTEXT] = requestParams;
        return response;
    }
    exports.getNetworkOptions = getNetworkOptions;
    exports.createFilterString = createFilterString;
    exports.createFilterStringFromMetadataAsQueryParams = createFilterStringFromMetadataAsQueryParams;
    exports.appendSuffixtoUrl = appendSuffixtoUrl;
    exports.getformattedResponseWithCommonParameters = getformattedResponseWithCommonParameters;
});
/**
 * Network wrapper for Binary SPA.
 * Created by Rakesh Gyanchandani on 27-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBNetworkUtils", ["exports", "KBError", "KBValidationUtils"], function(exports, _KBError, ValidationUtils) {
    "use strict";
    exports._esModule = true;
    var binaryLogger = kony.sdk.logsdk;
    var KBError = _KBError.KBError;
    var LOG_PREFIX = "KSBNetworkUtils : ";
    var networkProvider = new konyNetworkProvider();
    var KSErrorConstants = kony.sdk.binary.KBErrorConstants;
    var BinaryConstants = kony.sdk.binary.KBConstants;
    /**
     * Method to make GET calls to the server.
     * @param {string} syncServerAddress URL from where the download should occur.
     * @param {Object} queryParams JSON object containing URL query parameters, if any.
     * @param {Object} headers JSON object containing the headers to be sent.
     * @param {Object} options JSON object containing options to make the call.
     */
    var get = function(syncServerAddress, queryParams, headers, options) {
        //Adding queryParams in options
        options[kony.sdk.constants.QUERY_PARAMS] = queryParams;
        var networkPromise = new Promise(function(resolve, reject) {
            var networkSuccessCallback = function(response) {
                binaryLogger.debug(LOG_PREFIX + "Response body of network call : " + JSON.stringify(response));
                if (ValidationUtils.isNullOrEmptyObject(response) || kony.sdk.isNullOrUndefined(response[BinaryConstants.OP_STATUS]) || !ValidationUtils.isValidOpStatus(response[BinaryConstants.OP_STATUS])) {
                    reject(KSErrorConstants.CODE_HTTP_REQUEST_FAILED);
                }
                resolve(response);
            };
            var networkFailureCallback = function(errorObj) {
                var error;
                if (errorObj.errcode === kony.sdk.errorcodes.invalid_json_code) {
                    error = new KBError(KSErrorConstants.NW_INVALID_RESPONSE_OBJECT, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.connectivity_error_code) {
                    error = new KBError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.integrity_check_failed) {
                    error = new KBError(KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE, errorObj);
                } else {
                    error = new KBError(KSErrorConstants.GENERIC_NETWORK_ERROR, errorObj);
                }
                reject(error);
            };
            binaryLogger.debug(LOG_PREFIX + "URL : " + syncServerAddress);
            //Sending null for params and konyContentType for the GET call..
            networkProvider.get(syncServerAddress, null, headers, networkSuccessCallback, networkFailureCallback, null, options);
        });
        return networkPromise;
    };
    /**
     * Method to make POST calls to the server.
     * @param {string} syncServerAddress URL from where the download should occur.
     * @param {Object} queryParams JSON object containing URL query parameters, if any.
     * @param {Object} headers JSON object containing the headers to be sent.
     * @param {Object} body JSON object containing the body to be posted to the server.
     * @param {Object} options JSON object containing options to make the call.
     */
    var post = function(syncServerAddress, queryParams, headers, body, options, konyContentType) {
        //Check and add empty object..
        if (kony.sdk.isNullOrUndefined(body)) {
            body = {};
        }
        //Adding queryParams in options
        options[kony.sdk.constants.QUERY_PARAMS] = queryParams;
        var networkPromise = new Promise(function(resolve, reject) {
            function networkSuccessCallback(response) {
                binaryLogger.debug(LOG_PREFIX + "Response body of network call : " + JSON.stringify(response));
                if (ValidationUtils.isNullOrEmptyObject(response)) {
                    reject(KSErrorConstants.CODE_HTTP_REQUEST_FAILED);
                } else if (typeof(response) === "string") {
                    response = JSON.parse(response);
                }
                if (kony.sdk.isNullOrUndefined(response[BinaryConstants.OP_STATUS]) || !ValidationUtils.isValidOpStatus(response[BinaryConstants.OP_STATUS])) {
                    reject(KSErrorConstants.CODE_HTTP_REQUEST_FAILED);
                }
                resolve(response);
            }

            function networkFailureCallback(errorObj) {
                var error;
                if (errorObj.errcode === kony.sdk.errorcodes.invalid_json_code) {
                    error = new KBError(KSErrorConstants.NW_INVALID_RESPONSE_OBJECT, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.connectivity_error_code) {
                    error = new KBError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.integrity_check_failed) {
                    error = new KBError(KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE, errorObj);
                } else {
                    error = new KBError(KSErrorConstants.GENERIC_NETWORK_ERROR, errorObj);
                }
                reject(error);
            }
            binaryLogger.debug(LOG_PREFIX + "URL : " + syncServerAddress);
            //Sending 'application/json' as konyContentType to the network layer by default..
            if (!konyContentType || konyContentType === BinaryConstants.APPLICATION_JSON) {
                konyContentType = BinaryConstants.APPLICATION_JSON;
                networkProvider.post(syncServerAddress, body, headers, networkSuccessCallback, networkFailureCallback, konyContentType, options);
            } else {
                networkHandler(syncServerAddress, "POST", headers, body, networkSuccessCallback, networkFailureCallback, options);
            }
        });
        return networkPromise;
    };
    /**
     * Method to make PUT calls to the server.
     * @param {string} syncServerAddress URL from where the download should occur.
     * @param {Object} queryParams JSON object containing URL query parameters, if any.
     * @param {Object} headers JSON object containing the headers to be sent.
     * @param {Object} body JSON object containing the body to be posted to the server.
     * @param {Object} options JSON object containing options to make the call.
     */
    var put = function(syncServerAddress, queryParams, headers, body, options) {
        //Check and add empty object..
        if (kony.sdk.isNullOrUndefined(body)) {
            body = {};
        }
        var networkPromise = new Promise(function(resolve, reject) {
            function networkSuccessCallback(response) {
                binaryLogger.debug(LOG_PREFIX + "Response body of network call : " + JSON.stringify(response));
                if (ValidationUtils.isNullOrEmptyObject(response) || kony.sdk.isNullOrUndefined(response[BinaryConstants.OP_STATUS]) || !ValidationUtils.isValidOpStatus(response[BinaryConstants.OP_STATUS])) {
                    reject(KSErrorConstants.CODE_HTTP_REQUEST_FAILED);
                }
                resolve(response);
            }

            function networkFailureCallback(errorObj) {
                var error;
                if (errorObj.errcode === kony.sdk.errorcodes.invalid_json_code) {
                    error = new KBError(KSErrorConstants.NW_INVALID_RESPONSE_OBJECT, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.connectivity_error_code) {
                    error = new KBError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.integrity_check_failed) {
                    error = new KBError(KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE, errorObj);
                } else {
                    error = new KBError(KSErrorConstants.GENERIC_NETWORK_ERROR, errorObj);
                }
                reject(error);
            }
            binaryLogger.debug(LOG_PREFIX + "URL : " + syncServerAddress);
            //Sending 'application/json' as konyContentType to the network layer by default..
            networkProvider.put(syncServerAddress, body, headers, networkSuccessCallback, networkFailureCallback, "application/json", options);
        });
        return networkPromise;
    };
    /**
     * Method to make Delete calls to the server.
     * @param {string} syncServerAddress URL from where the download should occur.
     * @param {Object} queryParams JSON object containing URL query parameters, if any.
     * @param {Object} headers JSON object containing the headers to be sent.
     * @param {Object} body JSON object containing the body to be posted to the server.
     * @param {Object} options JSON object containing options to make the call.
     */
    var invokeDeleteRequest = function(syncServerAddress, queryParams, headers, body, options) {
        //Check and add empty object..
        if (kony.sdk.isNullOrUndefined(body)) {
            body = {};
        }
        //Adding queryParams in options
        options[kony.sdk.constants.QUERY_PARAMS] = queryParams;
        var networkPromise = new Promise(function(resolve, reject) {
            function networkSuccessCallback(response) {
                binaryLogger.debug(LOG_PREFIX + "Response body of network call : " + JSON.stringify(response));
                if (ValidationUtils.isNullOrEmptyObject(response) || kony.sdk.isNullOrUndefined(response[BinaryConstants.OP_STATUS]) || !ValidationUtils.isValidOpStatus(response[BinaryConstants.OP_STATUS])) {
                    reject(KSErrorConstants.CODE_HTTP_REQUEST_FAILED);
                }
                resolve(response);
            }

            function networkFailureCallback(errorObj) {
                var error;
                if (errorObj.errcode === kony.sdk.errorcodes.invalid_json_code) {
                    error = new KBError(KSErrorConstants.NW_INVALID_RESPONSE_OBJECT, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.connectivity_error_code) {
                    error = new KBError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.integrity_check_failed) {
                    error = new KBError(KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE, errorObj);
                } else {
                    error = new KBError(KSErrorConstants.GENERIC_NETWORK_ERROR, errorObj);
                }
                reject(error);
            }
            binaryLogger.debug(LOG_PREFIX + "URL : " + syncServerAddress);
            //Sending 'application/json' as konyContentType to the network layer by default..
            networkProvider.invokeDeleteRequest(syncServerAddress, body, headers, networkSuccessCallback, networkFailureCallback, "application/json", options);
        });
        return networkPromise;
    };
    var networkHandler = function(requestUrl, method, headers, requestBody, successCallback, failureCallback, options) {
        var xmlHttpRequest = new XMLHttpRequest();
        var successCB = successCallback;
        var failureCB = failureCallback;
        if (options && options["queryParams"] && options["queryParams"] instanceof Object) {
            requestUrl = addQueryParamsToURL(requestUrl, options["queryParams"]);
        }
        if (BinaryConstants.HTTP_METHOD_GET === method) {
            xmlHttpRequest.open(BinaryConstants.HTTP_METHOD_GET, requestUrl, true);
            xmlHttpRequest.responseType = BinaryConstants.BLOB;
        } else {
            // The responseType for the post request will be undefined hence default, which is "text" will be considered
            xmlHttpRequest.open(BinaryConstants.HTTP_METHOD_POST, requestUrl, true);
        }
        for (var header in headers) {
            if (headers.hasOwnProperty(header)) {
                xmlHttpRequest.setRequestHeader(header, headers[header]);
            }
        }

        function localRequestCallback() {
            var readyState = 0;
            var response = "";
            var status = xmlHttpRequest.status;
            switch (xmlHttpRequest.readyState) {
                case 0: // UNINITIALIZED
                case 1: // LOADING
                case 2: // LOADED
                case 3: // INTERACTIVE
                    readyState = xmlHttpRequest.readyState;
                    response = "";
                    break;
                case 4: // COMPLETED
                    readyState = xmlHttpRequest.readyState;
                    //Not using hasOwnProperty because its not available on browser generated objects like XMLHTTPRequest
                    if (xmlHttpRequest.response) {
                        response = xmlHttpRequest.response;
                    } else if (xmlHttpRequest.responseText) {
                        response = xmlHttpRequest.responseText;
                    }
                    if (status >= 200 && status <= 300) {
                        kony.sdk.verifyAndCallClosure(successCB, response);
                    } else {
                        kony.sdk.verifyAndCallClosure(failureCB, response);
                    }
                    break;
                default:
                    kony.sdk.logsdk.error("Unknown Error : XMLHttpRequest Error");
            }
        }
        xmlHttpRequest.onreadystatechange = localRequestCallback;
        xmlHttpRequest.send(requestBody);
        /**
         * copied from spa_offlineobjects/KSUtils/KSNetworkUtils.js
         * Method to add the query parameters after URI encoding to the URL.
         * @param {string} url URL to which the query params are to be appended.
         * @param {Object} queryParams JSON object containing the query parameters.
         */
        function addQueryParamsToURL(url, queryParams) {
            if (queryParams && Object.keys(queryParams).length > 0) {
                var encodedQueryParams = "";
                var ampersandSubstring = "&";
                for (var key in queryParams) {
                    encodedQueryParams += key + "=" + encodeURIComponent(queryParams[key]) + ampersandSubstring;
                }
                //Remove the trailing ampersand for the last key-value pair..
                encodedQueryParams = encodedQueryParams.slice(0, -1);
                //Check if the URL has query params already..
                if (url.indexOf('?') > -1) {
                    url += "&" + encodedQueryParams;
                } else {
                    url += "?" + encodedQueryParams;
                }
            }
            return url;
        }
    };
    exports.get = get;
    exports.post = post;
    exports.put = put;
    exports.invokeDeleteRequest = invokeDeleteRequest;
});
/**
 * Response Parser for Binary SPA.
 * Created by Rakesh Gyanchandani on 28-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBResponseParser", ["exports", "KBValidationUtils", "KBError"], function(exports, ValidationUtils, _KBError) {
    "use strict";
    var LOG_PREFIX = "KBResponseParser : ";
    var BinaryConstants = kony.sdk.binary.KBConstants;
    var KBErrorConstants = kony.sdk.binary.KBErrorConstants;
    var KBError = _KBError.KBError;
    var binaryLogger = kony.sdk.logsdk;
    /**
     * extract url from template.
     * @param template               template map
     * @param currentServiceUrl      current url
     * @param fileId                 file id to be downloaded.
     * @returns {*}
     */
    function extractFileOperationUrl(template, currentServiceUrl, fileId) {
        if (ValidationUtils.isNullOrEmptyObject(template)) {
            var errMsg = "download/upload template is either null or empty";
            binaryLogger.error(errMsg);
            throw new KBError(KBErrorConstants.CODE_TEMPLATE_PARSING, errMsg);
        }
        var map = JSON.parse(template);
        var relativePath = map[BinaryConstants.RELATIVE_PATH];
        var baseUrl = extractBaseServiceUrl(currentServiceUrl);
        if (ValidationUtils.isNullOrEmptyObject(baseUrl)) {
            var errMsg = "Malformed URL.";
            binaryLogger.error(errMsg);
            throw new KBError(KBErrorConstants.CODE_MALFORMED_URL, errMsg);
        }
        return (baseUrl + relativePath);
    }
    /**
     * extract base service url.
     * @param url        url of the file to be downloaded.
     * @returns {*}
     */
    function extractBaseServiceUrl(url) {
        var serviceIndex = url.indexOf(BinaryConstants.SERVICES);
        if (serviceIndex >= 0) {
            return url.substring(0, serviceIndex) + BinaryConstants.SERVICES;
        } else {
            return null;
        }
    }
    /**
     * Extracts the query Params from a url fragment string
     * @param url URL fragment to be parsed
     */
    function extractQueryParams(url) {
        var queryParams = {};
        var fragment = url.split("?")[1];
        if (fragment) {
            var parts = fragment.split("&");
            var arrayLength = parts.length;
            for (var i = 0; i < arrayLength; i++) {
                var splitParts = parts[i].split(/=(.+)/);
                queryParams[splitParts[0]] = splitParts[1];
            }
        }
        return queryParams;
    }
    exports.extractFileOperationUrl = extractFileOperationUrl;
    exports.extractBaseServiceUrl = extractBaseServiceUrl;
    exports.extractQueryParams = extractQueryParams;
});
/**
 * Validation Utils for Binary SPA.
 * Created by Rakesh Gyanchandani on 28-12-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KBValidationUtils", ["exports", "KBError", "KBCallbacks"], function(exports, _KBError, _KBCallbacks) {
    var LOG_PREFIX = "KBValidationUtils : ";
    var KBError = _KBError.KBError;
    var KBErrorConstants = kony.sdk.binary.KBErrorConstants;
    var BinaryConstants = kony.sdk.binary.KBConstants;
    var BinaryCallbacks = _KBCallbacks.KBCallbacks;
    var binaryLogger = kony.sdk.logsdk;
    var fileUploadType = kony.sdk.binary.FileUploadType;
    /**
     * isNullOrEmptyObject - checks of the object is null/undefined or empty
     * @param object of type boolean/string/JSON
     * @returns {boolean}
     */
    function isNullOrEmptyObject(object) {
        return (kony.sdk.isNullOrUndefined(object) || kony.sdk.isEmptyObject(object));
    }
    /**
     * Validates URL.
     * @param url URL to be validated.
     * @returns {boolean}
     */
    function validateUrl(url) {
        var pattern = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$/;
        if (!pattern.test(url)) {
            var errorMsg = "Invalid url provided.";
            binaryLogger.error(LOG_PREFIX, errorMsg);
            throw new KBError(KBErrorConstants.CODE_MISSING_SERVER_URL, errorMsg);
        }
        return true;
    }
    /**
     * Returns the value for disable integrity key.
     * @param options option containing disable integrity key.
     * @returns {boolean}
     */
    function disableIntegrityCheck(options) {
        var result = true;
        if (options != null && options[BinaryConstants.SKIP_MESSAGE_INTEGRITY]) {
            if (options[BinaryConstants.SKIP_MESSAGE_INTEGRITY] instanceof Boolean) {
                result = options[BinaryConstants.SKIP_MESSAGE_INTEGRITY];
            } else if (options[BinaryConstants.SKIP_MESSAGE_INTEGRITY] instanceof String) {
                if (options[BinaryConstants.SKIP_MESSAGE_INTEGRITY].toLowerCase() == 'false') {
                    result = false;
                } else {
                    result = true;
                }
            }
        }
        return result;
    }
    /**
     * Validate and create binary callbacks.
     * @param binaryCallback
     * @returns {*}
     */
    function validateAndCreateBinaryCallbackIfNotProvided(binaryCallback) {
        if (binaryCallback == null) {
            binaryLogger.warn("Binary Callbacks are null.");
            binaryCallback = new BinaryCallbacks();
        } else if (!binaryCallback.successCallback || !binaryCallback.failureCallback) {
            binaryLogger.warn((binaryCallback.successCallback ? "failureCallback" : "successCallback") + " is null.");
            binaryCallback = new BinaryCallbacks(binaryCallback.successCallback, binaryCallback.failureCallback);
        }
        return binaryCallback;
    }
    /**
     * Validates opstatus
     * @param opstatus
     * @returns {boolean}
     */
    function isValidOpStatus(opstatus) {
        return (opstatus == 0);
    }
    /**
     * Validates download parameters.
     * @param downloadParams
     */
    function validateDownloadParams(downloadParams) {
        if (isNullOrEmptyObject(downloadParams)) {
            var errMsg = " Null or empty value found for downloadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DOWNLOAD_INVALID_PARAMETER_VALUE, errMsg);
        }
        if (isNullOrEmptyObject(downloadParams[BinaryConstants.HEADERS])) {
            var errMsg = " Missing parameters " + BinaryConstants.HEADERS + " in downloadparams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DOWNLOAD_MISSING_PARAMETER, errMsg);
        }
        var value = downloadParams[BinaryConstants.HEADERS];
        if (typeof(value) !== "object") {
            var errMsg = " Datatype not of type JSON for " + BinaryConstants.HEADERS + " in downloadparams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DOWNLOAD_INVALID_PARAMETER_TYPE, errMsg);
        }
        if (isNullOrEmptyObject(downloadParams[BinaryConstants.METADATA])) {
            var errMsg = " Missing parameters " + BinaryConstants.METADATA + " in downloadparams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DOWNLOAD_MISSING_PARAMETER, errMsg);
        }
        value = downloadParams[BinaryConstants.METADATA];
        if (typeof(value) !== "object") {
            var errMsg = " Datatype not of type JSON for " + BinaryConstants.METADATA + " in downloadparams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DOWNLOAD_INVALID_PARAMETER_TYPE, errMsg);
        }
        if (isNullOrEmptyObject(value[BinaryConstants.FILE_ID])) {
            var errMsg = " Missing parameters " + BinaryConstants.FILE_ID + " in " + BinaryConstants.METADATA;
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DOWNLOAD_MISSING_PARAMETER, errMsg);
        }
    }
    /**
     * Validates upload parameters.
     * @param uploadParams
     */
    function validateUploadParams(uploadParams) {
        if (isNullOrEmptyObject(uploadParams)) {
            var errMsg = " Null or empty value found for uploadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_INVALID_PARAMETER_VALUE, errMsg);
        }
        if (isNullOrEmptyObject(uploadParams[BinaryConstants.HEADERS])) {
            var errMsg = " Missing parameters " + BinaryConstants.HEADERS + " in uploadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER, errMsg);
        }
        var value = uploadParams[BinaryConstants.HEADERS];
        if (typeof(value) !== "object") {
            var errMsg = " Datatype not of type JSON for " + BinaryConstants.HEADERS + " in uploadparams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_INVALID_PARAMETER_DATA_TYPE, errMsg);
        }
        if (isNullOrEmptyObject(uploadParams[BinaryConstants.METADATA])) {
            var errMsg = " Missing parameters " + BinaryConstants.METADATA + " in uploadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER, errMsg);
        }
        value = uploadParams[BinaryConstants.METADATA];
        if (typeof(value) !== "object") {
            var errMsg = " Datatype not of type JSON for " + BinaryConstants.METADATA + " in uploadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_INVALID_PARAMETER_DATA_TYPE, errMsg);
        }
        if (isNullOrEmptyObject(value[BinaryConstants.FILE_NAME])) {
            var errMsg = " Missing parameters " + BinaryConstants.FILE_NAME + " in " + BinaryConstants.METADATA;
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER, errMsg);
        }
        if (isNullOrEmptyObject(uploadParams[BinaryConstants.FILE_OBJECT])) {
            var errMsg = " Missing parameters " + BinaryConstants.FILE_OBJECT + " in uploadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER, errMsg);
        }
        //Validation of whether fileObject is an instance of File/Blob.
        if (!((uploadParams[BinaryConstants.FILE_OBJECT] instanceof File) || (uploadParams[BinaryConstants.FILE_OBJECT] instanceof Blob))) {
            var errMsg = " Parameters " + BinaryConstants.FILE_OBJECT + " not of type file or blob in uploadParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER, errMsg);
        }
    }
    /**
     * Validates update parameters.
     * @param updateParams
     */
    function validateUpdateParams(updateParams) {
        if (isNullOrEmptyObject(updateParams)) {
            var errMsg = " Null or empty value found for updateParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPDATE_INVALID_PARAMETER_VALUE, errMsg);
        }
        if (isNullOrEmptyObject(updateParams[BinaryConstants.HEADERS])) {
            var errMsg = " Missing parameters " + BinaryConstants.HEADERS + " in updateParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPDATE_MISSING_PARAMETER, errMsg);
        }
        var value = updateParams[BinaryConstants.HEADERS];
        if (typeof(value) !== "object") {
            var errMsg = " Datatype not of type JSON for " + BinaryConstants.HEADERS + " in updateParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_INVALID_PARAMETER_DATA_TYPE, errMsg);
        }
        if (isNullOrEmptyObject(updateParams[BinaryConstants.METADATA])) {
            var errMsg = " Missing parameters " + BinaryConstants.METADATA + " in updateParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPDATE_MISSING_PARAMETER, errMsg);
        }
        value = updateParams[BinaryConstants.METADATA];
        if (typeof(value) !== "object") {
            var errMsg = " Datatype not of type JSON for " + BinaryConstants.METADATA + " in updateParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPDATE_INVALID_PARAMETER_DATA_TYPE, errMsg);
        }
        if (isNullOrEmptyObject(value[BinaryConstants.FILE_ID])) {
            var errMsg = " Missing parameters " + BinaryConstants.FILE_ID + " in " + BinaryConstants.METADATA;
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_UPLOAD_MISSING_PARAMETER, errMsg);
        }
    }
    /**
     * Validates delete parameters.
     * @param deleteParams
     */
    function validateDeleteParams(deleteParams) {
        if (isNullOrEmptyObject(deleteParams)) {
            var errMsg = " Null or empty value found for deleteParams";
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(KBErrorConstants.CODE_DELETE_INVALID_PARAMETER, errMsg);
        }
    }
    /**
     * validates object for null or empty value.
     * @param value         value to validate..
     * @param errObj        error object to throw in case of null or empty.
     * @param errMsg        error message to log if validation failed.
     */
    function validObjectForNullOREmptyValue(value, errObj, errMsg) {
        if (isNullOrEmptyObject(value)) {
            binaryLogger.error(LOG_PREFIX + errMsg);
            throw new KBError(errObj, errMsg);
        }
    }
    /**
     * generates common params for input context.
     * @param url          url for Binary APIs.
     * @param headers      header for Binary APIs.
     * @param options      options for Binary APIs
     */
    function generateCommonInputContext(url, headers, options) {
        var inputContext = {};
        inputContext[BinaryConstants.URL] = url;
        if (!isNullOrEmptyObject(options)) {
            inputContext[BinaryConstants.OPTIONS] = options;
        } else {
            binaryLogger.warn("No options are defined.");
        }
        if (!isNullOrEmptyObject(headers)) {
            inputContext[BinaryConstants.HEADERS] = headers;
        } else {
            binaryLogger.warn("Headers is not defined");
        }
        inputContext[BinaryConstants.SKIP_MESSAGE_INTEGRITY] = disableIntegrityCheck(options);
        return inputContext;
    }
    exports.isNullOrEmptyObject = isNullOrEmptyObject;
    exports.validateUrl = validateUrl;
    exports.disableIntegrityCheck = disableIntegrityCheck;
    exports.validateAndCreateBinaryCallbackIfNotProvided = validateAndCreateBinaryCallbackIfNotProvided;
    exports.isValidOpStatus = isValidOpStatus;
    exports.validateDownloadParams = validateDownloadParams;
    exports.validateUploadParams = validateUploadParams;
    exports.validateUpdateParams = validateUpdateParams;
    exports.validateDeleteParams = validateDeleteParams;
    exports.validObjectForNullOREmptyValue = validObjectForNullOREmptyValue;
    exports.generateCommonInputContext = generateCommonInputContext;
});
define("SPAFileStorage", ["KBFileStorageManager", "KBCallbacks"], function(_KBFileStorageManager, _KBCallbacks) {
    var BinaryCallbacks = _KBCallbacks.KBCallbacks;
    kony.sdk.FileStorageClasses.listFiles = function(url, criteria, headers, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().listFiles(url, criteria, headers, new BinaryCallbacks(successCallback, failureCallback), options);
    };
    kony.sdk.FileStorageClasses.upload = function(url, uploadInputType, uploadParams, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().upload(url, uploadInputType, uploadParams, new BinaryCallbacks(successCallback, failureCallback), options);
    };
    kony.sdk.FileStorageClasses.download = function(url, downloadParams, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().download(url, downloadParams, new BinaryCallbacks(successCallback, failureCallback), options);
    };
    kony.sdk.FileStorageClasses.update = function(url, updateParams, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().update(url, updateParams, new BinaryCallbacks(successCallback, failureCallback), options);
    };
    kony.sdk.FileStorageClasses.deleteById = function(url, fileId, deleteParams, headers, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().deleteById(url, fileId, deleteParams, headers, new BinaryCallbacks(successCallback, failureCallback), options);
    };
    kony.sdk.FileStorageClasses.deleteByCriteria = function(url, deleteParams, headers, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().deleteByCriteria(url, deleteParams, headers, new BinaryCallbacks(successCallback, failureCallback), options);
    };
    kony.sdk.FileStorageClasses.abort = function(url, fileId, abortParams, headers, successCallback, failureCallback, options) {
        _KBFileStorageManager.getInstance().deleteById(url, fileId, abortParams, headers, new BinaryCallbacks(successCallback, failureCallback), options);
    };
});
require(["SPAFileStorage"]);
/**
 * kony-spa-offlineobjects version 8.4.20
 * This file is intended for desktopWeb/SPA only.
 */
if (typeof(kony) === "undefined") {
    kony = {};
}
if (typeof(kony.sdk) === "undefined") {
    kony.sdk = {};
}
if (typeof(kony.sdk.OfflineObjects) === "undefined") {
    kony.sdk.OfflineObjects = {};
}
if (typeof(kony.sdk.KNYObj) === "undefined") {
    kony.sdk.KNYObj = {};
}
if (typeof(kony.sdk.KNYObjSvc) === "undefined") {
    kony.sdk.KNYObjSvc = {};
}
var __extends = (this && this.__extends) || (function() {
    var extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }
        instanceof Array && function(d, b) {
            d.__proto__ = b;
        }) || function(d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return function(d, b) {
        extendStatics(d, b);

        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Object defining the constants for CRUD operations.
 * Created by Prasanthi Bonam on 29-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
kony.sdk.OfflineObjects.KSCriteria = Object.freeze({
    PRIMARY_KEYS: 0,
    WHERE_CONDITION_AS_A_MAP: 1,
    WHERE_CONDITION_AS_A_STRING: 2,
    NONE: 3
});
kony.sdk.OfflineObjects.KSCRUDConstants = {
    CRUD_OPTION_CRITERIA: "criteria",
    CRUD_OPTION_IS_UPDATE_BY_PK: "isUpdateByPK",
    CRUD_OPTION_IS_DELETE_BY_PK: "isDeleteByPK",
    CRUD_OPTION_SKIP_VALIDATION: "skipValidation",
    COLLATE_NOCASE: "COLLATE NOCASE",
    DEFAULT_VALUE_FOR_TRACK_CHANGES: true,
    DEFAULT_VALUE_FOR_TRACK_INTERMEDIATE_UPDATES: true
};
kony.sdk.OfflineObjects.KSDBSchemaVersion = Object.freeze({
    Version_None: 0,
    Version_Default: 1,
    Version_2: 2,
    /* 8.4 release */
});
kony.sdk.OfflineObjects.KSDatabaseConstants = Object.freeze({
    //----------------------------------------------
    // DataTypes
    //----------------------------------------------
    KSDataTypes: {
        "NUMBER": 'number',
        "STRING": 'string',
        "BOOLEAN": 'boolean',
        "DATE": 'date',
        "BINARY": 'binary'
    },
    //----------------------------------------------
    // DatabaseOperations Code
    //----------------------------------------------
    KSDatabaseOperations: {
        "INSERT": 1,
        "INSERT_OR_REPLACE": 2,
        "UPDATE": 3,
        "SELECT": 4,
        "DELETE": 5
    },
    //----------------------------------------------
    // kony fields
    //----------------------------------------------
    KONY_SYNC_HASH_SUM: "konysynchashsum",
    KONY_SYNC_CHANGE_TYPE: "konysyncchangetype",
    KONY_SYNC_CHANGE_TIME: "konysyncchangetime",
    //----------------------------------------------
    // metaInfo fields
    //----------------------------------------------
    UPLOAD_SESSION_NO: "uploadsessionno",
    FILTER_VALUE: "filtervalue",
    REPLAY_SEQUENCE_NUMBER: "replaysequencenumber",
    LAST_GENERATED_ID: "lastgeneratedid",
    //----------------------------------------------
    // properties table fields
    //----------------------------------------------
    PROPERTIES_TABLE_KEY_COLUMN: "key",
    PROPERTIES_TABLE_VALUE_COLUMN: "value",
    DB_SCHEMA_VERSION: "dbschemaversion",
    //----------------------------------------------
    // Table names
    //----------------------------------------------
    SQL_TABLE_KONY_PROPERTIES: "konysyncPROPERTIES",
    SQL_TABLE_KONY_SYNC_METADATA: "konysyncMETADATA",
    SQL_TABLE_KONY_SYNC_META_INFO: "konysyncMETAINFO",
    SQL_TABLE_KONY_SYNC_UPLOAD_CACHE: "konysyncUPLOADCACHE",
    SQL_TABLE_KONY_SYNC_OBJECT_DELTA_CONTEXT: "konysyncOBJECTDELTACONTEXT",
    //----------------------------------------------
    // Database name generator
    //----------------------------------------------
    NAMESPACE_SUFFIX_CHARACTER: ".",
    TABLE_TYPE_CONNECTOR_CHARACTER: '_',
    TABLE_COMPOSITE_PRIMARY_KEY_CONNECTOR: '+',
    TABLE_TYPE_HISTORY: "HISTORY",
    TABLE_TYPE_ORIGINAL: "ORIGINAL",
    //----------------------------------------------
    // Metadata Table constants
    //----------------------------------------------
    METADATA_TABLE_VERSION: "version",
    METADATA_TABLE_METADATA_JSON: "metadataJSON",
    METADATA_TABLE_DELTA_CONTEXT: "deltaContext",
    METADATA_TABLE_OBJECT_SERVICE_NAME: "objectServiceName",
    //----------------------------------------------
    // Prepared statements constants
    //----------------------------------------------
    OPERATION_TYPE: "operationtype",
    TABLE_NAME: "tablename",
    COLUMN: "column",
    ORDER: "order",
    //----------------------------------------------
    // Logical operation constants
    //----------------------------------------------
    LOGICAL_AND: "AND",
    LOGICAL_OR: "OR",
    //----------------------------------------------
    // Table Queries
    //----------------------------------------------
    QUERY_KONY_SYNC_UPLOAD_CACHE_TABLE: "&object_name,object_type,request_body,request_id,request_context,no_of_reattempts,last_attempted",
    //----------------------------------------------
    // Upload cache field names
    //----------------------------------------------
    UPLOAD_CACHE_OBJECT_NAME: "object_name",
    UPLOAD_CACHE_OBJECT_TYPE: "object_type",
    UPLOAD_CACHE_REQUEST_BODY: "request_body",
    UPLOAD_CACHE_REQUEST_ID: "request_id",
    UPLOAD_CACHE_REQUEST_CONTEXT: "request_context",
    UPLOAD_CACHE_NO_OF_REATTEMPTS: "no_of_reattempts",
    UPLOAD_CACHE_LAST_ATTEMPTED: "last_attempted"
});
kony.sdk.OfflineObjects.KSDatabaseSchemaVersion = Object.freeze({
    Version_None: 0,
    Version_Default: 1,
    /* 8.0 Release */
    Version_2: 2,
    /* 8.1 Release */
    Version_3: 3,
    /* 8.2 release */
    getLatestVersion: function() {
        return (Object.keys(this).length - 2);
    }
});
kony.sdk.OfflineObjects.KSErrorConstants = function() {
    function Error(code, message) {
        this.code = code;
        this.message = message;
        this.domain = "OfflineObjectsError";
    }
    var KSErrorConstants = {};
    //--------------------------------
    // Generic success & failure codes
    //--------------------------------
    KSErrorConstants.STATUS_SUCCESS = 0;
    KSErrorConstants.STATUS_FAILURE = -1;
    //------------------------------------------------
    // Error codes for Database Errors - (2000 - 2029)
    //------------------------------------------------
    KSErrorConstants.DB_GENERIC_ERROR = new Error(2000, "An error occurred in the Database Layer.");
    KSErrorConstants.DB_INSTANCE_NOT_INITIALIZED = new Error(2011, "Database instance is not initialized.");
    KSErrorConstants.DB_EXECUTE_QUERY_FAILED = new Error(2012, "Mandatory fields to execute a query are missing.");
    //------------------------------------------------
    // Error codes for Network Errors - (2030 to 2099)
    //------------------------------------------------
    KSErrorConstants.GENERIC_NETWORK_ERROR = new Error(2030, "An error occurred in the Network Layer.");
    KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR = new Error(2031, "Unable to connect to host.");
    KSErrorConstants.NW_SOCKET_TIMEOUT = new Error(2032, "Network call failed due to socket connection timeout");
    KSErrorConstants.NW_INVALID_RESPONSE_OBJECT = new Error(2037, "Network response is either null or invalid JSON.");
    KSErrorConstants.NW_INVALID_OPSTATUS_FROM_SERVER = new Error(2038, "Server responded with error opstatus.");
    KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE = new Error(2043, "HTTP message integrity check failed.");
    KSErrorConstants.NW_REQUEST_ALREADY_IN_PROGRESS = new Error(2044, "The upload request is already in progress.");
    //------------------------------------
    //Error codes for KSErrorConstants.CRUD Errors- (2300 - 2329)
    //------------------------------------
    KSErrorConstants.CRUD_GENERIC_ERROR = new Error(2300, "An error occurred in the ORM operation");
    KSErrorConstants.CRUD_RECORD_NOT_IN_MAIN_TABLE = new Error(2301, "No record found in the database for given column values or where condition");
    KSErrorConstants.CRUD_REFERENTIAL_INTEGRITY_VIOLATION = new Error(2302, "Foreign key constraint violation error");
    KSErrorConstants.CRUD_PRIMARY_KEYS_UPDATE_NOT_ALLOWED = new Error(2303, "Updating primary key(s) of a record is not allowed");
    KSErrorConstants.CRUD_INVALID_OPTIONS = new Error(2304, "Supplied options are invalid, common causes are incorrect property name or value or data types");
    KSErrorConstants.CRUD_NULL_OR_EMPTY_PRIMARY_KEY_VALUE = new Error(2305, "Primary key values cannot be null or empty");
    KSErrorConstants.CRUD_NULL_OR_EMPTY_COLUMN_NAME_IN_ORDERBY_MAP = new Error(2306, "Property or column names cannot be null or empty in orderByMap option");
    KSErrorConstants.CRUD_NULL_SDKRECORD = new Error(2307, "Cannot perform ORM operations on null or empty record");
    KSErrorConstants.CRUD_MANDATORY_COLUMNS_MISSING = new Error(2308, "Mandatory field or property missing in the ORM input");
    KSErrorConstants.CRUD_VALUE_SENT_FOR_AUTOGENERATED_COLUMN = new Error(2309, "Value should not be sent for auto generated columns");
    KSErrorConstants.CRUD_INVALID_ATTRIBUTE = new Error(2310, "Invalid field or property found in the ORM input");
    KSErrorConstants.CRUD_DATATYPE_OR_LENGTH_MISMATCH = new Error(2311, "ORM input is of invalid data type or length");
    KSErrorConstants.CRUD_NULL_OR_EMPTY_OPTIONS = new Error(2312, "Supplied options are either null or empty");
    KSErrorConstants.CRUD_MUTUALLY_EXCLUSIVE_OPTIONS_USED = new Error(2313, "Supplied options cannot be used together, they are mutually exclusive");
    KSErrorConstants.CRUD_INVALID_RECORD_OPERATION = new Error(2314, "Non deferred operation is not allowed on this record as previous changes are in deferred and sync pending state");
    //----------------------------------------------
    // Error codes for Setup Errors - (2330 - 2399)
    //----------------------------------------------
    KSErrorConstants.SETUP_GENERIC_ERROR = new Error(2330, "Setup failed with an error");
    KSErrorConstants.SETUP_METADATA_REFRESH_ERROR = new Error(2332, "Metadata refresh failed with an error");
    KSErrorConstants.SETUP_OBJECT_METADATA_NOT_FOUND = new Error(2333, "Object metadata not found for the given offline object");
    KSErrorConstants.SETUP_UNABLE_TO_PARSE_METADATA_JSON_RELATIONSHIP = new Error(2338, "Error parsing relationships");
    KSErrorConstants.INVALID_METADATA_JSON = new Error(2342, "Metadata JSON is invalid.");
    KSErrorConstants.SETUP_METADATA_NAMESPACES_NIL = new Error(2344, "Namespaces cannot be null or empty in the metadata");
    KSErrorConstants.SETUP_METADATA_OBJECTS_NIL = new Error(2345, "Objects cannot be null or empty in the metadata");
    KSErrorConstants.SETUP_INVALID_RELATIONSHIP_TYPE = new Error(2346, "Invalid relationship type found. Supported types are 'One To Many', 'Many To One' and 'One To One'");
    KSErrorConstants.SETUP_METADATA_ATTRIBUTES_NIL = new Error(2349, "Metadata attributes cannot be nil/empty");
    KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS = new Error(2353, "One or more Sync tasks (i.e. Setup/Drop/Reset) is currently in progress for the application");
    KSErrorConstants.SETUP_METADATA_OBJECTS_PRIMARY_KEY_NIL = new Error(2356, "Keys cannot be null or empty in the object metadata");
    //------------------------------------------------
    // Error codes for Metadata Errors - (2400 - 2429)
    //------------------------------------------------
    KSErrorConstants.METADATA_SDKOBJECT_SYNC_NAME_NULL_OR_EMPTY = new Error(2400, "Cannot create Offline Object with name as null or empty string");
    KSErrorConstants.METADATA_SDKOBJECTSERVICE_NAME_NULL_OR_EMPTY = new Error(2401, "Cannot create Offline Object Service with name as null or empty string");
    KSErrorConstants.METADATA_INVALID_OBJECT_SERVICE_NAME = new Error(2405, "Invalid object service name");
    KSErrorConstants.METADATA_OBJECT_NAME_EMPTY = new Error(2406, "SDK Object name cannot be nil/empty.");
    KSErrorConstants.METADATA_ATTRIBUTE_NAME_NULL_OR_EMPTY = new Error(2409, "Attribute name cannot be null/empty.");
    //------------------------------------------------
    // Error codes for Sync Errors - (2460 - 2559)
    //------------------------------------------------
    KSErrorConstants.SYNC_GENERIC_ERROR = new Error(2460, "Sync Failed due to unexpected error");
    KSErrorConstants.SYNC_IN_PROGRESS = new Error(2461, "Sync cannot be performed as other Offline Object operations are in progress");
    KSErrorConstants.SYNC_GENERIC_ROLLBACK_ERROR = new Error(2471, "An error occurred while trying to perform rollback");
    KSErrorConstants.SYNC_INVALID_FILTERS = new Error(2472, "Invalid Filters");
    KSErrorConstants.SYNC_UPLOAD_ERROR = new Error(2473, "Sync upload failed with an error");
    KSErrorConstants.SYNC_DOWNLOAD_ERROR = new Error(2474, "Sync download failed with an error");
    KSErrorConstants.SYNC_INVALID_SYNC_TYPE = new Error(2477, "Invalid value found for syncType option. It's either empty or null or not among valid options");
    KSErrorConstants.APPLICATION_SYNC_INVALID_OPTIONS = new Error(2482, "Application sync options provided are invalid.");
    KSErrorConstants.APPLICATION_SYNC_OBJECTSERVICES_NOT_FOUND = new Error(2483, "Setup is not performed. There are no object services to sync.");
    KSErrorConstants.SYNC_EMPTY_PRIMARYKEY_VALUE = new Error(2484, "Primary key %s not found for record.");
    //------------------------------------------------
    // Error codes for Internal Errors - (2900 - 2999)
    //------------------------------------------------
    KSErrorConstants.INTERNAL_INVALID_SYNC_MODE = new Error(2905, "Mode Should be OFFLINE");
    //-----------------------------------------------
    //Error codes for Internal Errors - (2900 - 2999)
    //-----------------------------------------------
    KSErrorConstants.INTERNAL_INVALID_ACTION_TYPE_SENT_TO_ORMFACTORY = new Error(2903, "Invalid action type is sent to ORMManagerFactory");
    //------------------------------------------
    // Error codes for Drop Errors - (2430 - 2459)
    //--------------------------------------------
    KSErrorConstants.DROP_DB_FAILED = new Error(2430, "An error occurred while dropping the database");
    //------------------------------------------
    //  Error codes for Upload Cache Errors
    // --------------------------------------------
    KSErrorConstants.INTERNAL_UPLOAD_CACHE_DUPLICATE_ENTRY_FOR_SAME_OBJECT = new Error(2913, "Upload cache has duplicate cache entry for same sync object");
    KSErrorConstants.SYNC_CACHE_UPLOAD_ERROR = new Error(2476, "Pending sync requests failed with an error");
    return KSErrorConstants;
}();
/**
 * Object defining the constants for internal use.
 */
kony.sdk.OfflineObjects.KSInternalConstants = Object.freeze({
    //Network constants
    BODY: "body",
    HEADERS: "headers",
    HTTP_METHOD_GET: "GET",
    QUERY_PARAMS: "queryParams",
    CONTENT_TYPE: "Content-Type",
    X_KONY_SERVICE_VERSION_VALUE: "2.0",
    APPLICATION_JSON: "application/json",
    X_KONY_API_VERSION: "X-Kony-API-Version",
    X_KONY_AUTHORIZATION: "X-Kony-Authorization",
    X_KONY_REPORTINGPARAMS: "X-Kony-ReportingParams",
    X_HTTP_METHOD_OVERRIDE: "X-Http-Method-Override",
    X_KONY_SERVICE_VERSION: "X-Kony-Service-Version",
    X_KONY_REQUEST_CACHE_ID: "X-Kony-RequestCacheId",
    URL: "url",
    NAME: "name",
    VERSION: "version",
    ENDPOINT_URL: "endpointURL",
    OBJECTSERVICE_METADATA_URL: "metadata_url",
    OBJECT_METADATA: "metadata",
    OBJECT_SERVICE_METADATA_CONTEXT: "objectServiceMetadataContext",
    OFFLINE: "offline",
    SYNC_EMPTY_NAMESPACE_NAME: "",
    UNNAMED_NAMESPACE: "kony_unnamed",
    SYNC_EMPTY_OBJECT_SERVICE_NAME: "",
    FULLY_QUALIFIED_NAME: "fullyQualifiedName",
    UNNAMED_NAMESPACE_WITH_DOT: "kony_unnamed.",
    //Metadata constants
    TIMESTAMP: "timestamp",
    UPLOAD_CACHE: "uploadCache",
    HTTP_RESPONSE: "httpresponse",
    CONFLICT_POLICY: "conflict_policy",
    OBJECT_SERVICE_NAME: "objectServiceName",
    IS_CHANGE_AFTER_LAST_FETCH_TIME: "isChangeAfterLastFetchTime",
    NAMESPACE_NAME: "name",
    NAMESPACES: "namespaces",
    NAMESPACE_ACTION: "action",
    PARENT_ROOT_METADATA: "parentRootMetadata",
    NAMESPACE_METADATA_DICTIONARY: "namespaceMetadataDictionary",
    OBJECT: "object",
    OBJECTS: "objects",
    OBJECTS_NAME: "name",
    OBJECTS_KEYS: "key",
    OBJECTS_ACTION: "action",
    OPERATIONS: "operations",
    OBJECTS_FIELDS: "fields",
    OBJECTS_OPERATIONS: "operations",
    OBJECTS_PRIMARY_KEYS: "primaryKey",
    OBJECTS_CACHE_TIMEOUT: "cache_timeout",
    OBJECTS_RELATIONSHIPS: "relationships",
    OBJECTS_SOFT_DELETE_FIELD: "softdelete_field",
    OBJECTS_CHILD_RELATIONSHIPS: "childRelationships",
    OBJECTS_DELTA_CONTEXT_FIELD: "delta_context_field",
    OBJECTS_PARENT_RELATIONSHIPS: "parentRelationships",
    PARENT_NAMESPACE_METADATA: "parentNamespaceMetadata",
    OBJECT_METADATA_DICTIONARY: "objectMetadataDictionary",
    OBJECTS_NON_NULLABLE_ATTRIBUTES: "nonNullableAttributes",
    ATTRIBUTES_NAME: "name",
    ATTRIBUTES: "attributes",
    ATTRIBUTES_ACTION: "action",
    ATTRIBUTES_LENGTH: "length",
    ATTRIBUTES_NULLABLE: "nullable",
    ATTRIBUTES_DATATYPE: "datatype",
    ATTRIBUTES_CREATABLE: "creatable",
    ATTRIBUTES_UPDATABLE: "updatable",
    ATTRIBUTES_SOFT_DELETABLE: "softDeletable",
    ATTRIBUTES_AUTO_GENERATED: "auto_generated",
    ATTRIBUTES_SOURCE_DATATYPE: "source_datatype",
    PARENT_OBJECT_METADATA: "parentObjectMetadata",
    RELATIONSHIP_NAME: "name",
    RELATIONSHIP_TYPE: "type",
    RELATIONSHIP_ACTION: "action",
    RELATIONSHIP_CASCADE: "cascade",
    RELATIONSHIP_TARGET_OBJECT: "target_object",
    RELATIONSHIP_SOURCE_OBJECT: "source_object",
    RELATIONSHIP_TARGET_ATTRIBUTES: "target_fields",
    RELATIONSHIP_SOURCE_ATTRIBUTES: "source_fields",
    RELATIONSHIP_BACKEND_CASCADE_SUPPORT: "backend_cascade_support",
    KSRelationshipTypes: {
        ONE_TO_ONE: "OneToOne",
        ONE_TO_MANY: "OneToMany",
        MANY_TO_ONE: "ManyToOne"
    },
    KSObjectOperationType: {
        get: "get",
        create: "create",
        update: "update",
        partialupdate: "partialupdate",
        delete: "delete"
    },
    EM_GENERIC_DATA_FETCHER: "Failed to retrieve network response for Object Service: ",
    EM_SETUP_VERSION_MISMATCH: "Offline setup failed due to version mismatch.",
    EM_FIRST_TIME_OFFLINE_SETUP: "Could not refresh metadata due to network error, object service metadata is not available offline for app version:",
    //SyncLevel Constants
    SYNCLEVEL_OBJECT: "Object",
    SYNCLEVEL_OBJECTSERVICE: "ObjectService",
    SYNCLEVEL_APPLICATION: "Application",
    // Task Constants
    SYNC_OBJECT: "syncObject",
    //Offline Constants
    OFFLINE_FLAG: "offline",
    OFFLINE_FLAG_VALUE: "true",
    //Sync Download Request Constants
    FILTER: "filter",
    DOLLAR_EXPAND: "$expand",
    DOLLAR_FILTER: "$filter",
    OBJECT_NAME: "objectname",
    ODATASTRING: "odatastring",
    QUERYPARAMS: "queryParams",
    REQUEST_BODY: "requestBody",
    SYNC_OPTIONS: "syncOptions",
    REQUEST_HEADERS: "requestHeader",
    DOLLAR_FILTER_EQUALS_TO: "$filter=",
    DOLLAR_EXPAND_EQUALS_TO: "$expand=",
    //Database Constants
    OBJS: "objs",
    DELTA: "delta",
    DELTACONTEXT: "deltacontext",
    DELTA_CONTEXT: "delta_context",
    BATCH_CONTEXT: "bc",
    //Download Response Constants
    ACTION: "action",
    RECORDS: "records",
    CHECKSUM: "checksum",
    METADATA: "metadata",
    OP_STATUS: "opstatus",
    _METADATA: "_metadata",
    HTTP_STATUS_CODE: "httpStatusCode",
    TRUE_STRING: "true",
    DOWNLOAD_RESPONSE_METADATA: "downloadResponseMetadata",
    //Upload Response Constants
    UPLOAD_RESPONSE_METADATA: "uploadResponseMetadata",
    INTERMEDIATE_ERR_MSG: "intermediateErrors",
    ERR_MSG: "errmsg",
    ERR_CODE: "errcode",
    //Upload Payload builder constants
    ARE_THERE_CHANGES_TO_UPLOAD: "areThereChangesToUpload",
    SESSION_ID: "sessionID",
    ECHO: "echo",
    DATA: "data",
    HAS_MORE_RECORDS: "hasMoreRecords",
    ABORT_ON_ERROR: "abortonError",
    TOTAL_NAMESPACES: "totalNamespaces",
    TOTAL_RECORDS: "totalRecords",
    TOTAL_OBJECTS: "totalObjects",
    RECORD_COUNT: "recordCount",
    IGNORE_DUPLICATES: "ignore_duplicate",
    ROW_ID: "rowId",
    HTTP_OVERRIDE_UPLOAD: "UPLOAD",
    REQUEST_QUERY_PARAMS: "queryParams",
    //Generic constants
    MODE: "OFFLINE",
    SCOPE_NAME: "scopename",
    //Download Response Body Parsing Constants
    DATA_OBJECTS: "dataObjects",
    OBJECTS_IN_RESPONSE: "Objects",
    METADATA_OBJECT: "metadataObject",
    //String
    DOT: ".",
    EQUALS: "=",
    EMPTY_STRING: "",
    COMMA_SEPARATOR: ",",
    LESS_THAN_EQUALS_TO: "<=",
    GREATER_THAN_EQUALS_TO: ">=",
    //Network Constants
    OPSTATUS_SUCCESS: 0,
    //Sync Errors
    UPLOAD_SYNC_ERRORS: "uploadSyncErrors",
    DOWNLOAD_SYNC_ERRORS: "downloadSyncErrors",
    //Constants inside Error Object
    ERROR_DOMAIN: "domain",
    //Sync Stats Constants
    TOTAL_UPLOADED_RECORDS: "totalUploadedRecords",
    TOTAL_DOWNLOADED_RECORDS: "totalDownloadedRecords",
    NUMBER_OF_RECORDS_SYNCED: "numberOfRecordsSynced",
    SYNC_OBJECT_NAME: "name",
    SUCCESS_COUNT: "successCount",
    TYPE: "type",
    //Batching constants
    BATCH_SIZE_FILTER: "$batchsize",
    DEFAULT_BATCH_NUMBER: 1,
    DEFAULT_DOWNLOAD_BATCH_SIZE: 500,
    //Data type Constants
    DATA_TYPE_BOOLEAN: "boolean",
    DATA_TYPE_STRING: "string",
    //Boolean Values Constants
    BOOLEAN_VALUE_TRUE: "true",
    BOOLEAN_VALUE_FALSE: "false",
    //String Constants
    INTERNAL_USER_INFO: "internalUserInfo",
    DB_SCHEMA_VERSION: "dbSchemaVersion",
    //Upload cache constants
    HTTP_STATUS: "httpStatus",
    HTTP_TOO_MANY_REQUESTS: 429,
    UPLOAD_BATCH_ERRORS: "uploadBatchErrors",
    CACHE_UPLOAD_ERRORS: "cacheUploadErrors",
    PARTIAL_SUCCESS_OPSTATUS_MIN_VALUE: 500100,
    PARTIAL_SUCCESS_OPSTATUS_MAX_VALUE: 500200,
    OPSTATUS_REQUEST_ALREADY_IN_PROGRESS: 500210
});
/**
 * Defines constants that are exposed to end user through offline objects API input and response objects.
 * Created by Prasanthi Bonam on 30-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
kony.sdk.OfflineObjects.KSPublicConstants = Object.freeze({
    STATUS: "status",
    // Constants for Config Policies
    DOWNLOAD_ONLY: "downloadOnly",
    UPLOAD_ONLY: "uploadOnly",
    FULL_SYNC: "fullSync",
    SYNC_TYPE: "syncType",
    UPLOAD_TAG: "upload",
    DOWNLOAD_TAG: "download",
    SYNC_STATS: "syncStats",
    UPLOAD_STATS: "uploadStats",
    DOWNLOAD_STATS: "downloadStats",
    GET_SYNC_STATS: "getSyncStats",
    SYNC_UPLOAD_QUERY_PARAMS: "uploadRequestQueryParams",
    SYNC_DOWNLOAD_QUERY_PARAMS: "downloadRequestQueryParams",
    SYNC_PENDING_RECORDS: "pendingSyncRecords",
    QUERY_PARAMS: "queryParams",
    //CRUD Constants
    ORDER_BY_DEFAULT: "ASC",
    ORDER_BY_ASCENDING: "ASC",
    ORDER_BY_DESCENDING: "DESC",
    ORDER_BY_ASCENDING_IGNORECASE: "ASC_IGNORECASE",
    ORDER_BY_DESCENDING_IGNORECASE: "DESC_IGNORECASE",
    CRUD_OPTION_ORDERBY_MAP: "orderByMap",
    CRUD_OPTION_PRIMARY_KEYS: "primaryKeys",
    CRUD_OPTION_WHERE_CONDITION: "whereCondition",
    CRUD_OPTION_WHERE_CONDITION_AS_A_STRING: "whereConditionAsAString",
    CRUD_OPTION_PROJECTION_COLUMNS: "projectionColumns",
    TRACK_CHANGES: "trackChanges",
    MARK_FOR_UPLOAD: "markForUpload",
    TRACK_INTERMEDIATE_UPDATES: "trackIntermediateUpdates",
    // Constants for SYNC ERROR propagation
    ERRMSG: "errmsg",
    OBJECT: "object",
    OPSTATUS: "opstatus",
    SYNC_ERRORS: "syncErrors",
    PRIMARY_KEYS: "primaryKeys",
    OBJECT_SERVICE: "objectService",
    //Batching constants
    DOWNLOAD_BATCH_SIZE: "downloadBatchSize",
    // Application Sync Constants
    APPLICATION_SYNC_MODE: "syncMode",
    APPLICATION_SYNC_PARALLEL: "parallel",
    APPLICATION_SYNC_SEQUENTIAL: "sequential",
    APPLICATION_SYNC_OBJECT_SERVICES_OPTIONS: "objectServicesOptions",
    APPLICATION_SYNC_SUCCESS_RESPONSE: "successResponse",
    APPLICATION_SYNC_FAILURE_RESPONSE: "failureResponse",
    // Running Tasks Context Constant
    RUNNING_TASKS_CONTEXT: "KSRunningTasksContext",
    APP_LAUNCH: "appLaunch"
});
kony.sdk.OfflineObjects.KSTableType = Object.freeze({
    "MAIN": 0,
    "ORIGINAL": 1,
    "HISTORY": 2
});
/**
 * Object defining the enumeration for each running tasks.
 * Created by Archana Narahari on 08-08-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
//-------------------------------------
// ENUM ASSOCIATED WITH EVERY SYNC TASK
//-------------------------------------
kony.sdk.OfflineObjects.KSTaskID = {
    SETUP: 1,
    DROP: 2,
    RESET: 4,
    ROLLBACK: 8,
    SYNC: 16
};
var KSTaskID = kony.sdk.OfflineObjects.KSTaskID;
//----------------------------------------------------------------------------------
// OBJECT STATING THE ENUM ASSOCIATED WITH EACH TASK AND THE TASKS THAT CAN BLOCK IT
//----------------------------------------------------------------------------------
kony.sdk.OfflineObjects.KSTasks = {
    SETUP: {
        ID: KSTaskID.SETUP,
        BLOCKINGTASKS: KSTaskID.SETUP | KSTaskID.DROP | KSTaskID.RESET | KSTaskID.SYNC | KSTaskID.ROLLBACK
    },
    DROP: {
        ID: KSTaskID.DROP,
        BLOCKINGTASKS: KSTaskID.SETUP | KSTaskID.DROP | KSTaskID.RESET | KSTaskID.SYNC | KSTaskID.ROLLBACK
    },
    RESET: {
        ID: KSTaskID.RESET,
        BLOCKINGTASKS: KSTaskID.SETUP | KSTaskID.DROP | KSTaskID.RESET | KSTaskID.SYNC | KSTaskID.ROLLBACK
    },
    ROLLBACK: {
        ID: KSTaskID.ROLLBACK,
        BLOCKINGTASKS: KSTaskID.SETUP | KSTaskID.DROP | KSTaskID.RESET | KSTaskID.ROLLBACK | KSTaskID.SYNC
    },
    SYNC: {
        ID: KSTaskID.SYNC,
        BLOCKINGTASKS: KSTaskID.SETUP | KSTaskID.DROP | KSTaskID.RESET | KSTaskID.ROLLBACK | KSTaskID.SYNC
    }
};
// ************************************* Start of KSDatabaseAPI.js ************************************* 
define("KSDatabaseAPI", ["require", "exports", "KonyNoSQLDatabaseHelper", "KSCommonUtils", "KSExceptionWrapperUtils"], function(require, exports, _KonyNoSQLDatabaseHelper, KSCommonUtils, KSExceptionWrapperUtils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var KSDatabaseAPI = /** @class */ (function() {
        var dbInstance = null;
        var KNYNoSQLDatabaseHelper = _KonyNoSQLDatabaseHelper.KonyNoSQLDatabaseHelper;

        function KSDatabaseAPI() {}
        KSDatabaseAPI.initializeDatabase = async function(dbname, dbInfo) {
            try {
                if (kony.sdk.isNullOrUndefined(dbInfo)) {
                    dbInfo = {};
                }
                dbInstance = await KNYNoSQLDatabaseHelper.getDBInstance(dbname, dbInfo);
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        KSDatabaseAPI.closeDBConnection = async function() {
            try {
                if (!kony.sdk.isNullOrUndefined(dbInstance)) {
                    return (await dbInstance.closeConnection());
                }
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        KSDatabaseAPI.resetDatabase = async function() {
            try {
                return (await dbInstance.resetDatabase());
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        KSDatabaseAPI.dropDatabase = async function(dbName) {
            try {
                if (dbInstance == null && dbName) {
                    if (await KSDatabaseAPI.databaseExists(dbName)) {
                        await KSDatabaseAPI.initializeDatabase(dbName);
                    } else {
                        return;
                    }
                }
                await dbInstance.dropDatabase(dbName);
                dbInstance = null;
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        KSDatabaseAPI.executeQuery = async function(query) {
            try {
                return (await dbInstance.executeQuery(query));
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        KSDatabaseAPI.executeQueriesAsTransaction = async function(queries, tableListAsStringArray) {
            if (KSCommonUtils.isNullOrEmptyObject(tableListAsStringArray)) {
                tableListAsStringArray = await dbInstance.getAllTablesList();
            }
            return dbInstance.transaction(kony.nosql.READ_WRITE, tableListAsStringArray, async function(transaction) {
                for (var i = 0; i < queries.length; i++) {
                    try {
                        await dbInstance.executeQuery(queries[i], transaction);
                    } catch (ex) {
                        kony.sdk.logsdk.error("KSDatabaseAPI :executeQueriesAsTransaction aborting transaction due to ", ex);
                        transaction.tx.abort();
                        return;
                    }
                }
            });
        };
        KSDatabaseAPI.executeQueries = async function(queries, rollbackOnError) {
            if (rollbackOnError) {
                return await KSDatabaseAPI.executeQueriesAsTransaction(queries);
            } else {
                var results = [];
                for (var i = 0; i < queries.length; i++) {
                    try {
                        var query = queries[i];
                        var result = await dbInstance.executeQuery(query);
                        results.push({
                            "query": query,
                            "status": "Success",
                            "queryResult": result
                        });
                    } catch (error) {
                        results.push({
                            "query": query,
                            "status": "Failure",
                            "queryResult": error
                        });
                    }
                }
                return results;
            }
        };
        KSDatabaseAPI.tableExists = async function(tableName) {
            try {
                return (await dbInstance.isTableFound(tableName));
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        KSDatabaseAPI.databaseExists = async function(databaseName) {
            try {
                return await KNYNoSQLDatabaseHelper.doesDatabaseExists(databaseName);
            } catch (DBException) {
                throw KSExceptionWrapperUtils.wrapDBException(DBException);
            }
        };
        return KSDatabaseAPI;
    }());
    exports.KSDatabaseAPI = KSDatabaseAPI;
});
// ************************************* End of KSDatabaseAPI.js ************************************* 
/**
 * KSDatabaseUpgradeManager
 * Created by Nikhil Kolhe on 01-05-2019.
 * Copyright  2019 Kony. All rights reserved.
 */
/* In KSDatabaseUpgradeManager unlike native platforms (android, iOS and windows) dbSchema version is not stored in konysyncPROPERTIES table
    where as it is stored in local storage with the key "dbSchemaVersion".

    Reason : For knowing the current db version we have to open the database with a specific version and that version with which
    the db is to be opened is not known.

    Example : If the DB version needs to be upgraded from version 2 to version 4. The db needs to be opened with version 2
    but if the current version is also stored in konysyncPROPERTIES table, we still are unaware with which version to open the db.
    Hence local storage is used to store the current db version.

    As the db version is stored in local storage during upgrade scenarios, db version from local storage is fetched and upgrade is performed.
     1) After successful setup the dbSchemaVersion key in local storage is updated/created(in case key is not present) with latest version.
     2) After each drop success the dbSchemaVersion key is also removed from local storage.
 */
define("KSDatabaseUpgradeManager", ["exports", "KSDatabaseAPI", "KSCommonUtils"], function(exports, _KSDatabaseAPI, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "KSDatabaseUpgradeManager : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSDBSchemaVersion = kony.sdk.OfflineObjects.KSDBSchemaVersion;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    /**
     *  Method performs DB upgrade if required
     *
     * @return Promise of db upgrade
     */
    async function performDBUpgrade() {
        logger.info(LOG_PREFIX, "Began to perform DB upgrade");
        var existingDBSchemaVersion = await getExistingDBSchemaVersion();
        if (existingDBSchemaVersion === KSDBSchemaVersion.Version_None || existingDBSchemaVersion === KSCommonUtils.getLatestDBVersion()) {
            logger.info(LOG_PREFIX, "DB schema version is same as current DB version or db exists");
        } else {
            logger.info(LOG_PREFIX, "DB schema upgrade is required");
            switch (existingDBSchemaVersion) {
                case KSDBSchemaVersion.Version_Default:
                    await performDBUpgradeFromV01ToV02();
                    break;
                default:
                    break;
            }
        }
        logger.info(LOG_PREFIX, "Successfully upgraded DB");
    }
    /**
     * Method performs DB schema upgrade from version 1 to version 2
     *
     * @return Promise of initializing database
     */
    async function performDBUpgradeFromV01ToV02() {
        logger.info(LOG_PREFIX, "Began to perform DB upgrade from version 1 to 2.");
        var createTableQuery = {};
        var dbName = KSCommonUtils.getOfflineObjectsDatabaseName();
        createTableQuery[KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE] = KSDatabaseConstants.QUERY_KONY_SYNC_UPLOAD_CACHE_TABLE;
        await KSDatabaseAPI.initializeDatabase(dbName, createTableQuery);
        logger.info(LOG_PREFIX, "Successfully upgraded DB from version 1 to 2.");
    }
    /**
     * Method to fetch current DB version from local storage
     *
     * @return {dbSchemaVersion}
     */
    async function getExistingDBSchemaVersion() {
        logger.debug(LOG_PREFIX, "Fetching existing DB schema version");
        var dbVersion = KSInternalConstants.DB_SCHEMA_VERSION;
        var dbName = KSCommonUtils.getOfflineObjectsDatabaseName();
        var dbExists = await KSDatabaseAPI.databaseExists(dbName);
        var dbSchemaVersion = kony.store.getItem(dbVersion);
        if (kony.sdk.isNullOrUndefined(dbSchemaVersion) && !dbExists) {
            dbSchemaVersion = KSDBSchemaVersion.Version_None;
        } else if (kony.sdk.isNullOrUndefined(dbSchemaVersion) && dbExists) {
            dbSchemaVersion = KSDBSchemaVersion.Version_Default;
        }
        logger.info(LOG_PREFIX, "Successfully fetched existing db schema version: " + dbSchemaVersion);
        return dbSchemaVersion;
    }
    exports.performDBUpgrade = performDBUpgrade;
});
define("KSQueryObjectBuilder", ["require", "exports", "KSCommonUtils"], function(require, exports, KSCommonUtils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var KSDbConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSDatabaseOperation = KSDbConstants.KSDatabaseOperations;
    //Given WhereClauseAsString Of the Form col1 == val1 OR col2 > val2
    //It converts into array of arrays such as [["col1","==","val1"],["OR"],["col2",">","val2"]]
    //Will not support columns with spaces inside them
    var convertWhereClauseAsStringToWhereClauseArray = function(where_clause) {
        function convertRhsValueAsPerDataType(value) {
            if (value === "false") {
                return false;
            } else if (value === "true") {
                return true;
            } else if (isNaN(value)) {
                if (value.startsWith("'") && value.endsWith("'") || value.startsWith('"') && value.endsWith('"')) {
                    value = value.slice(1, (value.length) - 1);
                }
                return value;
            } else {
                return Number(value);
            }
        }
        var delimiter = " ";
        var splittedArray = where_clause.split(delimiter);
        var resultArray = [];
        var tempArray = [];
        for (var index = 0; index < splittedArray.length;) {
            for (var operatorArrayIndex = 0; operatorArrayIndex < 3; operatorArrayIndex++, index++) {
                // get proper RHS value, in accordance with datatype, e.g.
                // "Age = 25" : in this case RHS should be a number 25, and result array should be ["Age", "=", 25]
                // "Age = '25'" :  in this case RHS should be a string "25", and result array should be ["Age", "=", "25"]
                // "isdeleted = true" : in this case RHS should be a boolean true, and result array should be ["isdeleted", "=", true]
                // "isdeleted = 'true'" : in this case RHS should be a string "true", and result array should be ["isdeleted", "=", "true"]
                if (operatorArrayIndex == 2) {
                    tempArray.push(convertRhsValueAsPerDataType(splittedArray[index]));
                } else {
                    tempArray.push(splittedArray[index]);
                }
            }
            resultArray.push(tempArray);
            tempArray = [];
            // This case is for checking End of the String parsing and also
            // Pushing the operand in the middle OR , AND
            if (index < splittedArray.length) {
                tempArray.push(splittedArray[index++]);
                resultArray.push(tempArray);
                tempArray = [];
            }
        }
        return resultArray;
    };
    var KSBaseQueryObjectBuilder = /** @class */ (function() {
        function KSBaseQueryObjectBuilder() {
            this.query = {};
            this.setWhereClause = function(_whereClause) {
                return this;
            };
            this.setWhereClauseAsString = function(_whereClauseAsString) {
                return this;
            };
            this.addInsertValues = function(_value) {
                return this;
            };
            this.setProjectionColumns = function(_projectionColumns) {
                return this;
            };
            this.addOrderByMap = function(_orderbyclause) {
                return this;
            };
            this.setUpdatedData = function(_updatedData) {
                return this;
            };
            this.setCallback = function(_calllback) {
                return this;
            };
            this.setLimit = function(_calllback) {
                return this;
            };
            this.build = function() {
                return this.query;
            };
            this.query = {
                [KSDbConstants.OPERATION_TYPE]: null,
                [KSDbConstants.TABLE_NAME]: null,
                "whereClause": null,
                "insertValues": null,
                "whereClauseAsString": null,
                "projectionColumn": null,
                "orderBy": null,
                "updateData": null,
                "limit": null,
                "callback": null
            };
        }
        return KSBaseQueryObjectBuilder;
    }()); // End of class file KSBaseQueryObjectBuilder
    var KSCreateQueryObjectBuilder = /** @class */ (function(_super) {
        function KSCreateQueryObjectBuilder(table_name, isReplace) {
            var _this = _super.call(this) || this;
            _this.addInsertValues = function(_value) {
                if (!KSCommonUtils.isNullOrEmptyObject(_value)) {
                    this.query.insertValues.push(_value);
                }
                return this;
            };
            _this.query[KSDbConstants.TABLE_NAME] = table_name;
            if (isReplace === true) {
                _this.query[KSDbConstants.OPERATION_TYPE] = KSDatabaseOperation.INSERT_OR_REPLACE;
            } else {
                _this.query[KSDbConstants.OPERATION_TYPE] = KSDatabaseOperation.INSERT;
            }
            _this.query["insertValues"] = [];
            return _this;
        }
        __extends(KSCreateQueryObjectBuilder, _super);
        return KSCreateQueryObjectBuilder;
    }(KSBaseQueryObjectBuilder)); //End of class KSCreateQueryObjectBuilder
    var KSDeleteQueryObjectBuilder = /** @class */ (function(_super) {
        function KSDeleteQueryObjectBuilder(table_name) {
            var _this = _super.call(this) || this;
            _this.setWhereClause = function(_whereClause) {
                if (!KSCommonUtils.isNullOrEmptyObject(_whereClause)) {
                    this.query.whereClause = _whereClause;
                }
                return this;
            };
            _this.setWhereClauseAsString = function(_whereClauseAsString) {
                if (!KSCommonUtils.isNullOrEmptyObject(_whereClauseAsString)) {
                    this.query.whereClause = convertWhereClauseAsStringToWhereClauseArray(_whereClauseAsString);
                }
                return this;
            };
            _this.query[KSDbConstants.OPERATION_TYPE] = KSDatabaseOperation.DELETE;
            _this.query[KSDbConstants.TABLE_NAME] = table_name;
            return _this;
        }
        __extends(KSDeleteQueryObjectBuilder, _super);
        return KSDeleteQueryObjectBuilder;
    }(KSBaseQueryObjectBuilder)); //End of class KSDeleteQueryObjectBuilder
    var KSReadQueryObjectBuilder = /** @class */ (function(_super) {
        function KSReadQueryObjectBuilder(table_name) {
            var _this = _super.call(this) || this;
            _this.setWhereClause = function(_whereClause) {
                if (!KSCommonUtils.isNullOrEmptyObject(_whereClause)) {
                    this.query.whereClause = _whereClause;
                }
                return this;
            };
            _this.setWhereClauseAsString = function(_whereClauseAsString) {
                if (!KSCommonUtils.isNullOrEmptyObject(_whereClauseAsString)) {
                    this.query.whereClause = convertWhereClauseAsStringToWhereClauseArray(_whereClauseAsString);
                }
                return this;
            };
            _this.setProjectionColumns = function(_projectionColumns) {
                if (!KSCommonUtils.isNullOrEmptyObject(_projectionColumns)) {
                    this.query.projectionColumn = _projectionColumns;
                }
                return this;
            };
            _this.addOrderByMap = function(_orderbyclause) {
                if (!KSCommonUtils.isNullOrEmptyObject(_orderbyclause)) {
                    this.query.orderBy = _orderbyclause;
                }
                return this;
            };
            _this.setCallback = function(_calllback) {
                this.query.callback = _calllback;
                return this;
            };
            _this.setLimit = function(_limit) {
                if (!KSCommonUtils.isNullOrEmptyObject(_limit)) {
                    this.query.limit = _limit;
                }
                return this;
            };
            _this.query[KSDbConstants.OPERATION_TYPE] = KSDatabaseOperation.SELECT;
            _this.query[KSDbConstants.TABLE_NAME] = table_name;
            return _this;
        }
        __extends(KSReadQueryObjectBuilder, _super);
        return KSReadQueryObjectBuilder;
    }(KSBaseQueryObjectBuilder)); //End of class KSReadQueryObjectBuilder
    var KSUpdateQueryObjectBuilder = /** @class */ (function(_super) {
        function KSUpdateQueryObjectBuilder(table_name) {
            var _this = _super.call(this) || this;
            _this.setWhereClause = function(_whereClause) {
                if (!KSCommonUtils.isNullOrEmptyObject(_whereClause)) {
                    this.query.whereClause = _whereClause;
                }
                return this;
            };
            _this.setWhereClauseAsString = function(_whereClauseAsString) {
                if (!KSCommonUtils.isNullOrEmptyObject(_whereClauseAsString)) {
                    this.query.whereClause = convertWhereClauseAsStringToWhereClauseArray(_whereClauseAsString);
                }
                return this;
            };
            _this.setUpdatedData = function(_updatedData) {
                if (!KSCommonUtils.isNullOrEmptyObject(_updatedData)) {
                    this.query.updateData = _updatedData;
                }
                return this;
            };
            _this.query[KSDbConstants.OPERATION_TYPE] = KSDatabaseOperation.UPDATE;
            _this.query[KSDbConstants.TABLE_NAME] = table_name;
            return _this;
        }
        __extends(KSUpdateQueryObjectBuilder, _super);
        return KSUpdateQueryObjectBuilder;
    }(KSBaseQueryObjectBuilder)); //End of class KSUpdateQueryObjectBuilder
    var KSQueryObjectBuilderFactory = /** @class */ (function() {
        function KSQueryObjectBuilderFactory() {}
        KSQueryObjectBuilderFactory.getQueryObjectForTableName = function(tablename, builderType) {
            switch (builderType) {
                case KSDatabaseOperation.INSERT:
                    return new KSCreateQueryObjectBuilder(tablename, false);
                case KSDatabaseOperation.INSERT_OR_REPLACE:
                    return new KSCreateQueryObjectBuilder(tablename, true);
                case KSDatabaseOperation.UPDATE:
                    return new KSUpdateQueryObjectBuilder(tablename);
                case KSDatabaseOperation.SELECT:
                    return new KSReadQueryObjectBuilder(tablename);
                case KSDatabaseOperation.DELETE:
                    return new KSDeleteQueryObjectBuilder(tablename);
                default:
            }
        };
        return KSQueryObjectBuilderFactory;
    }()); // End of class KSQueryObjectBuilderFactory
    exports.KSDatabaseOperation = KSDatabaseOperation;
    exports.KSBaseQueryObjectBuilder = KSBaseQueryObjectBuilder;
    exports.getQueryObjectForTableName = KSQueryObjectBuilderFactory.getQueryObjectForTableName;
});
/**
 * Wrapper methods over database.
 */
define("KSSyncDatabaseHelper", ["exports", "KSDatabaseAPI", "KSSQLQueryGenerator", "KSCommonUtils", "KSSDKObjectRecord", "KSError", "KSSetupManager", "KSSDKObjectService", "KSMarkForUploadUtils"], function(exports, _KSDatabaseAPI, KSSQLQueryGenerator, KSCommonUtils, _KSSDKObjectRecord, _KSError, KSSetupManager, KSSDKObjectService, KSMarkForUploadUtils) {
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSSyncDatabaseHelper : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSTableType = kony.sdk.OfflineObjects.KSTableType;
    var KSSDKObjectRecord = _KSSDKObjectRecord.KSSDKObjectRecord;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    var KSRelationshipTypes = kony.sdk.OfflineObjects.KSInternalConstants.KSRelationshipTypes;
    /**
     * Executes PreparedStatements in transaction
     * @param preparedStatements statements to execute
     */
    async function executePreparedStatementsAsTransaction(preparedStatements) {
        await KSDatabaseAPI.executeQueriesAsTransaction(preparedStatements);
    }
    /**
     * Method to build queries for the changes present in an array of objects.
     * @param sdkObjectArray Array of objects for which the queries need to be generated.
     * @returns {Array} Array of query objects built.
     */
    async function buildQueriesToPersistChangesForObjects(sdkObjectArray) {
        logger.trace(LOG_PREFIX, "Building query objects to persist changes.");
        var queryObjects = [];
        if (!kony.sdk.isNullOrUndefined(sdkObjectArray)) {
            for (var i = 0; i < sdkObjectArray.length; i++) {
                var queriesGenerated = await buildQueryObjectsForData(sdkObjectArray[i]);
                Array.prototype.push.apply(queryObjects, queriesGenerated);
            }
        }
        logger.info(LOG_PREFIX, "Queries successfully built for persisting response.");
        return queryObjects;
    }
    /**
     * Method to build queries for the changes present in an object.
     * The queries generated take into consideration the pending edits.
     * @param sdkObject Object for which the queries need to be generated.
     * @returns {Array} Array of query objects built.
     */
    async function buildQueryObjectsForData(sdkObject) {
        var segregatedRecords = await classifyRecordsAccordingToPendingEdits(sdkObject);
        var recordsWithPendingEdits = segregatedRecords.recordsWithPendingEdits;
        var recordsWithoutPendingEdits = segregatedRecords.recordsWithoutPendingEdits;
        var queryObjsForRecordsWithPendingEdits = getQueryObjsForRecordsWithPendingEdits(recordsWithPendingEdits);
        var queryObjsForRecordsWithoutPendingEdits = getQueryObjsForRecordsWithoutPendingEdits(recordsWithoutPendingEdits);
        var queryObjects = [];
        Array.prototype.push.apply(queryObjects, queryObjsForRecordsWithPendingEdits);
        Array.prototype.push.apply(queryObjects, queryObjsForRecordsWithoutPendingEdits);
        return queryObjects;
    }
    /**
     * Classifies records depending on whether the records has pending edits.
     * @param sdkObject Object containing the records to be classified.
     * @returns {{}} Classified records.
     */
    async function classifyRecordsAccordingToPendingEdits(sdkObject) {
        var recordsWithPendingEdits = {};
        var recordsWithoutPendingEdits = {};
        var classifiedRecords = sdkObject.recordsClassifedWithRecordAction;
        for (var recordAction in classifiedRecords) {
            var recordsWithPendingEditsForRecordAction = [];
            var recordsWithoutPendingEditsForRecordAction = [];
            for (var i = 0; i < classifiedRecords[recordAction].length; i++) {
                var record = classifiedRecords[recordAction][i];
                var primaryKeyValuePair = record.getPrimaryKeyValueMapOfRecord(record.getParentObject().getPrimaryKeys());
                var selectedRecord = await buildAndExecutePreparedStatementsOfTypeRead(record.getParentObject().getMetadata().name, KSTableType.ORIGINAL, primaryKeyValuePair, null);
                if (!KSCommonUtils.isNullOrEmptyObject(selectedRecord)) {
                    //Add record to recordsWithPendingEdits..
                    recordsWithPendingEditsForRecordAction.push(record);
                } else {
                    //Add record to recordWithoutPendingEdits..
                    recordsWithoutPendingEditsForRecordAction.push(record);
                }
            }
            recordsWithPendingEdits[recordAction] = recordsWithPendingEditsForRecordAction;
            recordsWithoutPendingEdits[recordAction] = recordsWithoutPendingEditsForRecordAction;
        }
        return {
            "recordsWithPendingEdits": recordsWithPendingEdits,
            "recordsWithoutPendingEdits": recordsWithoutPendingEdits
        };
    }
    /**
     * Method to build query objects for records with pending edits in the original table.
     * @param recordsWithPendingEdits Array of records with pending edits.
     * @returns {Array} Array of query objects to be inserted into the original table.
     */
    function getOriginalTableQueriesForPendingEdits(recordsWithPendingEdits) {
        var queryObjects = [];
        for (var recordAction in recordsWithPendingEdits) {
            var classifiedRecords = recordsWithPendingEdits[recordAction];
            var action = (recordAction == KSSDKObjectRecordAction.DELETE) ? KSSDKObjectRecordAction.CREATE : KSSDKObjectRecordAction.UPDATE;
            for (var i = 0; i < classifiedRecords.length; i++) {
                queryObjects.push(KSSQLQueryGenerator.getInsertQueryObjectForOriginalTable(classifiedRecords[i], action));
            }
        }
        return queryObjects;
    }
    /**
     * Method to build query objects for records with pending edits in the history table.
     * @param recordsWithPendingEdits Array of records with pending edits.
     * @returns {Array} Array of query objects to be inserted into the history table.
     */
    function getHistoryTableQueriesForPendingEdits(recordsWithPendingEdits) {
        var queryObjects = [];
        for (var recordAction in recordsWithPendingEdits) {
            var classifiedRecords = recordsWithPendingEdits[recordAction];
            Array.prototype.push.apply(queryObjects, KSSQLQueryGenerator.getUpdateChecksumQueryObject(classifiedRecords, KSTableType.HISTORY));
        }
        return queryObjects;
    }
    /**
     * Method to build query objects for records with pending edits in the main table.
     * @param recordsWithPendingEdits Array of records with pending edits.
     * @returns {Array} Array of query objects to be inserted into the main table.
     */
    function getMainTableQueriesForPendingEdits(recordsWithPendingEdits) {
        var queryObjects = [];
        for (var recordAction in recordsWithPendingEdits) {
            var classifiedRecords = recordsWithPendingEdits[recordAction];
            Array.prototype.push.apply(queryObjects, KSSQLQueryGenerator.getUpdateChecksumQueryObject(classifiedRecords, KSTableType.MAIN));
        }
        return queryObjects;
    }
    /**
     * Method to fetch the query objects for records with pending edits.
     * @param recordsWithPendingEdits Array of records which have pending edits.
     * @returns {Array}  Array of query objects generated to handle pending edits.
     */
    function getQueryObjsForRecordsWithPendingEdits(recordsWithPendingEdits) {
        var queryObjs = [];
        if (!KSCommonUtils.isNullOrEmptyObject(recordsWithPendingEdits)) {
            Array.prototype.push.apply(queryObjs, getMainTableQueriesForPendingEdits(recordsWithPendingEdits));
            Array.prototype.push.apply(queryObjs, getHistoryTableQueriesForPendingEdits(recordsWithPendingEdits));
            Array.prototype.push.apply(queryObjs, getOriginalTableQueriesForPendingEdits(recordsWithPendingEdits));
        }
        return queryObjs;
    }
    /**
     * Method to generate queries for records without pending edits.
     * @param records Records for which query needs to be generated.
     * @returns {*|Array} Array of query object.
     */
    function getQueryObjsForRecordsWithoutPendingEdits(records) {
        return KSSQLQueryGenerator.getSQLDataQueries(records, false);
    }
    /**
     * Method for build and executes statements for type select.
     * @param tableName Name of the table.
     * @param tableType Type of table on which READ needs to be performed.
     * @param whereClause Map containing where clause
     * @param orderBy OrderBy map.
     * @returns Object Selected records.
     */
    async function buildAndExecutePreparedStatementsOfTypeRead(tableName, tableType, whereClause, orderBy) {
        var queryObj = KSSQLQueryGenerator.buildPreparedStatementsOfTypeRead(tableName, tableType, whereClause, orderBy);
        return await KSDatabaseAPI.executeQuery(queryObj);
    }
    /**
     * Method for build and executes statements for type select.
     * @return {Promise}
     */
    async function dropDatabase() {
        return await KSDatabaseAPI.dropDatabase(KSCommonUtils.getOfflineObjectsDatabaseName());
    }
    /**
     * Gets the list of edits in history as records and adds them to objects, and return the list.
     * @param sdkObjects list of objects under a object service or an object
     * @return {Promise<Array>} Array of objects to upload
     */
    async function getDeltaChangesToUpload(sdkObjects) {
        var objectsToUpload = [];
        var sdkObjectsLength = sdkObjects.length;
        for (var index = 0; index < sdkObjectsLength; index++) {
            var sdkObject = sdkObjects[index];
            sdkObject.removeAllRecords();
            var lastRSNOfObjectService = await getLastReplaySequenceNumberOfObjectService(sdkObject.getObjectServiceName());
            var whereClause = KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER + " <= " + lastRSNOfObjectService + " AND " + KSMarkForUploadUtils.getDeferredActionCodesAsString();
            var query = KSSQLQueryGenerator.buildStatementOfTypeReadWithWhereConditionAsString(sdkObject.getFullyQualifiedName(), KSTableType.HISTORY, whereClause);
            var records = await KSDatabaseAPI.executeQuery(query);
            if (records.length > 0) {
                sdkObject.setRecords(populateSdkRecordsFromRecordsDicToUpload(records, sdkObject));
                objectsToUpload.push(sdkObject);
            }
        }
        return objectsToUpload;
    }
    /**
     * Constructs the SDKObjectRecords from the list of records from database.
     * @param recordsFromDB list of edited records form database
     * @param sdkobject the object under which edits are performed
     * @return {Array} Array of SDKObjectRecords.
     */
    function populateSdkRecordsFromRecordsDicToUpload(recordsFromDB, sdkobject) {
        var records = [];
        var recordsFromDBLength = recordsFromDB.length;
        for (var index = 0; index < recordsFromDBLength; index++) {
            var action;
            var record = recordsFromDB[index];
            if (record[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] === KSSDKObjectRecordAction.DO_NOT_TRACK_INTERMEDIATE_UPDATES) {
                action = kony.sdk.OfflineObjects.getValueOfRecordActionAsString[KSSDKObjectRecordAction.UPDATE];
            } else {
                action = kony.sdk.OfflineObjects.getValueOfRecordActionAsString[record[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE]];
            }
            var checksum = record[KSDatabaseConstants.KONY_SYNC_HASH_SUM];
            var rowId = record[KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER];
            KSCommonUtils.removeUnwantedColumns(sdkobject.getMetadata(), record);
            KSCommonUtils.removeColumnsWithNullValues(record);
            var sdkObjectRecord = new KSSDKObjectRecord(record, sdkobject);
            sdkObjectRecord.setAction(action);
            sdkObjectRecord.setCheckSum(!KSCommonUtils.isNullOrEmptyObject(checksum) ? checksum : "");
            sdkObjectRecord.setRowid(rowId);
            records.push(sdkObjectRecord);
        }
        return records;
    }
    /**
     * Method to check the relationships and accordingly sorting the list of SDK Objects.
     *
     * @param sdkObjectMetadata Metadata of the SDK Object which needs to be topologically sorted.
     * @param visitedSDKObjects Dictionary keeping track of the SDK Objects already topologically sorted.
     * @param responseSDKObjects Dictionary containing the name and SDK Object received in the response.
     * @param sortedSDKObjects Topologically sorted list of SDK Objects received in the response.
     */
    function topologicalSortUtil(sdkObjectMetadata, visitedSDKObjects, responseSDKObjects, sortedSDKObjects) {
        visitedSDKObjects[sdkObjectMetadata.fullyQualifiedName] = true;
        var relationships = sdkObjectMetadata.childRelationships;
        var lengthOfRelationships = relationships.length;
        for (var i = 0; i < lengthOfRelationships; i++) {
            var relationship = relationships[i];
            var childObjectMetadata;
            if (relationship.type === KSRelationshipTypes.ONE_TO_MANY) {
                childObjectMetadata = relationship.target_object;
            } else if (relationship.type === KSRelationshipTypes.MANY_TO_ONE) {
                childObjectMetadata = relationship.source_object;
            }
            var isVisited = visitedSDKObjects[childObjectMetadata.fullyQualifiedName];
            if (isVisited === false) {
                topologicalSortUtil(childObjectMetadata, visitedSDKObjects, responseSDKObjects, sortedSDKObjects);
            }
        }
        var sdkObject = responseSDKObjects[sdkObjectMetadata.fullyQualifiedName];
        if (!kony.sdk.isNullOrUndefined(sdkObject)) {
            sortedSDKObjects.push(sdkObject);
        }
    }
    /**
     *  Method to topologically sort the list of SDK Objects.
     *
     * @param listOfSDKObjects List of SDK Objects to be topologically sorted.
     */
    function topologicalSort(listOfSDKObjects) {
        var sortedSDKObjects = [];
        var visitedSDKObjects = {};
        var responseSDKObjects = {};
        var lengthOfSDKObjectsList = listOfSDKObjects.length;
        for (var i = 0; i < lengthOfSDKObjectsList; i++) {
            var sdkObject = listOfSDKObjects[i];
            visitedSDKObjects[sdkObject.metadata.fullyQualifiedName] = false;
            responseSDKObjects[sdkObject.metadata.fullyQualifiedName] = sdkObject;
        }
        for (var objectName in responseSDKObjects) {
            var isVisited = visitedSDKObjects[objectName];
            if (isVisited === false) {
                topologicalSortUtil(responseSDKObjects[objectName].metadata, visitedSDKObjects, responseSDKObjects, sortedSDKObjects);
            }
        }
        return sortedSDKObjects;
    }
    /**
     * Method to persist the upload response for given list of SDK objects.
     *
     * @param sdkObjects list of objects to be persisted.
     */
    async function persistUploadResponseForObjects(sdkObjects) {
        sdkObjects = topologicalSort(sdkObjects);
        kony.sdk.logsdk.debug("persistUploadResponseForObjects has been started");
        var sdkObjectsLen = sdkObjects.length;
        for (var index = 0; index < sdkObjectsLen; index++) {
            var uploadResponseFilterMap = sdkObjects[index].getUploadResponseFilterMap();
            var sdkObject = sdkObjects[index];
            for (var primaryKeyValueMap in uploadResponseFilterMap) {
                var statementsToExecuteInTransaction = [];
                var uploadRecordFilter = uploadResponseFilterMap[primaryKeyValueMap];
                var updatedPrimaryKeyValueMap = JSON.parse(primaryKeyValueMap);
                var tableName = sdkObject.getFullyQualifiedName();
                var latestSuccessRecord = uploadRecordFilter.getLatestSuccessRecord();
                var latestSuccessRecordRowId = uploadRecordFilter.getLatestSuccessRecordRowId();
                if (!kony.sdk.isNullOrUndefined(latestSuccessRecord)) {
                    kony.sdk.logsdk.debug("Filtered the records with given primary-key value " + primaryKeyValueMap + " has latestSuccessRecord  with rowId is " + latestSuccessRecordRowId);
                    //Gets the list of records in history with given latest success rowid and primary key value pair
                    // If the list of pending edits not considered in the current upload in history is 0 , we will delete the records in history and original with given primary key value pair
                    // and update the main table with autogen and checksum based on action
                    // else if they are pending edits then we update the original table with latest success record data , autogenkey, checksum, then we update history table pending
                    // edits for auto-gen pks and checksum  and update main table for autogen key value and checksum
                    //Update the Pk's with given value's from server
                    if (uploadRecordFilter.areAnyPKAutoGenerated()) {
                        Array.prototype.push.apply(statementsToExecuteInTransaction, updateTheAutoGenPkInGivenObject(tableName, uploadRecordFilter.getPrimaryKeyValuePair(), updatedPrimaryKeyValueMap));
                    }
                    //Get the records in history for last edit greater than the rowId of success record
                    var lastRecordsEditedInHistory = await getPendingRecordsFromHistoryForGivenPK(uploadRecordFilter.getPrimaryKeyValuePair(), latestSuccessRecordRowId, sdkObject.getFullyQualifiedName());
                    //Form the delete queries for history table to delete
                    statementsToExecuteInTransaction.push(getDeletePreparedStatementForHistory(tableName, updatedPrimaryKeyValueMap, latestSuccessRecordRowId));
                    if (lastRecordsEditedInHistory.length === 0) {
                        kony.sdk.logsdk.debug("No pending edits in history table for the given record with primary-key value pair " + primaryKeyValueMap);
                        //delete query in original table for give primary key value pair
                        statementsToExecuteInTransaction.push(getDeletePreparedStatementForOriginal(tableName, updatedPrimaryKeyValueMap));
                        //insert queries to main table
                        statementsToExecuteInTransaction.push(KSSQLQueryGenerator.getPreparedStatementToPerformActionOnMainTable(latestSuccessRecord, updatedPrimaryKeyValueMap));
                    } else {
                        kony.sdk.logsdk.debug("there are pending edits or failed records in history table for the record with primary-key value pair " + primaryKeyValueMap);
                        //insert query in original
                        statementsToExecuteInTransaction.push(getUpdatePreparedStatementForOriginal(latestSuccessRecord, updatedPrimaryKeyValueMap, kony.sdk.OfflineObjects.getReverseActionType(latestSuccessRecord.getAction())));
                        var updateMap = {};
                        updateMap[KSDatabaseConstants.KONY_SYNC_HASH_SUM] = latestSuccessRecord.getCheckSum();
                        //Update query in History table
                        statementsToExecuteInTransaction.push(getUpdatePreparedStatementForHistory(tableName, updatedPrimaryKeyValueMap, updateMap));
                        //update query in Main table
                        statementsToExecuteInTransaction.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.MAIN, updatedPrimaryKeyValueMap, updateMap));
                    }
                    if (uploadRecordFilter.areAnyPKAutoGenerated()) {
                        kony.sdk.logsdk.debug("there is an auto-generated pk value pair, so child tables needs to be updated with auto-gen key value from server");
                        Array.prototype.push.apply(statementsToExecuteInTransaction, getQueryStatementsForUpdatingFKsInChildTablesForAutoGeneratedPKsInParent(sdkObject.getMetadata(), uploadRecordFilter.getPrimaryKeyValuePair(), updatedPrimaryKeyValueMap));
                    }
                    await KSDatabaseAPI.executeQueries(statementsToExecuteInTransaction, true);
                }
            }
        }
    }
    /**
     * Forms the query statements to update the auto-gen pk in history,main and original table of related children.
     * @param parentObjectMetadata metadata of object to update auto-gen in all relations
     * @param autoGenKeyValuePair  map of primary-keys to its value's of a record from the server.
     * @param updatedKeyValue
     * @return {Array}  list of query statements to update the child tables auto-gen pk.
     */
    function getQueryStatementsForUpdatingFKsInChildTablesForAutoGeneratedPKsInParent(parentObjectMetadata, autoGenKeyValuePair, updatedKeyValue) {
        var statementsToExecuteInChild = [];
        var relationships = parentObjectMetadata[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS];
        var parentObjectAttributes = [];
        var childObjectAttributes = [];
        //Checking for child relationships
        var relationsLength = relationships.length;
        for (var index = 0; index < relationsLength; index++) {
            var relationship = relationships[index];
            var childObjectMetaData = null;
            if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.ONE_TO_MANY) {
                childObjectMetaData = relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT];
                parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
                childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
            } else if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.MANY_TO_ONE) {
                childObjectMetaData = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT];
                parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
                childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
            }
            if (childObjectMetaData != null) {
                var autoGenForeignKeyValueMap = KSCommonUtils.getForeignKeyValueMap(autoGenKeyValuePair, childObjectAttributes, parentObjectAttributes);
                var updatedAutoGenKeyValueMapFromServer = KSCommonUtils.getForeignKeyValueMap(updatedKeyValue, childObjectAttributes, parentObjectAttributes);
                var fullyQualifiedName = childObjectMetaData[KSInternalConstants.FULLY_QUALIFIED_NAME];
                if (Object.keys(autoGenForeignKeyValueMap).length > 0 && Object.keys(updatedAutoGenKeyValueMapFromServer).length > 0) {
                    statementsToExecuteInChild.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(fullyQualifiedName, KSTableType.MAIN, autoGenForeignKeyValueMap, updatedAutoGenKeyValueMapFromServer));
                    statementsToExecuteInChild.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(fullyQualifiedName, KSTableType.HISTORY, autoGenForeignKeyValueMap, updatedAutoGenKeyValueMapFromServer));
                    statementsToExecuteInChild.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(fullyQualifiedName, KSTableType.ORIGINAL, autoGenForeignKeyValueMap, updatedAutoGenKeyValueMapFromServer));
                    if (parentObjectMetadata !== childObjectMetaData) {
                        Array.prototype.push.apply(statementsToExecuteInChild, getQueryStatementsForUpdatingFKsInChildTablesForAutoGeneratedPKsInParent(childObjectMetaData, autoGenForeignKeyValueMap, updatedAutoGenKeyValueMapFromServer));
                    }
                }
            }
        }
        return statementsToExecuteInChild;
    }
    /**
     * Forms a list of statements to update the pk in history, main and original
     * @param tableName            tableName to update its auto-gen
     * @param whereMapForAutoGen   where condition to check the auto-gen value's
     * @param updateMapForAutoGen  update map which contains the updated auto-gen value from server
     * @return {Array}  list of query statements
     */
    function updateTheAutoGenPkInGivenObject(tableName, whereMapForAutoGen, updateMapForAutoGen) {
        var statementsToExecute = [];
        statementsToExecute.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.MAIN, whereMapForAutoGen, updateMapForAutoGen));
        statementsToExecute.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.HISTORY, whereMapForAutoGen, updateMapForAutoGen));
        statementsToExecute.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.ORIGINAL, whereMapForAutoGen, updateMapForAutoGen));
        return statementsToExecute;
    }
    /**
     * Returns the list of edits after a latestSuccessRecordRowId.
     * @param primaryKeyValuePair       to form the where condition.
     * @param latestSuccessRecordRowId  used in where condition, > the given rowId.
     * @param tableName                 the tableName on which query to execute.
     * @return {Promise<Array>} list of records > given rowId in history.
     */
    async function getPendingRecordsFromHistoryForGivenPK(primaryKeyValuePair, latestSuccessRecordRowId, tableName) {
        var whereCondition = buildWhereConditionAsString(primaryKeyValuePair);
        var ruleForReplaySequenceNumber = [];
        ruleForReplaySequenceNumber.push(KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER);
        ruleForReplaySequenceNumber.push(">");
        ruleForReplaySequenceNumber.push(latestSuccessRecordRowId);
        whereCondition.push(["AND"]);
        whereCondition.push(ruleForReplaySequenceNumber);
        var queryObj = KSSQLQueryGenerator.buildPreparedStatementsOfTypeRead(tableName, KSTableType.HISTORY, whereCondition);
        return await KSDatabaseAPI.executeQuery(queryObj);
    }
    /**
     * Forms the query statement to delete the edits which are less than the given rowId.
     * @param tableName                  the tableName on which query to execute.
     * @param primaryKeyValuePair        to form the where condition.
     * @param latestSuccessRecordRowId   used in where condition, <= the given rowId.
     * @return {*} returns query statements.
     */
    function getDeletePreparedStatementForHistory(tableName, primaryKeyValuePair, latestSuccessRecordRowId) {
        var whereCondition = buildWhereConditionAsString(primaryKeyValuePair);
        var ruleForReplaySequenceNumber = [];
        ruleForReplaySequenceNumber.push(KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER);
        ruleForReplaySequenceNumber.push("<=");
        ruleForReplaySequenceNumber.push(latestSuccessRecordRowId);
        whereCondition.push(["AND"]);
        whereCondition.push(ruleForReplaySequenceNumber);
        return KSSQLQueryGenerator.buildPreparedStatementsOfTypeDelete(tableName, KSTableType.HISTORY, whereCondition);
    }
    /**
     *  It converts into array of arrays such as [["col1","==","val1"],["AND"],["col2","=","val2"]]
     * @param primaryKeyValuePair
     * @return []  clause formed by appending AND to given primary key value pair as array.
     */
    function buildWhereConditionAsString(primaryKeyValuePair) {
        var whereConditionArray = [];
        for (var primaryKey in primaryKeyValuePair) {
            var rule = [];
            rule.push(primaryKey);
            rule.push("=");
            rule.push(primaryKeyValuePair[primaryKey]);
            whereConditionArray.push(rule);
            whereConditionArray.push(["AND"]);
        }
        whereConditionArray = whereConditionArray.slice(0, -1);
        return whereConditionArray;
    }
    /**
     * Forms Query Statement to delete the entry in original table
     * @param tableName  the tableName on which query to execute.
     * @param whereMap
     * @return Delete Query statement for original table.
     */
    function getDeletePreparedStatementForOriginal(tableName, whereMap) {
        return KSSQLQueryGenerator.buildPreparedStatementsOfTypeDelete(tableName, KSTableType.ORIGINAL, whereMap);
    }
    /**
     * Forms Query Statement to update the entry in original table for given pk-value pair.
     * @param sdkObjectRecord      Data to be updated
     * @param primaryKeyValuePair  data to updated for given pk-value pair.
     * @param actionType           reverse action type of last successful sync at server end.
     * @return Update query statement for original table.
     */
    function getUpdatePreparedStatementForOriginal(sdkObjectRecord, primaryKeyValuePair, actionType) {
        var whereCondition = buildWhereConditionAsString(primaryKeyValuePair);
        var updateData = {};
        KSCommonUtils.mergeTwoJSONMaps(updateData, sdkObjectRecord.getData());
        //We get the latest action type from the record after first edit
        updateData[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = actionType;
        updateData[KSDatabaseConstants.KONY_SYNC_HASH_SUM] = sdkObjectRecord.getCheckSum();
        return KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(sdkObjectRecord.getParentObject().getFullyQualifiedName(), KSTableType.ORIGINAL, whereCondition, updateData);
    }
    /**
     * Forms Query Statement to update the entries in history table for given pk-value pair.
     * @param tableName            the tableName on which query to execute.
     * @param primaryKeyValuePair  data to updated for given pk-value pair.
     * @param updateMap            Data to be updated
     * @return Update query statement for history table.
     */
    function getUpdatePreparedStatementForHistory(tableName, primaryKeyValuePair, updateMap) {
        var whereCondition = buildWhereConditionAsString(primaryKeyValuePair);
        return KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.HISTORY, whereCondition, updateMap);
    }
    /**
     * Method to fetch the last ReplaySequenceNumber for the given objectService
     *
     * @param objectServiceName the name of the object service
     * @return LastReplaySequenceNumber the last RSN for an object service
     */
    async function getLastReplaySequenceNumberOfObjectService(objectServiceName) {
        var KSSDKObjectService = require("KSSDKObjectService");
        var objectService = KSSDKObjectService.getInstanceByName(objectServiceName);
        var syncMetaInfo = await objectService.getSyncMetaInfo();
        return syncMetaInfo.getLastReplaySequenceNumber();
    }
    /**
     * Builds PreparedStatements for Rollback for an Object
     *
     * @param sdkObject          for which PreparedStatements have to be built
     * @param primaryKeyValueMap of record only for which rollback should happen
     * @return list of preparedStatements for rollback
     */
    async function buildPreparedStatementsForObjectRollback(sdkObject, primaryKeyValueMap) {
        kony.sdk.logsdk.debug("Building Prepared Statements to rollback on object : " + sdkObject.name);
        var preparedStatementsToRollback = [];
        var metadata = sdkObject.getMetadata();
        var fullyQualifiedName = metadata.fullyQualifiedName;
        var readPreparedStatementForOriginalTable;
        if (KSCommonUtils.isNullOrEmptyObject(primaryKeyValueMap)) {
            readPreparedStatementForOriginalTable = KSSQLQueryGenerator.buildPreparedStatementsOfTypeRead(fullyQualifiedName, KSTableType.ORIGINAL);
        } else {
            readPreparedStatementForOriginalTable = KSSQLQueryGenerator.buildPreparedStatementsOfTypeRead(fullyQualifiedName, KSTableType.ORIGINAL, primaryKeyValueMap);
        }
        var recordsInOriginalTable = await KSDatabaseAPI.executeQuery(readPreparedStatementForOriginalTable);
        var recordsInOriginalTableLength = recordsInOriginalTable.length;
        for (var index = 0; index < recordsInOriginalTableLength; index++) {
            Array.prototype.push.apply(preparedStatementsToRollback, buildPreparedStatementsToRollbackForARecordInObject(recordsInOriginalTable[index], sdkObject));
        }
        return preparedStatementsToRollback;
    }
    /**
     * Builds Prepared Statements to Rollback all tables of given object of given record
     *
     * @param sdkObject             on which rollback should happen
     * @param recordInOriginalTable for which rollback should happen
     * @return {Array} Prepared Statements to Rollback Main Table of given object
     **/
    function buildPreparedStatementsToRollbackForARecordInObject(recordInOriginalTable, sdkObject) {
        kony.sdk.logsdk.debug("Building Prepared Statements to rollback for a record in object : " + sdkObject.name);
        var statements = [];
        var metadata = sdkObject.getMetadata();
        var fullyQualifiedName = metadata.fullyQualifiedName;
        var primaryKeyValueMap = getPrimaryKeyValueMapForGivenRecord(sdkObject, recordInOriginalTable);
        //Building Prepared Statements for Original Table
        statements.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeDelete(fullyQualifiedName, KSTableType.ORIGINAL, primaryKeyValueMap));
        //Building Prepared Statements for History Table
        statements.push(KSSQLQueryGenerator.buildPreparedStatementsOfTypeDelete(fullyQualifiedName, KSTableType.HISTORY, primaryKeyValueMap));
        //Building PreparedStatements for MainTable
        var actionType = recordInOriginalTable[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE];
        delete recordInOriginalTable[KSDatabaseConstants.UPLOAD_SESSION_NO];
        delete recordInOriginalTable[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE];
        statements.push(buildPreparedStatementFromActionTypeForRollback(recordInOriginalTable, actionType, fullyQualifiedName, primaryKeyValueMap));
        return statements;
    }

    function getPrimaryKeyValueMapForGivenRecord(sdkObject, record) {
        kony.sdk.logsdk.debug("Getting primary key value map for given Object : " + sdkObject.name);
        var primaryKeyAttributes = sdkObject.getPrimaryKeys();
        var primaryKeyValueMap = {};
        var primaryKeyAttributesLength = primaryKeyAttributes.length;
        for (var index = 0; index < primaryKeyAttributesLength; index++) {
            primaryKeyValueMap[primaryKeyAttributes[index]] = record[primaryKeyAttributes[index]];
        }
        return primaryKeyValueMap;
    }
    /**
     * Builds Prepared Statements to Rollback MainTable from the given action type
     *
     * @param record     data from original table
     * @param actionType depending on which prepared statement has to be built
     * @param tableName  on which rollback should happen
     * @param primaryKeyValueMap primary-key value pair JSON
     * @return Prepared Statements to Rollback MainTable from the given action type
     * */
    function buildPreparedStatementFromActionTypeForRollback(record, actionType, tableName, primaryKeyValueMap) {
        kony.sdk.logsdk.debug("Building Prepared Statement for ActionType :  " + actionType + "for table : " + tableName);
        switch (actionType) {
            case KSSDKObjectRecordAction.CREATE:
            case KSSDKObjectRecordAction.DEFERRED_CREATE:
                return KSSQLQueryGenerator.buildPreparedStatementsOfTypeDelete(tableName, KSTableType.MAIN, primaryKeyValueMap);
            case KSSDKObjectRecordAction.UPDATE:
            case KSSDKObjectRecordAction.DELETE:
            case KSSDKObjectRecordAction.PARTIAL_UPDATE:
            case KSSDKObjectRecordAction.DEFERRED_UPDATE:
            case KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES:
            case KSSDKObjectRecordAction.DEFERRED_DELETE:
                return KSSQLQueryGenerator.buildQueryObjectsOfTypeInsertOrReplace(tableName, KSTableType.MAIN, record);
            default:
                var errorMessage = "Invalid ActionType received" + actionType;
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.SYNC_GENERIC_ROLLBACK_ERROR, errorMessage);
        }
    }
    /**
     * Builds PreparedStatements for Rollback for an Application
     * @return list of preparedStatements for rollback
     */
    async function buildPreparedStatementsForApplicationRollback() {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Building PreparedStatements For Rollback on Application Start.");
        var preparedStatementsForRollback = [];
        var setupManager = KSSetupManager.getInstance();
        var objectServiceListContext = setupManager.getSetupContext();
        for (var objectServiceName in objectServiceListContext) {
            var sdkObjectService = KSSDKObjectService.getInstanceByName(objectServiceName);
            Array.prototype.push.apply(preparedStatementsForRollback, await sdkObjectService.buildPreparedStatementsForObjectServiceRollback());
        }
        return preparedStatementsForRollback;
    }
    /**
     * Method to build whereClause for deferred records and track intermediate updates set to false
     *
     * @param options options containing primary key value pairs
     * @return {Array} Array of whereCondition
     */
    function buildWhereConditionToFetchRecordsWithDeferredAndTrackIntermediateUpdateSetToFalse(options) {
        var primaryKeyValuePair = options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS];
        var whereCondition = buildWhereConditionAsString(primaryKeyValuePair);
        var ruleForDoNotTrackIntermediateUpdates = [];
        var ruleForDeferredAndDoNotTrackIntermediateUpdates = [];
        ruleForDeferredAndDoNotTrackIntermediateUpdates.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE);
        ruleForDeferredAndDoNotTrackIntermediateUpdates.push(KSInternalConstants.GREATER_THAN_EQUALS_TO);
        ruleForDeferredAndDoNotTrackIntermediateUpdates.push(KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES);
        ruleForDoNotTrackIntermediateUpdates.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE);
        ruleForDoNotTrackIntermediateUpdates.push(KSInternalConstants.LESS_THAN_EQUALS_TO);
        ruleForDoNotTrackIntermediateUpdates.push(KSSDKObjectRecordAction.DO_NOT_TRACK_INTERMEDIATE_UPDATES);
        whereCondition.push([KSDatabaseConstants.LOGICAL_AND]);
        whereCondition.push(ruleForDeferredAndDoNotTrackIntermediateUpdates);
        whereCondition.push([KSDatabaseConstants.LOGICAL_AND]);
        whereCondition.push(ruleForDoNotTrackIntermediateUpdates);
        // Query for ex : UserID = 91 AND konysyncchangetype >= 70 AND konysyncchangetype <= 80
        return whereCondition;
    }
    /**
     * Method to fetch number of records deferred and track intermediate updates set to off
     *
     * options options containing primary key value pair
     * tableName tableName from which the records are needed
     */
    async function getNumberOfRecordsDeferredAndTrackIntermediateUpdateSetToFalse(options, tableName) {
        var whereClause = buildWhereConditionToFetchRecordsWithDeferredAndTrackIntermediateUpdateSetToFalse(options);
        var queryObj = KSSQLQueryGenerator.buildPreparedStatementsOfTypeRead(tableName, KSTableType.HISTORY, whereClause);
        var records = await KSDatabaseAPI.executeQuery(queryObj);
        return records.length;
    }
    /**
     * Builds update prepared statements for track intermediate upates
     *
     * sdkRecord sdkRecord on which update should be done
     * options options containing primary key value pair
     * tableName table on which update needs to be performed
     * @return update query
     */
    function buildUpdatePreparedStatementForTrackIntermediateUpdatesRecord(sdkRecord, options, tableName) {
        var whereClause = buildWhereConditionToFetchRecordsWithDeferredAndTrackIntermediateUpdateSetToFalse(options);
        var queryObj = KSSQLQueryGenerator.buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.HISTORY, whereClause, sdkRecord.getData());
        return queryObj;
    }
    exports.dropDatabase = dropDatabase;
    exports.getDeltaChangesToUpload = getDeltaChangesToUpload;
    exports.buildWhereConditionAsString = buildWhereConditionAsString;
    exports.persistUploadResponseForObjects = persistUploadResponseForObjects;
    exports.buildQueriesToPersistChangesForObjects = buildQueriesToPersistChangesForObjects;
    exports.executePreparedStatementsAsTransaction = executePreparedStatementsAsTransaction;
    exports.getLastReplaySequenceNumberOfObjectService = getLastReplaySequenceNumberOfObjectService;
    exports.buildAndExecutePreparedStatementsOfTypeRead = buildAndExecutePreparedStatementsOfTypeRead;
    exports.buildPreparedStatementsForObjectRollback = buildPreparedStatementsForObjectRollback;
    exports.buildPreparedStatementsForApplicationRollback = buildPreparedStatementsForApplicationRollback;
    exports.buildUpdatePreparedStatementForTrackIntermediateUpdatesRecord = buildUpdatePreparedStatementForTrackIntermediateUpdatesRecord;
    exports.getNumberOfRecordsDeferredAndTrackIntermediateUpdateSetToFalse = getNumberOfRecordsDeferredAndTrackIntermediateUpdateSetToFalse;
});
// ************************************* Start of KonyNoSQLDatabaseHelper.js *************************************
define("KonyNoSQLDatabaseHelper", ["require", "exports", "KSCommonUtils", "KSError", "KSExceptionWrapperUtils"], function(require, exports, KSCommonUtils, _KSError, KSExceptionWrapperUtils) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var KonyNoSQLDatabaseHelper = /** @class */ (function() {
        var nosqlDBInstance = null;
        var nosqlTablesList = null;
        var nosqlDatabaseName = null;
        var LOG_PREFIX = "KonyNoSQLDatabaseHelper : ";
        var log = kony.sdk.logsdk;
        var KSError = _KSError.KSError;
        var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
        var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
        var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
        var KSDataTypes = KSDatabaseConstants.KSDataTypes;
        /**
         * Constructor KonyNoSQLDatabaseHelper
         */
        function KonyNoSQLDatabaseHelper() {
            //Empty Constructor
        }

        function resetKonyNoSQLDatabaseHelperGlobals() {
            log.trace(LOG_PREFIX + "[resetKonyNoSQLDatabaseHelperGlobals] called...");
            nosqlDBInstance = null;
            nosqlDatabaseName = null;
            KonyNoSQLDatabaseHelper.db = null;
            KonyNoSQLDatabaseHelper.dbTablesList = null;
        }

        function deleteKonyNoSQLDatabase(dbname, fulfill, fail) {
            log.trace(LOG_PREFIX + "[deleteKonyNoSQLDatabase] called...");
            kony.nosql.deleteDatabase(dbname).then(res => {
                log.debug(LOG_PREFIX, "[deleteKonyNoSQLDatabase] successful.");
                fulfill(res);
            }).catch(deleteDBError => {
                log.error(LOG_PREFIX, "[deleteKonyNoSQLDatabase] failed with database error: " + JSON.stringify(deleteDBError));
                fail(KSExceptionWrapperUtils.wrapDBException(deleteDBError));
            });
        }

        function isDataReconciliation(pks, data) {
            log.trace(LOG_PREFIX + "[isDataReconciliation] Primary keys: " + pks);
            var isReconciliation = false;
            if ((typeof pks) === KSDataTypes.STRING) {
                if (data.hasOwnProperty(pks)) {
                    isReconciliation = true;
                }
            } else {
                var pksLength = pks.length;
                for (var index = 0; index < pksLength; index++) {
                    if (data.hasOwnProperty(pks[index])) {
                        isReconciliation = true;
                    }
                }
            }
            log.debug(LOG_PREFIX, "[isDataReconciliation] Primary keys: " + pks + " is " + isReconciliation);
            return isReconciliation;
        }

        function getKonyNoSqlConditionFromMap(whereClauseMap) {
            log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromMap] called...");
            var whereCondition = null;
            if (!kony.sdk.isNullOrUndefined(whereClauseMap)) {
                for (var key in whereClauseMap) {
                    var rule = null;
                    if (whereClauseMap.hasOwnProperty(key)) {
                        rule = getKonyNoSqlRule(key, kony.nosql.EQ, whereClauseMap[key]);
                        if (whereCondition == null) {
                            log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromMap] creating the first rule...");
                            whereCondition = new kony.nosql.Condition(rule);
                        } else {
                            log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromMap] adding nextRule to the exiting condition...");
                            whereCondition.addRule(kony.nosql.AND, rule);
                        }
                    }
                }
            }
            return whereCondition;
        }

        function getKonyNoSqlConditionFromArray(whereClauseArray) {
            log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromArray] called...");
            var whereCondition = null;
            var conditionLength = whereClauseArray.length;
            var firstRuleArray = whereClauseArray[0];
            if (conditionLength === 1) {
                var LhsOperand = whereClauseArray[0][0];
                var operation = whereClauseArray[0][1];
                var RhsOperand = whereClauseArray[0][2];
                log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromArray] Creating a simple Condition with only one rule...");
                if ((typeof(LhsOperand)).toLowerCase() === "string") {
                    whereCondition = new kony.nosql.Condition(getKonyNoSqlRule(LhsOperand, operation, RhsOperand));
                    log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromArray] Generated condition Object from simple Rule =>" + whereCondition);
                }
            } else if (conditionLength >= 3) {
                log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromArray] Creating first Condition of the complex where condition array...");
                whereCondition = new kony.nosql.Condition(getKonyNoSqlRule(firstRuleArray[0], firstRuleArray[1], firstRuleArray[2]));
                for (var outerIndex = 1; outerIndex < conditionLength;) {
                    var conjunctionOperation = whereClauseArray[outerIndex][0];
                    var LhsRuleArray = whereClauseArray[outerIndex + 1];
                    log.trace(LOG_PREFIX + "[getKonyNoSqlConditionFromArray] Adding next Rule of the complex array to the existing condition...");
                    whereCondition.addRule(getLogicalKonyOperation(conjunctionOperation), getKonyNoSqlRule(LhsRuleArray[0], LhsRuleArray[1], LhsRuleArray[2]));
                    outerIndex += 2;
                }
            }
            return whereCondition;
        }

        function getKonyNoSqlWhereCondition(whereClause) {
            log.trace(LOG_PREFIX + "[getKonyNoSqlWhereCondition] called... with whereClause: " + JSON.stringify(whereClause));
            var konyNosqlCondition = null;
            if (!kony.sdk.isNullOrUndefined(whereClause) && kony.sdk.isArray(whereClause)) {
                konyNosqlCondition = getKonyNoSqlConditionFromArray(whereClause);
            } else {
                konyNosqlCondition = getKonyNoSqlConditionFromMap(whereClause);
            }
            log.debug(LOG_PREFIX, "[getKonyNoSqlWhereCondition] generated condition: " + JSON.stringify(konyNosqlCondition));
            return konyNosqlCondition;
        }

        function getKonyNoSqlRule(leftHandSide, operator, rightHandSide) {
            log.trace(LOG_PREFIX + "[getKonyNoSqlRule] called... " + leftHandSide + " " + operator + " " + rightHandSide);
            switch (operator) {
                case "=":
                case "==":
                case kony.nosql.EQ:
                    return new kony.nosql.Rule(leftHandSide, kony.nosql.EQ, rightHandSide);
                case "<":
                case kony.nosql.LT:
                    return new kony.nosql.Rule(leftHandSide, kony.nosql.LT, rightHandSide);
                case "<=":
                case kony.nosql.LTE:
                    return new kony.nosql.Rule(leftHandSide, kony.nosql.LTE, rightHandSide);
                case ">":
                case kony.nosql.GT:
                    return new kony.nosql.Rule(leftHandSide, kony.nosql.GT, rightHandSide);
                case ">=":
                case kony.nosql.GTE:
                    return new kony.nosql.Rule(leftHandSide, kony.nosql.GTE, rightHandSide);
                case "<>":
                case "!=":
                case kony.nosql.NEQ:
                    return new kony.nosql.Rule(leftHandSide, kony.nosql.NEQ, rightHandSide);
                default:
                    log.warn(LOG_PREFIX + "[getKonyNoSqlRule] No proper operator passed...");
                    return null;
            }
        }

        function getLogicalKonyOperation(logicalOperator) {
            log.trace(LOG_PREFIX + "[getLogicalKonyOperation] called..." + logicalOperator);
            switch (logicalOperator.toUpperCase()) {
                case "AND":
                    return kony.nosql.AND;
                case "OR":
                    return kony.nosql.OR;
            }
        }

        function updateRecordsInTable(txn, tableName, updatedData, condition, fulfill, fail) {
            log.trace(LOG_PREFIX + "[updateRecordsInTable] called...");
            kony.nosql.updateRecords(txn, tableName, updatedData, condition).then(function(resultSet) {
                log.trace(LOG_PREFIX, "[updateRecordsFromTable " + tableName + "] successful.");
                fulfill(resultSet);
            }).catch(function(error) {
                log.error(LOG_PREFIX, "[updateRecordsFromTable " + tableName + "] failed with error: " + JSON.stringify(error));
                fail(KSExceptionWrapperUtils.wrapDBException(error));
            });
        }

        function reconcilePKsInTable(txn, tableName, updatedData, condition, fulfill, fail) {
            log.trace(LOG_PREFIX + "[reconcilePKsInTable] called...");
            var existingData = [];
            if (kony.sdk.isNullOrUndefined(updatedData)) {
                fulfill(0);
                return;
            }
            kony.nosql.fetchRecords(txn, tableName, condition).then(resultSet => {
                while (resultSet.next) {
                    existingData.push(resultSet.record);
                }
                var existingDataLength = existingData.length;
                // Finish operation if there are no records after select operation
                if (existingDataLength === 0) {
                    log.trace(LOG_PREFIX + "[reconcilePKsInTable] No records to reconcile.");
                    fulfill(0);
                } else {
                    //reconcile the fetched result with the new data (updatedData with PK changes)
                    for (var index = 0; index < existingDataLength; index++) {
                        KSCommonUtils.mergeTwoJSONMaps(existingData[index], updatedData);
                    }
                    // delete older data
                    kony.nosql.deleteRecords(txn, tableName, condition).then(count => {
                        log.trace(LOG_PREFIX, "records to reconcile: " + count);
                        //insert the reconciled records(JSON) in database
                        kony.nosql.addRecords(txn, tableName, existingData).then(res => {
                            fulfill(existingDataLength);
                        }).catch(insertException => {
                            log.error(LOG_PREFIX, "reconcile failed: " + JSON.stringify(insertException));
                            fail(KSExceptionWrapperUtils.wrapDBException(insertException));
                        });
                    }).catch(deleteException => {
                        log.error(LOG_PREFIX, "reconcile failed with error: " + JSON.stringify(deleteException));
                        fail(KSExceptionWrapperUtils.wrapDBException(selectException));
                    });
                }
            }).catch(selectException => {
                log.error(LOG_PREFIX, "reconcile failed: " + JSON.stringify(selectException));
                fail(KSExceptionWrapperUtils.wrapDBException(selectException));
            });
        }

        function deleteRecordsFromTable(txn, tableName, condition, fulfill, fail) {
            log.trace(LOG_PREFIX + "[deleteRecordsFromTable] called...");
            kony.nosql.deleteRecords(txn, tableName, condition).then(function(resultSet) {
                log.trace(LOG_PREFIX, "[deleteRecordsFromTable " + tableName + "] successful.");
                fulfill(resultSet);
            }).catch(function(error) {
                log.error(LOG_PREFIX, "[deleteRecordsFromTable " + tableName + "] failed with error: " + JSON.stringify(error));
                fail(KSExceptionWrapperUtils.wrapDBException(error));
            });
        }

        function insertRecordsInTable(txn, tableName, data, fulfill, fail) {
            log.trace(LOG_PREFIX + "[insertRecordsInTable '" + tableName + "'] called...");
            kony.nosql.addRecords(txn, tableName, data).then(function(resultSet) {
                log.trace(LOG_PREFIX, "[insertRecordsInTable] successful.");
                fulfill(resultSet);
            }).catch(function(error) {
                log.error("[insertRecordsInTable] Failed to insert record with error: " + JSON.stringify(error));
                fail(KSExceptionWrapperUtils.wrapDBException(error));
            });
        }

        function insertOrReplaceRecordsInTable(txn, tableName, data, fulfill, fail) {
            log.trace(LOG_PREFIX + "[insertOrReplaceRecordsInTable '" + tableName + "'] called...");
            kony.nosql.addOrReplaceRecords(txn, tableName, data).then(function(resultSet) {
                log.trace(LOG_PREFIX, "[insertOrReplaceRecordsInTable] successful.");
                fulfill(resultSet);
            }).catch(function(error) {
                log.error(LOG_PREFIX, "[insertOrReplaceRecordsInTable] failed with error: " + JSON.stringify(error));
                fail(KSExceptionWrapperUtils.wrapDBException(error));
            });
        }

        function fetchRecordsFromTable(txn, tableName, condition, projectionColumns, orderby, limit, fulfill, fail) {
            log.trace(LOG_PREFIX + "[fetchRecordsFromTable] called...");
            var projectionRequired = false;
            var columnToSort, sortOrder;

            function orderByAsc(x, y) {
                log.trace(LOG_PREFIX + "[orderByAsc] called...");
                return ((x[columnToSort] == y[columnToSort]) ? 0 : ((x[columnToSort] > y[columnToSort]) ? 1 : -1));
            }

            function orderByDesc(x, y) {
                log.trace(LOG_PREFIX + "[orderByDesc] called...");
                return ((x[columnToSort] == y[columnToSort]) ? 0 : ((y[columnToSort] > x[columnToSort]) ? 1 : -1));
            }
            //check if projectionColumns is present
            if (!KSCommonUtils.isNullOrEmptyObject(projectionColumns)) {
                projectionRequired = true;
            }
            // get the orderbycolumn and sorting order(asc/desc)
            log.trace(LOG_PREFIX + "[fetchRecordsFromTable] orderby " + JSON.stringify(orderby));
            if (!kony.sdk.isNullOrUndefined(orderby)) {
                for (var key in orderby) {
                    if (orderby.hasOwnProperty(key)) {
                        // get the first key in map and use for sorting
                        columnToSort = key;
                        sortOrder = orderby[key] ? orderby[key].toUpperCase() : KSPublicConstants.ORDER_BY_DEFAULT;
                        break;
                    }
                }
            }
            //fetch records using kony.nosql.fetchRecords
            kony.nosql.fetchRecords(txn, tableName, condition).then(function(resultSet) {
                var resultArray = [];
                var resultSetCount = 0;
                while (resultSet.next) {
                    var currentRecord = resultSet.record;
                    resultSetCount++;
                    if (projectionRequired) {
                        var columnsInRecordColumns = Object.keys(currentRecord);
                        for (var index = 0; index < columnsInRecordColumns.length; index++) {
                            // delete unneccessary columns from results
                            if (projectionColumns.indexOf(columnsInRecordColumns[index]) === -1) {
                                delete currentRecord[columnsInRecordColumns[index]];
                            }
                        }
                    }
                    resultArray.push(currentRecord);
                }
                log.trace(LOG_PREFIX + "[fetchRecordsFromTable] resultSetCount: " + resultSetCount);
                log.trace(LOG_PREFIX + "[fetchRecordsFromTable] columnToSort: " + columnToSort);
                log.trace(LOG_PREFIX + "[fetchRecordsFromTable] sortOrder: " + sortOrder);
                //sort the resultArray
                if (resultSetCount > 1 && orderby) {
                    if (sortOrder === "DESC") {
                        resultArray.sort(orderByDesc);
                    } else {
                        resultArray.sort(orderByAsc);
                    }
                }
                // limit the resultArray according to the limit value
                if (!kony.sdk.isNullOrUndefined(limit) && (typeof limit).toLowerCase() === "number") {
                    if (limit < resultSetCount) {
                        resultArray.splice(limit);
                    }
                }
                fulfill(resultArray);
            }).catch(function(error) {
                log.error(LOG_PREFIX + "[fetchRecordsFromTable " + tableName + "] Failed to fetch records with error: " + JSON.stringify(error));
                fail(KSExceptionWrapperUtils.wrapDBException(error));
            });
        }

        function getDBNotInitializedError() {
            log.trace(LOG_PREFIX + "[getDBNotInitializedError] Database object is not initialized.");
            return new KSError(KSErrorConstants.DB_INSTANCE_NOT_INITIALIZED);
        }
        /**
         * Defining KSDatabaseOperation for CRUDS
         */
        KonyNoSQLDatabaseHelper.KSDatabaseOperation = kony.sdk.OfflineObjects.KSDatabaseConstants.KSDatabaseOperations;
        /**
         *
         * @param {*} dbname
         * @param {*} dbInfo
         */
        KonyNoSQLDatabaseHelper.getDBInstance = function(dbname, dbInfo) {
            log.trace(LOG_PREFIX + "[getDBInstance '" + dbname + "'] called...");
            return new Promise(function(resolve, reject) {
                if (KonyNoSQLDatabaseHelper.db === null || nosqlDBInstance === null) {
                    nosqlDatabaseName = dbname;
                    if (!kony.sdk.isNullOrUndefined(dbInfo)) {
                        nosqlTablesList = Object.keys(dbInfo);
                    }
                    KonyNoSQLDatabaseHelper.db = new KonyNoSQLDatabaseHelper();
                    KonyNoSQLDatabaseHelper.db.parseDatabaseSchema(dbInfo);
                    var upgradeCallback = function(kdb) {
                        for (var tableName in dbInfo) {
                            var config = KonyNoSQLDatabaseHelper.db.getTableConfig(dbInfo[tableName]);
                            kony.nosql.createTable(kdb, tableName, config)
                        }
                    };
                    var dbVersion = KSCommonUtils.getLatestDBVersion();
                    kony.nosql.openDatabase(dbname, dbVersion, upgradeCallback).then(db => {
                        KonyNoSQLDatabaseHelper.dbTablesList = Object.keys(dbInfo);
                        nosqlDBInstance = db;
                        log.trace(LOG_PREFIX + "[getDBInstance] Opened database '" + dbname + "' successfully.");
                        resolve(KonyNoSQLDatabaseHelper.db);
                    }).catch(openDBError => {
                        log.error(LOG_PREFIX + "[getDBInstance] Error occured while opening '" + dbname + "' database with error: " + JSON.stringify(openDBError));
                        reject(KSExceptionWrapperUtils.wrapDBException(openDBError));
                    });
                } else {
                    resolve(KonyNoSQLDatabaseHelper.db);
                }
            });
        };
        /**
         *
         * @param {*} schema
         */
        KonyNoSQLDatabaseHelper.prototype.parseDatabaseSchema = function(schema) {
            log.trace(LOG_PREFIX + "[parseDatabaseSchema] called...");
            var key = '';
            for (key in schema) {
                (function(table, value) {
                    var columns = [];
                    schema[table] = [];
                    columns = value.split(',');
                    columns.forEach(function(name) {
                        var column = {};
                        if (name[0] === '&') {
                            name = name.substr(1, name.length - 1);
                            schema[table].push({
                                name: name,
                                primaryKey: true
                            });
                        } else if (name[0] === '+' && name[1] === '+') {
                            name = name.substr(2, name.length - 1);
                            schema[table].push({
                                name: name,
                                primaryKey: true,
                                autoIncrement: true
                            });
                        } else if (name[0] === '[' && name[name.length - 1] === ']') {
                            name = name.substr(1, name.length - 2);
                            name = name.split('+');
                            name.forEach(function(col) {
                                schema[table].push({
                                    name: col,
                                    primaryKey: true
                                });
                            });
                        } else {
                            schema[table].push({
                                name: name
                            });
                        }
                    });
                }(key, schema[key]));
            }
        };
        /**
         *
         * @param {*} tableObj
         */
        KonyNoSQLDatabaseHelper.prototype.getPrimaryKeysFromTableSchema = function(tableObj) {
            log.trace(LOG_PREFIX + "[getPrimaryKeysFromTableSchema] called...");
            var keys = [];
            tableObj.forEach(function(column) {
                if (column.primaryKey) {
                    keys.push(column.name);
                }
            });
            log.trace(LOG_PREFIX + "[getPrimaryKeysFromTableSchema] returns: " + JSON.stringify(keys));
            return keys;
        };
        /**
         *
         * @param {*} tableObj
         */
        KonyNoSQLDatabaseHelper.prototype.getColumnsObject = function(tableObj) {
            log.trace(LOG_PREFIX + "[getColumnsObject] called..");
            var columnsObj = {};
            tableObj.forEach(function(column) {
                columnsObj[column.name] = {};
            });
            log.trace(LOG_PREFIX + "[getColumnsObject] returns: " + JSON.stringify(columnsObj));
            return columnsObj;
        };
        /**
         *
         * @param {*} tableObj
         */
        KonyNoSQLDatabaseHelper.prototype.getTableConfig = function(tableObj) {
            log.trace(LOG_PREFIX + "[getTableConfig] called..");
            var primaryKeys, tableConfig = {};
            primaryKeys = this.getPrimaryKeysFromTableSchema(tableObj);
            if (primaryKeys.length === 1) {
                primaryKeys = primaryKeys[0];
            }
            var columns = this.getColumnsObject(tableObj);
            tableConfig.primaryKey = primaryKeys;
            tableConfig.indexes = columns;
            log.trace(LOG_PREFIX + "[getTableConfig] returning: " + JSON.stringify(tableConfig));
            return tableConfig;
        };
        /**
         *
         */
        KonyNoSQLDatabaseHelper.prototype.getAllTablesList = function() {
            return new Promise(function(resolve, reject) {
                if (kony.sdk.isNullOrUndefined(nosqlDBInstance)) {
                    reject(getDBNotInitializedError());
                } else {
                    kony.nosql.getTables(nosqlDBInstance).then(tables => {
                        log.trace(LOG_PREFIX + "[getAllTablesList]  returns: " + JSON.stringify(tables));
                        resolve(tables);
                    }).catch(getTablesError => {
                        log.error(LOG_PREFIX + "[getAllTablesList]  failed: " + JSON.stringify(getTablesError));
                        reject(KSExceptionWrapperUtils.wrapDBException(getTablesError));
                    });
                }
            }); // End of custom Promise
        };
        /**
         *
         */
        KonyNoSQLDatabaseHelper.prototype.resetDatabaseConnection = function() {
            log.trace(LOG_PREFIX + "[resetDatabaseConnection] called...");
            //TODO: db.close();
        };
        /**
         *
         */
        KonyNoSQLDatabaseHelper.prototype.closeConnection = function() {
            log.trace(LOG_PREFIX + "[closeConnection] called...");
            return new Promise(function(resolve, reject) {
                kony.nosql.closeDatabase(nosqlDBInstance).then(res => {
                    log.error(LOG_PREFIX + "[closeConnection] successful.");
                    resetKonyNoSQLDatabaseHelperGlobals();
                    resolve(res);
                }).catch(closeException => {
                    log.error(LOG_PREFIX + "[closeConnection] failed " + JSON.stringify(closeException));
                    reject(KSExceptionWrapperUtils.wrapDBException(closeException));
                })
            }); // End of Custom Promise
        };
        /**
         *
         */
        KonyNoSQLDatabaseHelper.prototype.resetDatabase = async function() {
            log.trace(LOG_PREFIX + "[resetDatabase] called...");
            var self = this;
            return new Promise(function(resolve, reject) {
                self.getAllTablesList().then(dbTablesList => {
                    if (!KSCommonUtils.isNullOrEmptyObject(dbTablesList)) {
                        self.transaction(mode, tablesList, function(txn) {
                            self.deleteDataFromTable(txn, dbTablesList[i], null);
                        }).then(res => {
                            log.trace(LOG_PREFIX + "[resetDatabase] successful");
                            resolve(res);
                        }).catch(transactionError => {
                            log.error(LOG_PREFIX + "[resetDatabase] failed with error: " + JSON.stringify(transactionError));
                            reject(transactionError);
                        });
                    }
                }).catch(gettablesError => {
                    log.error(LOG_PREFIX + "[resetDatabase]  failed..");
                    reject(gettablesError);
                });
            });
        };
        /**
         *
         * @param {*} dbName
         */
        KonyNoSQLDatabaseHelper.prototype.dropDatabase = async function(dbName) {
            log.trace(LOG_PREFIX + "[dropDatabase '" + dbName + "'] called...");
            return new Promise(function(resolve, reject) {
                if (kony.sdk.isNullOrUndefined(nosqlDBInstance)) {
                    reject(getDBNotInitializedError());
                } else {
                    kony.nosql.closeDatabase(nosqlDBInstance).then(res => {
                        resetKonyNoSQLDatabaseHelperGlobals();
                        deleteKonyNoSQLDatabase(dbName, resolve, reject);
                    }).catch(closeException => {
                        log.error(LOG_PREFIX + "[dropDatabase] failed..." + JSON.stringify(closeException));
                        reject(KSExceptionWrapperUtils.wrapDBException(closeException));
                    });
                }
            });
        };
        /**
         *
         * @param {*} query
         * @param {*} tx
         */
        KonyNoSQLDatabaseHelper.prototype.executeQuery = function(query, tx) {
            log.trace(LOG_PREFIX + "[executeQuery] called...");
            return KonyNoSQLDatabaseHelper.db.execute(query, tx);
        };
        /**
         *
         * @param {*} queryObj
         * @param {*} transaction
         */
        KonyNoSQLDatabaseHelper.prototype.execute = function(queryObj, transaction) {
            if (queryObj && queryObj.tablename && queryObj.operationtype) {
                log.trace(LOG_PREFIX + "[execute '" + queryObj.tablename + "'  - '" + queryObj.operationtype + "'] called...");
                var executePromise;
                switch (queryObj.operationtype) {
                    case KonyNoSQLDatabaseHelper.KSDatabaseOperation.INSERT:
                        executePromise = this.insertDataIntoTable(transaction, queryObj.tablename, queryObj.insertValues);
                        break;
                    case KonyNoSQLDatabaseHelper.KSDatabaseOperation.INSERT_OR_REPLACE:
                        executePromise = this.insertOrReplaceDataIntoTable(transaction, queryObj.tablename, queryObj.insertValues);
                        break;
                    case KonyNoSQLDatabaseHelper.KSDatabaseOperation.UPDATE:
                        if (queryObj.tablename && queryObj.updateData) {
                            executePromise = this.updateTableWithData(transaction, queryObj.tablename, queryObj.updateData, queryObj.whereClause);
                        }
                        break;
                    case KonyNoSQLDatabaseHelper.KSDatabaseOperation.SELECT:
                        if (queryObj.tablename) {
                            executePromise = this.selectDataFromTable(transaction, queryObj.tablename, queryObj.whereClause, queryObj.projectionColumn, queryObj.orderBy, queryObj.callback);
                        }
                        break;
                    case KonyNoSQLDatabaseHelper.KSDatabaseOperation.DELETE:
                        if (queryObj.tablename) {
                            executePromise = this.deleteDataFromTable(transaction, queryObj.tablename, queryObj.whereClause);
                        }
                        break;
                    default:
                        // code...
                        break;
                }
                return executePromise;
            } else {
                log.error(LOG_PREFIX + "[execute] Can not execute query as mandatory fields 'tablename' and 'operationtype' are missing.");
                return new KSError(KSErrorConstants.DB_EXECUTE_QUERY_FAILED);
            }
        };
        /**
         *
         * @param {*} tx
         * @param {*} tableName
         * @param {*} data
         */
        KonyNoSQLDatabaseHelper.prototype.insertDataIntoTable = function(tx, tableName, data) {
            log.trace(LOG_PREFIX + "[insertDataIntoTable '" + tableName + "'] called...");
            self = this;
            return new Promise(function(resolve, reject) {
                var queryResult;
                var insertSuccess = function(res) {
                    queryResult = res;
                };
                var insertFailure = function(insertError) {
                    queryResult = insertError;
                };
                if (kony.sdk.isNullOrUndefined(tx)) {
                    self.transaction(kony.nosql.READ_WRITE, [tableName], function(tx) {
                        insertRecordsInTable(tx, tableName, data, insertSuccess, insertFailure);
                    }).then(function(transactionResult) {
                        log.trace(LOG_PREFIX + "[insertDataIntoTable] Transaction successful.");
                        resolve(queryResult);
                    }).catch(function(transactionError) {
                        log.error(LOG_PREFIX + "[insertDataIntoTable] Transaction Failed: " + JSON.stringify(transactionError));
                        reject(queryResult);
                    }); //End of transcation catch
                } else {
                    insertRecordsInTable(tx, tableName, data, resolve, reject);
                }
            }); //End of custom Promise
        };
        /**
         *
         * @param {*} tx
         * @param {*} tableName
         * @param {*} data
         */
        KonyNoSQLDatabaseHelper.prototype.insertOrReplaceDataIntoTable = function(tx, tableName, data) {
            log.trace(LOG_PREFIX + "[insertDataIntoTable '" + tableName + "'] called...");
            var self = this;
            return new Promise(function(resolve, reject) {
                var queryResult;
                var insertSuccess = function(res) {
                    queryResult = res;
                };
                var insertFailure = function(insertError) {
                    queryResult = insertError;
                };
                if (kony.sdk.isNullOrUndefined(tx)) {
                    self.transaction(kony.nosql.READ_WRITE, [tableName], function(tx) {
                        insertOrReplaceRecordsInTable(tx, tableName, data, insertSuccess, insertFailure);
                    }).then(function(transactionResult) {
                        log.trace(LOG_PREFIX + "[insertDataIntoTable ]  Transaction successful.");
                        resolve(queryResult);
                    }).catch(function(transactionError) {
                        log.error(LOG_PREFIX + "[insertDataIntoTable]  Transaction failed with error" + JSON.stringify(transactionError));
                        reject(queryResult);
                    }); //End of transcation catch
                } else {
                    insertOrReplaceRecordsInTable(tx, tableName, data, resolve, reject);
                }
            }); //End of custom Promise
        };
        //addOrReplaceRecords
        /**
         *
         * @param {*} tx
         * @param {*} tableName
         * @param {*} selectWhereClause
         * @param {*} projection_col_list
         * @param {*} orderBy
         * @param {*} limit
         */
        KonyNoSQLDatabaseHelper.prototype.selectDataFromTable = function(tx, tableName, selectWhereClause, projection_col_list, orderBy, limit) {
            log.trace(LOG_PREFIX + "[selectDataFromTable '" + tableName + "'] called with");
            log.trace(LOG_PREFIX + "[selectDataFromTable '" + tableName + "'] projection_col_list:  " + JSON.stringify(projection_col_list));
            log.trace(LOG_PREFIX + "[selectDataFromTable '" + tableName + "'] orderBy:  " + JSON.stringify(orderBy));
            log.trace(LOG_PREFIX + "[selectDataFromTable '" + tableName + "'] limit:  " + JSON.stringify(limit));
            var self = this;
            return new Promise(function(resolve, reject) {
                var queryResult;
                var selectSuccess = function(res) {
                    queryResult = res;
                };
                var selectFailure = function(selectError) {
                    queryResult = selectError;
                };
                var whereCondition = getKonyNoSqlWhereCondition(selectWhereClause);
                var finalOrderBy = null;
                if (!kony.sdk.isNullOrUndefined(orderBy) && orderBy.hasOwnProperty("column") && !kony.sdk.isNullOrUndefined(orderBy.column)) {
                    // e.g. orderBy ={"column": "col_name", "order": "asc/desc"}
                    var orderbyColumnkey = orderBy.column;
                    if (!kony.sdk.util.isNullOrEmptyString(orderbyColumnkey)) {
                        var value = orderBy.order;
                        finalOrderBy = {};
                        finalOrderBy[orderbyColumnkey] = value;
                    }
                } else if (!kony.sdk.isNullOrUndefined(orderBy) && (KSCommonUtils.isInstanceOfMap(orderBy))) { // e.g. orderBy ={"col_name": "asc/desc"}
                    finalOrderBy = orderBy;
                }
                if (kony.sdk.isNullOrUndefined(tx)) {
                    self.transaction(kony.nosql.READ_WRITE, [tableName], function(tx) {
                        fetchRecordsFromTable(tx, tableName, whereCondition, projection_col_list, finalOrderBy, limit, selectSuccess, selectFailure);
                    }).then(function(transactionResult) {
                        log.trace(LOG_PREFIX + "[selectDataFromTable] Transaction successful.");
                        resolve(queryResult);
                    }).catch(function(transactionError) {
                        log.error(LOG_PREFIX + "[selectDataFromTable] Transaction failed: " + JSON.stringify(transactionError));
                        reject(queryResult);
                    }); //End of transcation catch
                } else {
                    fetchRecordsFromTable(tx, tableName, whereCondition, projection_col_list, finalOrderBy, limit, resolve, reject);
                }
            }); // End of custom Promise
        };
        /**
         *
         * @param {*} tx
         * @param {*} tableName
         * @param {*} whereClause
         * @param {*} newVal
         */
        KonyNoSQLDatabaseHelper.prototype.reconcilePKs = function(tx, tableName, whereClause, newVal) {
            log.trace(LOG_PREFIX + "[reconcilePKs '" + tableName + "'] called...");
            var self = this;
            return new Promise(function(resolve, reject) {
                var queryResult;
                var reconcileSuccess = function(res) {
                    queryResult = res;
                };
                var reconcileFailure = function(reconcileError) {
                    queryResult = reconcileError;
                };
                var whereCondition = getKonyNoSqlWhereCondition(whereClause);
                if (kony.sdk.isNullOrUndefined(tx)) {
                    self.transaction(kony.nosql.READ_WRITE, [tableName], function(tx) {
                        reconcilePKsInTable(tx, tableName, newVal, whereCondition, reconcileSuccess, reconcileFailure);
                    }).then(function(transactionResult) {
                        log.trace(LOG_PREFIX + "[reconcilePKs] Transaction successful.");
                        resolve(queryResult);
                    }).catch(function(transactionError) {
                        log.error(LOG_PREFIX + "[reconcilePKs] Transaction failed: " + JSON.stringify(transactionError));
                        reject(queryResult);
                    }); //End of transcation catch
                } else {
                    reconcilePKsInTable(tx, tableName, newVal, whereCondition, resolve, reject);
                }
            }); //End of custom Promise
        };
        /**
         *
         * @param {*} tx
         * @param {*} tableName
         * @param {*} newData
         * @param {*} updateWhereClause
         */
        KonyNoSQLDatabaseHelper.prototype.updateTableWithData = async function(tx, tableName, newData, updateWhereClause) {
            log.trace(LOG_PREFIX + "[updateTableWithData '" + tableName + "'] called...");
            var self = this;
            var updatePromise;
            var pks = await self.getPkSet(tableName, tx);
            if (isDataReconciliation(pks, newData)) {
                log.trace(LOG_PREFIX, "[updateTableWithData] this is a reconcile operation.");
                updatePromise = self.reconcilePKs(tx, tableName, updateWhereClause, newData);
            } else {
                updatePromise = new Promise(function(resolve, reject) {
                    if (kony.sdk.isNullOrUndefined(newData)) {
                        resolve(0);
                        return;
                    }
                    var queryResult;
                    var updateSuccess = function(res) {
                        queryResult = res;
                    };
                    var updateFailure = function(updateError) {
                        queryResult = updateError;
                    };
                    var whereCondition = getKonyNoSqlWhereCondition(updateWhereClause);
                    if (kony.sdk.isNullOrUndefined(tx)) {
                        self.transaction(kony.nosql.READ_WRITE, [tableName], function(tx) {
                            updateRecordsInTable(tx, tableName, newData, whereCondition, updateSuccess, updateFailure);
                        }).then(function(transactionResult) {
                            log.trace(LOG_PREFIX + "[updateTableWithData] Transaction successful.");
                            resolve(queryResult);
                        }).catch(function(transactionError) {
                            log.error(LOG_PREFIX + "[updateTableWithData] Transaction failed: " + JSON.stringify(transactionError));
                            reject(queryResult);
                        }); //End of transcation catch;
                    } else {
                        updateRecordsInTable(tx, tableName, newData, whereCondition, resolve, reject);
                    }
                }); // End of custom Promise
            }
            return updatePromise;
        };
        /**
         *
         * @param {*} tx
         * @param {*} tableName
         * @param {*} deleteWhereClause
         */
        KonyNoSQLDatabaseHelper.prototype.deleteDataFromTable = function(tx, tableName, deleteWhereClause) {
            log.trace(LOG_PREFIX + "[deleteDataFromTable '" + tableName + "']  called..");
            var self = this;
            return new Promise(function(resolve, reject) {
                var queryResult;
                var deleteSuccess = function(res) {
                    queryResult = res;
                };
                var deleteFailure = function(deleteError) {
                    queryResult = deleteError;
                };
                var whereCondition = getKonyNoSqlWhereCondition(deleteWhereClause);
                if (kony.sdk.isNullOrUndefined(tx)) {
                    self.transaction(kony.nosql.READ_WRITE, [tableName], function(tx) {
                        deleteRecordsFromTable(tx, tableName, whereCondition, deleteSuccess, deleteFailure);
                    }).then(function(transactionResult) {
                        log.trace(LOG_PREFIX + "[deleteDataFromTable]  Transaction successful.");
                        resolve(queryResult);
                    }).catch(function(transactionError) {
                        log.error(LOG_PREFIX + "[deleteDataFromTable]  Transaction failed: " + JSON.stringify(transactionError));
                        reject(queryResult);
                    }); //End of transaction catch
                } else {
                    deleteRecordsFromTable(tx, tableName, whereCondition, resolve, reject);
                }
            }); // End of custom Promise
        };
        /**
         *
         */
        KonyNoSQLDatabaseHelper.prototype.checkAndOpenConnection = async function() {
            log.trace(LOG_PREFIX + "[checkAndOpenConnection] called...");
            if (!KonyNoSQLDatabaseHelper.db.isOpen()) {
                log.warn(LOG_PREFIX, "[checkAndOpenConnection] Database is closed, reopening the connection.");
                KonyNoSQLDatabaseHelper.db = await KonyNoSQLDatabaseHelper.db.open();
            } else {
                log.trace(LOG_PREFIX, "[checkAndOpenConnection] Database is open.");
            }
        };
        /**
         *
         * @param {*} dbName
         * @returns  Promise <boolean>
         */
        KonyNoSQLDatabaseHelper.doesDatabaseExists = function(dbName) {
            log.trace(LOG_PREFIX + "[doesDatabaseExists  '" + dbName + "'] called");
            return kony.nosql.databaseExists(dbName);
        };
        /**
         *
         * @param {*} dbName
         * @returns  Promise <integer> version of the current DBObject
         */
        KonyNoSQLDatabaseHelper.getCurrentDBVersion = function(dbName) {
            return new Promise(function(resolve, reject) {
                if (kony.sdk.isNullOrUndefined(nosqlDBInstance)) {
                    reject(getDBNotInitializedError());
                } else {
                    kony.nosql.databaseVersion(nosqlDBInstance).then(version => {
                        log.trace(LOG_PREFIX + "[getCurrentDBVersion  '" + dbName + "'] got: " + version);
                        resolve(version);
                    }).catch(getVersionError => {
                        log.error(LOG_PREFIX + "[getCurrentDBVersion] failed: " + JSON.stringify(getVersionError));
                        reject(KSExceptionWrapperUtils.wrapDBException(getVersionError));
                    });
                }
            }); // End of custom Promise
        };
        /**
         *
         * @param {*} tablename
         */
        KonyNoSQLDatabaseHelper.prototype.isTableFound = function(tablename) {
            return new Promise(function(resolve, reject) {
                if (kony.sdk.isNullOrUndefined(nosqlDBInstance)) {
                    reject(getDBNotInitializedError());
                } else {
                    kony.nosql.tableExists(nosqlDBInstance, tablename).then(tablexists => {
                        log.trace(LOG_PREFIX + "[isTableFound " + tablename + "] got: " + tablexists);
                        resolve(tablexists);
                    }).catch(getTableError => {
                        log.error(LOG_PREFIX + "[isTableFound] failed: " + JSON.stringify(getTableError));
                        reject(KSExceptionWrapperUtils.wrapDBException(getTableError));
                    });
                }
            }); // End of custom Promise
        };
        /**
         *
         * @param {*} dbname
         */
        KonyNoSQLDatabaseHelper.getConnectionForExistingDB = async function(dbname) {
            log.trace(LOG_PREFIX + "[getConnectionForExistingDB " + dbname + "] called...");
            if (kony.sdk.isNullOrUndefined(KonyNoSQLDatabaseHelper.db)) {
                KonyNoSQLDatabaseHelper.getDBInstance(dbname);
            }
            await KonyNoSQLDatabaseHelper.db.checkAndOpenConnection();
            return KonyNoSQLDatabaseHelper.db;
        };
        /**
         * @param {*} tableName
         * @param {*} txn
         * @returns {Promise<Array>} List of PK of a table
         */
        KonyNoSQLDatabaseHelper.prototype.getPkSet = function(tableName, txn) {
            log.trace(LOG_PREFIX + "[getPkSet  " + tableName + "] called...");
            return new Promise(function(resolve, reject) {
                if (kony.sdk.isNullOrUndefined(nosqlDBInstance)) {
                    reject(getDBNotInitializedError());
                } else {
                    kony.nosql.getPrimaryKeys(nosqlDBInstance, tableName, txn).then(pkset => {
                        resolve(pkset);
                    }).catch(getPKError => {
                        log.trace(LOG_PREFIX + "[getPkSet] failed with error: " + JSON.stringify(getPKError));
                        reject(KSExceptionWrapperUtils.wrapDBException(getPKError));
                    });
                }
            }); // End of custom Promise
        };
        /**
         * @param {*} mode
         * @param {*} tablesList
         * @param {*} txCallback
         */
        KonyNoSQLDatabaseHelper.prototype.transaction = function(mode, tablesList, txCallback) {
            log.trace(LOG_PREFIX + "[transaction]  in " + mode + " called: " + JSON.stringify(tablesList));
            var konyNosqlTransaction = new Promise(function(resolve, reject) {
                kony.nosql.openTransaction(nosqlDBInstance, tablesList, mode, txCallback).then(konyTransactionResult => {
                    log.trace(LOG_PREFIX + "[transaction] successful.");
                    resolve(konyTransactionResult);
                }).catch(konyTransactionerror => {
                    log.error(LOG_PREFIX + "[transaction] failed: " + JSON.stringify(konyTransactionerror));
                    reject(KSExceptionWrapperUtils.wrapDBException(konyTransactionerror));
                });
            });
            return konyNosqlTransaction;
        };
        KonyNoSQLDatabaseHelper.db = null;
        KonyNoSQLDatabaseHelper.dbTablesList = null;
        return KonyNoSQLDatabaseHelper;
    }());
    exports.KonyNoSQLDatabaseHelper = KonyNoSQLDatabaseHelper;
});
// ************************************* End of KonyNoSQLDatabaseHelper.js *************************************
/**
 * Error object for error handling in Offline objects.
 */
define("KSError", ["exports"], function(exports) {
    "use strict";
    exports._esModule = true;
    exports.KSError = (function() {
        function KSError(errObj, userInfo) {
            if (errObj) {
                this.code = errObj.code;
                this.message = errObj.message;
                this.domain = errObj.domain;
            }
            this.userInfo = userInfo;
        }
        return KSError;
    }());
});
define("KSSDKObject", ["exports", "SyncEngine", "KSSetupManager", "KSBaseORMManager", "KSORMManagerFactory", "KSSDKObjectRecord", "KSSyncDatabaseHelper", "KSDeltaContextUtils", "KSDatabaseAPI", "KSError", "KSOptionsHelper", "KSCommonUtils", "KSUploadPayloadBuilder", "KSRequestResponseUtils", "KSNetworkUtils", "KSQueryObjectBuilder", "KSSQLQueryGenerator", "KSMarkForUploadUtils", "KSUploadCacheManager"], function(exports, SyncEngine, KSSetupManager, KSBaseORMManager, KSORMManagerFactory, KSSDKObjectRecord, KSSyncDatabaseHelper, KSDeltaContextUtils, _KSDatabaseAPI, _KSError, KSOptionsHelper, KSCommonUtils, KSUploadPayloadBuilder, KSRequestResponseUtils, KSNetworkUtils, KSQueryObjectBuilder, KSSQLQueryGenerator, KSMarkForUploadUtils, KSUploadCacheManager) {
    "use strict";
    exports._esModule = true;
    var sdk = kony.sdk;
    var logger = sdk.logsdk;
    var LOG_PREFIX = "KSSDKObject : ";
    var KSError = _KSError.KSError;
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSTableType = kony.sdk.OfflineObjects.KSTableType;
    var SDKObjectRecord = KSSDKObjectRecord.KSSDKObjectRecord;
    var KSErrorConstants = sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = sdk.OfflineObjects.KSDatabaseConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    /**
     * Constructor for KSSDKObject.
     * @param sdkObjectName Name of the SDKObject.
     * @param namespace Namespace of the SDKObject.
     * @param objectServiceName Name of the object service.
     * @constructor Return the SDKObject.
     */
    function KSSDKObject(sdkObjectName, namespace, objectServiceName) {
        if (sdk.isNullOrUndefined(sdkObjectName)) {
            var errorMessage = "SDK Object name cannot be null/empty.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.METADATA_SDKOBJECT_SYNC_NAME_NULL_OR_EMPTY, errorMessage);
        }
        this.filter = "";
        this.records = [];
        this.name = sdkObjectName;
        this.namespace = namespace;
        this.uploadResponseFilterMap = {};
        this.mode = KSInternalConstants.MODE;
        this.sdkObjectsForUploadAndDownload = [];
        this.recordsClassifedWithRecordAction = {};
        if (sdk.isNullOrUndefined(objectServiceName)) {
            this.metadata = KSSetupManager.getInstance().getObjectMetadataForNamespaceNameAndObjectName(this.namespace, this.name);
            this.objectServiceName = this.metadata[KSInternalConstants.OBJECT_SERVICE_NAME];
        } else {
            this.objectServiceName = objectServiceName;
            this.metadata = KSSetupManager.getInstance().getObjectMetadataInObjectServiceWithNamespaceNameAndObjectName(this.objectServiceName, this.namespace, this.name);
        }
        logger.trace(LOG_PREFIX, "Initialized an instance of SDKObject with name " + this.name);
    }
    //------------------------------------
    // PROTOTYPE GETTER AND SETTER METHODS
    //------------------------------------
    /**
     * Setter for setting the recordsClassifedWithRecordAction.
     * @param classifiedRecords Dictionary of classified records according to the record action.
     */
    KSSDKObject.prototype.setClassfiedRecordsWithAction = function(classifiedRecords) {
        this.recordsClassifedWithRecordAction = classifiedRecords;
    };
    /**
     * Adds the given primaryKeyValue as key to uploadRecordFilter to uploadResponseFilterMap JSON
     * @param primaryKeyValueMap
     * @param uploadRecordFilter
     */
    KSSDKObject.prototype.addUploadFilterToPrimaryKeyValue = function(primaryKeyValueMap, uploadRecordFilter) {
        this.uploadResponseFilterMap[primaryKeyValueMap] = uploadRecordFilter;
    };
    /**
     * Setter to set the records.
     * @param records Array of records in a SDKObject.
     */
    KSSDKObject.prototype.setRecords = function(records) {
        this.records = records;
    };
    /**
     * Getter to get the records.
     * @return records Array of records in a SDKObject.
     */
    KSSDKObject.prototype.getRecords = function() {
        return this.records;
    };
    /**
     * Getter to upload response filter map
     * @return Dictionary which has primaryKeyValue as key and uploadRecordFilter as value.
     */
    KSSDKObject.prototype.getUploadResponseFilterMap = function() {
        return this.uploadResponseFilterMap;
    };
    /**
     * Setter to add records to the SDKObjects.
     * @param record Array of records.
     */
    KSSDKObject.prototype.addRecord = function(record) {
        if (!sdk.isNullOrUndefined(record)) {
            this.records.push(record);
            classifyRecordAndUpdateWithParent.call(this, record, this);
        }
    };
    /**
     * Getter to fetch the primary key attributes of the SDKObject.
     * @returns {Array} Array of Primary Keys.
     */
    KSSDKObject.prototype.getPrimaryKeys = function() {
        return Object.keys(this.metadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS]);
    };
    /**
     * Method to fetch the fully qualified name.
     * @returns {*} Fully qualified name of the SDKObject.
     */
    KSSDKObject.prototype.getFullyQualifiedName = function() {
        return this.metadata[KSInternalConstants.FULLY_QUALIFIED_NAME];
    };
    /**
     * Getter to fetch the metadata associated with the SDKObject.
     * @returns Metadata associated with the SDKObject.
     */
    KSSDKObject.prototype.getMetadata = function() {
        return this.metadata;
    };
    /**
     * Method to return ObjectServiceName
     * @returns objectServiceName Returns objectService name.
     **/
    KSSDKObject.prototype.getObjectServiceName = function() {
        return this.objectServiceName;
    };
    /**
     * Method to return syncLevel
     **/
    KSSDKObject.prototype.getSyncLevel = function() {
        return KSInternalConstants.SYNCLEVEL_OBJECT;
    };
    //-------------------------------
    // PROTOTYPE METHODS FOR DOWNLOAD
    //-------------------------------
    /**
     * Method to invoke for preparing an object for sync session.
     **/
    KSSDKObject.prototype.prepareForSession = function() {
        // Unclassifying the records with action and clearing all the records
        KSCommonUtils.clearArrayObject(this.records);
        KSCommonUtils.clearJSONObject(this.recordsClassifedWithRecordAction);
    };
    /**
     * Method to invoke sync on a SDKObject.
     * @param syncConfig Options for sync.
     */
    KSSDKObject.prototype.startSync = async function(syncConfig) {
        logger.trace(LOG_PREFIX, "Invoked startSync in SDKObject.");
        assertMode(this.mode);
        validateOptions(syncConfig);
        logger.info(LOG_PREFIX, "Starting Sync Operation for Object:" + this.name);
        var syncEngineInstance = SyncEngine.getInstance();
        return (await syncEngineInstance.startSyncSessionForObject(syncConfig, this));
    };
    /**
     * Method to build the download request.
     * @param context Contains the options for sync like filter, query params etc.
     * @returns {{}} JSON object containing values to build a request in network layer.
     */
    KSSDKObject.prototype.createDownloadRequest = async function(context) {
        logger.trace(LOG_PREFIX, "Creating download request for object : " + this.name);
        setFilter.call(this, context[KSInternalConstants.SYNC_OPTIONS]);
        var requestParams = {};
        requestParams[KSInternalConstants.URL] = getEndpointURLString.call(this);
        requestParams[KSInternalConstants.QUERY_PARAMS] = buildDownloadRequestQueryParams.call(this, context);
        requestParams[KSInternalConstants.HEADERS] = getDownloadRequestHeaders.call(this);
        requestParams[KSInternalConstants.BODY] = await buildDownloadRequestBodyParam.call(this, context);
        logger.debug(LOG_PREFIX, "Successfully created parameters for object download request.");
        return requestParams;
    };
    /**
     * Method to parse the download response received from the network.
     * @param response Response JSON.
     * @returns {*} Returns a parsed response dictionary.
     */
    KSSDKObject.prototype.parseDownloadResponse = function(response) {
        logger.trace(LOG_PREFIX, "Parsing response for object : " + this.name);
        //Using require to avoid circular dependencies..
        var responseDictionary = require("KSRequestResponseUtils").getObjectDownloadResponseDictionaryFromNetworkResponse(response, this.name, this.objectServiceName);
        if (!sdk.isNullOrUndefined(responseDictionary) && responseDictionary.hasOwnProperty(KSInternalConstants.DATA_OBJECTS)) {
            this.sdkObjectsForUploadAndDownload = responseDictionary[KSInternalConstants.DATA_OBJECTS];
            responseDictionary[KSInternalConstants.HAS_MORE_RECORDS] = response[KSInternalConstants.HAS_MORE_RECORDS];
        }
        return responseDictionary;
    };
    /**
     * Method to persist the changes after parsing the response received from the network.
     * @param deltaContext Deltacontext received for the sync session.
     */
    KSSDKObject.prototype.persistDownloadChanges = async function(deltaContext) {
        logger.trace(LOG_PREFIX, "Persisting download for object : " + this.name);
        var queryObjectsForData = await KSSyncDatabaseHelper.buildQueriesToPersistChangesForObjects(this.sdkObjectsForUploadAndDownload);
        var filter = {};
        filter[this.name] = this.filter;
        var deltaContextQueryObj = KSDeltaContextUtils.buildDeltaContextQuery(deltaContext, filter);
        var queryObjects = [];
        Array.prototype.push.apply(queryObjects, queryObjectsForData);
        Array.prototype.push.apply(queryObjects, deltaContextQueryObj);
        logger.info(LOG_PREFIX, "Executing queries in transaction for persisting download response for object : " + this.name);
        await KSDatabaseAPI.executeQueries(queryObjects, true);
        logger.debug(LOG_PREFIX, "Successfully executed queries for persisting download response for object : " + this.name);
    };
    /**
     * Method to clear the objects and properties used for sync.
     */
    KSSDKObject.prototype.clearObjectsToPersist = function() {
        this.filter = "";
        KSCommonUtils.clearArrayObject(this.records);
        KSCommonUtils.clearArrayObject(this.sdkObjectsForUploadAndDownload);
        KSCommonUtils.clearJSONObject(this.recordsClassifedWithRecordAction);
    };
    /**
     * Rollback an Object to it's previous Sync State
     *
     * @param primaryKeyValueMap of record only for which rollback should happen
     */
    KSSDKObject.prototype.rollback = async function(primaryKeyValueMap) {
        var syncEngineInstance = SyncEngine.getInstance();
        if (syncEngineInstance.isRollbackOperationAllowed(KSInternalConstants.SYNCLEVEL_OBJECT, this)) {
            syncEngineInstance.updateRunningTaskContextWithRollbackTasks(KSInternalConstants.SYNCLEVEL_OBJECT, this);
            logger.info(LOG_PREFIX, "Rollback on Object : " + this.name + " Start.");
            var rollbackOptions = {};
            if (primaryKeyValueMap !== null) {
                rollbackOptions[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
            }
            rollbackOptions[KSInternalConstants.OBJECT_METADATA] = this.metadata;
            if (KSOptionsHelper.arePrimaryKeysValid(rollbackOptions)) {
                var preparedStatementsForRollback = await KSSyncDatabaseHelper.buildPreparedStatementsForObjectRollback(this, primaryKeyValueMap);
                await KSDatabaseAPI.executeQueries(preparedStatementsForRollback, true);
                await KSUploadCacheManager.getInstance().removeRecord(this.getFullyQualifiedName());
            }
        } else {
            var errorMessage = "Rollback cannot be performed as other Offline Object operations are in progress.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage);
        }
    };
    /**
     * Fetch primary keys which are deferred from Upload
     *
     * @returns primaryKeys of record deferred from upload
     */
    KSSDKObject.prototype.getDeferredRecordsFromDatabase = async function() {
        logger.info(LOG_PREFIX, "getDeferredRecordsFromDatabase :" + "Start");
        logger.info(LOG_PREFIX, "getDeferredRecordsFromDatabase :" + "Reading records from db");
        var records;
        var options = {};
        options[KSInternalConstants.METADATA] = this.metadata;
        var queryObject = KSMarkForUploadUtils.getSelectPreparedStatementForDeferredRecords(options, this.getPrimaryKeys());
        records = await KSDatabaseAPI.executeQuery(queryObject);
        if (!KSCommonUtils.isNullOrEmptyObject(records)) {
            logger.info(LOG_PREFIX, "getDeferredRecordsFromDatabase :" + "Number of records fetched: " + records.length);
        } else {
            logger.info(LOG_PREFIX, "getDeferredRecordsFromDatabase: " + "No records returned,either there are no records in local database for Object or some error occurred");
        }
        logger.info(LOG_PREFIX, "getDeferredRecordsFromDatabase: " + "Fetching records Succeeded");
        return records;
    };
    /**
     * Method to enable a record for upload
     *
     * @param options Contains the options for markForUpload
     * @return {boolean} returns true if the record marked for upload else false
     */
    KSSDKObject.prototype.markForUploadInDatabase = async function(options) {
        logger.info(LOG_PREFIX, "markForUploadInDatabase :" + "Start");
        logger.info(LOG_PREFIX, "markForUploadInDatabase :" + "markForUpload records for object " + this.name);
        var preparedStatements;
        if (KSCommonUtils.isNullOrEmptyObject(options)) {
            logger.error(LOG_PREFIX, "markForUploadInDatabase: " + "Invalid options passed in markForUpload");
            throw new KSError(KSErrorConstants.CRUD_NULL_OR_EMPTY_OPTIONS);
        }
        options[KSInternalConstants.METADATA] = this.metadata;
        if (KSOptionsHelper.skipValidation(options) || KSOptionsHelper.arePrimaryKeysSentInOptionsValid(options)) {
            preparedStatements = KSMarkForUploadUtils.getPreparedStatementForMarkForUpload(options, KSTableType.HISTORY);
            await KSSyncDatabaseHelper.executePreparedStatementsAsTransaction(preparedStatements);
        }
        logger.info(LOG_PREFIX, "markForUpload :" + "markForUpload on record with PK : " + JSON.stringify(options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS]) + " is successful.");
        return true;
    };
    //----------------------------
    // PROTOTYPE METHODS FOR UPLOAD
    //----------------------------
    /**
     * Method to fetch the headers for a upload request.
     * @returns {{}} JSON object for headers.
     */
    function getUploadRequestHeaders() {
        var headers = {};
        headers[KSInternalConstants.X_HTTP_METHOD_OVERRIDE] = KSInternalConstants.HTTP_OVERRIDE_UPLOAD;
        var version = this.metadata[KSInternalConstants.VERSION];
        if (!kony.sdk.isNullOrUndefined(version)) {
            headers[KSInternalConstants.X_KONY_API_VERSION] = version;
        }
        return headers;
    }
    /**
     * Object to upload.
     * @return {Promise<Array>} object to upload.
     */
    KSSDKObject.prototype.objectsToUpload = async function() {
        return await KSSyncDatabaseHelper.getDeltaChangesToUpload([this]);
    };
    /**
     * Creates upload request params and returns the json { payload, headers, url}
     * @param options Contains the options for sync like filter, query params etc.
     * @return {Promise<JSON>} requests parameters needed.
     */
    KSSDKObject.prototype.createUploadRequest = async function(options) {
        kony.sdk.logsdk.info(LOG_PREFIX, "CreateUploadRequest is called in SDKObject");
        var uploadRequestParams = {};
        var uploadRequestBuilder = await KSUploadPayloadBuilder.getInstance(this);
        if (!uploadRequestBuilder.areThereRecordsToUpload()) {
            logger.info(LOG_PREFIX, "No pending changes found to upload in object");
            uploadRequestParams[KSInternalConstants.ARE_THERE_CHANGES_TO_UPLOAD] = false;
            return uploadRequestParams;
        }
        uploadRequestParams[KSInternalConstants.URL] = getEndpointURLString.call(this);
        uploadRequestParams[KSInternalConstants.REQUEST_HEADERS] = getUploadRequestHeaders.call(this);
        uploadRequestParams[KSInternalConstants.REQUEST_BODY] = uploadRequestBuilder.getUploadRequestJson();
        uploadRequestParams[KSInternalConstants.REQUEST_QUERY_PARAMS] = KSOptionsHelper.validateAndGetQueryParams(options, KSPublicConstants.SYNC_UPLOAD_QUERY_PARAMS);
        uploadRequestParams[KSInternalConstants.ARE_THERE_CHANGES_TO_UPLOAD] = true;
        return uploadRequestParams;
    };
    /**
     * This will Parse the upload response and forms the JSON which has DATA_OBJECTS and SYNC_ERRORS.
     * @param response network response
     * @return Returns the JSON which has DATA_OBJECTS and SYNC_ERRORS.
     */
    KSSDKObject.prototype.parseUploadResponse = function(response) {
        return KSRequestResponseUtils.uploadResponseObjectsDictionaryFromJSONString(response);
    };
    /**
     * Persists the upload response in given object
     * @param sdkObject object to persist.
     */
    KSSDKObject.prototype.persistUploadChanges = async function(sdkObject) {
        await KSSyncDatabaseHelper.persistUploadResponseForObjects(sdkObject);
    };
    /**
     * Clears the records array and uploadResponseFilterMap.
     */
    KSSDKObject.prototype.removeAllRecords = function() {
        KSCommonUtils.clearArrayObject(this.records);
        KSCommonUtils.clearJSONObject(this.uploadResponseFilterMap);
    };
    //----------------------------
    // PROTOTYPE METHODS FOR CRUD
    //----------------------------
    /**
     * Method to create a record in the database
     * @param record Map containing the record data to be persisted.
     * @param options Map containing list of options.
     */
    KSSDKObject.prototype.createRecordsInDatabase = async function(record, options) {
        logger.trace(LOG_PREFIX, "createRecordsInDatabase : ", "Start.");
        logger.debug(LOG_PREFIX, "Creating records for object " + this.name + " with values " + JSON.stringify(record.getData()) + " and options " + JSON.stringify(options));
        record.setAction(KSSDKObjectRecordAction.CREATE);
        var ORMManager = KSORMManagerFactory.getORMManager(KSSDKObjectRecordAction.CREATE);
        return (await ORMManager.perform(record, options));
    };
    /**
     * Method to fetch records from the database
     * @param options Map containing primaryKeys of the record.
     */
    KSSDKObject.prototype.readRecordsFromDatabase = async function(options) {
        logger.trace(LOG_PREFIX, "readRecordsFromDatabase : ", "Start.");
        logger.debug(LOG_PREFIX, "Reading records of object " + this.name + " with options " + JSON.stringify(options));
        var ORMManager = KSORMManagerFactory.getORMManager(KSSDKObjectRecordAction.READ);
        var optionsForRead = kony.sdk.cloneObject(options);
        if (kony.sdk.isNullOrUndefined(optionsForRead)) {
            optionsForRead = {};
        }
        optionsForRead[KSInternalConstants.OBJECT_METADATA] = this.metadata;
        var records = await ORMManager.perform(null, optionsForRead);
        if (records) {
            logger.info(LOG_PREFIX, "Number of records fetched: " + records.length);
        } else {
            logger.info(LOG_PREFIX, "No records returned... either there are no records in local database for Object or some error occurred");
            records = null;
        }
        return records;
    };
    /**
     * Method to update a record in the database
     * @param record Map containing record data to be updated.
     * @param options Map containing primaryKeys if the record to be updated.
     */
    KSSDKObject.prototype.updateRecordsInDatabase = async function(record, options) {
        logger.trace(LOG_PREFIX, "updateRecordsInDatabase : ", "Start.");
        logger.debug(LOG_PREFIX, "Updating records for object " + this.name + " with values " + JSON.stringify(record.getData()) + " and options " + JSON.stringify(options));
        options[KSInternalConstants.OBJECT_METADATA] = this.metadata;
        record.setAction(KSSDKObjectRecordAction.UPDATE);
        var ORMManager = KSORMManagerFactory.getORMManager(KSSDKObjectRecordAction.UPDATE);
        return (await ORMManager.perform(record, options));
    };
    /**
     * Method to delete a record from database
     * @param options Map containing primaryKeys of the record to be deleted.
     */
    KSSDKObject.prototype.deleteRecordsInDatabase = async function(options) {
        logger.trace(LOG_PREFIX, "deleteRecordsInDatabase : ", "Start.");
        logger.debug(LOG_PREFIX, "Deleting records for object " + this.name + " with options " + JSON.stringify(options));
        var sdkRecord = new SDKObjectRecord({}, this);
        sdkRecord.setAction(KSSDKObjectRecordAction.DELETE);
        options[KSInternalConstants.OBJECT_METADATA] = this.metadata;
        var ORMManager = KSORMManagerFactory.getORMManager(KSSDKObjectRecordAction.DELETE);
        return (await ORMManager.perform(sdkRecord, options));
    };
    /**
     * Method to fetch pending sync records for the object
     * @param options Contains user defined options
     */
    KSSDKObject.prototype.getPendingRecordsForUpload = function(options) {
        //the method is not async as it is returning promise from KSDatabaseAPI.executeQuery which will be resolved/rejected at SDKObjectSync.js level
        logger.trace(LOG_PREFIX, " getPendingRecordsForUpload : ", "Enter.");
        var tableName = KSSQLQueryGenerator.getTableNameWithType(this.getFullyQualifiedName(), KSTableType.ORIGINAL);
        var primaryKeyNameList = this.getPrimaryKeys();
        var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseConstants.KSDatabaseOperations.SELECT);
        var statement = statementBuilder.setProjectionColumns(primaryKeyNameList).build();
        return KSDatabaseAPI.executeQuery(statement);
    };
    //-----------------------------------
    // PRIVATE GETTER AND SETTER METHODS
    //-----------------------------------
    /**
     * Getter to fetch the endpoint URL from metadata.
     * @returns Endpoint URL string.
     */
    function getEndpointURLString() {
        return this.metadata[KSInternalConstants.ENDPOINT_URL];
    }
    /**
     * Method to set the ODATA filter for the SDKObject.
     * @param syncOptions JSON containing the options sent for sync.
     */
    function setFilter(syncOptions) {
        logger.trace(LOG_PREFIX, "Setting filter for object : " + this.name);
        if (!sdk.isNullOrUndefined(syncOptions)) {
            this.filter = !sdk.isNullOrUndefined(syncOptions[KSInternalConstants.FILTER]) ? syncOptions[KSInternalConstants.FILTER] : this.filter;
            logger.info(LOG_PREFIX, "Setting Filter : " + this.filter);
        }
    }
    /**
     * Method to add the record to appropriate record action type in recordsClassifedWithRecordAction.
     * @param record Record to be classified and added.
     */
    function setClassifiedRecordWithAction(record) {
        if (this.recordsClassifedWithRecordAction.hasOwnProperty(record.getAction())) {
            this.recordsClassifedWithRecordAction[record.getAction()].push(record);
        } else {
            this.recordsClassifedWithRecordAction[record.getAction()] = [record];
        }
    }
    /**
     * Method to classify the record and add the reference of the parent object.
     * @param record Record to be added to recordsClassifedWithRecordAction.
     * @param parent Reference of the parent object to be added.
     */
    function classifyRecordAndUpdateWithParent(record, parent) {
        record.setParentObject(parent);
        setClassifiedRecordWithAction.call(this, record);
    }
    //-------------------------------
    // PRIVATE METHODS FOR VALIDATION
    //-------------------------------
    /**
     * Method to validate the sync options.
     * @param syncConfig Options sent for object sync.
     */
    function validateOptions(syncConfig) {
        logger.trace(LOG_PREFIX, "Validating the options sent for sync.");
        validateFilter(syncConfig);
        KSOptionsHelper.validateSyncConfigPolicy(syncConfig);
    }
    /**
     * Method to validate filter.
     * @param syncConfig Options sent for object sync.
     */
    function validateFilter(syncConfig) {
        var genericErrorMessage = "Filters applied to the current sync operation are invalid:";
        if (!sdk.isNullOrUndefined(syncConfig) && syncConfig.hasOwnProperty(KSInternalConstants.FILTER)) {
            var filter = syncConfig[KSInternalConstants.FILTER];
            if (KSCommonUtils.isNullOrEmptyObject(filter)) {
                var errorMessage = "Filters sent are null/empty.";
                logger.error(LOG_PREFIX, genericErrorMessage + errorMessage);
                throw new KSError(KSErrorConstants.SYNC_INVALID_FILTERS, genericErrorMessage + errorMessage);
            } else if (typeof filter !== "string") {
                var errorMessage = "Filters sent are not of type String.";
                logger.error(LOG_PREFIX, genericErrorMessage + errorMessage);
                throw new KSError(KSErrorConstants.SYNC_INVALID_FILTERS, genericErrorMessage + errorMessage);
            }
            logger.debug(LOG_PREFIX, "Validation of filters successful.");
        }
    }
    //------------------------------------
    // PRIVATE HELPER METHODS FOR DOWNLOAD
    //------------------------------------
    /**
     * Method to assert the mode of the object.
     * @param mode
     */
    function assertMode(mode) {
        if (mode !== KSInternalConstants.MODE) {
            var errorMessage = "Sync Mode error";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.INTERNAL_INVALID_SYNC_MODE, errorMessage);
        }
    }
    /**
     * Method to fetch the headers for a download request.
     * @returns {{}} JSON object for headers.
     */
    function getDownloadRequestHeaders() {
        var headers = {};
        var version = this.metadata[KSInternalConstants.VERSION];
        if (!kony.sdk.isNullOrUndefined(version)) {
            headers[KSInternalConstants.X_KONY_API_VERSION] = version;
        }
        return headers;
    }
    /**
     * Method to fetch the delta context stored in the DB.
     * @returns DeltaContext JSON.
     */
    async function getDeltaContext() {
        var mapOfNameAndFilter = {};
        mapOfNameAndFilter[KSInternalConstants.OBJECT_NAME] = this.getFullyQualifiedName();
        mapOfNameAndFilter[KSInternalConstants.FILTER] = this.filter;
        return await KSDeltaContextUtils.getDeltaContextForGivenObjectNamesAndFilters([mapOfNameAndFilter]);
    }
    /**
     * Building queryParams to be sent during download request.
     * @param context options sent during sync.
     * @returns Object JSONObject containing the query params.
     */
    function buildDownloadRequestQueryParams(context) {
        var options = context[KSInternalConstants.SYNC_OPTIONS];
        var queryParams = KSOptionsHelper.validateAndGetQueryParams(options, KSPublicConstants.SYNC_DOWNLOAD_QUERY_PARAMS);
        if (!KSCommonUtils.isNullOrEmptyObject(this.filter)) {
            queryParams[KSInternalConstants.DOLLAR_FILTER] = this.filter;
        }
        //Check if exists and add $expand
        var dollarExpandValueOfObject = require("KSRequestResponseUtils").getDollarExpandValueFromObjectOperations(this.metadata);
        if (dollarExpandValueOfObject.length > 0) {
            queryParams[KSInternalConstants.DOLLAR_EXPAND] = dollarExpandValueOfObject;
        }
        queryParams[KSInternalConstants.BATCH_SIZE_FILTER] = context[KSInternalConstants.SYNC_OPTIONS][KSPublicConstants.DOWNLOAD_BATCH_SIZE];
        return queryParams;
    }
    /**
     * Method to build the body for download request.
     * @returns Object jsonObject to be sent as a part of the body.
     */
    async function buildDownloadRequestBodyParam(batchContext) {
        var jsonObject = {};
        if (!KSCommonUtils.isNullOrEmptyObject(batchContext[KSInternalConstants.BATCH_CONTEXT])) {
            jsonObject[KSInternalConstants.DELTA_CONTEXT] = batchContext[KSInternalConstants.BATCH_CONTEXT];
        } else {
            var deltaContextList = await getDeltaContext.call(this);
            if (!KSCommonUtils.isNullOrEmptyObject(deltaContextList)) {
                var objsDictionary = {};
                for (var i = 0; i < deltaContextList.length; i++) {
                    var deltaContextDictionary = {};
                    deltaContextDictionary[KSInternalConstants.DELTA] = deltaContextList[i][KSInternalConstants.DELTACONTEXT];
                    objsDictionary[deltaContextList[i][KSInternalConstants.OBJECT_NAME]] = deltaContextDictionary;
                }
                var objectLevelDictionary = {};
                objectLevelDictionary[KSInternalConstants.OBJS] = objsDictionary;
                jsonObject[KSInternalConstants.DELTA_CONTEXT] = objectLevelDictionary;
            }
        }
        return jsonObject;
    }
    exports.KSSDKObject = KSSDKObject;
});
/**
 * KSSDKObjectRecord
 * Created by Haritha Kintali on 30-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
define("KSSDKObjectRecord", ["exports", "KSSDKObjectRecordMetadata", "KSError"], function(exports, KSSDKObjectRecordMetadata, _KSError) {
    "use strict";
    exports._esModule = true;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSError = _KSError.KSError;

    function KSSDKObjectRecord(record, parentObject) {
        this.data = record ? kony.sdk.cloneObject(record) : {};
        this.parentObject = parentObject ? parentObject : {};
        this.recordMetadata = new KSSDKObjectRecordMetadata.KSSDKObjectRecordMetadata();
    }
    KSSDKObjectRecord.prototype.getData = function() {
        return this.data;
    };
    KSSDKObjectRecord.prototype.getParentObject = function() {
        return this.parentObject;
    };
    KSSDKObjectRecord.prototype.setParentObject = function(parentObject) {
        this.parentObject = parentObject;
    };
    KSSDKObjectRecord.prototype.getRecordMetadata = function() {
        return this.recordMetadata;
    };
    KSSDKObjectRecord.prototype.setRecordMetadata = function(recordMetadata) {
        this.recordMetadata = recordMetadata;
    };
    KSSDKObjectRecord.prototype.objectForKey = function(key) {
        return this.data[key];
    };
    KSSDKObjectRecord.prototype.setObjectForKey = function(key, value) {
        this.data[key] = value;
    };
    KSSDKObjectRecord.prototype.getAction = function() {
        return this.recordMetadata.action;
    };
    KSSDKObjectRecord.prototype.setAction = function(action) {
        this.recordMetadata.action = action;
    };
    KSSDKObjectRecord.prototype.getCheckSum = function() {
        return this.recordMetadata.checkSum;
    };
    KSSDKObjectRecord.prototype.setCheckSum = function(checkSum) {
        this.recordMetadata.checkSum = checkSum;
    };
    KSSDKObjectRecord.prototype.getOpStatus = function() {
        return this.recordMetadata.opStatus;
    };
    KSSDKObjectRecord.prototype.setOpStatus = function(opStatus) {
        this.recordMetadata.opStatus = opStatus;
    };
    KSSDKObjectRecord.prototype.setRowid = function(rowid) {
        this.recordMetadata.rowId = rowid;
    };
    KSSDKObjectRecord.prototype.getRowId = function() {
        return this.recordMetadata.rowId;
    };
    KSSDKObjectRecord.prototype.getErrorMessage = function() {
        return this.recordMetadata.errorMessage;
    };
    KSSDKObjectRecord.prototype.setErrorMessage = function(errorMessage) {
        this.recordMetadata.errorMessage = errorMessage;
    };
    KSSDKObjectRecord.prototype.getIntermediateErrors = function() {
        return this.recordMetadata.intermediateErrors;
    };
    KSSDKObjectRecord.prototype.setIntermediateErrors = function(intermediateErrors) {
        this.recordMetadata.intermediateErrors = intermediateErrors;
    };
    KSSDKObjectRecord.prototype.getPrimaryKeyValueMapOfRecord = function(primaryKeys) {
        var primaryKeyValueMap = {};
        if (primaryKeys) {
            for (var i = 0; i < primaryKeys.length; i++) {
                var key = primaryKeys[i];
                primaryKeyValueMap[key] = this.data[key];
            }
        }
        return primaryKeyValueMap;
    };
    /**
     * Get primary key value map of the upload record
     * @param primaryKeys - primary key attributes of the record
     * @return primaryKeyValueMap - JSON of the primary key(s) values of the record
     */
    KSSDKObjectRecord.prototype.getPrimaryKeyValueMapOfUploadRecord = function(primaryKeys) {
        var primaryKeyValueMap = {};
        if (primaryKeys) {
            for (var i = 0; i < primaryKeys.length; i++) {
                var key = primaryKeys[i];
                if (this.data.hasOwnProperty(key)) {
                    primaryKeyValueMap[key] = this.data[key];
                } else {
                    var error = new KSError(KSErrorConstants.SYNC_EMPTY_PRIMARYKEY_VALUE, "In upload response, primary keys are mandatory");
                    error.message = (error.message).replace('%s', key);
                    throw error;
                }
            }
        }
        return primaryKeyValueMap;
    };
    KSSDKObjectRecord.prototype.isGivenPKValuePairPresentInRecord = function(primaryKeyValuePair) {
        for (var key in primaryKeyValuePair) {
            if (!this.data[key] || this.data[key] != primaryKeyValuePair[key]) {
                return false;
            }
        }
        return true;
    };
    exports.KSSDKObjectRecord = KSSDKObjectRecord;
});
kony.sdk.OfflineObjects.KSSDKObjectRecordAction = Object.freeze({
    UPDATE: 0,
    CREATE: 1,
    PARTIAL_UPDATE: 2,
    DELETE: 3,
    READ: 4,
    NONE: 5,
    DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES: 70,
    DO_NOT_TRACK_INTERMEDIATE_UPDATES: 80,
    DEFERRED_UPDATE: 90,
    DEFERRED_CREATE: 91,
    DEFERRED_DELETE: 93
});
/**
 * Returns the action as string for its enum type
 * @type {Readonly<string>} action type as string
 */
kony.sdk.OfflineObjects.getValueOfRecordActionAsString = Object.freeze({
    0: "update",
    1: "create",
    2: "partialupdate",
    3: "delete",
    4: "read",
    5: "none",
    70: "deferedAndDontTrackIntermediateUpdates",
    80: "dontTrackIntermediateUpdates",
    90: "deferredupdate",
    91: "deferredcreate",
    93: "deferreddelete"
});
/**
 * Method to map KSSDKObjectRecordAction to downloaded action type of record.
 * @param recordAction Record action type received in download response.
 * @returns {number} Corresponding KSSDKObjectRecordAction for record action type
 * received in download response.
 */
kony.sdk.OfflineObjects.getKSSDKObjectRecordAction = function(recordAction) {
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    switch (recordAction) {
        case "update":
            return KSSDKObjectRecordAction.UPDATE;
        case "partialupdate":
            return KSSDKObjectRecordAction.PARTIAL_UPDATE;
        case "create":
            return KSSDKObjectRecordAction.CREATE;
        case "delete":
            return KSSDKObjectRecordAction.DELETE;
        default:
            return KSSDKObjectRecordAction.NONE;
    }
};
/**
 * Gives the counter action type for given action type.
 * @param recordAction Record action type received from database.
 * @return {number} Counter KSSDKObjectRecordAction for given record action type.
 */
kony.sdk.OfflineObjects.getReverseActionType = function(recordAction) {
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    switch (recordAction) {
        case KSSDKObjectRecordAction.UPDATE:
        case KSSDKObjectRecordAction.PARTIAL_UPDATE:
            return KSSDKObjectRecordAction.UPDATE;
        case KSSDKObjectRecordAction.CREATE:
            return KSSDKObjectRecordAction.DELETE;
        case KSSDKObjectRecordAction.DELETE:
            return KSSDKObjectRecordAction.CREATE;
        default:
            return KSSDKObjectRecordAction.NONE;
    }
};
/**
 * KSSDKObjectRecordMetadata
 * Created by Haritha Kintali on 30-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
define("KSSDKObjectRecordMetadata", ["exports"], function(exports) {
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;

    function KSSDKObjectRecordMetadata() {
        this.action = KSSDKObjectRecordAction.UPDATE;
        this.ignoreOfflineDuplicates = false;
        this.opStatus = 0;
        this.checkSum = null;
        this.rowId = null;
        this.errorMessage = null;
        this.intermediateErrors = null;
    }
    exports.KSSDKObjectRecordMetadata = KSSDKObjectRecordMetadata;
});
define("KSSDKObjectService", ["exports", "KSSetupManager", "KSSyncMetaInfo", "KSError", "KSDeltaContextUtils", "KSDatabaseAPI", "KSSyncDatabaseHelper", "KSOptionsHelper", "KSCommonUtils", "SyncEngine", "KSMetadataUtils", "KSUploadPayloadBuilder", "KSUploadCacheManager"], function(exports, KSSetupManager, KSSyncMetaInfo, _KSError, KSDeltaContextUtils, _KSDatabaseAPI, KSSyncDatabaseHelper, KSOptionsHelper, KSCommonUtils, SyncEngine, KSMetadataUtils, KSUploadPayloadBuilder, KSUploadCacheManager) {
    "use strict";
    exports._esModule = true;
    var sdk = kony.sdk;
    var logger = sdk.logsdk;
    var sdkObjectServicesMap = {};
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSSDKObjectService : ";
    var _KSSDKObject = require("KSSDKObject");
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSErrorConstants = sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = sdk.OfflineObjects.KSInternalConstants;
    /**
     *  This creates the object of KSSDKObjectService.
     * @param objectServiceName object Service Name.
     * @constructor
     */
    function KSSDKObjectService(objectServiceName) {
        if (KSCommonUtils.isNullOrEmptyObject(objectServiceName)) {
            var errorMessage = "Cannot create Offline Object Service with name as null or empty string.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.METADATA_SDKOBJECTSERVICE_NAME_NULL_OR_EMPTY, errorMessage);
        }
        this.filter = {};
        this.objectNames = [];
        this.name = objectServiceName;
        this.mode = KSInternalConstants.MODE;
        this.fullyQualifiedNamesForObjects = [];
        this.sdkObjectsForUploadAndDownload = [];
        this.metadata = KSSetupManager.getInstance().getSetupContext()[objectServiceName];
        populateObjectNames.call(this);
    }
    //------------------------------------
    // PROTOTYPE GETTER AND SETTER METHODS
    //------------------------------------
    /**
     * Method to fetch the fullyQualifiedNames for objects in the object service.
     * @returns {Array} FullyQualifiedNames for objects in the object service.
     */
    KSSDKObjectService.prototype.getObjectNames = function() {
        return this.fullyQualifiedNamesForObjects;
    };
    /**
     *  Method to fetch fully qualified name of the object service.
     * @returns {*} Fully qualified name of the object service.
     */
    KSSDKObjectService.prototype.getFullyQualifiedName = function() {
        return this.name;
    };
    /**
     *  Method to fetch name of the object service .
     * @returns {*} Name of the object service.
     */
    KSSDKObjectService.prototype.getObjectServiceName = function() {
        return this.name;
    };
    /**
     * Method to fetch the sync level.
     * @returns {string} Sync level.
     */
    KSSDKObjectService.prototype.getSyncLevel = function() {
        return KSInternalConstants.SYNCLEVEL_OBJECTSERVICE;
    };
    /**
     * Method to fetch the Sync MetaInfo associated to the object service.
     * @returns {*} MetaInfo dictionary.
     */
    KSSDKObjectService.prototype.getSyncMetaInfo = async function() {
        if (sdk.isNullOrUndefined(this.metainfo)) {
            this.metainfo = await KSSyncMetaInfo.getInstance(this.name);
        }
        return this.metainfo;
    };
    /**
     * Getter to fetch the metadata associated with the object service.
     * @returns Metadata associated with the object servic.
     */
    KSSDKObjectService.prototype.getMetadata = function() {
        return this.metadata;
    };
    //-------------------------------
    // PROTOTYPE METHODS FOR DOWNLOAD
    //-------------------------------
    /**
     * Method to fetch the headers for a upload request.
     * @returns {{}} JSON object for headers.
     */
    function getUploadRequestHeaders() {
        var headers = {};
        headers[KSInternalConstants.X_HTTP_METHOD_OVERRIDE] = KSInternalConstants.HTTP_OVERRIDE_UPLOAD;
        var version = this.metadata[KSInternalConstants.VERSION];
        if (!kony.sdk.isNullOrUndefined(version)) {
            headers[KSInternalConstants.X_KONY_API_VERSION] = version;
        }
        return headers;
    }
    /**
     * Method to start sync on the given object service.
     *
     * @param options syncConfig Options passed for sync.
     */
    KSSDKObjectService.prototype.startSync = async function(options) {
        logger.trace(LOG_PREFIX, "Starting Sync Session for Object Service : " + this.name);
        assertMode(this.mode);
        validateOptions.call(this, options);
        logger.info(LOG_PREFIX, "Starting Sync Operation for ObjectService : " + this.name);
        var syncEngineInstance = SyncEngine.getInstance();
        return (await syncEngineInstance.startSyncSessionForObject(options, this));
    };
    /**
     * Method to clear the objects and properties used for sync.
     */
    KSSDKObjectService.prototype.clearObjectsToPersist = function() {
        this.filter = {};
        KSCommonUtils.clearArrayObject(this.sdkObjectsForUploadAndDownload);
    };
    /**
     * Forms a list of objects for object service.
     * @return {Array} list of objects under object service.
     */
    KSSDKObjectService.prototype.getAllObjects = function() {
        var sdkObjects = [];
        var objectNamesLen = this.objectNames.length;
        for (var index = objectNamesLen - 1; index >= 0; index--) {
            sdkObjects.push(new _KSSDKObject.KSSDKObject(this.objectNames[index], null, this.name));
        }
        return sdkObjects;
    };
    /**
     * List of objects to upload
     * @return {Promise<Array>} objects to upload
     */
    KSSDKObjectService.prototype.objectsToUpload = async function() {
        var sdkObjects = this.getAllObjects();
        return await KSSyncDatabaseHelper.getDeltaChangesToUpload(sdkObjects);
    };
    /**
     * Creates upload request params and returns the json { payload, headers, url}
     * @options Contains the options for sync like filter, query params etc.
     * @return {Promise<JSON>} requests parameters needed.
     */
    KSSDKObjectService.prototype.createUploadRequest = async function(options) {
        logger.info(LOG_PREFIX, "CreateUploadRequest is called in SDKObject");
        var uploadRequestParams = {};
        var uploadRequestBuilder = await KSUploadPayloadBuilder.getInstance(this);
        if (!uploadRequestBuilder.areThereRecordsToUpload()) {
            logger.info(LOG_PREFIX, "There are no pending changes to upload in object service " + this.name);
            uploadRequestParams[KSInternalConstants.ARE_THERE_CHANGES_TO_UPLOAD] = false;
            return uploadRequestParams;
        }
        uploadRequestParams[KSInternalConstants.URL] = getEndPointURLString.call(this);
        uploadRequestParams[KSInternalConstants.REQUEST_HEADERS] = getUploadRequestHeaders.call(this);
        uploadRequestParams[KSInternalConstants.REQUEST_BODY] = uploadRequestBuilder.getUploadRequestJson();
        uploadRequestParams[KSInternalConstants.REQUEST_QUERY_PARAMS] = KSOptionsHelper.validateAndGetQueryParams(options, KSPublicConstants.SYNC_UPLOAD_QUERY_PARAMS);
        uploadRequestParams[KSInternalConstants.ARE_THERE_CHANGES_TO_UPLOAD] = true;
        return uploadRequestParams;
    };
    /**
     * This will Parse the upload response and forms the JSON which has DATA_OBJECTS and SYNC_ERRORS.
     * @param response  given network response.
     * @return {JSON} Returns the JSON which has DATA_OBJECTS and SYNC_ERRORS.
     */
    KSSDKObjectService.prototype.parseUploadResponse = function(response) {
        return require("KSRequestResponseUtils").uploadResponseObjectsDictionaryFromJSONString(response);
    };
    /**
     * Persists the upload response in given object
     * @param sdkObjects    objects to persist.
     */
    KSSDKObjectService.prototype.persistUploadChanges = async function(sdkObjects) {
        await KSSyncDatabaseHelper.persistUploadResponseForObjects(sdkObjects);
    };
    /**
     *  Method to creates the download request parameters for sync.
     * @param context context passed to create download request.
     * @returns requestBodyParams The download request parameters.
     */
    KSSDKObjectService.prototype.createDownloadRequest = async function(context) {
        logger.trace(LOG_PREFIX, "Starting CreateDownloadRequest for Object Service.");
        var requestParams = {};
        try {
            setFilter.call(this, context);
            var queryParams = buildDownloadRequestQueryParams(context);
            var deltaContext;
            if (KSCommonUtils.isNullOrEmptyObject(context[KSInternalConstants.BATCH_CONTEXT])) {
                deltaContext = await getDeltaContext.call(this);
            } else {
                deltaContext = context;
            }
            var requestBodyParam = buildDownloadRequestBodyParam.call(this, deltaContext);
            requestParams[KSInternalConstants.URL] = getEndPointURLString.call(this);
            requestParams[KSInternalConstants.BODY] = requestBodyParam;
            requestParams[KSInternalConstants.QUERY_PARAMS] = queryParams;
            requestParams[KSInternalConstants.HEADERS] = getDownloadRequestHeaders.call(this);
            logger.debug(LOG_PREFIX, "Successfully created parameters for object service download request.");
            return requestParams;
        } catch (exception) {
            var errorMessage = "Error in  building download request " + exception;
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.SYNC_GENERIC_ERROR, errorMessage);
        }
    };
    /**
     *  Method to prepare the object service instance for sync session.
     */
    KSSDKObjectService.prototype.prepareForSession = function() {};
    /**
     * Method to parse the download response received from the network.
     * @param downloadResponse Response JSON.
     * @returns {*|{}} Returns a parsed response dictionary.
     */
    KSSDKObjectService.prototype.parseDownloadResponse = function(downloadResponse) {
        logger.trace(LOG_PREFIX, "Parsing response for object service : " + this.name);
        //Using require to avoid circular dependencies..
        var responseDictionary = require("KSRequestResponseUtils").getObjectServiceDownloadResponseDictionaryFromNetworkResponse(downloadResponse, this.name);
        if (!sdk.isNullOrUndefined(responseDictionary) && responseDictionary.hasOwnProperty(KSInternalConstants.DATA_OBJECTS)) {
            this.sdkObjectsForUploadAndDownload = responseDictionary[KSInternalConstants.DATA_OBJECTS];
            responseDictionary[KSInternalConstants.HAS_MORE_RECORDS] = downloadResponse[KSInternalConstants.HAS_MORE_RECORDS];
        }
        return responseDictionary;
    };
    /**
     * Method to persist the changes after parsing the response received from the network.
     * @param deltaContext Delta context received for the sync session.
     */
    KSSDKObjectService.prototype.persistDownloadChanges = async function(deltaContext) {
        logger.trace(LOG_PREFIX, "Persisting download for object service : " + this.name);
        var queryObjectsForData = await KSSyncDatabaseHelper.buildQueriesToPersistChangesForObjects(this.sdkObjectsForUploadAndDownload);
        var deltaContextQueryObj = KSDeltaContextUtils.buildDeltaContextQuery(deltaContext, this.filter);
        var queryObjects = [];
        Array.prototype.push.apply(queryObjects, queryObjectsForData);
        Array.prototype.push.apply(queryObjects, deltaContextQueryObj);
        logger.info(LOG_PREFIX, "Executing queries in transaction for persisting download response for object service : " + this.name);
        await KSDatabaseAPI.executeQueries(queryObjects, true);
        logger.debug(LOG_PREFIX, "Successfully executed queries for persisting download response for object service : " + this.name);
    };
    /**
     * Rollback an ObjectService to it's previous Sync State
     */
    KSSDKObjectService.prototype.rollback = async function() {
        var syncEngineInstance = SyncEngine.getInstance();
        if (syncEngineInstance.isRollbackOperationAllowed(KSInternalConstants.SYNCLEVEL_OBJECTSERVICE, this)) {
            syncEngineInstance.updateRunningTaskContextWithRollbackTasks(KSInternalConstants.SYNCLEVEL_OBJECTSERVICE, this);
            logger.info(LOG_PREFIX, "Rollback on Object service : " + this.name + " Start.");
            var preparedStatementsForRollback = await this.buildPreparedStatementsForObjectServiceRollback();
            await KSDatabaseAPI.executeQueries(preparedStatementsForRollback, true);
            await clearUploadCacheOnRollback(this.getFullyQualifiedName(), this.fullyQualifiedNamesForObjects);
        } else {
            var errorMessage = "Rollback cannot be performed as other Offline Object operations are in progress.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage);
        }
    };
    async function clearUploadCacheOnRollback(objectServiceName, objectNames) {
        var cacheManagerInstance = KSUploadCacheManager.getInstance();
        await cacheManagerInstance.removeRecord(objectServiceName);
        var objectsCount = objectNames.length;
        for (var index = 0; index < objectsCount; index++) {
            await cacheManagerInstance.removeRecord(objectNames[index]);
        }
    }
    /**
     * Method to build the prepared statements for rollback.
     * @returns {Promise<Array>} Array of prepared statements.
     */
    KSSDKObjectService.prototype.buildPreparedStatementsForObjectServiceRollback = async function() {
        logger.debug(LOG_PREFIX, "Building PreparedStatements For Rollback on ObjectService : " + this.name);
        var preparedStatementsForRollback = [];
        var sdkObjects = this.getAllObjects();
        var sdkObjectsLength = sdkObjects.length;
        for (var index = 0; index < sdkObjectsLength; index++) {
            Array.prototype.push.apply(preparedStatementsForRollback, await KSSyncDatabaseHelper.buildPreparedStatementsForObjectRollback(sdkObjects[index], null));
        }
        return preparedStatementsForRollback;
    };
    //-----------------------------------
    // PRIVATE GETTER AND SETTER METHODS
    //-----------------------------------
    /**
     * Method to populate objectNames and fullyQualifiedNamesForObjects from namespacemetadata.
     */
    function populateObjectNames() {
        logger.trace(LOG_PREFIX, "Populating fully qualified names of SDK Objects.");
        if (sdk.isNullOrUndefined(this.metadata)) {
            var errorMessage = "Metadata not found for object service : " + this.name;
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.METADATA_INVALID_OBJECT_SERVICE_NAME, errorMessage);
        }
        var namespaceMetadataList = this.metadata[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY];
        for (var namespace in namespaceMetadataList) {
            var objectMetadataList = namespaceMetadataList[namespace][KSInternalConstants.OBJECT_METADATA_DICTIONARY];
            for (var objectName in objectMetadataList) {
                this.objectNames.push(objectName);
                this.fullyQualifiedNamesForObjects.push(objectMetadataList[objectName][KSInternalConstants.FULLY_QUALIFIED_NAME]);
            }
        }
        logger.debug(LOG_PREFIX, JSON.stringify(this.objectNames));
    }
    /**
     *  Method to return the endpoint url for sync.
     * @returns {string} URL string.
     */
    function getEndPointURLString() {
        return this.metadata[KSInternalConstants.ENDPOINT_URL];
    }
    /**
     * Method to fetch instance of object service.
     * @param objectServiceName Name of the object service.
     * @returns {*} The object service instance.
     */
    function getInstanceByName(objectServiceName) {
        logger.trace(LOG_PREFIX, "Fetching instance of KSSDKObjectService with name : " + objectServiceName);
        if (!sdkObjectServicesMap.hasOwnProperty(objectServiceName)) {
            sdkObjectServicesMap[objectServiceName] = new KSSDKObjectService(objectServiceName);
        }
        return sdkObjectServicesMap[objectServiceName];
    }
    /**
     * Clears the sdkObjectServicesMap.
     */
    function clearObjectServiceMap() {
        KSCommonUtils.clearJSONObject(sdkObjectServicesMap);
    }
    //-----------------------------------
    // PRIVATE HELPER METHODS FOR DOWNLOAD
    //-----------------------------------
    /**
     * Method to assert the mode of the object.
     * @param mode Mode of the sync object.
     */
    function assertMode(mode) {
        if (mode != KSInternalConstants.MODE) {
            var errorMessage = "Mode should be OFFLINE.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.INTERNAL_INVALID_SYNC_MODE, errorMessage);
        }
    }
    /**
     * This function creates request Body for create Download Request
     * @param deltaContext deltaContext List
     * @returns jsonString JSON string to be sent in the body.
     */
    function buildDownloadRequestBodyParam(deltaContext) {
        logger.trace(LOG_PREFIX, "Building body params of download request.");
        var deltaContextObject = {};
        var objsDictionary = {};
        var objectNameAndDollarExpandValueMap = getDollarExpandValueForAllObjectsInObjectService.call(this);
        if (!KSCommonUtils.isNullOrEmptyObject(deltaContext[KSInternalConstants.BATCH_CONTEXT])) {
            deltaContextObject[KSInternalConstants.DELTA_CONTEXT] = deltaContext[KSInternalConstants.BATCH_CONTEXT];
        } else {
            if (!KSCommonUtils.isNullOrEmptyObject(deltaContext)) {
                logger.info(LOG_PREFIX, "Adding deltaContext values in the download request body.");
                // Adding deltaContext key in the request Body for each object
                var deltaContextLength = deltaContext.length;
                for (var name = 0; name < deltaContextLength; name++) {
                    var fullyQualifiedObjectName = deltaContext[name][KSInternalConstants.OBJECT_NAME];
                    var objectName = KSMetadataUtils.objectNameFromFullyQualifiedName(fullyQualifiedObjectName);
                    var contextDictionary = {};
                    contextDictionary[KSInternalConstants.DELTA] = deltaContext[name][KSInternalConstants.DELTACONTEXT];
                    objsDictionary[objectName] = contextDictionary;
                }
            }
            //loop to add filter data and $expand odata query options to the object
            //Works even if delta context is not available only for some objects in the object service
            var fullyQualifiedObjectLength = this.fullyQualifiedNamesForObjects.length;
            for (var name = 0; name < fullyQualifiedObjectLength; name++) {
                var fullyQualifiedName = this.fullyQualifiedNamesForObjects[name];
                var objectName = KSMetadataUtils.objectNameFromFullyQualifiedName(fullyQualifiedName);
                var odataStringValue = "";
                var filterForObject = this.filter[objectName];
                if (!KSCommonUtils.isNullOrEmptyObject(filterForObject)) {
                    odataStringValue += KSInternalConstants.DOLLAR_FILTER_EQUALS_TO + filterForObject;
                }
                if (objectNameAndDollarExpandValueMap.hasOwnProperty(fullyQualifiedName)) {
                    var dollarExpandString = KSInternalConstants.DOLLAR_EXPAND_EQUALS_TO + objectNameAndDollarExpandValueMap[fullyQualifiedName];
                    if (odataStringValue.length > 0) {
                        dollarExpandString = '&' + dollarExpandString;
                    }
                    odataStringValue += dollarExpandString;
                }
                if (!KSCommonUtils.isNullOrEmptyObject(odataStringValue)) {
                    if (objsDictionary.hasOwnProperty(objectName)) {
                        objsDictionary[objectName][KSInternalConstants.ODATASTRING] = odataStringValue;
                    } else {
                        var contextDictionary = {};
                        contextDictionary[KSInternalConstants.ODATASTRING] = odataStringValue;
                        objsDictionary[objectName] = contextDictionary;
                    }
                }
            }
        }
        if (!KSCommonUtils.isNullOrEmptyObject(objsDictionary)) {
            var objectLevelDictionary = {};
            objectLevelDictionary[KSInternalConstants.OBJS] = objsDictionary;
            deltaContextObject[KSInternalConstants.DELTA_CONTEXT] = objectLevelDictionary;
        }
        logger.debug(LOG_PREFIX, "Successfully built request body.");
        return deltaContextObject;
    }
    /**
     * This function gets records from indexedDB matching deltContext
     * @returns {*}
     */
    async function getDeltaContext() {
        logger.trace(LOG_PREFIX, "Starting to fetch delta context.");
        var listOfObjectNamesAndFilters = getListOfObjectNameAndFilters.call(this);
        return await KSDeltaContextUtils.getDeltaContextForGivenObjectNamesAndFilters(listOfObjectNamesAndFilters);
    }
    /**
     * Method to fetch the headers for a download request.
     * @returns {{}} JSON object for headers.
     */
    function getDownloadRequestHeaders() {
        logger.trace(LOG_PREFIX, "Starting to build request headers.");
        var headers = {};
        var version = this.metadata[KSInternalConstants.VERSION];
        if (!kony.sdk.isNullOrUndefined(version)) {
            headers[KSInternalConstants.X_KONY_API_VERSION] = version;
        }
        logger.debug(LOG_PREFIX, "Request Headers : " + JSON.stringify(headers));
        return headers;
    }
    /**
     * Fetches the listOfObjectNameAndFilters to be passed for fetching DeltaContext
     * @returns {Array}
     */
    function getListOfObjectNameAndFilters() {
        logger.trace(LOG_PREFIX, "Preparing list of object names and their respective filters.");
        var listOfObjectNameAndFilters = [];
        var lengthOfFullyQualifiedNamesForObjects = this.fullyQualifiedNamesForObjects.length;
        for (var i = 0; i < lengthOfFullyQualifiedNamesForObjects; i++) {
            var objectNameAndFilterMap = {};
            var objectName = this.fullyQualifiedNamesForObjects[i];
            var filter = kony.sdk.isNullOrUndefined(this.filter[KSMetadataUtils.objectNameFromFullyQualifiedName(objectName)]) ? KSInternalConstants.EMPTY_STRING : this.filter[KSMetadataUtils.objectNameFromFullyQualifiedName(objectName)];
            objectNameAndFilterMap[KSInternalConstants.OBJECT_NAME] = objectName;
            objectNameAndFilterMap[KSInternalConstants.FILTER] = filter;
            listOfObjectNameAndFilters.push(objectNameAndFilterMap);
        }
        logger.debug(LOG_PREFIX, "List Of ObjectName and Filters are : " + JSON.stringify(listOfObjectNameAndFilters));
        return listOfObjectNameAndFilters;
    }
    /**
     *  Sets filter
     * @param context context
     */
    function setFilter(context) {
        logger.trace(LOG_PREFIX, "Starting to set filter.");
        var options = context[KSInternalConstants.SYNC_OPTIONS];
        if (!kony.sdk.isNullOrUndefined(options) && options.hasOwnProperty(KSInternalConstants.FILTER)) {
            var filterMap = options[KSInternalConstants.FILTER];
            logger.debug(LOG_PREFIX, "Setting Filter: " + JSON.stringify(filterMap));
            this.filter = filterMap;
        }
        var lengthOfFullyQualifiedObjects = this.fullyQualifiedNamesForObjects.length;
        for (var i = 0; i < lengthOfFullyQualifiedObjects; i++) {
            if (!this.filter.hasOwnProperty(this.fullyQualifiedNamesForObjects[i])) {
                this.filter[this.fullyQualifiedNamesForObjects[i]] = "";
            }
        }
        logger.debug(LOG_PREFIX, "Filters object is as follows : " + JSON.stringify(this.filter));
    }
    /**
     * This builds the Download Request Query Params for create Download request
     * @param context context
     * @returns queryParams
     */
    function buildDownloadRequestQueryParams(context) {
        logger.trace(LOG_PREFIX, "Starting to build query params for download request.");
        var options = context[KSInternalConstants.SYNC_OPTIONS];
        var queryParams = KSOptionsHelper.validateAndGetQueryParams(options, KSPublicConstants.SYNC_DOWNLOAD_QUERY_PARAMS);
        queryParams[KSInternalConstants.OFFLINE_FLAG] = KSInternalConstants.OFFLINE_FLAG_VALUE;
        queryParams[KSInternalConstants.BATCH_SIZE_FILTER] = context[KSInternalConstants.SYNC_OPTIONS][KSPublicConstants.DOWNLOAD_BATCH_SIZE];
        logger.debug(LOG_PREFIX, "QueryParams are as follows : " + JSON.stringify(queryParams));
        return queryParams;
    }
    //-----------------------------------
    // PRIVATE METHODS FOR OPTIONS VALIDATIONS
    //-----------------------------------
    /**
     * This util validates the options passed to startSync
     * @param options SyncConfig
     */
    function validateOptions(options) {
        logger.trace(LOG_PREFIX, "Validating the options sent for sync.");
        validateFilters.call(this, options);
        KSOptionsHelper.validateSyncConfigPolicy(options);
    }
    /**
     * This util validates the filters passed in options of startSync
     * @param options SyncConfig
     */
    function validateFilters(options) {
        logger.trace(LOG_PREFIX, "Starting to validate the filters.");
        if (!kony.sdk.isNullOrUndefined(options) && options.hasOwnProperty(KSInternalConstants.FILTER)) {
            var filterObject = options[KSInternalConstants.FILTER];
            //Validate if the filter object is not null, instance of Map and not empty..
            if ((!(typeof filterObject == "object")) || (KSCommonUtils.isNullOrEmptyObject(filterObject))) {
                var errorMessage = "Filters sent are either null/empty or of a unexpected datatype.";
                logger.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.SYNC_INVALID_FILTERS, errorMessage);
            }
            //Validate that all the objects in the filter map sent belong to the ObjectService
            //and the filter associated with it is not null
            var filterMap = filterObject;
            for (var objectName in filterMap) {
                if (this.objectNames.indexOf(objectName) != -1 || this.fullyQualifiedNamesForObjects.indexOf(objectName) != -1) {
                    var filterObjectSentForObject = filterMap[objectName];
                    if ((typeof filterObjectSentForObject != "string") || (KSCommonUtils.isNullOrEmptyObject(filterObjectSentForObject))) {
                        var errorMessage = "Filter sent for object " + objectName + " is either null/empty string or not a string.";
                        logger.error(LOG_PREFIX, errorMessage);
                        throw new KSError(KSErrorConstants.SYNC_INVALID_FILTERS, errorMessage);
                    }
                } else {
                    var errorMessage = objectName + " sent in filter options doesn't belong to ObjectService " + this.name;
                    logger.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.SYNC_INVALID_FILTERS, errorMessage);
                }
            }
        }
        logger.info(LOG_PREFIX, "Filters sent in the options are valid.");
    }
    /**
     * Method to get $expand query option value for all the objects in the object service
     * @return Map having Object Name as key and $expand as value.
     */
    function getDollarExpandValueForAllObjectsInObjectService() {
        var objectNameAndDollarExpandValueMap = {};
        var objectsLength = this.fullyQualifiedNamesForObjects.length;
        for (var index = 0; index < objectsLength; index++) {
            var fullyQualifiedObjectName = this.fullyQualifiedNamesForObjects[index];
            var objectMetadata = KSSetupManager.getInstance().getObjectMetadataForFullyQualifiedObjectName(fullyQualifiedObjectName);
            var dollarExpandValueOfObject = require("KSRequestResponseUtils").getDollarExpandValueFromObjectOperations(objectMetadata);
            if (dollarExpandValueOfObject.length > 0) {
                objectNameAndDollarExpandValueMap[fullyQualifiedObjectName] = dollarExpandValueOfObject;
            }
        }
        return objectNameAndDollarExpandValueMap;
    }
    exports.getInstanceByName = getInstanceByName;
    exports.clearObjectServiceMap = clearObjectServiceMap;
});
define("KSSyncMetaInfo", ["exports", "KSSQLQueryGenerator", "KSDatabaseAPI"], function(exports, KSSQLQueryGenerator, _KSDatabaseAPI) {
    var TAG = "KSSyncMetaInfo : ";
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;

    function KSSyncMetaInfo(objectServiceName) {
        this.objectServiceName = objectServiceName;
        this.uploadSyncSessionNumber = 1;
        this.replaySequenceNumber = 1;
        this.lastGeneratedId = -1;
    }
    async function init(objectServiceName) {
        var _this = new KSSyncMetaInfo(objectServiceName);
        var result = await getMetaInfoForObjectServiceName(_this.objectServiceName);
        if (result) {
            for (var key in result) {
                if (result.hasOwnProperty(key)) {
                    switch (key.toLocaleLowerCase()) {
                        case (KSDatabaseConstants.UPLOAD_SESSION_NO).toLocaleLowerCase():
                            _this.uploadSyncSessionNumber = result[key];
                            break;
                        case (KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER).toLocaleLowerCase():
                            _this.replaySequenceNumber = result[key];
                            break;
                        case (KSDatabaseConstants.LAST_GENERATED_ID).toLocaleLowerCase():
                            _this.lastGeneratedId = result[key];
                            _this.lastGeneratedId = _this.lastGeneratedId > -1 ? -1 : _this.lastGeneratedId;
                            break;
                    }
                }
            }
        }
        return _this;
    }
    KSSyncMetaInfo.prototype.getLastGeneratedId = async function() {
        var currentId = this.lastGeneratedId;
        this.lastGeneratedId--;
        var metaInfoMap = {};
        metaInfoMap[KSDatabaseConstants.LAST_GENERATED_ID] = this.lastGeneratedId;
        await updateMetaInfoForObjectServiceName(this.objectServiceName, metaInfoMap);
        return currentId;
    };
    KSSyncMetaInfo.prototype.getReplaySequenceNumber = async function() {
        var currentReplaySequence = this.replaySequenceNumber;
        this.replaySequenceNumber++;
        var metaInfoMap = {};
        metaInfoMap[KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER] = this.replaySequenceNumber;
        await updateMetaInfoForObjectServiceName(this.objectServiceName, metaInfoMap);
        return currentReplaySequence;
    };
    KSSyncMetaInfo.prototype.getLastReplaySequenceNumber = function() {
        return this.replaySequenceNumber - 1;
    };
    KSSyncMetaInfo.prototype.getUploadSyncVersionNumber = function() {
        return this.uploadSyncSessionNumber;
    };
    async function getMetaInfoForObjectServiceName(objectServiceName) {
        var query = KSSQLQueryGenerator.getSelectQueryForMetaInfoTable(objectServiceName);
        var metaInfo = await KSDatabaseAPI.executeQuery(query);
        if (kony.sdk.isEmptyObject(metaInfo)) {
            kony.sdk.logsdk.warn(TAG, "MetaInfo not found for the object service : " + objectServiceName);
            return null;
        } else {
            kony.sdk.logsdk.debug(TAG, "Successfully fetched the metainfo for the object service : " + objectServiceName);
            return metaInfo[0];
        }
    }
    async function updateMetaInfoForObjectServiceName(objectServiceName, metaInfo) {
        var query = KSSQLQueryGenerator.getUpdateQueryForMetaInfoTable(objectServiceName, metaInfo);
        await KSDatabaseAPI.executeQuery(query);
    }
    exports.getInstance = init;
});
/**
 * Base ORMManager
 * Created by Haritha Kintali on 30-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
define("KSBaseORMManager", ["exports", "KSCommonUtils", "KSSDKObjectRecord", "KSSDKObjectService", "KSDatabaseAPI", "KSQueryObjectBuilder", "KSSQLQueryGenerator", "KSError", "KSOptionsHelper", "KSSyncDatabaseHelper", "KSMarkForUploadUtils"], function(exports, KSCommonUtils, _KSSDKObjectRecord, KSSDKObjectService, _KSDatabaseAPI, KSQueryObjectBuilder, KSSQLQueryGenerator, _KSError, KSOptionsHelper, KSSyncDatabaseHelper, KSMarkForUploadUtils) {
    "use strict";

    function KSBaseORMManager() {}
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSBaseORMManager : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSCriteria = kony.sdk.OfflineObjects.KSCriteria;
    var KSTableType = kony.sdk.OfflineObjects.KSTableType;
    var KSSDKObjectRecord = _KSSDKObjectRecord.KSSDKObjectRecord;
    var KSCRUDConstants = kony.sdk.OfflineObjects.KSCRUDConstants;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSRelationshipTypes = KSInternalConstants.KSRelationshipTypes;
    var KSDatabaseOperation = KSDatabaseConstants.KSDatabaseOperations;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    /**
     * Method to build an insert prepared statement for Original table.
     *
     * @param sdkRecord Record containing the data to be persisted.
     * @param options   Map containing the primaryKeysMap
     * @returns {Promise<*>} Insert prepared statement
     */
    KSBaseORMManager.prototype.buildPreparedStatementForOriginalTable = async function(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatementForOriginalTable : ", "Start");
        var tableName = KSSQLQueryGenerator.getTableNameWithType(sdkRecord.getParentObject().getFullyQualifiedName(), KSTableType.ORIGINAL);
        var record = await this.getRecordByPK(options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS], tableName);
        if (kony.sdk.isEmptyObject(record)) {
            kony.sdk.logsdk.debug(LOG_PREFIX, "Record not present in original table, creating insert prepared statement.");
            return this.getInsertPreparedStatement(sdkRecord, tableName);
        } else {
            kony.sdk.logsdk.debug(LOG_PREFIX, "Record already present in original table.");
            return null;
        }
    };
    /**
     * Method to build an insert prepared statement for History table.
     *
     * @param sdkRecord SDKRecord containing the data to be inserted
     * @returns {*} Insert prepared statement.
     */
    KSBaseORMManager.prototype.buildPreparedStatementForHistoryTable = function(sdkRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatementForHistoryTable : ", "Start");
        var tableName = KSSQLQueryGenerator.getTableNameWithType(sdkRecord.getParentObject().getFullyQualifiedName(), KSTableType.HISTORY);
        return this.getInsertPreparedStatement(sdkRecord, tableName);
    };
    /**
     * Method to add primary keys and update columns.
     *
     * @param sdkRecord KSSDKObjectRecord containing the updateColumns key values
     * @param options   Map containing primaryKeys map
     * @returns {KSSDKObjectRecord.KSSDKObjectRecord}
     */
    KSBaseORMManager.prototype.addPrimaryKeysToSDKRecord = function(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "addPrimaryKeysToSDKRecord : ", "Start");
        var data = {};
        KSCommonUtils.mergeTwoJSONMaps(data, sdkRecord.getData());
        KSCommonUtils.mergeTwoJSONMaps(data, options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS]);
        return new KSSDKObjectRecord(data, sdkRecord.getParentObject());
    };
    /**
     * Method to fetch the lastGeneratedID in an objectService
     *
     * @param objectServiceName Name of the objectService
     * @returns {Promise<*>} Last generated ID
     */
    KSBaseORMManager.prototype.getLastGeneratedIDForObjectService = async function(objectServiceName) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "getLastGeneratedIDForObjectService : ", "Start");
        var objectService = KSSDKObjectService.getInstanceByName(objectServiceName);
        var syncMetaInfo = await objectService.getSyncMetaInfo();
        return syncMetaInfo.getLastGeneratedId();
    };
    /**
     * Gets the record from the database for a given primaryKey
     *
     * @param primaryKeyValueMap contains primary keys
     * @param tableName          from which record is to be fetched
     * @returns {Promise<void>}  list of records fetched for the given primaryKey
     */
    KSBaseORMManager.prototype.getRecordByPK = async function(primaryKeyValueMap, tableName) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "getRecordByPK : ", "Start");
        var query = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.SELECT).setWhereClause(primaryKeyValueMap).build();
        var records = await KSDatabaseAPI.executeQuery(query);
        return records[0];
    };
    /**
     * Method to fetch records from the table for the given criteria
     *
     * @param options            contains criteria like primary key(s), whereConditionAsAMap
     *                           and whereConditionAsAString.
     * @param tableName          from which records are to be fetched
     * @returns {Promise<void>}  list of records fetched for the given criteria
     */
    KSBaseORMManager.prototype.getRecordsByCriteria = async function(options, tableName) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "getRecordsByCriteria : ", "Start");
        var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.SELECT);
        var query = this.buildPreparedStatementForGivenCriteria(statementBuilder, options);
        var records = await KSDatabaseAPI.executeQuery(query);
        if (kony.sdk.isEmptyObject(records)) {
            kony.sdk.logsdk.debug(LOG_PREFIX + " : getRecordsByCriteria", "No records present with the given criteria.");
        }
        return records;
    };
    /**
     * Method to build a prepared statement based on the given criteria
     * @param statementBuilder a query builder object
     * @param options user given options
     * @returns {*} a prepared statement
     */
    KSBaseORMManager.prototype.buildPreparedStatementForGivenCriteria = function(statementBuilder, options) {
        var statement = null;
        var criteria = null;
        switch (options[KSCRUDConstants.CRUD_OPTION_CRITERIA]) {
            case KSCriteria.PRIMARY_KEYS:
                criteria = options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS];
                statement = statementBuilder.setWhereClause(criteria).build();
                break;
            case KSCriteria.WHERE_CONDITION_AS_A_MAP:
                criteria = options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION];
                statement = statementBuilder.setWhereClause(criteria).build();
                break;
            case KSCriteria.WHERE_CONDITION_AS_A_STRING:
                criteria = options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION_AS_A_STRING];
                statement = statementBuilder.setWhereClauseAsString(criteria).build();
                break;
            case KSCriteria.NONE:
                statement = statementBuilder.build();
                break;
            default:
                kony.sdk.logsdk.error(LOG_PREFIX + " : buildPreparedStatementForGivenCriteria", "Failed to build prepared statement due to invalid input for criteria type");
        }
        return statement;
    };
    /**
     * Method to validate the options
     *
     * @param options contains primary key(s), whereConditionAsAMap and whereConditionAsAString
     * @return true, if validations are successful
     */
    KSBaseORMManager.prototype.areOptionsValid = function(options) {
        //Validating whereCondition
        if (this.isWhereConditionValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + " : areOptionsValid", "WhereCondition validation is successful");
        }
        //Check for primaryKeys key in Options Map
        var primaryKeys = options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS];
        if (kony.sdk.isNullOrUndefined(primaryKeys)) {
            kony.sdk.logsdk.warn(LOG_PREFIX + " : areOptionsValid", "Primary keys supplied through options are null.");
        } else {
            //Validate the size of the primaryKeys Map
            if (Object.keys(primaryKeys).length === 0) {
                kony.sdk.logsdk.error(LOG_PREFIX + " : areOptionsValid", "Primary keys supplied through options are empty.");
                throw new KSError(KSErrorConstants.CRUD_NULL_OR_EMPTY_PRIMARY_KEY_VALUE);
            }
            //Validating primaryKeys
            if (KSOptionsHelper.arePrimaryKeysValid(options)) {
                kony.sdk.logsdk.info(LOG_PREFIX + " : areOptionsValid", "PrimaryKeys validation is successful");
            }
        }
        return true;
    };
    /**
     * Method to set criteria from primary key(s), whereConditionAsAMap, whereConditionAsAString
     * in the given priority.
     *
     * @param options contain primary key(s) and criteria
     */
    KSBaseORMManager.prototype.setCriteriaInOptions = function(options) {
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS)) {
            options[KSCRUDConstants.CRUD_OPTION_CRITERIA] = KSCriteria.PRIMARY_KEYS;
            kony.sdk.logsdk.debug(LOG_PREFIX + " : setCriteriaInOptions", "Considering CRUD_OPTION_PRIMARY_KEYS as criteria to update. " + "Ignoring the whereCondition and whereConditionAsAString (if provided any).");
        } else if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_WHERE_CONDITION)) {
            options[KSCRUDConstants.CRUD_OPTION_CRITERIA] = KSCriteria.WHERE_CONDITION_AS_A_MAP;
            kony.sdk.logsdk.debug(LOG_PREFIX + " : setCriteriaInOptions", "Considering CRUD_OPTION_WHERE_CONDITION as criteria to update. " + "Ignoring the whereConditionAsAString (if provided any).");
        } else if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_WHERE_CONDITION_AS_A_STRING)) {
            options[KSCRUDConstants.CRUD_OPTION_CRITERIA] = KSCriteria.WHERE_CONDITION_AS_A_STRING;
            kony.sdk.logsdk.debug(LOG_PREFIX + " : setCriteriaInOptions", "Considering CRUD_OPTION_WHERE_CONDITION_AS_A_STRING as criteria to update.");
        } else {
            options[KSCRUDConstants.CRUD_OPTION_CRITERIA] = KSCriteria.NONE;
            kony.sdk.logsdk.debug(LOG_PREFIX + " : setCriteriaInOptions", "No criteria provided to update record(s).");
        }
    };
    /**
     * Helper method to clone options which handles the cloning of metadata that contains cyclic dependencies.
     *
     * @param options object to be cloned
     * @returns {*} a cloned object
     */
    KSBaseORMManager.prototype.cloneOptions = function(options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + " : cloneOptions", "Start.");
        var metadata = options[KSInternalConstants.OBJECT_METADATA];
        delete options[KSInternalConstants.OBJECT_METADATA];
        var clonedObject = kony.sdk.cloneObject(options);
        clonedObject[KSInternalConstants.OBJECT_METADATA] = metadata;
        options[KSInternalConstants.OBJECT_METADATA] = metadata;
        return clonedObject;
    };
    /**
     * Method to fetch PKs for a given record from its metadata
     *
     * @param metadata the metadata of the object
     * @param recordInMainTable an record in the table
     */
    KSBaseORMManager.prototype.getPrimaryKeyValuesFromDBRecord = function(metadata, recordInMainTable) {
            kony.sdk.logsdk.trace(LOG_PREFIX + " : getPrimaryKeyValuesFromDBRecord", "Start.");
            var primaryKeys = metadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS];
            var primaryKeyValueMap = {};
            for (var key in primaryKeys) {
                primaryKeyValueMap[key] = recordInMainTable[key];
            }
            return primaryKeyValueMap;
        }
        /**
         * Method to fetch existing records from Main table
         *
         * @param sdkRecord sdkRecord
         * @param options   contains the criteria to fetch the records
         * @returns {Promise<void>} List of existing records
         */
    KSBaseORMManager.prototype.getExistingRecordsFromMainTable = async function(sdkRecord, options) {
            var fullyQualifiedName = sdkRecord.getParentObject().getFullyQualifiedName();
            var recordsFromMainTable = await this.getRecordsByCriteria(options, fullyQualifiedName);
            if (KSCommonUtils.isNullOrEmptyObject(recordsFromMainTable)) {
                var errorMessage = "There is no record in the database with the given criteria.";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_RECORD_NOT_IN_MAIN_TABLE);
            }
            return recordsFromMainTable;
        }
        /**
         * Method to fetch columns names given metadata.
         * @param metadata the object metadata
         * @returns {string[]} An array of column names
         */
    KSBaseORMManager.prototype.getColumnNamesFromMetadata = function(metadata) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "getColumnNamesFromMetadata : ", "Start");
        return Object.keys(metadata[KSInternalConstants.ATTRIBUTES]);
    };
    /**
     * Method to create KSSDKObjectRecord out of a list of data maps.
     *
     * @param listOfDataMaps List of maps containing data
     * @param parentObject   sdkObject to which the record is associated with
     * @returns {KSSDKObjectRecord.KSSDKObjectRecord}
     */
    KSBaseORMManager.prototype.createSDKRecordFromDataMaps = function(listOfDataMaps, parentObject) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "createSDKRecordFromDataMaps : ", "Start");
        if (!kony.sdk.isEmptyObject(listOfDataMaps)) {
            var mapOfKeyValues = {};
            var dataMapsCount = listOfDataMaps.length;
            for (var index = 0; index < dataMapsCount; index++) {
                var map = listOfDataMaps[index];
                KSCommonUtils.mergeTwoJSONMaps(mapOfKeyValues, map);
            }
            return new KSSDKObjectRecord(mapOfKeyValues, parentObject);
        }
    };
    /**
     * Method to retrieve KonySyncChangeType, LastReplaySequenceNumber and UploadSessionNumber
     *
     * @param sdkRecord KSSDKObjectRecord for which the metainfo is to be retrieved
     * @returns {Promise<void>} Map containing KonySyncChangeType, LastReplaySequenceNumber and UploadSessionNumber
     */
    KSBaseORMManager.prototype.getCommonMetaInfo = async function(sdkRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "getCommonMetaInfo : ", "Start");
        var metaInfo = {};
        metaInfo[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = sdkRecord.getAction();
        var objectService = KSSDKObjectService.getInstanceByName(sdkRecord.getParentObject().getObjectServiceName());
        var syncMetaInfo = await objectService.getSyncMetaInfo();
        var replaySequenceNumber = await syncMetaInfo.getReplaySequenceNumber();
        metaInfo[KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER] = replaySequenceNumber;
        var uploadSessionNumber = syncMetaInfo.getUploadSyncVersionNumber();
        metaInfo[KSDatabaseConstants.UPLOAD_SESSION_NO] = uploadSessionNumber;
        return metaInfo;
    };
    /**
     * Method to create an insert prepared statement given a KSSDKObjectRecord and tableName
     *
     * @param sdkRecord KSSDKObjectRecord containing data to the persisted
     * @param tableName Name of the table
     * @returns {*} Insert prepared statement
     */
    KSBaseORMManager.prototype.getInsertPreparedStatement = function(sdkRecord, tableName) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "getInsertPreparedStatement : ", "Start");
        return KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.INSERT).addInsertValues(sdkRecord.getData()).build();
    };
    /**
     * Validates whether the data in the record is valid or not according to metadata
     *
     * @param sdkRecord in which data has to be validated
     * @return true if data is valid else false
     * @throws OfflineObjectsException
     */
    KSBaseORMManager.prototype.isRecordDataValid = function(sdkRecord) {
            kony.sdk.logsdk.trace(LOG_PREFIX + "isRecordDataValid : ", "Start");
            var data = sdkRecord.getData();
            var metadata = sdkRecord.getParentObject().getMetadata();
            var errorMessage;
            for (var key in data) {
                if (!metadata[KSInternalConstants.ATTRIBUTES].hasOwnProperty(key)) {
                    errorMessage = "There is no attribute with name " + key;
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_INVALID_ATTRIBUTE, errorMessage);
                }
                var objectAttribute = metadata[KSInternalConstants.ATTRIBUTES][key];
                var value = sdkRecord.objectForKey(key);
                if (kony.sdk.isNullOrUndefined(value)) {
                    if (!objectAttribute[KSInternalConstants.ATTRIBUTES_NULLABLE]) {
                        errorMessage = "Mandatory field " + key + " cannot have an empty or null value.";
                        kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                        throw new KSError(KSErrorConstants.CRUD_MANDATORY_COLUMNS_MISSING, errorMessage);
                    }
                    continue;
                }
                KSOptionsHelper.isValidAttribute(objectAttribute, value);
            }
            return true;
        }
        /**
         * Validates referential integrity of sdk object
         *
         * @param sdkObjectRecord record for which referential integrity constraint has to be validated
         * @param existingRecord  record in local database, in case of update operation
         * @return {boolean} true on validation success else false
         */
    KSBaseORMManager.prototype.isReferentialIntegrityValid = async function(sdkObjectRecord, existingRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "isReferentialIntegrityValid : ", "Start");
        var metadata = sdkObjectRecord.getParentObject().getMetadata();
        kony.sdk.logsdk.debug(LOG_PREFIX, "Validating SDK object record " + JSON.stringify(sdkObjectRecord.getData()));
        var relationships = metadata[KSInternalConstants.OBJECTS_PARENT_RELATIONSHIPS];
        kony.sdk.logsdk.debug(LOG_PREFIX, "Parent relationships count " + Object.keys(relationships).length);
        var parentObjectAttributes = [];
        var childObjectAttributes = [];
        //Checking for parent relationships
        for (var index = 0; index < relationships.length; index++) {
            var relationship = relationships[index];
            var parentObjectMetadata = null;
            if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.ONE_TO_MANY) {
                parentObjectMetadata = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT];
                parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
                childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
            } else if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.MANY_TO_ONE) {
                parentObjectMetadata = relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT];
                parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
                childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
            }
            if (areAllNullableForeignKeyValuesAreNull(childObjectAttributes, sdkObjectRecord)) {
                var columnNames = '';
                Object.keys(childObjectAttributes).forEach(function(index) {
                    columnNames += childObjectAttributes[index][KSInternalConstants.ATTRIBUTES_NAME] + ", ";
                });
                kony.sdk.logsdk.warn(LOG_PREFIX, "All the child object attributes " + columnNames + " are nullable and their respective values are null in the record " + JSON.stringify(sdkObjectRecord.getData()));
                continue;
            }
            var sdkRecordToValidate = sdkObjectRecord;
            if (sdkObjectRecord.getAction() === KSSDKObjectRecordAction.UPDATE || sdkObjectRecord.getAction() === KSSDKObjectRecordAction.PARTIAL_UPDATE) {
                if (!(await this.areForeignKeyValuesUpdated(sdkObjectRecord, childObjectAttributes))) {
                    continue;
                }
                if (!areAllForeignKeyValuesSentForUpdate(sdkObjectRecord, childObjectAttributes)) {
                    sdkRecordToValidate = addForeignKeysToSDKRecord(sdkObjectRecord, existingRecord);
                }
            }
            var results = await this.getRelatedRecordsForGivenRecord(sdkRecordToValidate, parentObjectMetadata, parentObjectAttributes, childObjectAttributes);
            if (KSCommonUtils.isNullOrEmptyObject(results)) {
                var keys = '';
                Object.keys(childObjectAttributes).forEach(function(index) {
                    var columnName = childObjectAttributes[index][KSInternalConstants.ATTRIBUTES_NAME];
                    keys += (columnName + " = " + sdkObjectRecord.getData()[columnName] + ", ");
                });
                var errorMessage = "There are no records in parent table " + parentObjectMetadata[KSInternalConstants.OBJECTS_NAME] + " with key(s) " + keys;
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_REFERENTIAL_INTEGRITY_VIOLATION, errorMessage);
            }
        }
        kony.sdk.logsdk.debug(LOG_PREFIX, "The referential integrity for object record " + JSON.stringify(sdkObjectRecord.getData()) + " is valid.");
        return true;
    };
    /**
     * validates whereCondition in the given options
     * @param options JSON containing the primaryKeysMap, whereConditionMap etc
     * @returns {boolean} true on validation successful else false
     */
    KSBaseORMManager.prototype.isWhereConditionValid = function(options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Start.");
        var errorMessage;
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_WHERE_CONDITION)) {
            var whereConditionMap = options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION];
            //Check if whereCondition is passed as null
            if (kony.sdk.isNullOrUndefined(whereConditionMap)) {
                errorMessage = "The given input for where clause is either null or undefined.";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
            if (KSCommonUtils.isInstanceOfMap(whereConditionMap)) {
                var metadata = options[KSInternalConstants.OBJECT_METADATA];
                for (var key in whereConditionMap) {
                    if (whereConditionMap.hasOwnProperty(key)) {
                        var attribute = metadata[KSInternalConstants.ATTRIBUTES][key];
                        if (kony.sdk.isNullOrUndefined(attribute)) {
                            errorMessage = "The given column name " + key + " in the where clause is invalid";
                            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                            throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                        }
                        KSOptionsHelper.isValidAttribute(attribute, whereConditionMap[key]);
                    }
                }
            } else {
                errorMessage = "whereCondition should be of type map";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
        }
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_WHERE_CONDITION_AS_A_STRING)) {
            var whereConditionAsAString = options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION_AS_A_STRING];
            if (typeof whereConditionAsAString !== KSDatabaseConstants.KSDataTypes.STRING) {
                errorMessage = "The given input for WhereConditionAsAString is not of type string";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
        }
        return true;
    };
    KSBaseORMManager.prototype.getRelatedRecordsForGivenRecord = async function(sdkRecord, targetObjectMetadata, targetObjectAttributes, sourceObjectAttributes) {
            kony.sdk.logsdk.trace(LOG_PREFIX + "getRelatedRecordsForGivenRecord : ", "Start");
            var foreignKeyValueMap = {};
            var length = sourceObjectAttributes.length;
            for (var index = 0; index < length; index++) {
                var sourceAttributeName = sourceObjectAttributes[index][KSInternalConstants.ATTRIBUTES_NAME];
                if (sdkRecord.getData().hasOwnProperty(sourceAttributeName)) {
                    var attributeValue = sdkRecord.objectForKey(sourceAttributeName);
                    var targetAttributeName = targetObjectAttributes[index][KSInternalConstants.ATTRIBUTES_NAME];
                    foreignKeyValueMap[targetAttributeName] = attributeValue;
                }
            }
            var records = await KSSyncDatabaseHelper.buildAndExecutePreparedStatementsOfTypeRead(targetObjectMetadata[KSInternalConstants.OBJECTS_NAME], KSTableType.MAIN, foreignKeyValueMap);
            return records;
        }
        /**
         * Validates if Change Tracking Options are valid
         * Also, checks for the mutually exclusive set of options.
         *
         * @param options the options
         * @return boolean true, if the options are valid
         */
    KSBaseORMManager.prototype.areChangeTrackingOptionsValid = function(options) {
            if (!KSCommonUtils.isNullOrEmptyObject(options)) {
                areProvidedOptionsMutuallyExclusive(options);
                if (KSOptionsHelper.isValidBoolTypeOption(options, KSPublicConstants.TRACK_CHANGES)) {
                    kony.sdk.logsdk.info(LOG_PREFIX + " areChangeTrackingOptionsValid: ", "The flag " + KSPublicConstants.TRACK_CHANGES + "is set for the record");
                }
                if (KSOptionsHelper.isValidBoolTypeOption(options, KSPublicConstants.TRACK_INTERMEDIATE_UPDATES)) {
                    kony.sdk.logsdk.info(LOG_PREFIX + " areChangeTrackingOptionsValid: ", "The flag " + KSPublicConstants.TRACK_INTERMEDIATE_UPDATES + "is set for the record");
                }
                if (KSOptionsHelper.isValidBoolTypeOption(options, KSPublicConstants.MARK_FOR_UPLOAD)) {
                    kony.sdk.logsdk.info(LOG_PREFIX + " areChangeTrackingOptionsValid: ", "The flag " + KSPublicConstants.MARK_FOR_UPLOAD + "is set for the record");
                }
            }
            return true;
        }
        /**
         * Validate if the given change tracking options are mutually exclusive
         *
         * @param options the change tracking options
         */
    function areProvidedOptionsMutuallyExclusive(options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "areProvidedOptionsMutuallyExclusive : ", "Start");
        var isValid = true;
        var errorMsg = "";
        if (options.hasOwnProperty(KSPublicConstants.TRACK_CHANGES)) {
            if (options.hasOwnProperty(KSPublicConstants.TRACK_INTERMEDIATE_UPDATES)) {
                errorMsg = "Provide either \"trackChanges\" or \"trackIntermediateChanges\" in options. ";
                kony.sdk.logsdk.error(LOG_PREFIX + " areProvidedOptionsMutuallyExclusive: ", errorMsg);
                isValid = false;
            }
            if (options.hasOwnProperty(KSPublicConstants.MARK_FOR_UPLOAD)) {
                errorMsg = errorMsg.concat("Provide either \"trackChanges\" or \"markForUpload\" in options. ");
                kony.sdk.logsdk.error(LOG_PREFIX + " areProvidedOptionsMutuallyExclusive: ", errorMsg);
                isValid = false;
            }
            if (!isValid) {
                throw new KSError(KSErrorConstants.CRUD_MUTUALLY_EXCLUSIVE_OPTIONS_USED, errorMsg);
            }
        }
    }
    /**
     * Checks whether foreignKeys in the given record are updated or not
     *
     * @param record                 which is to be verified
     * @param foreignKeyAttributes foreign key attributes
     * @return true/false (true if foreign keys are updated else false)
     */
    KSBaseORMManager.prototype.areForeignKeyValuesUpdated = async function(record, foreignKeyAttributes) {
            kony.sdk.logsdk.trace(LOG_PREFIX + "areForeignKeyValuesUpdated : ", "Checking if the foreign keys are updated.");
            var whereConditionMap = {};
            var sdkObject = record.getParentObject();
            var length = foreignKeyAttributes.length;
            for (var index = 0; index < length; index++) {
                var attributeName = foreignKeyAttributes[index][KSInternalConstants.ATTRIBUTES_NAME];
                if (record.getData().hasOwnProperty(attributeName)) {
                    //Adding FK Column to whereCondition
                    whereConditionMap[attributeName] = record.objectForKey(attributeName);
                }
            }
            if (KSCommonUtils.isNullOrEmptyObject(whereConditionMap)) {
                return false;
            }
            var primaryKeyValueMap = record.getPrimaryKeyValueMapOfRecord(sdkObject.getPrimaryKeys());
            KSCommonUtils.mergeTwoJSONMaps(whereConditionMap, primaryKeyValueMap);
            var records = await KSSyncDatabaseHelper.buildAndExecutePreparedStatementsOfTypeRead(sdkObject.getFullyQualifiedName(), KSTableType.MAIN, whereConditionMap, null);
            return KSCommonUtils.isNullOrEmptyObject(records);
        }
        /**
         * Checks the markForUpload flag from options and tells whether
         * the sdk record to be deferred for upload or not
         *
         * @param options containing markForUpload flag
         * @return boolean true if the record is to be deferred else false
         */
    KSBaseORMManager.prototype.isSDKRecordToBeDeferredFromUpload = function(options) {
            kony.sdk.logsdk.trace(LOG_PREFIX + "isSDKRecordToBeDeferredFromUpload : ", "with options " + options);
            var deferFromUpload = false;
            if (!KSCommonUtils.isNullOrEmptyObject(options)) {
                if (options.hasOwnProperty(KSPublicConstants.MARK_FOR_UPLOAD)) {
                    var markForUpload = options[KSPublicConstants.MARK_FOR_UPLOAD];
                    if (!kony.sdk.isNullOrUndefined(markForUpload) && typeof markForUpload === KSInternalConstants.DATA_TYPE_BOOLEAN) {
                        deferFromUpload = !markForUpload;
                    }
                }
                kony.sdk.logsdk.trace(LOG_PREFIX + "isSDKRecordToBeDeferredFromUpload : ", deferFromUpload.toString());
            }
            return deferFromUpload;
        }
        /**
         * Check if previous record bearing the primary keys is not deferred
         *
         * @param sdkRecord record which is to be verified if deferred
         * @return true if record already deferred from upload else false
         */
    KSBaseORMManager.prototype.checkIfRecordIsAlreadyDeferredFromUpload = async function(sdkRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "checkIfRecordIsAlreadyDeferredFromUpload for sdk record : ", "Start");
        var isValid = false;
        var query;
        var primaryKeyValueMapOfRecord = sdkRecord.getPrimaryKeyValueMapOfRecord(sdkRecord.getParentObject().getPrimaryKeys());
        if (Object.keys(primaryKeyValueMapOfRecord).length > 0) {
            var whereConditionForDeferredRecords = KSMarkForUploadUtils.buildWhereConditionForDeferredRecords(primaryKeyValueMapOfRecord);
            var tableName = KSSQLQueryGenerator.getTableNameWithType(sdkRecord.getParentObject().getFullyQualifiedName(), KSTableType.HISTORY);
            var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseConstants.KSDatabaseOperations.SELECT);
            query = statementBuilder.setWhereClause(whereConditionForDeferredRecords).build();
            var records = await KSDatabaseAPI.executeQuery(query);
            if (!KSCommonUtils.isNullOrEmptyObject(records)) {
                isValid = true;
                var errorMessage = "Non deferred operation is not allowed on this record";
                kony.sdk.logsdk.error(LOG_PREFIX, "checkIfRecordIsAlreadyDeferredFromUpload" + errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_RECORD_OPERATION, errorMessage);
            }
        }
        return isValid;
    };
    /**
     * Marks the sdk record as deferred for upload
     *
     * @param sdkObjectRecord to be marked as deferred for upload
     */
    KSBaseORMManager.prototype.markSDKRecordAsDeferredFromUpload = function(sdkObjectRecord) {
            kony.sdk.logsdk.trace(LOG_PREFIX + "markSDKRecordAsDeferredFromUpload for sdk record : ", "Start");
            switch (sdkObjectRecord.getAction()) {
                case KSSDKObjectRecordAction.CREATE:
                    kony.sdk.logsdk.trace(LOG_PREFIX, "Changing the sdk record create action to deferred create");
                    sdkObjectRecord.setAction(KSSDKObjectRecordAction.DEFERRED_CREATE);
                    break;
                case KSSDKObjectRecordAction.UPDATE:
                    kony.sdk.logsdk.trace(LOG_PREFIX, "Changing the sdk record update action to deferred update");
                    sdkObjectRecord.setAction(KSSDKObjectRecordAction.DEFERRED_UPDATE);
                    break;
                case KSSDKObjectRecordAction.DELETE:
                    kony.sdk.logsdk.trace(LOG_PREFIX, "Changing the sdk record delete action to deferred delete");
                    sdkObjectRecord.setAction(KSSDKObjectRecordAction.DEFERRED_DELETE);
                    break;
                default:
                    kony.sdk.logsdk.trace(LOG_PREFIX, "Sdk record action not supported for deferring");
                    break;
            }
        }
        /**
         * Checks whether all the source object attribute values are null
         *
         * @param foreignKeyAttributes source object attributes
         * @param sourceRecord           in which nullable types and values are validated
         * @return true/false (true if all types are nullable and values are null else false)
         */
    function areAllNullableForeignKeyValuesAreNull(foreignKeyAttributes, sourceRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "areAllNullableForeignKeyValuesAreNull : ", "Checking if all the foreign key attributes are nullable and their values are null.");
        var allTypesAndValuesNullable = true;
        for (var index = 0; index < foreignKeyAttributes.length; index++) {
            var objectAttribute = foreignKeyAttributes[index];
            var columnName = objectAttribute[KSInternalConstants.ATTRIBUTES_NAME];
            if (!objectAttribute[KSInternalConstants.ATTRIBUTES_NULLABLE] || !kony.sdk.isNullOrUndefined(sourceRecord.objectForKey(columnName))) {
                allTypesAndValuesNullable = false;
                break;
            }
        }
        kony.sdk.logsdk.debug(LOG_PREFIX, "Are all foreign keys are nullable and their values null: " + allTypesAndValuesNullable);
        return allTypesAndValuesNullable;
    }
    /**
     * Checks whether all foreignKeys are sent for update
     *
     * @param record                 which has to be validated
     * @param foreignKeyAttributes foreign key attributes
     * @return true/false(true if all foreign keys are sent for update else false)
     */
    function areAllForeignKeyValuesSentForUpdate(record, foreignKeyAttributes) {
        var recordData = record.getData();
        for (var index = 0; index < foreignKeyAttributes.length; index++) {
            var attributeName = foreignKeyAttributes[index][KSInternalConstants.ATTRIBUTES_NAME];
            if (!recordData.hasOwnProperty(attributeName)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Adds ForeignKey Value pairs to given record from existing record
     *
     * @param sdkRecord      to which foreign Keys have to be added
     * @param existingRecord from which foreign keys have to be added
     * @return sdkRecord which contains all foreignKey value pairs
     */
    function addForeignKeysToSDKRecord(sdkRecord, existingRecord) {
        var data = {};
        KSCommonUtils.mergeTwoJSONMaps(data, existingRecord.getData());
        KSCommonUtils.mergeTwoJSONMaps(data, sdkRecord.getData());
        return new KSSDKObjectRecord(data, sdkRecord.getParentObject());
    }
    exports.KSBaseORMManager = KSBaseORMManager;
});
/**
 * Create ORMManager
 * Created by Haritha Kintali on 30-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
define("KSCreateORMManager", ["exports", "KSBaseORMManager", "KSDatabaseAPI", "KSCommonUtils", "KSSQLQueryGenerator", "KSOptionsHelper", "KSError"], function(exports, KSBaseORMManager, _KSDatabaseAPI, KSCommonUtils, KSSQLQueryGenerator, KSOptionsHelper, _KSError) {
    "use strict";

    function KSCreateORMManager() {}
    __extends(KSCreateORMManager, KSBaseORMManager.KSBaseORMManager);
    var instance = null;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSCreateORMManager : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSCRUDConstants = kony.sdk.OfflineObjects.KSCRUDConstants;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Gets an instance of KSCreateORMManager
     * @returns {*}
     */
    KSCreateORMManager.getInstance = function() {
        if (instance == null) {
            instance = new KSCreateORMManager();
        }
        return instance;
    };
    KSCreateORMManager.prototype.perform = async function(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "perform : ", "Start.");
        if (instance.areChangeTrackingOptionsValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "perform : ", "Change Tracking options validation is successful");
        }
        var isRecordToBeDeferred = instance.isSDKRecordToBeDeferredFromUpload(options);
        if (!KSOptionsHelper.skipValidation(options)) {
            if (await isSDKRecordValid(sdkRecord, isRecordToBeDeferred, options)) {
                kony.sdk.logsdk.info(LOG_PREFIX, "Record validation is successful.");
            }
        }
        //if the record is not marked for upload, mark it as deferred
        if (isRecordToBeDeferred) {
            instance.markSDKRecordAsDeferredFromUpload(sdkRecord);
        }
        return (await performDBOperation(sdkRecord, options));
    };
    /**
     * Method to build and execute queries on the DB
     *
     * @param sdkRecord SDKObjectRecord containing insertColumns
     * @param options   The crud options
     * @returns {Promise<*>} Created record
     */
    async function performDBOperation(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "performDBOperation : ", "Start.");
        var sdkObject = sdkRecord.getParentObject();
        var metadata = sdkObject.getMetadata();
        var primaryKeys = metadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS];
        var trackChanges = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_CHANGES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_CHANGES);
        for (var primaryKey in primaryKeys) {
            if (primaryKeys[primaryKey][KSInternalConstants.ATTRIBUTES_AUTO_GENERATED] && (trackChanges || kony.sdk.isNullOrUndefined(sdkRecord.objectForKey(primaryKey)))) {
                var lastGeneratedId = await instance.getLastGeneratedIDForObjectService(metadata[KSInternalConstants.OBJECT_SERVICE_NAME]);
                sdkRecord.setObjectForKey(primaryKey, lastGeneratedId);
            }
        }
        var statements = await buildPreparedStatements(sdkRecord, options, null);
        var tables = KSSQLQueryGenerator.getAllTableNames(sdkObject.getFullyQualifiedName());
        await KSDatabaseAPI.executeQueriesAsTransaction(statements, tables);
        var primaryKeyValueMap = sdkRecord.getPrimaryKeyValueMapOfRecord(sdkObject.getPrimaryKeys());
        var recordCreated = await instance.getRecordByPK(primaryKeyValueMap, sdkObject.getFullyQualifiedName());
        KSCommonUtils.removeUnwantedColumns(metadata, recordCreated);
        return recordCreated;
    }
    /**
     * Method to build prepared statements for Main, Original and History table
     *
     * @param sdkRecord         SDKObjectRecord containing insertColumns
     * @param options           The crud options
     * @param recordInMainTable Map depicting the record fetched from Main table
     * @returns {Promise<Array>} An array of prepared statements for Main, Original and History table
     */
    async function buildPreparedStatements(sdkRecord, options, recordInMainTable) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatements : ", "Start.");
        var changeTypeMap = {};
        changeTypeMap[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = KSCommonUtils.getBaseORMActionFromRecordActionCode(sdkRecord.getAction());
        var listOfDataMaps = [];
        listOfDataMaps.push(sdkRecord.getData());
        listOfDataMaps.push(changeTypeMap);
        var sdkObject = sdkRecord.getParentObject();
        var sdkRecordForBuilder = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkObject);
        var primaryKeyValueMap = sdkRecordForBuilder.getPrimaryKeyValueMapOfRecord(sdkObject.getPrimaryKeys());
        var optionsForOriginalTable = {};
        optionsForOriginalTable[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
        //Build prepared statement for Original table
        var statement = await instance.buildPreparedStatementForOriginalTable(sdkRecordForBuilder, optionsForOriginalTable);
        var statements = [];
        if (!kony.sdk.isNullOrUndefined(statement)) {
            statements.push(statement);
        }
        //Build prepared statement for Main table
        statements.push(buildPreparedStatementForMainTable(sdkRecord, options));
        var isTrackChangesEnabled = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_CHANGES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_CHANGES);
        if (isTrackChangesEnabled) {
            var metaInfo = await instance.getCommonMetaInfo(sdkRecord);
            KSCommonUtils.clearJSONObject(listOfDataMaps);
            listOfDataMaps.push(sdkRecord.getData());
            listOfDataMaps.push(metaInfo);
            sdkRecordForBuilder = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkObject);
            //Build prepared statement for History table
            statements.push(instance.buildPreparedStatementForHistoryTable(sdkRecordForBuilder));
        }
        return statements;
    }
    /**
     * Method to build an insert prepared statement for Main table
     *
     * @param sdkRecord SDKObjectRecord containing insertColumns
     * @return Create prepared statement
     */
    function buildPreparedStatementForMainTable(sdkRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatementForMainTable : ", "Start.");
        var tableName = sdkRecord.getParentObject().getFullyQualifiedName();
        return instance.getInsertPreparedStatement(sdkRecord, tableName);
    }
    /**
     * Method to validate the given sdkRecord
     *
     * @param sdkRecord SDKObjectRecord containing data to the persisted
     * @param isRecordToBeDeferred flag for sdk record to be deferred
     * @param options The crud options
     * @returns {boolean} true if valid, false otherwise
     */
    async function isSDKRecordValid(sdkRecord, isRecordToBeDeferred, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "isSDKRecordValid : ", "Start.");
        var data = sdkRecord.getData();
        var metadata = sdkRecord.getParentObject().getMetadata();
        //Check if record is empty
        if (KSCommonUtils.isNullOrEmptyObject(data)) {
            var errorMessage = "SDK object record is either null or empty";
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.CRUD_NULL_SDKRECORD, errorMessage);
        }
        //Validating sdk object record mandatory fields
        if (validateNonNullableAndAutogeneratedAttributesInRecord(sdkRecord, options)) {
            kony.sdk.logsdk.info(LOG_PREFIX, "The validation for non nullable and autogenerated attributes is successful");
        }
        //Validating sdk record object datatypes
        if (instance.isRecordDataValid(sdkRecord)) {
            kony.sdk.logsdk.info(LOG_PREFIX, "The data validation for the given record is successful");
        }
        //Check for integrity constraint violation in relationships
        if (!KSCommonUtils.isNullOrEmptyObject(metadata[KSInternalConstants.OBJECTS_PARENT_RELATIONSHIPS])) {
            if (await instance.isReferentialIntegrityValid(sdkRecord, null)) {
                kony.sdk.logsdk.info(LOG_PREFIX, "The foreignKey constraints are satisfied");
            }
        }
        if (!isRecordToBeDeferred && !(await instance.checkIfRecordIsAlreadyDeferredFromUpload(sdkRecord))) {
            kony.sdk.logsdk.info(LOG_PREFIX, "isSDKRecordValid :" + "Record does not have any previous deferred action history. Hence valid");
        }
        return true;
    }
    /**
     * @param sdkRecord in which whether all nonNullable Attributes are present has to be checked
     * @return true if all nonNullable Attributes are present else false
     * @throws OfflineObjectsException
     */
    function validateNonNullableAndAutogeneratedAttributesInRecord(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "validateNonNullableAndAutogeneratedAttributesInRecord : ", "Start.");
        var metadata = sdkRecord.getParentObject().getMetadata();
        var nonNullableAttributes = metadata[KSInternalConstants.OBJECTS_NON_NULLABLE_ATTRIBUTES];
        var trackChanges = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_CHANGES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_CHANGES);
        for (var key in nonNullableAttributes) {
            var objectAttribute = nonNullableAttributes[key];
            var name = objectAttribute[KSInternalConstants.OBJECTS_NAME];
            var errorMessage;
            if (KSCommonUtils.isNullOrEmptyObject(sdkRecord.objectForKey(name))) {
                if (!objectAttribute[KSInternalConstants.ATTRIBUTES_AUTO_GENERATED]) {
                    errorMessage = "Value should not be null for a non-nullable attribute " + name;
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_MANDATORY_COLUMNS_MISSING, errorMessage);
                }
            } else if (objectAttribute[KSInternalConstants.ATTRIBUTES_AUTO_GENERATED] && trackChanges) {
                errorMessage = "Value should not be provided for an auto-generated column " + name;
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_VALUE_SENT_FOR_AUTOGENERATED_COLUMN, errorMessage);
            }
        }
        return true;
    }
    exports.getInstance = KSCreateORMManager.getInstance;
});
/**
 * Delete ORMManager
 * Created by Haritha Kintali on 30-05-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSDeleteORMManager", ["exports", "KSBaseORMManager", "KSCommonUtils", "KSQueryObjectBuilder", "KSDatabaseAPI", "KSError", "KSSQLQueryGenerator", "KSOptionsHelper", "KSSDKObjectRecord"], function(exports, KSBaseORMManager, KSCommonUtils, KSQueryObjectBuilder, _KSDatabaseAPI, _KSError, KSSQLQueryGenerator, KSOptionsHelper, _KSSDKObjectRecord) {
    "use strict";
    var KSSDKObject = require("KSSDKObject");

    function KSDeleteORMManager() {}
    __extends(KSDeleteORMManager, KSBaseORMManager.KSBaseORMManager);
    var sdk = kony.sdk;
    var instance = null;
    var logger = sdk.logsdk;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSDeleteORMManager : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSCriteria = kony.sdk.OfflineObjects.KSCriteria;
    var KSSDKObjectRecord = _KSSDKObjectRecord.KSSDKObjectRecord;
    var KSCRUDConstants = kony.sdk.OfflineObjects.KSCRUDConstants;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSRelationshipTypes = KSInternalConstants.KSRelationshipTypes;
    var KSDatabaseOperation = KSDatabaseConstants.KSDatabaseOperations;
    /**
     * Gets an instance KSDeleteORMManager
     * @returns {*} An instance of the Delete ORM Manager.
     */
    KSDeleteORMManager.getInstance = function() {
        if (instance == null) {
            instance = new KSDeleteORMManager();
        }
        return instance;
    };
    KSDeleteORMManager.prototype.perform = async function(sdkRecord, options) {
        logger.trace(LOG_PREFIX + "perform : ", "Start.");
        if (instance.areChangeTrackingOptionsValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "perform : ", "Change Tracking options validation is successful");
        }
        instance.setCriteriaInOptions(options);
        if (!KSOptionsHelper.skipValidation(options)) {
            var isDeleteByPK = options[KSCRUDConstants.CRUD_OPTION_IS_DELETE_BY_PK];
            var isRecordToBeDeferred = instance.isSDKRecordToBeDeferredFromUpload(options);
            if (isDeleteByPK) {
                // Validates PK(s) and throws an exception if not provided, in case of deleteByPK
                if (KSOptionsHelper.arePrimaryKeysSentInOptionsValid(options)) {
                    logger.info(LOG_PREFIX, "Options validation for deleteByPK is successful");
                }
            } else {
                // Validates PK(s), if any, in case of delete
                if (instance.areOptionsValid(options)) {
                    logger.info(LOG_PREFIX + ":perform", "Options validation for delete is successful");
                }
            }
            var optionsForValidation = instance.cloneOptions(options);
            if (await isSDKRecordValid(sdkRecord, isRecordToBeDeferred, optionsForValidation)) {
                logger.info(LOG_PREFIX, "Record validation is successful");
            }
            // If the record is not marked for upload, mark it as deferred
            if (isRecordToBeDeferred) {
                instance.markSDKRecordAsDeferredFromUpload(sdkRecord);
            }
        }
        return (await performDBOperation(sdkRecord, options));
    };
    /**
     * Performs DB related operations for Delete operation
     *
     * @param sdkRecord which contains parentObject
     * @param options contains primaryKeyValueMap of the record to be deleted
     * @returns {Promise<boolean>} returns true if delete is success else throws Exception
     */
    async function performDBOperation(sdkRecord, options) {
        logger.trace(LOG_PREFIX, "Start.");
        var fullyQualifiedName = sdkRecord.getParentObject().getFullyQualifiedName();
        var recordsInMainTable = await instance.getRecordsByCriteria(options, fullyQualifiedName);
        if (!kony.sdk.isEmptyObject(recordsInMainTable)) {
            var statements = await buildPreparedStatements(sdkRecord, options, recordsInMainTable);
            await KSDatabaseAPI.executeQueriesAsTransaction(statements);
            return true;
        } else {
            var errorMessage = "Error in fetching record(s) from main table.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.CRUD_RECORD_NOT_IN_MAIN_TABLE, errorMessage);
        }
    }
    async function buildStatementsForChildEntity(sdkRecord, childRelations, statements, options) {
        logger.trace(LOG_PREFIX, "Start.");
        var childRelationshipsCount = childRelations.length;
        for (var index = 0; index < childRelationshipsCount; index++) {
            var childRelation = childRelations[index];
            if (childRelation[KSInternalConstants.RELATIONSHIP_CASCADE]) {
                var childObjectName = null;
                if (childRelation[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.ONE_TO_MANY) {
                    childObjectName = childRelation[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT][KSInternalConstants.NAME];
                } else if (childRelation[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.MANY_TO_ONE) {
                    childObjectName = childRelation[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT][KSInternalConstants.NAME];
                }
                var sdkObject = new KSSDKObject.KSSDKObject(childObjectName);
                var foreignKeyMap = getForeignKeyValueMapFromRelation(childRelation, sdkRecord);
                await buildStatementsForCascadeDeleteOfChildRecords(sdkObject, foreignKeyMap, statements, options);
            } else {
                var records = await fetchChildRecordsForRelationship(childRelation, sdkRecord);
                if (records.length > 0) {
                    var errorMessage = "Cascade delete is false in the relation hierarchy." + " Delete operation can't be performed on the object: " + sdkRecord.getMetadata().getFullyQualifiedName();
                    logger.error(LOG_PREFIX + errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_REFERENTIAL_INTEGRITY_VIOLATION, errorMessage);
                }
            }
        }
    }
    async function buildStatementsForCascadeDeleteOfChildRecords(sdkObject, fkMap, statements, crudOptions) {
        logger.trace(LOG_PREFIX, "Start.");
        var childRelationshipsList = sdkObject.getMetadata()[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS];
        var queryObj = KSSQLQueryGenerator.buildPreparedStatementsOfTypeRead(sdkObject.name, kony.sdk.OfflineObjects.KSTableType.MAIN, fkMap);
        var childRecords = await KSDatabaseAPI.executeQuery(queryObj);
        if (childRecords !== null && childRecords.length > 0) {
            var childRecordsSize = childRecords.length;
            for (var index = 0; index < childRecordsSize; index++) {
                var childRecord = childRecords[index];
                var sdkRecord = new KSSDKObjectRecord(childRecord, sdkObject);
                sdkRecord.setAction(kony.sdk.OfflineObjects.KSSDKObjectRecordAction.DELETE);
                if (childRelationshipsList !== null && childRelationshipsList.length > 0) {
                    await buildStatementsForChildEntity(sdkRecord, childRelationshipsList, statements, crudOptions);
                }
                //Build sdkRecord for Original table
                var changeTypeMap = {};
                changeTypeMap[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = sdkRecord.getAction();
                var listOfDataMaps = {};
                KSCommonUtils.mergeTwoJSONMaps(listOfDataMaps, childRecord);
                KSCommonUtils.mergeTwoJSONMaps(listOfDataMaps, changeTypeMap);
                var primaryKeysMap = sdkRecord.getPrimaryKeyValueMapOfRecord(sdkRecord.getParentObject().getPrimaryKeys());
                var options = {};
                options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeysMap;
                var sdkRecordForBuilder = createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
                //Build statement for Original table
                var statement = await instance.buildPreparedStatementForOriginalTable(sdkRecordForBuilder, options);
                if (statement != null) {
                    statements.push(statement);
                }
                var isTrackChangesEnabled = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_CHANGES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_CHANGES);
                if (isTrackChangesEnabled) {
                    //Build sdkRecord for History table
                    var metaInfo = await instance.getCommonMetaInfo(sdkRecord);
                    listOfDataMaps = {};
                    KSCommonUtils.mergeTwoJSONMaps(listOfDataMaps, childRecord);
                    KSCommonUtils.mergeTwoJSONMaps(listOfDataMaps, metaInfo);
                    var sdkRecordForBuilderForHistory = createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
                    //Build statement for History table
                    statements.push(instance.buildPreparedStatementForHistoryTable(sdkRecordForBuilderForHistory));
                }
            }
            var recordForDeletion = new KSSDKObjectRecord({}, sdkObject);
            var options = {};
            options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION] = fkMap;
            options[KSCRUDConstants.CRUD_OPTION_CRITERIA] = KSCriteria.WHERE_CONDITION_AS_A_MAP;
            statements.push(buildPreparedStatementForMainTable(recordForDeletion, options));
        }
    }

    function createSDKRecordFromDataMaps(listOfDataMaps, parentObject) {
        if (listOfDataMaps) {
            return new KSSDKObjectRecord(listOfDataMaps, parentObject);
        }
    }

    function getForeignKeyValueMapFromRelation(relationship, sdkRecord) {
        logger.trace(LOG_PREFIX, "Start.");
        var parentObjectAttributes = [];
        var childObjectAttributes = [];
        //Checking for child relationships
        if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.ONE_TO_MANY) {
            parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
            childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
        } else if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.MANY_TO_ONE) {
            parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
            childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
        }
        var foreignKeyValueMap = {};
        if (parentObjectAttributes != null && childObjectAttributes != null) {
            var parentObjectAttributesLength = parentObjectAttributes.length;
            for (var index = 0; index < parentObjectAttributesLength; index++) {
                var parentObjectAttribute = parentObjectAttributes[index];
                var columnValue = sdkRecord.getData()[parentObjectAttribute[KSInternalConstants.NAME]];
                if (columnValue) {
                    var targetObjectAttribute = childObjectAttributes[index];
                    foreignKeyValueMap[targetObjectAttribute[KSInternalConstants.NAME]] = columnValue;
                }
            }
        }
        return foreignKeyValueMap;
    }
    /**
     * Builds prepared statements for Delete ORM action
     *
     * @param sdkRecord which contains parentObject
     * @param options contains primaryKeyValueMap of the record to be deleted
     * @param recordsInMainTable of the given primaryKeyValueMap
     * @returns {Promise<Array>} returns an array of preparedStatements for
     *                           Main, Original and History tables for Delete ORM action
     */
    async function buildPreparedStatements(sdkRecord, options, recordsInMainTable) {
        logger.trace(LOG_PREFIX, "Start.");
        var statements = [];
        var objectMetadata = sdkRecord.getParentObject().getMetadata();
        var optionsForBuilder = instance.cloneOptions(options);
        var isDeleteByPK = options[KSCRUDConstants.CRUD_OPTION_IS_DELETE_BY_PK];
        //Build prepared statement for Main table
        statements.push(buildPreparedStatementForMainTable(sdkRecord, optionsForBuilder));
        var arrayLength = recordsInMainTable.length;
        for (var index = 0; index < arrayLength; index++) {
            if (!isDeleteByPK) {
                // Fetch the primary key values from existing record in case of delete by criteria
                var primaryKeyValueMap = instance.getPrimaryKeyValuesFromDBRecord(objectMetadata, recordsInMainTable[index]);
                optionsForBuilder[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
            }
            //Build prepared statements for children if cascade is enabled..
            if (isCascadeDeleteEnabled(objectMetadata)) {
                var recordToBeDeleted = new KSSDKObjectRecord(recordsInMainTable[index], sdkRecord.getParentObject());
                recordToBeDeleted.setAction(kony.sdk.OfflineObjects.KSSDKObjectRecordAction.DELETE);
                await buildStatementsForChildEntity(recordToBeDeleted, recordToBeDeleted.getParentObject().getMetadata()[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS], statements, optionsForBuilder);
            }
            // Build prepared statements for Original and History Tables
            await buildPreparedStatementsForOriginalAndHistory(sdkRecord, optionsForBuilder, recordsInMainTable[index], statements);
        }
        return statements;
    }
    /**
     * Builds prepared statements for Original and History tables
     *
     * @param sdkRecord to be deleted
     * @param options contains PK(s) and criteria
     * @param record existing record to be deleted
     * @param statements holds a list of prepared statements
     * @returns {Promise<Array>} an array of preparedStatements for Original and History tables
     */
    async function buildPreparedStatementsForOriginalAndHistory(sdkRecord, options, record, statements) {
        logger.trace(LOG_PREFIX + "buildPreparedStatementsForOriginalAndHistory : ", "Start.");
        var metadata = options[KSInternalConstants.OBJECT_METADATA];
        var isDeleteByPK = options[KSCRUDConstants.CRUD_OPTION_IS_DELETE_BY_PK];
        if (!isDeleteByPK) {
            // Fetch the primary key values from existing record in case of delete by criteria
            var primaryKeyValueMap = instance.getPrimaryKeyValuesFromDBRecord(metadata, record);
            options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
        }
        //Build SDKRecord for Original table
        var changeTypeMap = {};
        changeTypeMap[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = KSCommonUtils.getBaseORMActionFromRecordActionCode(sdkRecord.getAction());
        var listOfDataMaps = [];
        listOfDataMaps.push(record);
        listOfDataMaps.push(changeTypeMap);
        var sdkRecordForBuilder = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
        //Build prepared statement for Original table
        var statement = await instance.buildPreparedStatementForOriginalTable(sdkRecordForBuilder, options);
        if (!kony.sdk.isNullOrUndefined(statement)) {
            statements.push(statement);
        }
        var isTrackChangesEnabled = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_CHANGES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_CHANGES);
        if (isTrackChangesEnabled) {
            //Build SDKRecord for History table
            var metaInfo = await instance.getCommonMetaInfo(sdkRecord);
            KSCommonUtils.clearJSONObject(listOfDataMaps);
            listOfDataMaps.push(record);
            listOfDataMaps.push(metaInfo);
            var sdkRecordForHistory = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
            //Build prepared statement for History table
            statements.push(instance.buildPreparedStatementForHistoryTable(sdkRecordForHistory));
        }
    }
    /**
     * Generates prepared statement for Main table for Delete operation
     *
     * @param sdkRecord which contains parentObject
     * @param options contains primaryKeyValueMap of the record to be deleted
     * @returns {*} prepared statement for Main table for Delete operation
     */
    function buildPreparedStatementForMainTable(sdkRecord, options) {
        logger.trace(LOG_PREFIX, "Start.");
        var tableName = sdkRecord.getParentObject().getFullyQualifiedName();
        var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.DELETE);
        return instance.buildPreparedStatementForGivenCriteria(statementBuilder, options);
    }
    /**
     * Method to validate the SDK record
     *
     * @param sdkRecord SDKObjectRecord to be validated
     * @param isRecordToBeDeferred is record to be deferred
     * @param options contains PK(s), criteria and other options
     * @return {boolean} true if validation is success, else false
     */
    async function isSDKRecordValid(sdkRecord, isRecordToBeDeferred, options) {
        logger.trace(LOG_PREFIX + "isSDKRecordValid : ", "Start.");
        var sdkObject = sdkRecord.getParentObject();
        var metadata = sdkObject.getMetadata();
        //Checks whether the given record has an entry in main table or not
        var recordsFromMainTable = await instance.getExistingRecordsFromMainTable(sdkRecord, options);
        var isDeleteByPK = options[KSCRUDConstants.CRUD_OPTION_IS_DELETE_BY_PK];
        for (var index in recordsFromMainTable) {
            var existingRecord = new KSSDKObjectRecord(recordsFromMainTable[index], sdkObject);
            if (!isDeleteByPK) {
                // Fetch the primary key values from existing record in case of delete by criteria
                var primaryKeyValueMap = instance.getPrimaryKeyValuesFromDBRecord(metadata, recordsFromMainTable[index]);
                options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
            }
            var recordForValidation = instance.addPrimaryKeysToSDKRecord(sdkRecord, options);
            //Check for integrity constraint violation in relationships if cascade delete is not enabled..
            if (!KSCommonUtils.isNullOrEmptyObject(metadata[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS])) {
                if (!isCascadeDeleteEnabled(metadata)) {
                    var parentHaveChildren = await doParentRecordHaveAssociatedChildRecords(existingRecord);
                    if (!parentHaveChildren) {
                        logger.info(LOG_PREFIX, "There are no child records associated with the given record");
                    }
                }
            }
            if (!isRecordToBeDeferred && !(await instance.checkIfRecordIsAlreadyDeferredFromUpload(recordForValidation))) {
                kony.sdk.logsdk.info(LOG_PREFIX, "isSDKRecordValid :" + "Record does not have any previous deferred action history. Hence valid");
            }
        }
        return true;
    }

    function isCascadeDeleteEnabled(objectMetadata) {
        var childRelationshipsList = objectMetadata[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS];
        var childRelationshipsCount = childRelationshipsList.length;
        for (var index = 0; index < childRelationshipsCount; index++) {
            if (childRelationshipsList[index][KSInternalConstants.RELATIONSHIP_CASCADE]) {
                return true;
            }
        }
        return false;
    }
    /**
     * Validates sdk object's referential integrity
     *
     * @param sdkRecord record for which referential integrity constraint has to be validated
     * @return true/false (true on validation successful else false)
     */
    async function doParentRecordHaveAssociatedChildRecords(sdkRecord) {
        logger.trace(LOG_PREFIX + " : doParentRecordHaveAssociatedChildRecords", "Start.");
        var metadata = sdkRecord.getParentObject().getMetadata();
        logger.debug(LOG_PREFIX, "Validating SDK object record " + JSON.stringify(sdkRecord.getData()));
        var relationships = metadata[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS];
        logger.info(LOG_PREFIX, "The child relationships count " + Object.keys(relationships).length);
        //Checking for child relationships
        for (var index = 0; index < relationships.length; index++) {
            var results = await fetchChildRecordsForRelationship(relationships[index], sdkRecord);
            if (!KSCommonUtils.isNullOrEmptyObject(results)) {
                var errorMessage = "Cannot delete the record as it has associated child records.";
                logger.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_REFERENTIAL_INTEGRITY_VIOLATION, errorMessage);
            }
        }
        return false;
    }
    /**
     * Method to fetch child records for a given relationship
     * @param relationship defines the relationship type, can be OneToMany or ManyToOne
     * @param sdkRecord record for which child records need to be fetched
     * @returns {*} list of child records, if any.
     */
    async function fetchChildRecordsForRelationship(relationship, sdkRecord) {
        var parentObjectAttributes = [];
        var childObjectAttributes = [];
        var childObjectMetadata = null;
        if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.ONE_TO_MANY) {
            childObjectMetadata = relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT];
            childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
            parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
        } else if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.MANY_TO_ONE) {
            childObjectMetadata = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT];
            childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
            parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
        }
        return (await instance.getRelatedRecordsForGivenRecord(sdkRecord, childObjectMetadata, childObjectAttributes, parentObjectAttributes));
    }
    exports.getInstance = KSDeleteORMManager.getInstance;
});
define("KSORMManagerFactory", ["exports", "KSCreateORMManager", "KSReadORMManager", "KSUpdateORMManager", "KSDeleteORMManager", "KSError"], function(exports, KSCreateORMManager, KSReadORMManager, KSUpdateORMManager, KSDeleteORMManager, _KSError) {
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSORMManagerFactory";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;

    function getORMManager(actionType) {
        switch (actionType) {
            case KSSDKObjectRecordAction.CREATE:
                return KSCreateORMManager.getInstance();
            case KSSDKObjectRecordAction.READ:
                return KSReadORMManager.getInstance();
            case KSSDKObjectRecordAction.UPDATE:
                return KSUpdateORMManager.getInstance();
            case KSSDKObjectRecordAction.DELETE:
                return KSDeleteORMManager.getInstance();
            default:
                var errorMessage = "Invalid action type is sent to ORMManagerFactory";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.INTERNAL_INVALID_ACTION_TYPE_SENT_TO_ORMFACTORY, errorMessage);
        }
    }
    exports.getORMManager = getORMManager;
});
/**
 * Read ORMManager
 * Created by Prasanthi Bonam on 30-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
define("KSReadORMManager", ["exports", "KSBaseORMManager", "KSDatabaseAPI", "KSQueryObjectBuilder", "KSOptionsHelper", "KSCommonUtils", "KSError"], function(exports, KSBaseORMManager, _KSDatabaseAPI, KSQueryObjectBuilder, KSOptionsHelper, KSCommonUtils, _KSError) {
    function KSReadORMManager() {}
    __extends(KSReadORMManager, KSBaseORMManager.KSBaseORMManager);
    var instance = null;
    var LOG_PREFIX = "KSReadORMManager : ";
    var KSError = _KSError.KSError;
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSDatabaseOperation = KSDatabaseConstants.KSDatabaseOperations;
    /**
     * Gets an instance of KSReadORMManager
     * @returns {*}
     */
    KSReadORMManager.getInstance = function() {
        if (instance == null) {
            instance = new KSReadORMManager();
        }
        return instance;
    };
    KSReadORMManager.prototype.perform = async function(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX, "Start.");
        if (!KSOptionsHelper.skipValidation(options)) {
            if (areOptionsValid(options)) {
                kony.sdk.logsdk.info(LOG_PREFIX + "Options validation is successful.");
            }
        }
        return await performDBOperation(sdkRecord, options);
    };
    /**
     * Method to build and execute queries on the DB
     *
     * @param sdkRecord SDKObjectRecord containing updateColumns
     * @param options   Map containing primaryKeys
     * @returns {Promise<void>} Number of records updated
     */
    async function performDBOperation(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX, "Start.");
        var metadata = options[KSInternalConstants.OBJECT_METADATA];
        var tableName = metadata[KSInternalConstants.FULLY_QUALIFIED_NAME];
        var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.SELECT);
        var projectionColumns = options[KSPublicConstants.CRUD_OPTION_PROJECTION_COLUMNS];
        if (KSCommonUtils.isNullOrEmptyObject(projectionColumns)) {
            projectionColumns = instance.getColumnNamesFromMetadata(metadata);
        }
        var statement = statementBuilder.setProjectionColumns(projectionColumns);
        var primaryKeysList = options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS];
        var whereConditionMap = options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION];
        var whereConditionAsAString = options[KSPublicConstants.CRUD_OPTION_WHERE_CONDITION_AS_A_STRING];
        if (!KSCommonUtils.isNullOrEmptyObject(primaryKeysList)) {
            statement.setWhereClause(primaryKeysList);
        } else if (!KSCommonUtils.isNullOrEmptyObject(whereConditionMap)) {
            statement.setWhereClause(whereConditionMap);
        } else if (!KSCommonUtils.isNullOrEmptyObject(whereConditionAsAString)) {
            statement.setWhereClauseAsString(whereConditionAsAString);
        }
        var orderByMap = options[KSPublicConstants.CRUD_OPTION_ORDERBY_MAP];
        if (!KSCommonUtils.isNullOrEmptyObject(orderByMap)) {
            var order = {};
            for (var key in orderByMap[0]) {
                if (orderByMap[0].hasOwnProperty(key)) {
                    order[KSDatabaseConstants.COLUMN] = key;
                    order[KSDatabaseConstants.ORDER] = orderByMap[0][key];
                }
            }
            statement.addOrderByMap(order);
        }
        return await KSDatabaseAPI.executeQuery(statement.build());
    }
    /**
     * Validates options parameter
     * @param options to be validated
     * @returns {boolean} returns true if validation is successful else false
     */
    function areOptionsValid(options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Start.");
        //Validating primaryKeys
        if (KSOptionsHelper.arePrimaryKeysValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "PrimaryKeys validation is successful");
        }
        //Validating whereCondition
        if (instance.isWhereConditionValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "WhereCondition validation is successful");
        }
        //validating OrderByMap
        if (isOrderByMapValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "orderByMap validation is successful");
        }
        //validating projectionColumns
        if (areProjectionColumnsValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "projectionColumns validation is successful");
        }
        return true;
    }

    function isOrderByMapValid(options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Start.");
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_ORDERBY_MAP)) {
            var errorMessage;
            var orderByMap = options[KSPublicConstants.CRUD_OPTION_ORDERBY_MAP];
            if (kony.sdk.isNullOrUndefined(orderByMap)) {
                errorMessage = "The given value for orderByMap is either null or undefined";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
            if (Array.isArray(orderByMap)) {
                kony.sdk.logsdk.info(LOG_PREFIX + "Validating orderByMap " + JSON.stringify(orderByMap));
                if (orderByMap.length > 1) {
                    errorMessage = "orderByMap should contain only one entry";
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                }
                var metadata = options[KSInternalConstants.OBJECT_METADATA];
                var orderBy = orderByMap[0];
                if (KSCommonUtils.isInstanceOfMap(orderBy)) {
                    for (var key in orderBy) {
                        if (orderBy.hasOwnProperty(key)) {
                            var attribute = metadata[KSInternalConstants.ATTRIBUTES][key];
                            if (kony.sdk.isNullOrUndefined(attribute)) {
                                errorMessage = "The given column name " + key + " in the orderByMap is invalid";
                                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                            }
                            if (typeof orderBy[key] !== "string") {
                                errorMessage = "The given input for orderByMap is not of type string";
                                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                            }
                        }
                    }
                } else {
                    errorMessage = "orderByMap should be of type Map";
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                }
            } else {
                errorMessage = "The given input for orderByMap should be of type array";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
        }
        return true;
    }

    function areProjectionColumnsValid(options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Start.");
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_PROJECTION_COLUMNS)) {
            var errorMessage;
            var projectionColumns = options[KSPublicConstants.CRUD_OPTION_PROJECTION_COLUMNS];
            if (kony.sdk.isNullOrUndefined(projectionColumns)) {
                errorMessage = "The given input for projectionColumns is either null or undefined";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
            if (Array.isArray(projectionColumns)) {
                kony.sdk.logsdk.info(LOG_PREFIX + "Validating Projection Columns " + JSON.stringify(projectionColumns));
                var metadata = options[KSInternalConstants.OBJECT_METADATA];
                for (var index = projectionColumns.length - 1; index >= 0; index--) {
                    var attribute = metadata[KSInternalConstants.ATTRIBUTES][projectionColumns[index]];
                    if (kony.sdk.isNullOrUndefined(attribute)) {
                        errorMessage = "The given column name " + projectionColumns[index] + " in the projectionColumns is invalid";
                        kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                        throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                    }
                }
            } else {
                errorMessage = "The given input for projectionColumns should be of type array";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
        }
        return true;
    }
    exports.getInstance = KSReadORMManager.getInstance;
});
/**
 * Update ORMManager
 * Created by Prasanthi Bonam on 29-05-2018.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSUpdateORMManager", ["exports", "KSBaseORMManager", "KSDatabaseAPI", "KSCommonUtils", "KSOptionsHelper", "KSQueryObjectBuilder", "KSError", "KSSQLQueryGenerator", "KSSDKObjectRecord", "KSSyncDatabaseHelper"], function(exports, KSBaseORMManager, _KSDatabaseAPI, KSCommonUtils, KSOptionsHelper, KSQueryObjectBuilder, _KSError, KSSQLQueryGenerator, _KSSDKObjectRecord, KSSyncDatabaseHelper) {
    "use strict";

    function KSUpdateORMManager() {}
    __extends(KSUpdateORMManager, KSBaseORMManager.KSBaseORMManager);
    var instance = null;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSUpdateORMManager : ";
    var OfflineObjects = kony.sdk.OfflineObjects;
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSErrorConstants = OfflineObjects.KSErrorConstants;
    var KSPublicConstants = OfflineObjects.KSPublicConstants;
    var KSSDKObjectRecord = _KSSDKObjectRecord.KSSDKObjectRecord;
    var KSDatabaseConstants = OfflineObjects.KSDatabaseConstants;
    var KSCRUDConstants = OfflineObjects.KSCRUDConstants;
    var KSDatabaseOperation = KSDatabaseConstants.KSDatabaseOperations;
    var KSSDKObjectRecordAction = OfflineObjects.KSSDKObjectRecordAction;
    var KSInternalConstants = OfflineObjects.KSInternalConstants;
    var KSRelationshipTypes = KSInternalConstants.KSRelationshipTypes;
    var KSTableType = OfflineObjects.KSTableType;
    /**
     * Gets an instance of KSUpdateORMManager
     * @returns {*}
     */
    KSUpdateORMManager.getInstance = function() {
        if (instance == null) {
            instance = new KSUpdateORMManager();
        }
        return instance;
    };
    KSUpdateORMManager.prototype.perform = async function(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "performDBOperation : ", "Start.");
        if (instance.areChangeTrackingOptionsValid(options)) {
            kony.sdk.logsdk.info(LOG_PREFIX + "perform : ", "Change Tracking options validation is successful");
        }
        instance.setCriteriaInOptions(options);
        if (!KSOptionsHelper.skipValidation(options)) {
            var isUpdateByPK = options[KSCRUDConstants.CRUD_OPTION_IS_UPDATE_BY_PK];
            var isRecordToBeDeferred = instance.isSDKRecordToBeDeferredFromUpload(options);
            if (isUpdateByPK) {
                // Validates PK(s) and throws an exception if not provided, in case of updateByPK
                if (KSOptionsHelper.arePrimaryKeysSentInOptionsValid(options)) {
                    kony.sdk.logsdk.info(LOG_PREFIX + ":perform", "Options validation for updateByPK is successful");
                }
            } else {
                // Validates PK(s), if any, in case of update
                if (instance.areOptionsValid(options)) {
                    kony.sdk.logsdk.info(LOG_PREFIX + ":perform", "Options validation for update is successful");
                }
            }
            var recordsFromMainTable = await instance.getExistingRecordsFromMainTable(sdkRecord, options);
            checkAndRejectUpdateToPrimaryKeys(sdkRecord, recordsFromMainTable);
            var optionsForValidation = instance.cloneOptions(options);
            if (await isSDKRecordValid(sdkRecord, optionsForValidation, recordsFromMainTable, isRecordToBeDeferred, isUpdateByPK)) {
                kony.sdk.logsdk.info(LOG_PREFIX, "Record validation is successful");
            }
            // If the record is not marked for upload, mark it as deferred
            if (isRecordToBeDeferred) {
                instance.markSDKRecordAsDeferredFromUpload(sdkRecord);
            }
        }
        return (await performDBOperation(sdkRecord, options));
    };
    /**
     * Performs DB related operations for Update operation
     *
     * @param sdkRecord contains updated data
     * @param options contains primaryKeyValueMap of the record to be updated
     * @returns {Promise<boolean>} returns true if update is success else throws Exception
     */
    async function performDBOperation(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "performDBOperation : ", "Start.");
        var fullyQualifiedName = sdkRecord.getParentObject().getFullyQualifiedName();
        var recordsInMainTable = await instance.getRecordsByCriteria(options, fullyQualifiedName);
        if (!kony.sdk.isEmptyObject(recordsInMainTable)) {
            var statements = await buildPreparedStatements(sdkRecord, options, recordsInMainTable);
            var tables = KSSQLQueryGenerator.getAllTableNames(fullyQualifiedName);
            await KSDatabaseAPI.executeQueriesAsTransaction(statements, tables);
            return true;
        } else {
            var errorMessage = "Error in fetching record(s) from main table.";
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.CRUD_RECORD_NOT_IN_MAIN_TABLE, errorMessage);
        }
    }
    /**
     * Builds prepared statements for Original and History tables
     *
     * @param sdkRecord contains data to be updated
     * @param options contains PK(s) and criteria
     * @param records existing records to be updated
     * @param statements holds a list of prepared statements
     * @returns {Promise<Array>} an array of preparedStatements for Original and History tables
     */
    async function buildPreparedStatementsForOriginalAndHistory(sdkRecord, options, records, statements) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatementsForOriginalAndHistory : ", "Start.");
        var metadata = options[KSInternalConstants.OBJECT_METADATA];
        var isUpdateByPK = options[KSCRUDConstants.CRUD_OPTION_IS_UPDATE_BY_PK];
        for (var index in records) {
            if (!isUpdateByPK) {
                // Fetch the primary key values from existing record in case of update by criteria
                var primaryKeyValueMap = instance.getPrimaryKeyValuesFromDBRecord(metadata, records[index]);
                options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
            }
            //Build SDKRecord for Original table
            var changeTypeMap = {};
            changeTypeMap[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = KSCommonUtils.getBaseORMActionFromRecordActionCode(sdkRecord.getAction());
            var listOfDataMaps = [];
            listOfDataMaps.push(records[index]);
            listOfDataMaps.push(changeTypeMap);
            var sdkRecordForOriginal = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
            //Build prepared statement for Original table
            var statement = await instance.buildPreparedStatementForOriginalTable(sdkRecordForOriginal, options);
            if (!kony.sdk.isNullOrUndefined(statement)) {
                statements.push(statement);
            }
            var isTrackChangesEnabled = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_CHANGES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_CHANGES);
            if (isTrackChangesEnabled) {
                //Build SDKRecord for History table
                var metaInfo = await instance.getCommonMetaInfo(sdkRecord);
                KSCommonUtils.clearJSONObject(listOfDataMaps);
                listOfDataMaps.push(records[index]);
                listOfDataMaps.push(sdkRecord.getData());
                listOfDataMaps.push(metaInfo);
                var sdkRecordForBuilderForHistory = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
                sdkRecordForBuilderForHistory.setAction(sdkRecord.getAction());
                //Build prepared statement for History table
                await buildPreparedStatementForHistoryTable(sdkRecordForBuilderForHistory, options, statements);
            }
        }
    }
    /**
     * Method to build insert or update prepared statement for History table.
     *
     * @param sdkRecord contains data to be updated
     * @param options   Map containing primaryKeys and change tracking options
     * @returns {Promise<Array>} Insert or Update prepared statements based on the Track Intermediate Updates flag
     */
    async function buildPreparedStatementForHistoryTable(sdkRecord, options, statements) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatementForHistoryTable : ", "Start");
        var sdkRecordForHistory = sdkRecord;
        var tableName = KSSQLQueryGenerator.getTableNameWithType(sdkRecord.getParentObject().getFullyQualifiedName(), KSTableType.HISTORY);
        // If there is an update with Track Intermediate Updates = OFF,
        // replace an existing record(if any) with action type = 80, else insert a new entry.
        var isTrackIntermediateUpdatesEnabled = KSOptionsHelper.getOptionValueOrDefaultForGivenKey(options, KSPublicConstants.TRACK_INTERMEDIATE_UPDATES, KSCRUDConstants.DEFAULT_VALUE_FOR_TRACK_INTERMEDIATE_UPDATES);
        if (!isTrackIntermediateUpdatesEnabled) {
            // if the record is already deferred
            if (sdkRecord.getAction() === KSSDKObjectRecordAction.DEFERRED_UPDATE) {
                sdkRecord.setAction(KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES);
            } else {
                sdkRecord.setAction(KSSDKObjectRecordAction.DO_NOT_TRACK_INTERMEDIATE_UPDATES);
            }
            //Build SDKRecord for History table
            var changeTypeMap = {};
            changeTypeMap[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = sdkRecord.getAction();
            var listOfDataMaps = [];
            listOfDataMaps.push(sdkRecord.getData());
            listOfDataMaps.push(changeTypeMap);
            sdkRecordForHistory = instance.createSDKRecordFromDataMaps(listOfDataMaps, sdkRecord.getParentObject());
        }
        var recordsInHistoryTable = await KSSyncDatabaseHelper.getNumberOfRecordsDeferredAndTrackIntermediateUpdateSetToFalse(options, sdkRecord.getParentObject().getFullyQualifiedName());
        if (recordsInHistoryTable === 0) {
            statements.push(instance.getInsertPreparedStatement(sdkRecordForHistory, tableName));
        } else if (recordsInHistoryTable === 1) {
            statements.push(await KSSyncDatabaseHelper.buildUpdatePreparedStatementForTrackIntermediateUpdatesRecord(sdkRecordForHistory, options, sdkRecord.getParentObject().getFullyQualifiedName()));
        } else {
            var errMsg = "Expected to have only one record with action type = 80 in history table.";
            kony.sdk.logsdk.trace(LOG_PREFIX + " : buildPreparedStatementForHistoryTable", errMsg);
            throw new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, errMsg);
        }
    }
    /**
     * Generates prepared statement for Main table for Update operation
     *
     * @param sdkRecord contains updated data
     * @param options contains PK(s) and criteria
     * @returns {*} prepared statement for Main table for Update operation
     */
    function buildPreparedStatementForMainTable(sdkRecord, options) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatementForMainTable : ", "Start.");
        var tableName = sdkRecord.getParentObject().getFullyQualifiedName();
        var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.UPDATE);
        return instance.buildPreparedStatementForGivenCriteria(statementBuilder.setUpdatedData(sdkRecord.getData()), options);
    }
    /**
     * Builds prepared statements for Update ORM action
     *
     * @param sdkRecord contains updated data
     * @param options contains PK(s) and criteria
     * @param records existing records to be updated
     * @returns {Promise<Array>} an array of preparedStatements for
     *                           Main, Original and History tables for Update ORM action
     */
    async function buildPreparedStatements(sdkRecord, options, records) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "buildPreparedStatements : ", "Start.");
        var statements = [];
        var optionsForBuilder = instance.cloneOptions(options);
        //Build prepared statement for Main table
        statements.push(buildPreparedStatementForMainTable(sdkRecord, optionsForBuilder));
        // Build prepared statements for Original and History Tables
        await buildPreparedStatementsForOriginalAndHistory(sdkRecord, optionsForBuilder, records, statements);
        return statements;
    }
    /**
     * Checks whether primaryKeys are sent for update
     *
     * @param sdkRecord          which has to be checked
     * @param recordsFromMainTable list of existing records to be updated
     */
    function checkAndRejectUpdateToPrimaryKeys(sdkRecord, recordsFromMainTable) {
        var errorMessage;
        var data = sdkRecord.getData();
        var noOfRecords = recordsFromMainTable.length;
        if (noOfRecords > 1) {
            var primaryKeys = sdkRecord.getParentObject().getPrimaryKeys();
            for (var index in primaryKeys) {
                if (data.hasOwnProperty(primaryKeys[index])) {
                    errorMessage = "Primary Key " + primaryKeys[index] + "=" + data[primaryKeys[index]] + " is sent for update. Updating primary keys is not allowed";
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_PRIMARY_KEYS_UPDATE_NOT_ALLOWED, errorMessage);
                }
            }
        } else {
            var metadata = sdkRecord.getParentObject().getMetadata();
            var primaryKeyValueMap = instance.getPrimaryKeyValuesFromDBRecord(metadata, recordsFromMainTable[0]);
            for (var key in primaryKeyValueMap) {
                if (data.hasOwnProperty(key) && (data[key] !== primaryKeyValueMap[key])) {
                    errorMessage = "Primary Key " + key + "=" + data[key] + " is sent for update. Updating primary keys is not allowed";
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_PRIMARY_KEYS_UPDATE_NOT_ALLOWED, errorMessage);
                }
            }
        }
    }
    /**
     * Method to validate updateColumns given by the user
     *
     * @param sdkRecord SDKObjectRecord to be validated
     * @param options contains PK(s), criteria and other options
     * @param isRecordToBeDeferred true if the record is to be deferred
     * @param recordsFromMainTable list of existing records from the main table
     * @param isUpdateByPK true, if the calling api is updateByPK otherwise it is update
     * @return {boolean} true if validation is success, else false
     */
    async function isSDKRecordValid(sdkRecord, options, recordsFromMainTable, isRecordToBeDeferred, isUpdateByPK) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "isSDKRecordValid : ", "Start.");
        var data = sdkRecord.getData();
        var sdkObject = sdkRecord.getParentObject();
        var metadata = sdkObject.getMetadata();
        var errorMessage;
        //Check if record is empty
        if (KSCommonUtils.isNullOrEmptyObject(data)) {
            errorMessage = "SDK object record is null or empty";
            kony.sdk.logsdk.error(LOG_PREFIX + " : isSDKRecordValid", errorMessage);
            throw new KSError(KSErrorConstants.CRUD_NULL_SDKRECORD, errorMessage);
        }
        //Validating sdk record object datatypes
        if (instance.isRecordDataValid(sdkRecord)) {
            kony.sdk.logsdk.info(LOG_PREFIX, "The validation of record data is successful");
        }
        for (var index in recordsFromMainTable) {
            if (!isUpdateByPK) {
                // Fetch the primary key values from existing record in case of update by criteria
                var primaryKeyValueMap = instance.getPrimaryKeyValuesFromDBRecord(metadata, recordsFromMainTable[index]);
                options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS] = primaryKeyValueMap;
            }
            var recordForValidation = instance.addPrimaryKeysToSDKRecord(sdkRecord, options);
            var existingRecord = new KSSDKObjectRecord(recordsFromMainTable[index], sdkRecord);
            //Check for integrity constraint violation in relationships
            if (!KSCommonUtils.isNullOrEmptyObject(metadata[KSInternalConstants.OBJECTS_PARENT_RELATIONSHIPS])) {
                if (await instance.isReferentialIntegrityValid(recordForValidation, existingRecord)) {
                    kony.sdk.logsdk.info(LOG_PREFIX, "The foreignKey constraints are satisfied");
                }
            }
            if (!KSCommonUtils.isNullOrEmptyObject(metadata[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS])) {
                var existingParentHaveChildren = await doExistingParentRecordHaveAssociatedChildRecords(recordForValidation, existingRecord);
                if (!existingParentHaveChildren) {
                    kony.sdk.logsdk.info(LOG_PREFIX, "There are no child records associated with the given record");
                }
            }
            if (!isRecordToBeDeferred && !(await instance.checkIfRecordIsAlreadyDeferredFromUpload(recordForValidation))) {
                kony.sdk.logsdk.info(LOG_PREFIX, "isSDKRecordValid :" + "Record does not have any previous deferred action history. Hence valid");
            }
        }
        return true;
    }
    /**
     * Method to verify if the existing record that is to be updated do have any child records
     * @param newRecord SDKObjectRecord to be validated
     * @param existingRecord SDKObjectRecord that is to be updated
     */
    async function doExistingParentRecordHaveAssociatedChildRecords(newRecord, existingRecord) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "doExistingParentRecordHaveAssociatedChildRecords : ", "Start.");
        var metadata = newRecord.getParentObject().getMetadata();
        kony.sdk.logsdk.debug(LOG_PREFIX, "Validating SDK object record " + JSON.stringify(newRecord.getData()));
        var relationships = metadata[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS];
        kony.sdk.logsdk.info(LOG_PREFIX, "The child relationships count " + Object.keys(relationships).length);
        var parentObjectAttributes = [];
        var childObjectAttributes = [];
        //Checking for child relationships
        for (var index = 0; index < relationships.length; index++) {
            var relationship = relationships[index];
            var childObjectMetadata = null;
            if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.ONE_TO_MANY) {
                childObjectMetadata = relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT];
                childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
                parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
            } else if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSRelationshipTypes.MANY_TO_ONE) {
                childObjectMetadata = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT];
                childObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES];
                parentObjectAttributes = relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES];
            }
            if (await instance.areForeignKeyValuesUpdated(newRecord, parentObjectAttributes)) {
                // If there are any associated child records with the previous FK value, then we do not allow the user to update its foreign keys
                var results = await instance.getRelatedRecordsForGivenRecord(existingRecord, childObjectMetadata, childObjectAttributes, parentObjectAttributes);
                if (!KSCommonUtils.isNullOrEmptyObject(results)) {
                    var errorMessage = "The record has associated child records of object " + childObjectMetadata[KSInternalConstants.OBJECTS_NAME] + ", updating the foreign key is not allowed.";
                    kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                    throw new KSError(KSErrorConstants.CRUD_REFERENTIAL_INTEGRITY_VIOLATION, errorMessage);
                }
            }
        }
        return false;
    }
    exports.getInstance = KSUpdateORMManager.getInstance;
});
/**
 * Module to help parse the download response.
 */
define("KSDownloadResponseParser", ["exports", "KSSDKObjectRecord", "KSCommonUtils", "KSSyncErrorUtils"], function(exports, _KSSDKObjectRecord, KSCommonUtils, KSSyncErrorUtils) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var _KSSDKObject = require("KSSDKObject");
    var LOG_PREFIX = "KSDownloadResponseParser : ";
    var KSSDKObjectRecord = _KSSDKObjectRecord.KSSDKObjectRecord;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    /**
     * Constructor for DownloadResponseParser.
     * @constructor Initialised the sdkObjectMapFromDownloadResponse.
     */
    function KSDownloadResponseParser() {
        this.errorMessages = [];
        this.sdkObjectMapFromDownloadResponse = {};
    }
    /**
     * Method to retrieve a list of SDKObjects containing parsed records from download response.
     * @param downloadResponse JSON object from download network call.
     * @param objectName Name of the object downloaded.
     * @param objectServiceName Name of the object service downloaded.
     * @returns {Object} Array of SDKObjects containing parsed records from download response.
     */
    KSDownloadResponseParser.prototype.getSDKObjectsListFromObjectDownloadResponse = function(downloadResponse, objectName, objectServiceName) {
        logger.trace(LOG_PREFIX, "Starting the download response parsing for object : " + objectName);
        var records = downloadResponse[KSInternalConstants.RECORDS];
        var opstatus = downloadResponse[KSInternalConstants.OP_STATUS];
        if (opstatus === KSInternalConstants.OPSTATUS_SUCCESS) {
            if (!KSCommonUtils.isNullOrEmptyObject(records)) {
                logger.trace(LOG_PREFIX, "Began to parse record data in object: " + objectName + " in object service: " + objectServiceName);
                this.parseRecordDataInObject(records, objectName, objectServiceName);
                logger.debug(LOG_PREFIX, "Successfully parsed the download response for object : " + objectName + " in object service: " + objectServiceName);
            } else {
                logger.info(LOG_PREFIX, "Download of object is successful with no records for the object: " + objectName + " in object service: " + objectServiceName);
            }
        } else {
            logger.error(LOG_PREFIX, "Error in parsing the download response for object : " + objectName + " in object service: " + objectServiceName);
            Array.prototype.push.apply(this.errorMessages, KSSyncErrorUtils.formatSyncErrors(objectServiceName, [downloadResponse[KSInternalConstants.ERR_MSG]], null, opstatus, objectName));
        }
        return Object.values(this.sdkObjectMapFromDownloadResponse);
    };
    /**
     * Method to retrieve a list of SDKObjects containing parsed records from download response.
     * @param downloadResponse JSON object from download network call.
     * @param objectServiceName Name of the object service downloaded.
     * @returns {Object} Array of SDKObjects containing parsed records from download response.
     */
    KSDownloadResponseParser.prototype.getSDKObjectsListFromObjectServiceDownloadResponse = function(downloadResponse, objectServiceName) {
        logger.trace(LOG_PREFIX, "Starting the download response parsing for object service : " + objectServiceName);
        var objects = downloadResponse[KSInternalConstants.OBJECTS_IN_RESPONSE];
        if (!kony.sdk.isNullOrUndefined(objects)) {
            var objectsLength = objects.length;
            for (var index = 0; index < objectsLength; index++) {
                this.getSDKObjectsListFromObjectDownloadResponse(objects[index], objects[index].name, objectServiceName);
            }
        }
        logger.debug(LOG_PREFIX, "Successfully parsed the download response for object service : " + objectServiceName);
        return Object.values(this.sdkObjectMapFromDownloadResponse);
    };
    /**
     * Method to parse the records within an object.
     * @param records Records received from the download response.
     * @param objectName Name of the object downloaded.
     * @param objectServiceName Name of the object service downloaded.
     */
    KSDownloadResponseParser.prototype.parseRecordDataInObject = function(records, objectName, objectServiceName) {
        var recordsLength = records.length;
        var sdkObject = getSDKObjectByObjectName.call(this, objectName, objectServiceName);
        //Get Child Object Names and column Names
        var childObjectNames = getChildObjectNames(sdkObject);
        var columnNames = Object.keys(sdkObject.getMetadata()[KSInternalConstants.ATTRIBUTES]);
        for (var recordIndex = 0; recordIndex < recordsLength; recordIndex++) {
            var sdkObjectRecord = getSDKObjectRecordFromRecordInResponse(records[recordIndex], columnNames);
            sdkObject.addRecord(sdkObjectRecord);
            var childObjectNamesLength = childObjectNames.length;
            for (var childObjectIndex = 0; childObjectIndex < childObjectNamesLength; childObjectIndex++) {
                var childObjectName = childObjectNames[childObjectIndex];
                var childRecords = records[recordIndex][childObjectName];
                if (!KSCommonUtils.isNullOrEmptyObject(childRecords) && kony.sdk.isArray(childRecords)) {
                    logger.trace(LOG_PREFIX, "Started parsing for related object : " + childObjectName + " in object: " + objectName + " in object service: " + objectServiceName);
                    this.parseRecordDataInObject(childRecords, childObjectName, objectServiceName);
                }
            }
        }
    };
    /**
     *  Returns the errorMessages
     * @returns {Array}
     */
    KSDownloadResponseParser.prototype.getDownloadSyncErrors = function() {
        return this.errorMessages;
    };
    /**
     * Method to build KSSDKObjectRecord from record in download response.
     * @param record Record receieved in download response.
     * @param columnNames Name of the columns in metadata for the object downloaded.
     * @returns {*|KSSDKObjectRecord} KSSDKObjectRecord built from record in download response.
     */
    function getSDKObjectRecordFromRecordInResponse(record, columnNames) {
        var columnNameAndValuesMap = {};
        for (var i = 0; i < columnNames.length; i++) {
            var recordValue = record[columnNames[i]];
            //This check is to avoid the case where child table name
            // is same as one of the column in the parent table.
            if (!kony.sdk.isArray(recordValue)) {
                columnNameAndValuesMap[columnNames[i]] = recordValue;
            }
        }
        var sdkObjectRecordInstance = new KSSDKObjectRecord(columnNameAndValuesMap);
        var recordAction = kony.sdk.OfflineObjects.getKSSDKObjectRecordAction(record[KSInternalConstants._METADATA][KSInternalConstants.ACTION]);
        if (recordAction !== KSSDKObjectRecordAction.DELETE) {
            recordAction = KSSDKObjectRecordAction.UPDATE;
        }
        sdkObjectRecordInstance.setAction(recordAction);
        sdkObjectRecordInstance.setCheckSum(record[KSInternalConstants._METADATA][KSInternalConstants.CHECKSUM]);
        return sdkObjectRecordInstance;
    }
    /**
     * Method to create KSSDKObject.
     * @param objectName Name of the object downloaded.
     * @param objectServiceName Name of the object service downloaded.
     * @returns {*} KSSDKObject created using objectName, namespace and objectServiceName.
     */
    function getSDKObjectByObjectName(objectName, objectServiceName) {
        var sdkObject = this.sdkObjectMapFromDownloadResponse[objectName];
        if (kony.sdk.isNullOrUndefined(sdkObject)) {
            // This object here is taking objectName, empty namespace and objectServiceName..
            sdkObject = new _KSSDKObject.KSSDKObject(objectName, "", objectServiceName);
            this.sdkObjectMapFromDownloadResponse[objectName] = sdkObject;
        }
        return sdkObject;
    }
    /**
     * The method returns a list of object names to which are the child of the current object
     *
     * @param sdkObject The object for which child names list is required
     * @return The list of child object names
     * @throws KSError
     */
    function getChildObjectNames(sdkObject) {
        var relatedRelationshipList = sdkObject.getMetadata()[KSInternalConstants.OBJECTS_RELATIONSHIPS];
        var relatedRelationshipListLength = relatedRelationshipList.length;
        var childObjectNames = [];
        for (var i = 0; i < relatedRelationshipListLength; i++) {
            var relationshipMetadata = relatedRelationshipList[i];
            childObjectNames[i] = relationshipMetadata[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT];
        }
        return childObjectNames;
    }
    exports.KSDownloadResponseParser = KSDownloadResponseParser;
});
define("KSUploadPayloadBuilder", ["exports", "KSRequestResponseUtils"], function(exports, KSRequestResponseUtils) {
    var LOG_PREFIX = "KSUploadPayloadBuilder : ";
    /**
     * Class to construct upload payload
     * @constructor
     */
    function KSUploadPayloadBuilder() {
        this.objectsToUpload = [];
        this.recordsToUpload = [];
    }
    /**
     * Instantiates KSUploadPayloadBuilder.
     * @param syncObject  object to build payload for.
     * @return {Promise<KSUploadPayloadBuilder>} instance of KSUploadPayloadBuilder
     */
    async function init(syncObject) {
        var uploadPayloadBuilder = new KSUploadPayloadBuilder();
        await uploadPayloadBuilder.populateObjectsAndRecordsToUploadFromSyncableObject(syncObject);
        return uploadPayloadBuilder;
    }
    /**
     * Populates and Sort the records to upload according to rowId.
     * @param syncObject   object to build payload for.
     */
    KSUploadPayloadBuilder.prototype.populateObjectsAndRecordsToUploadFromSyncableObject = async function(syncObject) {
        this.objectsToUpload = await syncObject.objectsToUpload();
        var objectsToUploadLength = this.objectsToUpload.length;
        for (var index = 0; index < objectsToUploadLength; index++) {
            Array.prototype.push.apply(this.recordsToUpload, this.objectsToUpload[index].getRecords());
        }
        if (this.recordsToUpload.length === 0) {
            kony.sdk.logsdk.info(LOG_PREFIX + "No pending changes found to upload in object: " + syncObject.getFullyQualifiedName());
            return;
        }
        this.recordsToUpload.sort(function(a, b) {
            return a.getRowId() - b.getRowId()
        });
    };
    /**
     * Conditional check for length of records to upload.
     * @return {boolean} true or false based on the length of records to upload
     */
    KSUploadPayloadBuilder.prototype.areThereRecordsToUpload = function() {
        return this.recordsToUpload.length > 0;
    };
    /**
     * Forms the upload payload constructed from the records to upload.
     * @return {JSON} Upload payload constructed from the records to upload.
     */
    KSUploadPayloadBuilder.prototype.getUploadRequestJson = function() {
        return KSRequestResponseUtils.buildUploadPayloadFromObjects(this.recordsToUpload);
    };
    exports.getInstance = init;
});
define("KSUploadRecordsFilter", ["exports", "KSCommonUtils"], function(exports, KSCommonUtils) {
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Filters the given list of records and populates auto-gen , latestSuccessRecord, latestSuccessRecordRowId.
     * @param successRecords   array of sdkObjectRecords for given pk-value pair.
     * @param primaryKeyValue  map of primary-key values.
     * @constructor
     */
    function KSUploadRecordsFilter(successRecords, primaryKeyValue) {
        this.autoGenPKValuePairSentInRequest = {};
        this.pkValuePairSentInResponse = primaryKeyValue;
        this.isAutoGeneratedPKValueAvailable = false;
        var successRecordsLen = successRecords.length;
        if (successRecordsLen > 0) {
            for (var index = 0; index < successRecordsLen; index++) {
                if (!this.isAutoGeneratedPKValueAvailable) {
                    updateAutoGenPKInRecordIfExists.call(this, successRecords[index]);
                } else {
                    break;
                }
            }
        }
        this.latestSuccessRecord = successRecords.reduce(function(a, b) {
            if (a.getRowId() > b.getRowId()) {
                return a;
            }
            return b;
        });
        this.latestSuccessRecordRowId = this.latestSuccessRecord.getRowId();
        KSCommonUtils.removeUnwantedColumns(this.latestSuccessRecord.getParentObject().getMetadata(), this.latestSuccessRecord.getData());
    }
    /**
     * Checks for _primarykey in the given record and populates the auto-gen if any.
     * @param sdkObjectRecord  record to populate auto-gen key if any.
     */
    function updateAutoGenPKInRecordIfExists(sdkObjectRecord) {
        for (var primaryKey in this.pkValuePairSentInResponse) {
            var sdkObjectRecordData = sdkObjectRecord[KSInternalConstants.DATA];
            var autoGenKey = "_" + primaryKey;
            if (sdkObjectRecordData.hasOwnProperty(autoGenKey)) {
                this.autoGenPKValuePairSentInRequest[primaryKey] = sdkObjectRecordData[autoGenKey];
                this.isAutoGeneratedPKValueAvailable = true;
                delete sdkObjectRecordData[autoGenKey];
            } else {
                this.autoGenPKValuePairSentInRequest[primaryKey] = sdkObjectRecordData[primaryKey];
            }
        }
    }
    /**
     * Returns the auto-gen key value pair if any or non-auto gen.
     * @return JSON for primary-key value pair.
     */
    KSUploadRecordsFilter.prototype.getPrimaryKeyValuePair = function() {
        return this.isAutoGeneratedPKValueAvailable ? this.autoGenPKValuePairSentInRequest : this.pkValuePairSentInResponse;
    };
    /**
     * Returns true in case of any autogenerated key found in record.
     * @return {boolean} true if any auto-generated
     */
    KSUploadRecordsFilter.prototype.areAnyPKAutoGenerated = function() {
        return this.isAutoGeneratedPKValueAvailable;
    };
    /**
     * @return the latestSuccessRecord
     */
    KSUploadRecordsFilter.prototype.getLatestSuccessRecord = function() {
        return this.latestSuccessRecord;
    };
    /**
     * @return the latestSuccessRecordRowId
     */
    KSUploadRecordsFilter.prototype.getLatestSuccessRecordRowId = function() {
        return this.latestSuccessRecordRowId;
    };
    exports.KSUploadRecordsFilter = KSUploadRecordsFilter;
});
define("KSUploadResponseParser", ["exports", "KSError", "KSUploadRecordsFilter", "KSSyncErrorUtils", "KSCommonUtils"], function(exports, _KSError, _UploadRecordsFilter, KSSyncErrorUtils, KSCommonUtils) {
    var KSError = _KSError.KSError;
    var KSSDKObject = require("KSSDKObject");
    var _KSSDKObjectRecord = require("KSSDKObjectRecord");
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var UploadRecordsFilter = _UploadRecordsFilter.KSUploadRecordsFilter;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    /**
     * Forms the dict after parsing the response of objects.
     * @param sdkObjects array of json objects from upload response.
     * @constructor
     */
    function KSUploadResponseParser(sdkObjects) {
        this.objects = sdkObjects;
        this.successObjectsMap = {};
        this.uploadResponseObjectsDict = {};
        this.syncErrors = [];
        parseResponse.call(this);
        filterRecords.call(this);
    }
    /**
     * Segregates the response over each object and filters the records.
     */
    function parseResponse() {
        var objectsLength = this.objects.length;
        for (var index = 0; index < objectsLength; index++) {
            var recordJson = this.objects[index][KSInternalConstants.RECORDS];
            var objectName = this.objects[index][KSInternalConstants.NAME];
            parseRecords.call(this, recordJson, objectName);
        }
    }
    /**
     * Parse the records for given object.
     * @param records    json array of records.
     * @param objectName name of the object for given records.
     */
    function parseRecords(records, objectName) {
        var uploadObject = getSDKObjectByObjectName.call(this, objectName);
        var primaryKeys = uploadObject.getPrimaryKeys();
        var recordsLength = records.length;
        for (var index = 0; index < recordsLength; index++) {
            var record = records[index];
            var recordMetadata = record[KSInternalConstants._METADATA];
            delete record[KSInternalConstants._METADATA];
            var sdkObjectRecord = new _KSSDKObjectRecord.KSSDKObjectRecord(record, uploadObject);
            populateSDKRecordMetadataInRecord(sdkObjectRecord, recordMetadata);
            var errorMessage = recordMetadata[KSInternalConstants.ERR_MSG];
            var primaryKeyValueMap = sdkObjectRecord.getPrimaryKeyValueMapOfUploadRecord(primaryKeys);
            var primaryKeyValues = JSON.stringify(primaryKeyValueMap);
            if (errorMessage) {
                Array.prototype.push.apply(this.syncErrors, KSSyncErrorUtils.formatSyncErrors(uploadObject.getObjectServiceName(), [errorMessage], primaryKeyValueMap, sdkObjectRecord.getOpStatus(), objectName));
                continue;
            }
            var rowid = recordMetadata[KSInternalConstants.ROW_ID];
            if (kony.sdk.isNullOrUndefined(rowid)) {
                throw new KSError(KSErrorConstants.SYNC_UPLOAD_ERROR, "rowId key missing for a record of object -" + objectName);
            }
            populateIntermediateErrorsInSyncErrors.call(this, recordMetadata[KSInternalConstants.INTERMEDIATE_ERR_MSG], uploadObject, primaryKeyValueMap, sdkObjectRecord.getOpStatus());
            sdkObjectRecord.setRowid(rowid);
            addUploadResponseObjectsDict.call(this, uploadObject.name, primaryKeyValues, sdkObjectRecord);
        }
    }
    /**
     * Forms the map which has object name as key and value as another map  { <object name> : { <PK value pair> : [list fo records] } }
     * @param objectName          key of the uploadResponseObjectsDict
     * @param primaryKeyValueMap  a key under given objectName
     * @param sdkobjectRecord     records to be populated in array of records under primaryKeyValueMap for given object name.
     */
    function addUploadResponseObjectsDict(objectName, primaryKeyValueMap, sdkobjectRecord) {
        if (!this.uploadResponseObjectsDict.hasOwnProperty(objectName)) {
            this.uploadResponseObjectsDict[objectName] = {};
        }
        if (!this.uploadResponseObjectsDict[objectName].hasOwnProperty(primaryKeyValueMap)) {
            this.uploadResponseObjectsDict[objectName][primaryKeyValueMap] = [];
        }
        this.uploadResponseObjectsDict[objectName][primaryKeyValueMap].push(sdkobjectRecord);
    }
    /**
     * Filters the records by UploadRecordsFilter which takes list of records under a given pk-value pair.
     */
    function filterRecords() {
        for (var objectName in this.uploadResponseObjectsDict) {
            var primaryKeyValueMapToRecords = this.uploadResponseObjectsDict[objectName];
            for (var primaryKeyValueMap in primaryKeyValueMapToRecords) {
                var uploadRecordsFilter = new UploadRecordsFilter(primaryKeyValueMapToRecords[primaryKeyValueMap], JSON.parse(primaryKeyValueMap));
                var sdkObject = this.successObjectsMap[objectName];
                sdkObject.addUploadFilterToPrimaryKeyValue(primaryKeyValueMap, uploadRecordsFilter);
            }
        }
    }
    /**
     * Populates the RecordMetadata in given SDKObjectRecord.
     * @param sdkObjectRecord recordMetadata to be added to the given record.
     * @param recordMetadata  to be populated in given sdkObjectRecord
     */
    function populateSDKRecordMetadataInRecord(sdkObjectRecord, recordMetadata) {
        var recordAction = kony.sdk.OfflineObjects.getKSSDKObjectRecordAction(recordMetadata[KSInternalConstants.ACTION]);
        if (recordAction !== KSSDKObjectRecordAction.DELETE) {
            recordAction = KSSDKObjectRecordAction.UPDATE;
        }
        sdkObjectRecord.setAction(recordAction);
        var checksum = recordMetadata[KSInternalConstants.CHECKSUM];
        sdkObjectRecord.setCheckSum(!kony.sdk.isNullOrUndefined(checksum) ? checksum : null);
        var opStatus = recordMetadata[KSInternalConstants.OP_STATUS];
        sdkObjectRecord.setOpStatus(!kony.sdk.isNullOrUndefined(opStatus) ? opStatus : null);
    }
    /**
     * Returns SDKObject instance if present in map , or creates and adds to map, returns it.
     * @param objectName instance to be created for.
     * @return KSSDKObject instance
     */
    function getSDKObjectByObjectName(objectName) {
        if (!this.successObjectsMap.hasOwnProperty(objectName)) {
            this.successObjectsMap[objectName] = new KSSDKObject.KSSDKObject(objectName);
        }
        return this.successObjectsMap[objectName];
    }
    /**
     * Populates intermediateErrors in syncErrors.
     * @param intermediateErrors errors got for a record
     * @param uploadObject       object got in upload response
     * @param primaryKeyValues   primary keys got for a record
     * @param opStatus           opstatus for a record
     */
    function populateIntermediateErrorsInSyncErrors(intermediateErrors, uploadObject, primaryKeyValues, opStatus) {
        if (!KSCommonUtils.isNullOrEmptyObject(intermediateErrors)) {
            var errors = [];
            for (var key in intermediateErrors) {
                errors.push(intermediateErrors[key]);
            }
            Array.prototype.push.apply(this.syncErrors, KSSyncErrorUtils.formatSyncErrors(uploadObject.getObjectServiceName(), errors, primaryKeyValues, opStatus, uploadObject.name));
        }
    }
    /**
     * @return the map of DATA_OBJECTS and SYNC_ERRORS.
     */
    KSUploadResponseParser.prototype.getRecordsToPersist = function() {
        var successObjects = [];
        for (var key in this.successObjectsMap) {
            successObjects.push(this.successObjectsMap[key]);
        }
        return {
            [KSInternalConstants.DATA_OBJECTS]: successObjects,
            [KSInternalConstants.UPLOAD_SYNC_ERRORS]: this.syncErrors
        };
    };
    exports.KSUploadResponseParser = KSUploadResponseParser;
});
/**
 * KSApplicationSync
 * Created by Harshini Bonam on 24/05/18.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSApplicationSync", ["exports", "SyncEngine", "KSSyncMFUtils", "KSError", "KSApplicationSyncHelper"], function(exports, SyncEngine, KSSyncMFUtils, _KSError, KSApplicationSyncHelper) {
    "use strict";
    exports._esModule = true;
    var LOG_PREFIX = "KSApplicationSync : ";
    var syncEngineInstance = SyncEngine.getInstance();
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSError = _KSError.KSError;
    /**
     * Method to perform Offline Application Sync Setup.
     *
     * @param objServiceList Object services with metadata URLs and other information
     * @param options required to setup the database connection
     * @param successCallback will be invoked on the success of setup.
     * @param failureCallback will be invoked at the time of any error.
     */
    exports.setup = function(objServiceList, options, successCallback, failureCallback) {
        try {
            kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects setup has begun.");
            syncEngineInstance.setup(objServiceList, options, successCallback, failureCallback);
        } catch (error) {
            kony.sdk.logsdk.error(LOG_PREFIX + "Offline objects setup has failed.");
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    };
    /**
     * Method to drop all tables in an Offline Application
     *
     * @param options required to setup the database connection
     * @param successCallback will be invoked on the successful drop of all tables of an Application.
     * @param failureCallback will be invoked if all tables are not dropped.
     */
    exports.drop = function(options, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects drop called.");
        syncEngineInstance.drop(options, successCallback, failureCallback);
    };
    /**
     * Funtion to reset application's sync database.
     * This is done by dropping all tables followed by offline setup at application level.
     *
     * @param objectServiceList Objects with metadata URLs in a Dictionary
     * @param resetOptions are required to setup the database connection
     * @param successCallback will be invoked on the Success of Reset.
     * @param failureCallback will be invoked at the time of any error.
     */
    exports.reset = function(objServiceList, options, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects reset called.");
        syncEngineInstance.reset(objServiceList, options, successCallback, failureCallback);
    };
    /**
     * Rollback Application to it's previous Sync State
     * @param successCallback will be invoked on the Success of rollback.
     * @param failureCallback will be invoked at the time of any error.
     */
    exports.rollback = function(successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects rollback called.");

        function onSuccess() {
            syncEngineInstance.rollbackTaskCompleted(KSInternalConstants.SYNCLEVEL_APPLICATION);
            kony.sdk.logsdk.info(LOG_PREFIX + "Offline objects rollback is successful.");
            kony.sdk.verifyAndCallClosure(successCallback, true);
        }

        function onFailure(error) {
            kony.sdk.logsdk.error(LOG_PREFIX + "Offline objects rollback has failed.");
            syncEngineInstance.rollbackTaskCompleted(KSInternalConstants.SYNCLEVEL_APPLICATION);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.SYNC_GENERIC_ROLLBACK_ERROR, error.stack);
            }
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
        syncEngineInstance.rollback().then(onSuccess, onFailure);
    };
    /**
     * Gets the token from MF-SDK
     * @param token set to Utils.
     */
    exports.setToken = function(token) {
        kony.sdk.logsdk.trace(LOG_PREFIX, "Began to set Token.");
        KSSyncMFUtils.setToken(token);
        kony.sdk.logsdk.debug(LOG_PREFIX, "Token set for Offline Objects.");
    };
    /**
     * Gets the reportingParams from MF-SDK
     * @param reportingParams sets to Utils.
     */
    exports.setReportingParams = function(reportingParams) {
        kony.sdk.logsdk.trace(LOG_PREFIX, "Began to set reportingParams.");
        KSSyncMFUtils.setReportingParams(reportingParams);
        kony.sdk.logsdk.debug(LOG_PREFIX, "reportingParams set for Offline Objects.");
    };
    /**
     * Method to perform Offline Application Sync.
     * @param options options required for Application Sync
     * @param successCallback will be invoked on the success of Application Sync.
     * @param failureCallback will be invoked on the failure of Application Sync.
     */
    exports.startSync = function(options, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX, "Application Sync Called.");
        try {
            KSApplicationSyncHelper.startSync(options, successCallback, failureCallback);
        } catch (error) {
            kony.sdk.logsdk.error(LOG_PREFIX + "Application Sync failed with error " + error.message);
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    }
});
/**
 * KSMetadataJSONParser
 * Created by Harshini Bonam on 24/05/18.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSMetadataJSONParser", ["exports", "KSMetadataUtils", "KSCommonUtils", "KSError"], function(exports, KSMetadataUtils, KSCommonUtils, _KSError) {
    "use strict";
    exports._esModule = true;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSMetadataJSONParser : ";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Gets the namespaces populated with information of all offline objects and their attributes
     * @param objectServiceContext object service metadata context
     * @param metadataResponse network JSON to be parsed
     * @return RootMetadataObject fully populated with the data from JSONObject
     * @throws Exception in case of errors
     */
    function parse(objectServiceContext, metadataResponse) {
        var objectServiceName = objectServiceContext.name;
        runPass1(objectServiceContext, metadataResponse);
        kony.sdk.logsdk.trace(LOG_PREFIX, "Run pass 1 complete for " + objectServiceName);
        runPass2(objectServiceName, metadataResponse);
        kony.sdk.logsdk.trace(LOG_PREFIX, "Run pass 2 complete for " + objectServiceName);
        return metadataResponse;
    }
    /**
     * First pass of JSON parser.
     * Adds new key-value pairs at namespace, object and attribute level
     * @param objectServiceContext object service metadata context
     * @param metadataResponse network JSON to be parsed
     * @throws Exception in case of errors
     */
    function runPass1(objectServiceContext, metadataResponse) {
        var objectServiceName = objectServiceContext.name;
        var namespaceArray = metadataResponse[KSInternalConstants.NAMESPACES];
        if (KSCommonUtils.isNullOrEmptyObject(namespaceArray)) {
            var errorMessage = "Invalid namespaces in object service " + objectServiceName;
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.SETUP_METADATA_NAMESPACES_NIL, errorMessage);
        }
        metadataResponse[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY] = {};
        var namespaceLength = namespaceArray.length;
        for (var namespaceIndex = 0; namespaceIndex < namespaceLength; namespaceIndex++) {
            var namespace = namespaceArray[namespaceIndex];
            var namespaceName = namespace[KSInternalConstants.NAMESPACE_NAME];
            kony.sdk.logsdk.trace(LOG_PREFIX, "Normalizing namespace name.");
            namespaceName = KSMetadataUtils.normalizedNamespaceName(namespaceName);
            namespace[KSInternalConstants.NAMESPACE_NAME] = namespaceName;
            kony.sdk.logsdk.trace(LOG_PREFIX, "began to parse Namespace " + namespaceName + " for " + objectServiceName);
            namespace[KSInternalConstants.PARENT_ROOT_METADATA] = metadataResponse;
            populateObjectMetadataProperties(objectServiceContext, namespace);
            metadataResponse[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY][namespaceName] = namespace;
            kony.sdk.logsdk.trace(LOG_PREFIX, "Parsing complete for Namespace " + namespaceName + " in " + objectServiceName);
        }
    }
    /**
     * Method to populate ObjectMetadata from namespace object
     * @param objectServiceContext object service metadata context
     * @param namespace metadata JSON
     * @throws Exception in case of errors
     */
    function populateObjectMetadataProperties(objectServiceContext, namespace) {
        var objectServiceName = objectServiceContext.name;
        var namespaceName = namespace[KSInternalConstants.NAMESPACE_NAME];
        var objectsArray = namespace[KSInternalConstants.OBJECTS];
        if (KSCommonUtils.isNullOrEmptyObject(objectsArray)) {
            var errorMessage = "Invalid objects in object service " + objectServiceName + " in namespace " + namespace[KSInternalConstants.NAMESPACE_NAME];
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.SETUP_METADATA_OBJECTS_NIL, errorMessage);
        }
        namespace[KSInternalConstants.OBJECT_METADATA_DICTIONARY] = {};
        var objectMetadataLength = objectsArray.length;
        for (var objectIndex = 0; objectIndex < objectMetadataLength; objectIndex++) {
            var object = objectsArray[objectIndex];
            var objectName = object[KSInternalConstants.OBJECTS_NAME];
            if (KSCommonUtils.isNullOrEmptyObject(objectName)) {
                var errorMessage = "Invalid object name " + object[KSInternalConstants.OBJECTS_NAME] + " in object service " + objectServiceName + " in namespace " + namespaceName;
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.METADATA_OBJECT_NAME_EMPTY, errorMessage);
            }
            kony.sdk.logsdk.trace(LOG_PREFIX, "began to parse object " + objectName + " in Namespace " + namespaceName + " for " + objectServiceName);
            object[KSInternalConstants.PARENT_NAMESPACE_METADATA] = namespace;
            object[KSInternalConstants.OBJECT_SERVICE_NAME] = objectServiceContext.name;
            object[KSInternalConstants.VERSION] = objectServiceContext.objectServiceVersion;
            object[KSInternalConstants.FULLY_QUALIFIED_NAME] = getFullQualifiedObjectName(namespaceName, objectName);
            object[KSInternalConstants.ENDPOINT_URL] = objectServiceContext.url + "/objects/" + object[KSInternalConstants.FULLY_QUALIFIED_NAME];
            object[KSInternalConstants.OBJECTS_PARENT_RELATIONSHIPS] = [];
            object[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS] = [];
            //populating attributes
            populateObjectAttributesProperties(objectServiceName, namespaceName, object);
            //Since now we have all the attributes,
            //populating attribute level soft deletable flag.
            populateSoftDeletableAttribute(object);
            //populating primary key dictionary
            populatePrimaryKeyAttributes(object);
            namespace[KSInternalConstants.OBJECT_METADATA_DICTIONARY][objectName] = object;
            kony.sdk.logsdk.trace(LOG_PREFIX, "Parsing completed for object " + objectName + " in Namespace " + namespaceName + " for " + objectServiceName);
        }
    }
    /**
     * Method to set soft-delete property between object and attribute
     * @param object metadata for which the softdelete has to be populated
     */
    function populateSoftDeletableAttribute(object) {
        var softDeleteAttributeName = object[KSInternalConstants.OBJECTS_SOFT_DELETE_FIELD];
        if (!kony.sdk.util.isNullOrEmptyString(softDeleteAttributeName)) {
            kony.sdk.logsdk.trace(LOG_PREFIX, "began to parse soft delete field in " + object[KSInternalConstants.OBJECTS_NAME] + " in Namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + " for " + object[KSInternalConstants.OBJECT_SERVICE_NAME]);
            //object -> attribute -> isSoftDeletable = true;
            object[KSInternalConstants.ATTRIBUTES][softDeleteAttributeName]
                [KSInternalConstants.ATTRIBUTES_SOFT_DELETABLE] = true;
            //object -> softdelete_field = attribute
            object[KSInternalConstants.OBJECTS_SOFT_DELETE_FIELD] = object[KSInternalConstants.ATTRIBUTES]
                [softDeleteAttributeName];
            kony.sdk.logsdk.trace(LOG_PREFIX, "Parsing completed for soft delete field in " + object[KSInternalConstants.OBJECTS_NAME] + " in Namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + " for " + object[KSInternalConstants.OBJECT_SERVICE_NAME]);
        }
    }
    /**
     * Method to populate primary keys for objectMetadata as JSON Dictionary
     * @param object metadata for which the primary keys have to be populated
     */
    function populatePrimaryKeyAttributes(object) {
        kony.sdk.logsdk.trace(LOG_PREFIX, "began to parse primary keys in " + object[KSInternalConstants.OBJECTS_NAME] + " in Namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + " for " + object[KSInternalConstants.OBJECT_SERVICE_NAME]);
        var keys = object[KSInternalConstants.OBJECTS_KEYS];
        if (KSCommonUtils.isNullOrEmptyObject(keys)) {
            var errorMessage = "Invalid object keys in " + object[KSInternalConstants.OBJECTS_NAME] + " in " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + " for " + object[KSInternalConstants.OBJECT_SERVICE_NAME];
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.SETUP_METADATA_OBJECTS_PRIMARY_KEY_NIL, errorMessage);
        }
        object[KSInternalConstants.OBJECTS_PRIMARY_KEYS] = {};
        var keysLength = keys.length;
        for (var keyIndex = 0; keyIndex < keysLength; keyIndex++) {
            var keyName = keys[keyIndex];
            object[KSInternalConstants.OBJECTS_PRIMARY_KEYS][keyName] = object[KSInternalConstants.ATTRIBUTES][keyName];
        }
        kony.sdk.logsdk.trace(LOG_PREFIX, "Parsing completed for primary keys in " + object[KSInternalConstants.OBJECTS_NAME] + " in Namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + " for " + object[KSInternalConstants.OBJECT_SERVICE_NAME]);
    }
    /**
     * Method to populate attribute metadata from object metadata
     * @param objectServiceName object service name
     * @param namespaceName namespace name
     * @param object object metadata for which the attributes have to be populated
     * @throws Exception in case of errors
     */
    //NOTE: default value and auto-increment are not yet supported from Kony Fabric app schema for Objects
    function populateObjectAttributesProperties(objectServiceName, namespaceName, object) {
        var objectName = object[KSInternalConstants.OBJECTS_NAME];
        kony.sdk.logsdk.trace(LOG_PREFIX, "began to parse attributes in " + objectName + " in Namespace " + namespaceName + " for " + objectServiceName);
        var attributeArray = object[KSInternalConstants.OBJECTS_FIELDS];
        if (KSCommonUtils.isNullOrEmptyObject(attributeArray)) {
            var errorMessage = "Invalid attributes in " + objectServiceName + " object service " + namespaceName + " namespace " + objectName + "object name.";
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.SETUP_METADATA_ATTRIBUTES_NIL, errorMessage);
        }
        object[KSInternalConstants.ATTRIBUTES] = {};
        object[KSInternalConstants.OBJECTS_NON_NULLABLE_ATTRIBUTES] = {};
        var attributesLength = attributeArray.length;
        for (var attributeIndex = 0; attributeIndex < attributesLength; attributeIndex++) {
            var attribute = attributeArray[attributeIndex];
            var attributeName = attribute[KSInternalConstants.ATTRIBUTES_NAME];
            if (KSCommonUtils.isNullOrEmptyObject(attributeName)) {
                var errorMessage = "Invalid attribute name" + attributeName + " in " + objectServiceName + " object service " + namespaceName + " namespace " + objectName + "object name.";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.METADATA_ATTRIBUTE_NAME_NULL_OR_EMPTY, errorMessage);
            }
            attribute[KSInternalConstants.PARENT_OBJECT_METADATA] = object;
            //populating non-nullable fields at object level.
            populateNonNullableFields(object, attribute);
            object[KSInternalConstants.ATTRIBUTES][attributeName] = attribute;
        }
        kony.sdk.logsdk.trace(LOG_PREFIX, "Parsing completed for attributes in " + objectName + " in Namespace " + namespaceName + " for " + objectServiceName);
    }
    /**
     * Method to populate non nullable attributes for objectMetadata
     * @param object metadata for which the primary keys have to be populated
     * @param attribute which has to classified as nullable or non-nullable
     */
    function populateNonNullableFields(object, attribute) {
        if (!attribute[KSInternalConstants.ATTRIBUTES_NULLABLE]) {
            object[KSInternalConstants.OBJECTS_NON_NULLABLE_ATTRIBUTES][attribute[KSInternalConstants.ATTRIBUTES_NAME]] = attribute;
            kony.sdk.logsdk.trace(LOG_PREFIX, "Parsing completed for non-nullable attribute in " + object[KSInternalConstants.OBJECTS_NAME] + " in Namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + " for " + object[KSInternalConstants.OBJECT_SERVICE_NAME]);
        }
    }
    /**
     * Second pass of JSON parser.
     * Adds relationships between objects.
     * @param objectServiceName object service metadata context
     * @param metadataResponse network JSON to be parsed
     * @throws Exception in case of errors
     */
    function runPass2(objectServiceName, metadataResponse) {
        var namespaceMetadataDictionary = metadataResponse[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY];
        for (var namespaceName in namespaceMetadataDictionary) {
            if (namespaceMetadataDictionary.hasOwnProperty(namespaceName)) {
                var namespace = namespaceMetadataDictionary[namespaceName];
                var objectMetadataDictionary = namespace[KSInternalConstants.OBJECT_METADATA_DICTIONARY];
                for (var objectName in objectMetadataDictionary) {
                    if (objectMetadataDictionary.hasOwnProperty(objectName)) {
                        var object = objectMetadataDictionary[objectName];
                        var objectRelationships = object[KSInternalConstants.OBJECTS_RELATIONSHIPS];
                        var relationshipLength = objectRelationships.length;
                        for (var relationshipIndex = 0; relationshipIndex < relationshipLength; relationshipIndex++) {
                            var relationship = objectRelationships[relationshipIndex];
                            var clonedRelationship = kony.sdk.cloneObject(relationship);
                            var relationshipType = clonedRelationship[KSInternalConstants.RELATIONSHIP_TYPE];
                            if (relationshipType === KSInternalConstants.KSRelationshipTypes.ONE_TO_MANY || relationshipType === KSInternalConstants.KSRelationshipTypes.MANY_TO_ONE || relationshipType === KSInternalConstants.KSRelationshipTypes.ONE_TO_ONE) {
                                kony.sdk.logsdk.trace(LOG_PREFIX, "Populating relationships in object " + objectName + " for object service " + objectServiceName);
                                populateRelationship(metadataResponse, object, clonedRelationship);
                                addParentAndChildRelationship(clonedRelationship);
                            } else {
                                var errorMessage = "Invalid relationship type " + relationshipType + " in object service " + objectServiceName + " namespace " + namespaceName + " object name " + objectName;
                                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                                throw new KSError(KSErrorConstants.SETUP_INVALID_RELATIONSHIP_TYPE, errorMessage);
                            }
                        }
                        deleteExtraKeysInObject(object);
                    }
                }
                deleteExtraKeysInNamespace(namespace);
            }
        }
        deleteExtraKeysInMetadataResponse(metadataResponse);
    }
    /**
     * Method to delete keys that are irrelevant or redundant in the metadata response level.
     * @param metadataResponse JSON to be parsed
     */
    function deleteExtraKeysInMetadataResponse(metadataResponse) {
        delete metadataResponse[KSInternalConstants.OFFLINE];
        delete metadataResponse[KSInternalConstants.NAMESPACES];
        delete metadataResponse[KSInternalConstants.HTTP_RESPONSE];
        delete metadataResponse[KSInternalConstants.CONFLICT_POLICY];
        delete metadataResponse[KSInternalConstants.IS_CHANGE_AFTER_LAST_FETCH_TIME];
        kony.sdk.logsdk.trace(LOG_PREFIX, "Deleted keys " + KSInternalConstants.NAMESPACES + ", " + KSInternalConstants.HTTP_RESPONSE + ", " + KSInternalConstants.CONFLICT_POLICY + ", " + KSInternalConstants.IS_CHANGE_AFTER_LAST_FETCH_TIME + KSInternalConstants.OFFLINE);
    }
    /**
     * Method to delete keys that are irrelevant or redundant in the namespace level.
     * @param namespaceMetadata JSON to be parsed
     */
    function deleteExtraKeysInNamespace(namespaceMetadata) {
        delete namespaceMetadata[KSInternalConstants.OBJECTS];
        delete namespaceMetadata[KSInternalConstants.NAMESPACE_ACTION];
        kony.sdk.logsdk.trace(LOG_PREFIX, "Deleted keys " + KSInternalConstants.OBJECTS + ", " + KSInternalConstants.NAMESPACE_ACTION + " in namespace " + namespaceMetadata[KSInternalConstants.NAMESPACE_NAME]);
    }
    /**
     * Method to delete keys that are irrelevant or redundant in the object level.
     * @param objectMetadata JSON to be parsed
     */
    function deleteExtraKeysInObject(objectMetadata) {
        delete objectMetadata[KSInternalConstants.OBJECTS_KEYS];
        delete objectMetadata[KSInternalConstants.OBJECTS_FIELDS];
        delete objectMetadata[KSInternalConstants.CONFLICT_POLICY];
        delete objectMetadata[KSInternalConstants.OBJECTS_CACHE_TIMEOUT];
        delete objectMetadata[KSInternalConstants.OBJECTS_DELTA_CONTEXT_FIELD];
        kony.sdk.logsdk.trace(LOG_PREFIX, "Deleted keys " + KSInternalConstants.OBJECTS_KEYS + ", " + KSInternalConstants.OBJECTS_FIELDS + ", " + KSInternalConstants.CONFLICT_POLICY + ", " + KSInternalConstants.OBJECTS_DELTA_CONTEXT_FIELD + ", " + KSInternalConstants.OBJECTS_CACHE_TIMEOUT + " in object " + objectMetadata[KSInternalConstants.OBJECTS_NAME]);
    }
    /**
     * Method to setup relationships among objects across all namespaces
     * @param metadataResponse network JSON to be parsed
     * @param object metadata for the relationship has to be parsed
     * @param relationship raw relationship which is sent in network response
     * @throws OfflineObjectsException In case of errors
     */
    function populateRelationship(metadataResponse, object, relationship) {
        var relationshipType = relationship[KSInternalConstants.RELATIONSHIP_TYPE];
        if (relationshipType === relationship[KSInternalConstants.KSRelationshipTypes.ONE_TO_ONE]) {
            relationship[KSInternalConstants.RELATIONSHIP_TYPE] = KSInternalConstants.KSRelationshipTypes.ONE_TO_MANY;
            kony.sdk.logsdk.trace(LOG_PREFIX, "Converted one to one relationship to one to many in object " + object[KSInternalConstants.OBJECTS_NAME] + "for object service " + object[KSInternalConstants.OBJECT_SERVICE_NAME]);
        }
        relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT] = object;
        var fullyQualifiedTargetObjectName = KSMetadataUtils.normalizedFullyQualifiedName(relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT]);
        var targetObject = getObjectMetadataFromRootMetadata(metadataResponse, fullyQualifiedTargetObjectName);
        if (KSCommonUtils.isNullOrEmptyObject(fullyQualifiedTargetObjectName) || KSCommonUtils.isNullOrEmptyObject(targetObject)) {
            var errorMessage = "Incorrect target object name found in relationship of object" + object.name + " in namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + "in object service " + object[KSInternalConstants.OBJECT_SERVICE_NAME];
            kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.SETUP_UNABLE_TO_PARSE_METADATA_JSON_RELATIONSHIP, errorMessage);
        }
        relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT] = targetObject;
        var sourceAttributes = object[KSInternalConstants.ATTRIBUTES];
        populateSourceAttributes(object, relationship, sourceAttributes);
        var targetAttributes = targetObject[KSInternalConstants.ATTRIBUTES];
        populateTargetAttributes(targetObject, relationship, targetAttributes);
    }
    /**
     * Method to set source attributes for a relationship object
     * @param object metadata in which the relation is defined in the network response
     * @param relationship relationship object to which the source attributes have to be populated
     * @param attributes all the attributes of the source object.
     */
    function populateSourceAttributes(object, relationship, attributes) {
        var sourceAttributes = kony.sdk.cloneObject(relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES]);
        relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES] = [];
        var attributesLength = sourceAttributes.length;
        for (var attributeIndex = 0; attributeIndex < attributesLength; attributeIndex++) {
            var attributeName = sourceAttributes[attributeIndex];
            if (kony.sdk.isNullOrUndefined(attributes[attributeName])) {
                var errorMessage = "Incorrect source attribute name '" + attributeName + "' found in relationship of object" + object.name + " in namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + "in object service " + object[KSInternalConstants.OBJECT_SERVICE_NAME];
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.SETUP_UNABLE_TO_PARSE_METADATA_JSON_RELATIONSHIP, errorMessage);
            }
            relationship[KSInternalConstants.RELATIONSHIP_SOURCE_ATTRIBUTES].push(attributes[attributeName]);
        }
    }
    /**
     * Method to set target attributes for a relationship object
     * @param object metadata in which the relation is defined in the network response
     * @param relationship relationship object to which the source attributes have to be populated
     * @param attributes all the attributes of the target object.
     */
    function populateTargetAttributes(object, relationship, attributes) {
        var targetAttributes = kony.sdk.cloneObject(relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES]);
        relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES] = [];
        var attributesLength = targetAttributes.length;
        for (var attributeIndex = 0; attributeIndex < attributesLength; attributeIndex++) {
            var attributeName = targetAttributes[attributeIndex];
            if (kony.sdk.isNullOrUndefined(attributes[attributeName])) {
                var errorMessage = "Incorrect target attribute name '" + attributeName + "' found in relationship of object" + object.name + " in namespace " + object[KSInternalConstants.PARENT_NAMESPACE_METADATA][KSInternalConstants.NAMESPACE_NAME] + "in object service " + object[KSInternalConstants.OBJECT_SERVICE_NAME];
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.SETUP_UNABLE_TO_PARSE_METADATA_JSON_RELATIONSHIP, errorMessage);
            }
            relationship[KSInternalConstants.RELATIONSHIP_TARGET_ATTRIBUTES].push(attributes[attributeName]);
        }
    }
    /**
     * Adds parent and child relationships
     * @param relationship Relationship object to be parsed for adding relationships
     */
    function addParentAndChildRelationship(relationship) {
        if (relationship[KSInternalConstants.RELATIONSHIP_TYPE] === KSInternalConstants.KSRelationshipTypes.ONE_TO_MANY) {
            addRelationshipToParent(relationship, relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT]);
            addRelationshipToChild(relationship, relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT]);
        } else {
            addRelationshipToParent(relationship, relationship[KSInternalConstants.RELATIONSHIP_TARGET_OBJECT]);
            addRelationshipToChild(relationship, relationship[KSInternalConstants.RELATIONSHIP_SOURCE_OBJECT]);
        }
    }
    /**
     * Add a relationship to parent object
     * @param relationship Relationship object
     * @param parent Parent object
     */
    function addRelationshipToParent(relationship, parent) {
        parent[KSInternalConstants.OBJECTS_CHILD_RELATIONSHIPS].push(relationship);
    }
    /**
     * Add a relationship to child object
     * @param relationship Relationship object
     * @param child Child object
     */
    function addRelationshipToChild(relationship, child) {
        child[KSInternalConstants.OBJECTS_PARENT_RELATIONSHIPS].push(relationship);
    }
    /**
     * getter Method to retrieve objectMetadata from rootMetadataObject
     * @param metadataResponse the rootMetadataObject
     * @param fullyQualifiedName of the object
     * @returns objectMetadata
     */
    function getObjectMetadataFromRootMetadata(metadataResponse, fullyQualifiedName) {
        var objectName = KSMetadataUtils.objectNameFromFullyQualifiedName(fullyQualifiedName);
        var namespaceName = KSMetadataUtils.normalizedNamespaceName(KSMetadataUtils.namespaceNameFromFullyQualifiedName(fullyQualifiedName));
        return metadataResponse[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY][namespaceName]
            [KSInternalConstants.OBJECT_METADATA_DICTIONARY][objectName];
    }
    /**
     * Method to get fully qualified name of an object
     * @param namespaceName if empty/undefined namespaceName is normalized to kony_unnamed
     * @param objectName
     * @returns fullyQualifiedName
     */
    function getFullQualifiedObjectName(namespaceName, objectName) {
        return KSMetadataUtils.normalizedFullyQualifiedNameForNamespaceNameAndObjectName(namespaceName, objectName);
    }
    exports.parse = parse;
});
/**
 * KSObjectServiceMetadataContext
 * Created by Harshini Bonam on 24/05/18.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSObjectServiceMetadataContext", ["exports", "KSSQLQueryGenerator", "KSDatabaseAPI", "KSCommonUtils"], function(exports, KSSQLQueryGenerator, _KSDatabaseAPI, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var LOG_PREFIX = "KSObjectServiceMetadataContext : ";
    var logger = kony.sdk.logsdk;
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Instantiates an instance of ObjectServiceMetadataContext class.
     * populates objectServiceName, metadata URL, sync URL and object service version to itself.
     * @param objectServiceName
     * @param objectServiceContext
     * @constructor
     */
    function KSObjectServiceMetadataContext(objectServiceName, objectServiceContext) {
        this.name = objectServiceName;
        this.url = objectServiceContext[KSInternalConstants.URL];
        this.metadataURL = objectServiceContext[KSInternalConstants.OBJECTSERVICE_METADATA_URL];
        this.objectServiceVersion = objectServiceContext[KSInternalConstants.VERSION];
        this.deltaContext = null;
        this.rootMetadataObject = null;
        this.offlineObjectServiceVersion = null;
    }
    /**
     * Overloaded constructor that tries populate offline metadata, deltacontext and version
     * from the konysyncMetadata table if a record exists with given object service name.
     * Otherwise, the mentioned params are null by default.
     * @param objectServiceName
     * @param objectServiceContext
     * @returns {Promise<KSObjectServiceMetadataContext>}
     * @throws setupException
     */
    async function init(objectServiceName, objectServiceContext) {
        var _this = new KSObjectServiceMetadataContext(objectServiceName, objectServiceContext);
        try {
            var record = await getMetadataJSONAndDeltaContextFromMetadataTable.call(_this);
            if (record) {
                if (!KSCommonUtils.isNullOrEmptyObject(record[KSDatabaseConstants.METADATA_TABLE_METADATA_JSON])) {
                    _this.rootMetadataObject = record[KSDatabaseConstants.METADATA_TABLE_METADATA_JSON];
                    logger.trace(LOG_PREFIX, "Retrieved metadataJSON:" + _this.rootMetadataObject + " from client DB.");
                }
                if (!KSCommonUtils.isNullOrEmptyObject(record[KSDatabaseConstants.METADATA_TABLE_DELTA_CONTEXT])) {
                    _this.deltaContext = record[KSDatabaseConstants.METADATA_TABLE_DELTA_CONTEXT];
                    logger.trace(LOG_PREFIX, "Retrieved deltaContext: " + _this.deltaContext + " from client DB.");
                }
                if (!KSCommonUtils.isNullOrEmptyObject(record[KSDatabaseConstants.METADATA_TABLE_VERSION])) {
                    _this.offlineObjectServiceVersion = record[KSDatabaseConstants.METADATA_TABLE_VERSION];
                    logger.trace(LOG_PREFIX, "Retrieved version: " + _this.offlineObjectServiceVersion + " from client DB.");
                }
            }
            return _this;
        } catch (setupException) {
            setupException[KSInternalConstants.OBJECT_SERVICE_NAME] = objectServiceName;
            throw setupException;
        }
    }
    /**
     * Method to fetch offline saved data from konysyncMetadata table, if database and the table exist.
     * @returns {Promise<konysyncMetadata table record>}
     * @throws DatabaseException
     */
    async function getMetadataJSONAndDeltaContextFromMetadataTable() {
        var query = KSSQLQueryGenerator.getSQLSelectQueryForMetadataTableProperties(this.name);
        var dbName = KSCommonUtils.getOfflineObjectsDatabaseName();
        var dbExists = await KSDatabaseAPI.databaseExists(dbName);
        if (dbExists) {
            try {
                await KSDatabaseAPI.initializeDatabase(dbName);
                var tableExists = await KSDatabaseAPI.tableExists(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_METADATA);
                if (tableExists) {
                    var result = await KSDatabaseAPI.executeQuery(query);
                    if (KSCommonUtils.isNullOrEmptyObject(result)) {
                        logger.warn(LOG_PREFIX, "Metadata record not found for the object service : " + this.name);
                        return null;
                    } else {
                        logger.debug(LOG_PREFIX, "Successfully fetched the metadata record for the object service : " + this.name);
                        return result[0];
                    }
                } else {
                    logger.warn(LOG_PREFIX, "Metadata record not found for the object service : " + this.name);
                    return null;
                }
            } catch (dbException) {
                logger.error(LOG_PREFIX, "An exception occurred while trying to get connection for existing db : object service " + this.name + "Exception : " + dbException);
                throw dbException;
            }
        }
    }
    /**
     * Method to determine if the konysyncMetadata table contains offline metadata
     * for the object service in this instance.
     * @returns {boolean}
     */
    KSObjectServiceMetadataContext.prototype.doesMetadataTableContainObjectService = function() {
        return !(KSCommonUtils.isNullOrEmptyObject(this.deltaContext));
    };
    exports.getInstance = init;
});
/**
 * KSObjectServiceSetup
 * Created by Harshini Bonam on 24/05/18.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSObjectServiceSetup", ["exports", "KSMetadataUtils", "KSNetworkUtils", "KSError"], function(exports, KSMetadataUtils, KSNetworkUtils, _KSError) {
    "use strict";
    exports._esModule = true;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSObjectServiceSetup : ";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Instantiates an instance of KSObjectServiceSetup
     * If the input _objectServiceMetadataContext already contains offline metadata, then this
     * initialisation would skip network data fetching, rootmetadata parsing and create table query generation.
     * @param _objectServiceMetadataContext
     * @param _successCallback
     * @param _failureCallback
     * @constructor
     */
    function KSObjectServiceSetup(_objectServiceMetadataContext, _successCallback, _failureCallback) {
        this.successCallback = _successCallback;
        this.failureCallback = _failureCallback;
        this.rawNetworkResponse = null;
        this.objectServiceMetadataContext = _objectServiceMetadataContext;
        this.shouldCreateObjectTables = !(this.objectServiceMetadataContext.doesMetadataTableContainObjectService());
        initializeLocalVariables.call(this);
        if (this.shouldCreateObjectTables) {
            startMetadataDownload.call(this);
            //WARN: Don't add code after this startMetadataDownload as it is asynchronous.
        } else {
            this.rootMetadataObject = this.objectServiceMetadataContext.rootMetadataObject;
            invokeSuccessCallback.call(this);
            //WARN: Don't add code after.
        }
    }
    /**
     * Method to populate private instance variables.
     */
    function initializeLocalVariables() {
        this.objectServiceName = this.objectServiceMetadataContext.name;
        this.currentVersion = this.objectServiceMetadataContext.objectServiceVersion;
        this.createTableQueries = {};
    }
    /**
     * Method to start object service metadata download.
     * On success, this method invokes rootMetadata parser and create table query generation.
     * On failure, this method invokes failureCallback with the appropriate error percolated from network failureCallback.
     */
    function startMetadataDownload() {
        var headers = {};
        headers[KSInternalConstants.X_KONY_SERVICE_VERSION] = KSInternalConstants.X_KONY_SERVICE_VERSION_VALUE;
        headers[KSInternalConstants.X_KONY_API_VERSION] = this.currentVersion;
        var onNetworkResponseSuccess = function(response) {
            this.rawNetworkResponse = kony.sdk.cloneObject(response);
            parseResponseAndCreateTables.call(this, this.rawNetworkResponse);
        };
        var onNetworkError = function(errorObj) {
            var errorDescription = KSInternalConstants.EM_FIRST_TIME_OFFLINE_SETUP + ' ' + this.objectServiceName + ' ' + this.currentVersion;
            kony.sdk.logsdk.error(LOG_PREFIX, errorDescription);
            invokeFailureCallback.call(this, errorObj);
        };
        KSNetworkUtils.get(this.objectServiceMetadataContext.metadataURL, null, headers, null, onNetworkResponseSuccess.bind(this), onNetworkError.bind(this));
    }
    /**
     * Method to parse metadata from network response and generate create table queries.
     * @param metadataJSON
     */
    function parseResponseAndCreateTables(metadataJSON) {
        try {
            this.rootMetadataObject = KSMetadataUtils.parseSetupMetadataJSON.call(this, this.objectServiceMetadataContext, metadataJSON);
            populateObjectServiceMetadataContextInRootMetadataObject.call(this);
            this.createTableQueries = KSMetadataUtils.getQueriesToCreateTablesForObjectService(this.objectServiceName, this.rootMetadataObject);
            invokeSuccessCallback.call(this);
        } catch (parseException) {
            invokeFailureCallback.call(this, parseException);
        }
    }
    /**
     * Method to populate endpoint URL and object service version from service doc,
     * into rootMetadataObject.
     */
    function populateObjectServiceMetadataContextInRootMetadataObject() {
        this.rootMetadataObject[KSInternalConstants.ENDPOINT_URL] = this.objectServiceMetadataContext.url;
        this.rootMetadataObject[KSInternalConstants.VERSION] = this.objectServiceMetadataContext.objectServiceVersion;
    }
    /**
     * Method to populate objectServiceMetadataContext with rootMetadataObject, latest deltaContext,
     * and then invokes successCallback to notify the SetupManager for completion.
     */
    function invokeSuccessCallback() {
        this.objectServiceMetadataContext.rootMetadataObject = this.rootMetadataObject;
        this.objectServiceMetadataContext.deltaContext = this.rootMetadataObject[KSInternalConstants.TIMESTAMP];
        this.successCallback(this.objectServiceName, this.rootMetadataObject, this.createTableQueries);
    }
    /**
     * Method to invoke failureCallback to notify the SetupManager for error
     * in corresponding object service.
     * @param errorObj
     */
    function invokeFailureCallback(errorObj) {
        this.failureCallback(this.objectServiceName, errorObj);
    }
    exports.KSObjectServiceSetup = KSObjectServiceSetup;
});
/**
 * KSSetupManager
 * Created by Harshini Bonam on 24/05/18.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSSetupManager", ["exports", "KSMetadataUtils", "KSCommonUtils", "KSObjectServiceSetup", "KSObjectServiceMetadataContext", "KSError"], function(exports, KSMetadataUtils, KSCommonUtils, KSObjectServiceSetupClass, KSObjectServiceMetadataContextClass, _KSError) {
    "use strict";
    exports._esModule = true;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSSetupManager : ";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var setupStatus;
    var setupContext;
    var newSetupContext;
    var refreshCounter;
    var successCallback;
    var failureCallback;
    var objectServiceListContext;
    var objectServiceMetadataContexts;
    var objectServiceObjectsDDLQueries;
    var instance = null;
    /**
     * Instantiates an instance of KSSetupManager class.
     * @constructor
     */
    function KSSetupManager() {
        setupStatus = {};
        setupContext = {};
        newSetupContext = {};
        objectServiceMetadataContexts = {};
        objectServiceObjectsDDLQueries = {};
        clearProperties();
    }
    /**
     * Method to return the successfully setup object services list
     * @returns Returns the list of Successfully setup Object Services
     */
    KSSetupManager.prototype.getSetupStatus = function() {
        return setupStatus;
    };
    /**
     * Method to enforce singleton instance of SetupManager.
     * @returns {singleton instance of SetupManager}
     */
    KSSetupManager.getInstance = function() {
        if (instance == null) {
            instance = new KSSetupManager();
        }
        return instance;
    };
    /**
     * Method to check if upload cache is enabled for the object service.
     * @param syncObject
     * @return {true/false}
     */
    KSSetupManager.prototype.isUploadCacheEnabledForObject = function(syncObject) {
        var objectServiceName = syncObject.getObjectServiceName();
        var rootMetadataObject = setupContext[objectServiceName];
        return rootMetadataObject[KSInternalConstants.UPLOAD_CACHE];
    };
    /**
     * Method to initialize values for setup and instantiates objectServiceMetadataContext and
     * objectServiceSetup classes for each object service provided in offline objectServiceList.
     * @param objectServiceList
     * @param options
     * @param _successCallback
     * @param _failureCallback
     */
    KSSetupManager.prototype.setup = function(objectServiceList, options, _successCallback, _failureCallback) {
        kony.sdk.logsdk.debug(LOG_PREFIX + "Setup is in progress");
        initializeValuesForSetup.call(this, objectServiceList, _successCallback, _failureCallback);
        for (var objectServiceName in objectServiceList) {
            if (objectServiceList.hasOwnProperty(objectServiceName)) {
                (KSObjectServiceMetadataContextClass.getInstance(objectServiceName, objectServiceList[objectServiceName])).then(objectServiceMetadataContext => {
                    objectServiceMetadataContexts[objectServiceMetadataContext.name] = objectServiceMetadataContext;
                    new KSObjectServiceSetupClass.KSObjectServiceSetup(objectServiceMetadataContext, objectServiceSetupSuccessCallback, objectServiceSetupFailureCallback);
                }).catch(exception => {
                    kony.sdk.logsdk.error(LOG_PREFIX, "Failed to fetch offline metadata.");
                    objectServiceSetupFailureCallback(exception[KSInternalConstants.OBJECT_SERVICE_NAME], exception);
                });
            }
        }
    };
    /**
     * Method to reset all the private instance variables of SetupManager.
     */
    KSSetupManager.prototype.reset = function() {
        refreshCounter = 0;
        successCallback = null;
        failureCallback = null;
        KSCommonUtils.clearJSONObject(setupStatus);
        KSCommonUtils.clearJSONObject(setupContext);
        KSCommonUtils.clearJSONObject(newSetupContext);
        KSCommonUtils.clearJSONObject(objectServiceMetadataContexts);
        KSCommonUtils.clearJSONObject(objectServiceObjectsDDLQueries);
    };
    /**
     * Getter method for setupContext JSON that contains rootMetadataObjects for each objectServiceName key.
     * @returns {setupContext}
     */
    KSSetupManager.prototype.getSetupContext = function() {
        return setupContext;
    };
    /**
     * Listener method of objectServiceSetup instances on successful completion initialisation.
     * This method increments the refreshCounter by 1, adds the object service name into setupStatus's
     * successfulObjectServiceList and depending on the queries that are generated, the root metadata object is assigned to
     * either setupContext or newSetupContext. In the end, it invokes verifyAndCreateTables.
     * @param objectServiceName
     * @param rootMetadataObject
     * @param queries
     * @returns {Promise<void>}
     */
    async function objectServiceSetupSuccessCallback(objectServiceName, rootMetadataObject, queries) {
        refreshCounter++;
        if (kony.sdk.isNullOrUndefined(setupStatus.successfulObjectServices)) {
            setupStatus.successfulObjectServices = [];
        }
        setupStatus.successfulObjectServices.push(objectServiceName);
        if (KSCommonUtils.isNullOrEmptyObject(queries)) {
            setupContext[objectServiceName] = rootMetadataObject;
        } else {
            newSetupContext[objectServiceName] = rootMetadataObject;
            KSMetadataUtils.mergeJSONObjects(queries, objectServiceObjectsDDLQueries);
        }
        await verifyAndCreateTables();
    }
    /**
     * Listener method of objectServiceSetup instances on failure to initialise.
     * This method increments the refreshCounter by 1, adds the object service name into setupStatus's
     * failedObjectServices JSON object, and corresponding error (depending on the error enumerability) is set as value.
     * @param objectServiceName
     * @param error
     * @returns {Promise<void>}
     */
    async function objectServiceSetupFailureCallback(objectServiceName, error) {
        refreshCounter++;
        if (kony.sdk.isNullOrUndefined(setupStatus.failedObjectServices)) {
            setupStatus.failedObjectServices = {};
        }
        if (!KSCommonUtils.isExceptionObjectEnumerable(error)) {
            error = error.toString();
        }
        setupStatus.failedObjectServices[objectServiceName] = error;
        await verifyAndCreateTables();
    }
    /**
     * Method to verify if the refresh counter reached end value, create tables if setupContext is empty.
     * Meaning, setupContext is empty only for first time setup, and newSetupContext has the required rootMetadataObjects.
     * Upon successful creation of tables and insertion into meta tables, the newSetupContext is merged into setupContext
     * and successCallback is invoked to notify SyncEngine for completion.
     * In case of any error, we clone the setupStatus, clear all the necessary setupManager instance variables and
     * then invoke failureCallback with the cloned setupStatus/setupError to notify SyncEngine for completion.
     * @returns {Promise<void>}
     */
    async function verifyAndCreateTables() {
        if (refreshCounter === Object.keys(objectServiceListContext).length) {
            var failureCount = kony.sdk.isNullOrUndefined(setupStatus.failedObjectServices) ? 0 : Object.keys(setupStatus.failedObjectServices).length;
            if (failureCount === refreshCounter) {
                var clonedSetupStatus = kony.sdk.cloneObject(setupStatus);
                kony.sdk.logsdk.error(LOG_PREFIX, "Kony Offline Objects Setup failed : " + JSON.stringify(clonedSetupStatus));
                clearProperties();
                failureCallback(new KSError(KSErrorConstants.SETUP_METADATA_REFRESH_ERROR, clonedSetupStatus));
            } else {
                try {
                    //Since incrementalSetup is not supported now, the below check skips table creation
                    // when there are any incremental changes.
                    if (KSCommonUtils.isNullOrEmptyObject(setupContext) && !KSCommonUtils.isNullOrEmptyObject(objectServiceObjectsDDLQueries)) {
                        var metaTableQueries = KSMetadataUtils.getMetaTableCreateQueries();
                        KSMetadataUtils.mergeJSONObjects(metaTableQueries, objectServiceObjectsDDLQueries);
                        await KSMetadataUtils.createTablesForAllObjectServices(objectServiceObjectsDDLQueries);
                        await KSMetadataUtils.insertIntoMetadataAndMetaInfoTables(objectServiceMetadataContexts);
                        KSMetadataUtils.mergeJSONObjects(newSetupContext, setupContext);
                    }
                    if (failureCount === 0) {
                        kony.store.setItem(KSInternalConstants.DB_SCHEMA_VERSION, KSCommonUtils.getLatestDBVersion());
                        var successObj = {};
                        successObj[KSPublicConstants.STATUS] = KSErrorConstants.STATUS_SUCCESS;
                        kony.sdk.logsdk.debug(LOG_PREFIX, "Kony Offline Objects Setup successful.");
                        successCallback(successObj);
                    } else {
                        var clonedSetupStatus = kony.sdk.cloneObject(setupStatus);
                        kony.sdk.logsdk.error(LOG_PREFIX, "Kony Offline Objects Setup failed : " + JSON.stringify(clonedSetupStatus));
                        clearProperties();
                        failureCallback(new KSError(KSErrorConstants.SETUP_METADATA_REFRESH_ERROR, clonedSetupStatus));
                    }
                } catch (exception) {
                    kony.sdk.logsdk.error(LOG_PREFIX, exception);
                    clearProperties();
                    failureCallback(new KSError(KSErrorConstants.SETUP_GENERIC_ERROR, exception));
                }
            }
        }
    }
    /**
     * Method to clear Setup Manager properties other than callbacks and setupContext.
     * Since setupContext still should help initializing SDKObjects/SDKObjectServices which were setup successfully.
     */
    function clearProperties() {
        refreshCounter = 0;
        KSCommonUtils.clearJSONObject(setupStatus);
        KSCommonUtils.clearJSONObject(newSetupContext);
        KSCommonUtils.clearJSONObject(objectServiceMetadataContexts);
        KSCommonUtils.clearJSONObject(objectServiceObjectsDDLQueries);
    }
    /**
     * Method to initialize private instance variables for Setup Manager along with callbacks and objectServiceList.
     * @param objectServiceList
     * @param _successCallback
     * @param _failureCallback
     */
    function initializeValuesForSetup(objectServiceList, _successCallback, _failureCallback) {
        this.reset();
        successCallback = _successCallback;
        failureCallback = _failureCallback;
        objectServiceListContext = objectServiceList;
    }
    //---------------------------------
    // Utils
    //---------------------------------
    /**
     * Getter method to retrieve objectMetadata for given fullyQualifiedName.
     * @param fullyQualifiedObjectName
     * @returns {objectMetadata}
     * @throws {KSError} if objectMetadata for given fullyQualifiedName is not found in the setupContext.
     */
    KSSetupManager.prototype.getObjectMetadataForFullyQualifiedObjectName = function(fullyQualifiedObjectName) {
        for (var objectServiceName in setupContext) {
            if (setupContext.hasOwnProperty(objectServiceName)) {
                var objectMetadata = instance.getObjectMetadataInObjectServiceWithFullyQualifiedObjectName(objectServiceName, fullyQualifiedObjectName);
                if (objectMetadata) {
                    kony.sdk.logsdk.debug(LOG_PREFIX, "Found SDKObject " + fullyQualifiedObjectName + " in object service " + objectServiceName);
                    return objectMetadata;
                }
            }
        }
        var errorMessage = "No object metadata available for the given SDKObject " + fullyQualifiedObjectName;
        kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
        throw new KSError(KSErrorConstants.SETUP_OBJECT_METADATA_NOT_FOUND, errorMessage);
    };
    /**
     * Getter method to retrieve objectMetadata for given namespaceName and objectName.
     * @param namespaceName
     * @param objectName
     * @returns {objectMetadata}
     * @throws {KSError} if objectMetadata for given namespaceName and objectName, is not found in the setupContext.
     */
    KSSetupManager.prototype.getObjectMetadataForNamespaceNameAndObjectName = function(namespaceName, objectName) {
        for (var objectServiceName in setupContext) {
            if (setupContext.hasOwnProperty(objectServiceName)) {
                var objectMetadata = instance.getObjectMetadataInObjectServiceWithNamespaceNameAndObjectName(objectServiceName, namespaceName, objectName);
                if (objectMetadata) {
                    kony.sdk.logsdk.debug(LOG_PREFIX, "Found SDKObject " + objectName + " of namespace " + namespaceName + " in object service " + objectServiceName);
                    return objectMetadata;
                }
            }
        }
        var errorMessage = "No object metadata available for the given SDKObject " + objectName + " in " + namespaceName + " namespace.";
        kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
        throw new KSError(KSErrorConstants.SETUP_OBJECT_METADATA_NOT_FOUND, errorMessage);
    };
    /**
     * Getter method to retrieve objectMetadata for given objectServiceName and fullyQualifiedName.
     * @param objectServiceName
     * @param fullyQualifiedObjectName
     * @returns {objectMetadata}/null if objectMetadata for given objectServiceName and fullyQualifiedName,
     * is not found in the setupContext.
     */
    KSSetupManager.prototype.getObjectMetadataInObjectServiceWithFullyQualifiedObjectName = function(objectServiceName, fullyQualifiedObjectName) {
        var namespaceName = KSMetadataUtils.namespaceNameFromFullyQualifiedName(fullyQualifiedObjectName);
        var objectName = KSMetadataUtils.objectNameFromFullyQualifiedName(fullyQualifiedObjectName);
        var objectMetadata = instance.getObjectMetadataInObjectServiceWithNamespaceNameAndObjectName(objectServiceName, namespaceName, objectName);
        if (objectMetadata) {
            kony.sdk.logsdk.debug(LOG_PREFIX, "Found SDKObject " + fullyQualifiedObjectName + " in object service " + objectServiceName);
            return objectMetadata;
        }
    };
    /**
     * Getter method to retrieve objectMetadata for given objectServiceName, namespaceName and objectName.
     * @param objectServiceName
     * @param namespaceName
     * @param objectName
     * @returns {objectMetadata}/null if objectMetadata for given objectServiceName, namespaceName and objectName,
     * is not found in the setupContext.
     */
    KSSetupManager.prototype.getObjectMetadataInObjectServiceWithNamespaceNameAndObjectName = function(objectServiceName, namespaceName, objectName) {
        var objectService = setupContext[objectServiceName];
        if (objectService) {
            var normalizedNamespaceName = KSMetadataUtils.normalizedNamespaceName(namespaceName);
            var namespace = objectService[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY][normalizedNamespaceName];
            if (namespace) {
                var objectMetadata = namespace[KSInternalConstants.OBJECT_METADATA_DICTIONARY][objectName];
                if (objectMetadata) {
                    return objectMetadata;
                }
            }
        }
        return null;
    };
    exports.getInstance = KSSetupManager.getInstance;
});
/**
 * KSApplicationSync
 * Created by KH9363 on 18/02/2019.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSApplicationSyncHelper", ["exports", "SyncEngine", "KSSyncMFUtils", "KSError", "KSSetupManager", "KSOptionsHelper", "SDKObjectServiceSync"], function(exports, SyncEngine, KSSyncMFUtils, _KSError, KSSetupManager, KSOptionsHelper, _SDKObjectServiceSync) {
    "use strict";
    exports._esModule = true;
    var LOG_PREFIX = "KSApplicationSyncHelper : ";
    var logger = kony.sdk.logsdk;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSError = _KSError.KSError;
    var syncEngineInstance = SyncEngine.getInstance();
    var setupInstance = KSSetupManager.getInstance();
    var objectServicesOptions = {};
    var sdkObjectServiceInstancesMap = {};
    var syncSuccessResponse = {};
    var syncErrorResponse = {};
    var objectServiceNamesList = {};
    var syncCounter = 0;
    /**
     * Creates instances for object Services
     */
    function populateObjectServicesInstances() {
        var objectServicesListContext = setupInstance.getSetupContext();
        var sdkObjectServiceSync = _SDKObjectServiceSync.SDKObjectServiceSync;
        for (var objectServiceName in objectServicesListContext) {
            try {
                var syncObjectService = new sdkObjectServiceSync(objectServiceName);
                logger.debug(LOG_PREFIX, "SDKObjectService instance created successfully for objectservice " + objectServiceName);
                sdkObjectServiceInstancesMap[objectServiceName] = syncObjectService;
            } catch (error) {
                logger.error(LOG_PREFIX, "SDKObjectService creation failed " + error.message);
                syncErrorResponse[objectServiceName] = error;
            }
        }
        if (Object.keys(sdkObjectServiceInstancesMap).length === 0) {
            var errorMessage = "Application Sync failed. SDKObjectService instance creation failed for all Object Services";
            logger.error(LOG_PREFIX, errorMessage);
            var error = new KSError(KSErrorConstants.SYNC_GENERIC_ERROR, errorMessage);
            error.userInfo = syncErrorResponse;
            return error;
        }
    }
    /**
     * Method to Sync all object Services in an application
     *
     * @param options                  options for each object service provided by user
     * @param successCallback          Success Callback provided by user to be called after sync
     * @param failureCallback          Failure Callback provided by user to be called after sync
     * @param progressCallback         Progress callback to be called for each object service
     */
    async function startSync(options, successCallback, failureCallback, progressCallback) {
        logger.trace(LOG_PREFIX, "Application Sync Called.");
        try {
            isSetupSuccessful();
            if (kony.sdk.isNullOrUndefined(options)) {
                options = {};
            }
            var objectServiceNamesList = Object.keys(setupInstance.getSetupContext());
            KSOptionsHelper.areApplicationSyncOptionsValid(options, objectServiceNamesList);
            logger.trace(LOG_PREFIX, "Application sync options are valid.");
            syncEngineInstance.checkAndSetFlagForApplicationSync();
            await applicationSyncInit(options, objectServiceNamesList, successCallback, failureCallback);
        } catch (error) {
            logger.error(LOG_PREFIX + "Application Sync failed with error " + error.message);
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    }
    /**
     * Method to check whether setup is successful or not
     *
     * @return boolean true if setup is successful else false
     */
    function isSetupSuccessful() {
        var isSetupSuccessful = false;
        var setupStatus = setupInstance.getSetupStatus();
        if (!kony.sdk.isNullOrUndefined(setupStatus.successfulObjectServices) && (setupStatus.successfulObjectServices).length !== 0) {
            isSetupSuccessful = true;
            logger.trace(LOG_PREFIX, "Setup is successful.");
        } else {
            logger.error(LOG_PREFIX + "Setup is not performed. There are no object services to sync.");
            throw new KSError(KSErrorConstants.APPLICATION_SYNC_OBJECTSERVICES_NOT_FOUND, "Setup is not performed. There are no object services to sync.")
        }
        return isSetupSuccessful;
    }
    /**
     * Method to initialize application sync helper class variables
     * and starts application sync in parallel or sequential
     * @param options                   options for each object service provided by user
     * @param objectServiceNameList    List of Object Services present in the Application
     * @param successCallback           Success Callback provided by user to be called after sync
     * @param failureCallback           Failure Callback provided by user to be called after sync
     */
    async function applicationSyncInit(options, objectServiceNameList, successCallback, failureCallback) {
        try {
            clear();
            objectServiceNamesList = objectServiceNameList;
            var objSvcsOptions = options[KSPublicConstants.APPLICATION_SYNC_OBJECT_SERVICES_OPTIONS];
            objectServicesOptions = (kony.sdk.util.isJsonObject(objSvcsOptions)) ? objSvcsOptions : {};
            populateObjectServicesInstances();
            if (options[KSPublicConstants.APPLICATION_SYNC_MODE] === KSPublicConstants.APPLICATION_SYNC_SEQUENTIAL) {
                logger.debug(LOG_PREFIX, "Starting Application Sync in sequence");
                await startObjectServicesSyncInSequence(successCallback, failureCallback);
            } else {
                logger.debug(LOG_PREFIX, "Starting Application Sync in parallel");
                await startObjectServicesSyncInParallel(successCallback, failureCallback);
            }
        } catch (error) {
            syncEngineInstance.applicationSyncCompleted();
            logger.error(LOG_PREFIX + error.message);
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    }
    /**
     * This method initiates sync for object service
     *
     * @param objectServiceName                Name of object service
     * @param onSuccess                        Success Callback provided by user to be called after sync
     * @param onFailure                        Failure Callback provided by user to be called after sync
     */
    function objectServiceStartSync(objectServiceName, onSuccess, onFailure) {
        var syncObjectService = sdkObjectServiceInstancesMap[objectServiceName];
        var objectServiceOptions;
        if (!kony.sdk.isNullOrUndefined(objectServicesOptions) && objectServicesOptions.hasOwnProperty(objectServiceName)) {
            objectServiceOptions = objectServicesOptions[objectServiceName];
        } else {
            objectServiceOptions = {};
        }
        syncObjectService.startSync(objectServiceOptions, onSuccess, onFailure);
    }
    /**
     * Method to populate objectServiceResponse with keys syncSuccessResponse and syncErrorResponse
     *
     * @param objectServiceResponse JSON which will contain syncSuccessResponse and syncErrorResponse
     */
    function setObjectServiceResponse(objectServiceResponse) {
        if ((Object.keys(syncSuccessResponse)).length > 0) {
            objectServiceResponse[KSPublicConstants.APPLICATION_SYNC_SUCCESS_RESPONSE] = syncSuccessResponse;
        }
        if ((Object.keys(syncErrorResponse)).length > 0) {
            objectServiceResponse[KSPublicConstants.APPLICATION_SYNC_FAILURE_RESPONSE] = syncErrorResponse;
        }
    }
    /**
     * Asynchronous Sync flow, Sync happens parallel for object services
     * @param successCallback  Success Callback provided by user to be called after sync
     * @param failureCallback  Failure Callback provided by user to be called after sync
     */
    async function startObjectServicesSyncInParallel(successCallback, failureCallback) {
        logger.debug(LOG_PREFIX, "startObjectServicesSyncInParallel called");
        var objectServiceName = Object.keys(sdkObjectServiceInstancesMap)[syncCounter];
        logger.debug(LOG_PREFIX, "Starting sync for object service " + objectServiceName);

        function onSuccess(syncResponse) {
            logger.debug(LOG_PREFIX, "Sync successful for object service " + syncResponse[KSInternalConstants.OBJECT_SERVICE_NAME]);
            syncSuccessResponse[syncResponse[KSInternalConstants.OBJECT_SERVICE_NAME]] = syncResponse;
            syncCounter++;
            if (syncCounter === Object.keys(sdkObjectServiceInstancesMap).length) {
                setResponseAndInvokeCallback(successCallback, failureCallback);
            }
        }

        function onFailure(error) {
            var objectServiceName = error.userInfo[KSInternalConstants.OBJECT_SERVICE_NAME];
            logger.debug(LOG_PREFIX, "Sync failed for object service " + objectServiceName);
            syncErrorResponse[objectServiceName] = error;
            syncCounter++;
            if (syncCounter === Object.keys(sdkObjectServiceInstancesMap).length) {
                setResponseAndInvokeCallback(successCallback, failureCallback);
            }
        }
        for (var objectServiceName in sdkObjectServiceInstancesMap) {
            objectServiceStartSync(objectServiceName, onSuccess, onFailure);
        }
    }
    /**
     * Synchronous Sync flow, Sync happens sequentially for object services
     * @param successCallback  Success Callback provided by user to be called after sync
     * @param failureCallback  Failure Callback provided by user to be called after sync
     */
    async function startObjectServicesSyncInSequence(successCallback, failureCallback) {
        logger.debug(LOG_PREFIX, "startObjectServicesSyncInSequence called");
        var objectServiceName = Object.keys(sdkObjectServiceInstancesMap)[syncCounter];
        logger.debug(LOG_PREFIX, "Starting sync for object service " + objectServiceName);

        function onSuccess(syncResponse) {
            logger.debug(LOG_PREFIX, "Sync successful for object service " + JSON.stringify(syncResponse));
            syncSuccessResponse[syncResponse[KSInternalConstants.OBJECT_SERVICE_NAME]] = syncResponse;
            syncCounter++;
            if (syncCounter < Object.keys(sdkObjectServiceInstancesMap).length) {
                var objectServiceName = Object.keys(sdkObjectServiceInstancesMap)[syncCounter];
                objectServiceStartSync(objectServiceName, onSuccess, onFailure);
            } else {
                setResponseAndInvokeCallback(successCallback, failureCallback);
            }
        }

        function onFailure(error) {
            logger.debug(LOG_PREFIX, "Sync failed for object service ");
            var objectServiceName = error.userInfo[KSInternalConstants.OBJECT_SERVICE_NAME];
            syncErrorResponse[objectServiceName] = error;
            syncCounter++;
            if (syncCounter < Object.keys(sdkObjectServiceInstancesMap).length) {
                objectServiceStartSync(Object.keys(sdkObjectServiceInstancesMap)[syncCounter], onSuccess, onFailure);
            } else {
                setResponseAndInvokeCallback(successCallback, failureCallback);
            }
        }
        objectServiceStartSync(objectServiceName, onSuccess, onFailure);
    }
    /**
     * Clears the global variables
     */
    function clear() {
        objectServicesOptions = {};
        sdkObjectServiceInstancesMap = {};
        syncSuccessResponse = {};
        syncErrorResponse = {};
        objectServiceNamesList = {};
        syncCounter = 0;
        logger.trace(LOG_PREFIX, "Cleared all global variables.");
    }
    /**
     * Method to be called after all the syncing tasks are done
     * @param objectServiceResponse  JSON which will contain syncSuccessResponse and syncErrorResponse
     * @param successCallback        Success Callback provided by user to be called after sync
     * @param failureCallback        Failure Callback provided by user to be called after sync
     */
    function applicationSyncCompletionHandler(applicationSyncResponse, successCallback, failureCallback) {
        syncEngineInstance.applicationSyncCompleted();
        if (Object.keys(syncErrorResponse).length === 0) {
            logger.debug(LOG_PREFIX, "Application sync success. Calling success callback ");
            kony.sdk.verifyAndCallClosure(successCallback, applicationSyncResponse);
        } else {
            var errorMessage = "Application sync failed. Calling failure callback";
            logger.error(LOG_PREFIX, errorMessage);
            var error = new KSError(KSErrorConstants.SYNC_GENERIC_ERROR, errorMessage);
            error.userInfo = applicationSyncResponse;
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    }
    /**
     * Decides whether to invoke success or failure callback of Application Sync
     */
    function setResponseAndInvokeCallback(successCallback, failureCallback) {
        var objectServiceResponse = {};
        setObjectServiceResponse(objectServiceResponse);
        if ((Object.keys(syncErrorResponse)).length === 0) {
            logger.trace(LOG_PREFIX, "Completed Application sync for " + Object.keys(sdkObjectServiceInstancesMap) + ".");
        } else {
            var errorMessage = "Application Sync failed due to failure in sync of one or more object services,[ " + Object.keys(syncErrorResponse) + "]. Calling Failure Callback.";
            logger.error(LOG_PREFIX, errorMessage);
        }
        applicationSyncCompletionHandler(objectServiceResponse, successCallback, failureCallback);
    }
    exports.startSync = startSync;
});
/**
 * Module to manage the running tasks in offline objects.
 */
define("KSRunningTasksManager", ["exports", "KSCommonUtils"], function(exports, KSCommonUtils) {
    var instance = null;
    var KSTasks = kony.sdk.OfflineObjects.KSTasks;
    var KSTaskID = kony.sdk.OfflineObjects.KSTaskID;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var trackActiveSyncTasks;
    /**
     * Method to initialise the KSRunningTasksContext in the local store, if not present already.
     * @constructor Constructor for KSRunningTasksManager.
     */
    function KSRunningTasksManager() {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        trackActiveSyncTasks = [];
        if (KSCommonUtils.isNullOrEmptyObject(runningTasksContext)) {
            var runningTasksContext = {
                APPLICATION_LEVEL: 0
            };
            KSCommonUtils.setRunningTasksContext(runningTasksContext);
        }
    }
    /**
     * Method to make KSRunningTasksManager a singleton.
     * @returns {*} Instance of KSRunningTasksManager.
     */
    KSRunningTasksManager.getInstance = function() {
        if (instance == null) {
            instance = new KSRunningTasksManager();
        }
        return instance;
    };
    //-------------------------------------
    // METHODS FOR APPLICATION LEVEL TASKS
    //-------------------------------------
    /**
     * Method to check if the application level API is allowed to execute.
     * @param taskToBeChecked Application level task which needs to be checked.
     * @returns {boolean} Boolean stating if the application level API is allowed to execute.
     */
    KSRunningTasksManager.prototype.isApplicationLevelOperationAllowed = function(taskToBeChecked) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        return ((runningTasksContext.APPLICATION_LEVEL & taskToBeChecked.BLOCKINGTASKS) === 0);
    };
    /**
     * Method to update the KSRunningTasksContext in local storage with Application level API task.
     * @param taskToBeAdded Application level API task which needs to be added to the KSRunningTasksContext.
     */
    KSRunningTasksManager.prototype.updateRunningTaskContextWithApplicationTasks = function(taskToBeAdded) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        runningTasksContext.APPLICATION_LEVEL = runningTasksContext.APPLICATION_LEVEL | taskToBeAdded.ID;
        KSCommonUtils.setRunningTasksContext(runningTasksContext);
    };
    /**
     * Method to remove Application level API task from KSRunningTasksContext in local storage.
     * @param taskToBeRemoved Application level API task which needs to be removed from the KSRunningTasksContext.
     */
    KSRunningTasksManager.prototype.removeApplicationTaskFromRunningTaskContext = function(taskToBeRemoved) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        // The bitwise Negation operation is succeeded by Zero fill right shift operation
        // to give a unsigned integer as result.
        // Bitwise And operation is followed by a bitwise Negation operation to flip the corresponding bit.
        runningTasksContext.APPLICATION_LEVEL = runningTasksContext.APPLICATION_LEVEL & (~(taskToBeRemoved.ID) >>> 0);
        KSCommonUtils.setRunningTasksContext(runningTasksContext);
    };
    //---------------------------
    // METHODS FOR SYNCING TASKS
    //---------------------------
    /**
     * Method to check if the sync on syncable object is allowed to execute.
     * @param syncableObject syncableObject which needs to be checked.
     * @returns {boolean} Boolean stating if the sync on syncableObject is allowed to execute.
     */
    KSRunningTasksManager.prototype.isSyncOperationAllowed = function(syncableObject) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        // The bitwise Negation operation is succeeded by Zero fill right shift operation
        // to give a unsigned integer as result.
        // Bitwise And operation is followed by a bitwise Negation operation to flip the corresponding bit.
        if ((runningTasksContext.APPLICATION_LEVEL & (KSTasks.SYNC.BLOCKINGTASKS & (~(KSTaskID.SYNC) >>> 0))) > 0) {
            return false;
        }
        var name = getKeyForSyncableObject.call(this, syncableObject.name, syncableObject.getSyncLevel(), syncableObject);
        if (runningTasksContext.hasOwnProperty(name) && ((runningTasksContext[name] & KSTasks.SYNC.BLOCKINGTASKS) > 0)) {
            return false;
        }
        if (syncableObject.getSyncLevel() == KSInternalConstants.SYNCLEVEL_OBJECT) {
            var objectServiceName = getKeyForSyncableObject(syncableObject.objectServiceName);
            if (runningTasksContext.hasOwnProperty(objectServiceName) && ((runningTasksContext[objectServiceName] & KSTasks.SYNC.BLOCKINGTASKS) > 0)) {
                return false;
            }
        } else if (syncableObject.getSyncLevel() == KSInternalConstants.SYNCLEVEL_OBJECTSERVICE) {
            var objectNamesArray = syncableObject.getObjectNames();
            for (var i = objectNamesArray.length - 1; i >= 0; i--) {
                var objectName = getKeyForSyncableObject.call(this, objectNamesArray[i], KSInternalConstants.SYNCLEVEL_OBJECT, syncableObject);
                if (runningTasksContext.hasOwnProperty(objectName)) {
                    if ((runningTasksContext[objectName] & KSTasks.SYNC.BLOCKINGTASKS) > 0) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    /**
     * Method to update the KSRunningTasksContext in local storage with sync on syncable task.
     * @param syncableObject SyncableObject which needs to be added to the KSRunningTasksContext.
     */
    KSRunningTasksManager.prototype.updateRunningTaskContextWithSyncableTasks = function(syncableObject) {
        var name = getKeyForSyncableObject.call(this, syncableObject.name, syncableObject.getSyncLevel(), syncableObject);
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        runningTasksContext.APPLICATION_LEVEL = runningTasksContext.APPLICATION_LEVEL | KSTasks.SYNC.ID;
        if (runningTasksContext.hasOwnProperty(name)) {
            runningTasksContext[name] = runningTasksContext[name] | KSTasks.SYNC.ID;
        } else {
            runningTasksContext[name] = KSTasks.SYNC.ID;
        }
        trackActiveSyncTasks.push(name);
        KSCommonUtils.setRunningTasksContext(runningTasksContext);
    };
    /**
     * Method to remove sync task on SyncableObject from KSRunningTasksContext in local storage.
     * @param syncableObject Syncable object whose sync operation needs to be removed from the KSRunningTasksContext.
     */
    KSRunningTasksManager.prototype.removeSyncableTasksFromRunningTaskContext = function(syncableObject) {
        var name = getKeyForSyncableObject.call(this, syncableObject.name, syncableObject.getSyncLevel(), syncableObject);
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        // The bitwise Negation operation is succeeded by Zero fill right shift operation
        // to give a unsigned integer as result.
        // Bitwise And operation is followed by a bitwise Negation operation to flip the corresponding bit.
        runningTasksContext[name] = runningTasksContext[name] & (~(KSTasks.SYNC.ID) >>> 0);
        trackActiveSyncTasks.remove(name);
        if (trackActiveSyncTasks.length === 0) {
            runningTasksContext.APPLICATION_LEVEL = runningTasksContext.APPLICATION_LEVEL & (~(KSTasks.SYNC.ID) >>> 0);
        }
        KSCommonUtils.setRunningTasksContext(runningTasksContext);
    };
    /**
     * Method to check if the rollback on syncable object is allowed to execute.
     * @param rollbackLevel the level at which rollback is performed.
     * @param rollbackObject rollbackObject which needs to be checked.
     * @returns {boolean} Boolean stating if the rollback on rollbackObject is allowed to execute.
     */
    KSRunningTasksManager.prototype.isRollbackOperationAllowed = function(rollbackLevel, rollbackObject) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        if ((runningTasksContext.APPLICATION_LEVEL & KSTasks.ROLLBACK.BLOCKINGTASKS) > 0) {
            return false;
        }
        if (rollbackLevel !== KSInternalConstants.SYNCLEVEL_APPLICATION) {
            var name = getKeyForSyncableObject.call(this, rollbackObject.name, rollbackObject.getSyncLevel(), rollbackObject);
            if (runningTasksContext.hasOwnProperty(name) && ((runningTasksContext[name] & KSTasks.ROLLBACK.BLOCKINGTASKS) > 0)) {
                return false;
            }
            if (rollbackObject.getSyncLevel() == KSInternalConstants.SYNCLEVEL_OBJECT) {
                var objectServiceName = getKeyForSyncableObject(rollbackObject.objectServiceName);
                if (runningTasksContext.hasOwnProperty(objectServiceName) && ((runningTasksContext[objectServiceName] & KSTasks.ROLLBACK.BLOCKINGTASKS) > 0)) {
                    return false;
                }
            } else if (rollbackObject.getSyncLevel() == KSInternalConstants.SYNCLEVEL_OBJECTSERVICE) {
                var objectNamesArray = rollbackObject.getObjectNames();
                for (var i = objectNamesArray.length - 1; i >= 0; i--) {
                    var objectName = getKeyForSyncableObject.call(this, objectNamesArray[i], KSInternalConstants.SYNCLEVEL_OBJECT, rollbackObject);
                    if (runningTasksContext.hasOwnProperty(objectName)) {
                        if ((runningTasksContext[objectName] & KSTasks.ROLLBACK.BLOCKINGTASKS) > 0) {
                            return false;
                        }
                    }
                }
            }
        } else {
            for (var runningTask in runningTasksContext) {
                if ((runningTasksContext[runningTask] & KSTasks.ROLLBACK.BLOCKINGTASKS) > 0) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * Method to update the KSRunningTasksContext in local storage with rollback on syncable task.
     * @param rollbackLevel the level at which rollback is performed.
     * @param rollbackObject SyncableObject which needs to be added to the KSRunningTasksContext.
     */
    KSRunningTasksManager.prototype.updateRunningTaskContextWithRollbackTasks = function(rollbackLevel, rollbackObject) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        if (rollbackLevel !== KSInternalConstants.SYNCLEVEL_APPLICATION) {
            var name = getKeyForSyncableObject.call(this, rollbackObject.name, rollbackObject.getSyncLevel(), rollbackObject);
            if (runningTasksContext.hasOwnProperty(name)) {
                runningTasksContext[name] = runningTasksContext[name] | KSTasks.ROLLBACK.ID;
            } else {
                runningTasksContext[name] = KSTasks.ROLLBACK.ID;
            }
        } else {
            runningTasksContext.APPLICATION_LEVEL = runningTasksContext.APPLICATION_LEVEL | KSTasks.ROLLBACK.ID;
        }
        KSCommonUtils.setRunningTasksContext(runningTasksContext);
    };
    /**
     * Method to remove rollback task on SyncableObject from KSRunningTasksContext in local storage.
     * @param rollbackLevel the level at which rollback is performed.
     * @param rollbackObject Syncable object whose rollback operation needs to be removed from the KSRunningTasksContext.
     */
    KSRunningTasksManager.prototype.removeRollbackTasksFromRunningTaskContext = function(rollbackLevel, rollbackObject) {
        var runningTasksContext = KSCommonUtils.getRunningTasksContext();
        if (rollbackLevel !== KSInternalConstants.SYNCLEVEL_APPLICATION) {
            // The bitwise Negation operation is succeeded by Zero fill right shift operation
            // to give a unsigned integer as result.
            // Bitwise And operation is followed by a bitwise Negation operation to flip the corresponding bit.
            var name = getKeyForSyncableObject.call(this, rollbackObject.name, rollbackObject.getSyncLevel(), rollbackObject);
            runningTasksContext[name] = runningTasksContext[name] & (~(KSTasks.ROLLBACK.ID) >>> 0);
        } else {
            runningTasksContext.APPLICATION_LEVEL = runningTasksContext.APPLICATION_LEVEL & (~(KSTasks.ROLLBACK.ID) >>> 0);
        }
        KSCommonUtils.setRunningTasksContext(runningTasksContext);
    };
    //------------------
    // HELPER METHODS
    //------------------
    /**
     * Method to build the key for the syncable object.
     * @param name Name of the syncable object.
     * @param syncLevel Level of the object for which the key needs to be created.
     * @param syncableObject Syncable object upon which the sync is invoked.
     * @returns {string} Key constructed to be stored in the local storage.
     */
    function getKeyForSyncableObject(name, syncLevel, syncableObject) {
        var constructedName = name;
        if (syncLevel === KSInternalConstants.SYNCLEVEL_OBJECT) {
            var objectServiceName = (syncableObject.getSyncLevel() === KSInternalConstants.SYNCLEVEL_OBJECT) ? syncableObject.objectServiceName : syncableObject.name;
            constructedName = objectServiceName + KSInternalConstants.DOT + name;
        }
        return constructedName.toUpperCase();
    }
    exports.getInstance = KSRunningTasksManager.getInstance;
});
define("SyncEngine", ["exports", "KSSetupManager", "KSError", "KSSyncingTask", "KSSyncDatabaseHelper", "KSSDKObjectService", "KSRunningTasksManager", "KSCommonUtils", "KSDatabaseUpgradeManager", "KSUploadCacheManager"], function(exports, KSSetupManager, _KSError, _KSSyncingTask, KSSyncDatabaseHelper, KSSDKObjectService, KSRunningTasksManager, KSCommonUtils, KSDatabaseUpgradeManager, KSUploadCacheManager) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "SyncEngine : ";
    var KSTasks = kony.sdk.OfflineObjects.KSTasks;
    var KSSyncingTask = _KSSyncingTask.KSSyncingTask;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var instance = null;

    function SyncEngine() {}
    SyncEngine.getInstance = function() {
        if (instance == null) {
            instance = new SyncEngine();
        }
        return instance;
    };
    SyncEngine.prototype.setup = function(objServiceList, options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX + "Setup invoked.");
        try {
            KSCommonUtils.resetLocksOnPageReload();
            //STEP1. initialize DB with options.
            //STEP2. check if setup is already in progress.
            if (KSRunningTasksManager.getInstance().isApplicationLevelOperationAllowed(KSTasks.SETUP)) {
                KSRunningTasksManager.getInstance().updateRunningTaskContextWithApplicationTasks(KSTasks.SETUP);
                KSDatabaseUpgradeManager.performDBUpgrade().then(res => {
                    setupOfflineObjectServices(objServiceList, options, successCallback, failureCallback);
                }).catch(exception => {
                    logger.error(LOG_PREFIX, "Setup failed with error: " + exception);
                    kony.sdk.verifyAndCallClosure(failureCallback, exception);
                });
            } else {
                var errorMessage = "Setup cannot be performed as other Offline Object operations are in progress.";
                logger.warn(LOG_PREFIX, errorMessage);
                kony.sdk.verifyAndCallClosure(failureCallback, new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage));
            }
        } catch (setupException) {
            logger.error(LOG_PREFIX, "Setup failed with error: " + setupException);
            kony.sdk.verifyAndCallClosure(failureCallback, setupException);
        }
    };

    function setupOfflineObjectServices(objServiceList, options, successCallback, failureCallback) {
        //STEP2a. perform database upgrade
        //STEP2b. invoke SetupManager
        var localSuccessCallback = function(response) {
            logger.debug(LOG_PREFIX + "Setup successful ");
            setupTaskCompleted();
            kony.sdk.verifyAndCallClosure(successCallback, response);
        };
        var localFailureCallback = function(error) {
            logger.error(LOG_PREFIX, "Setup failed with error: " + error);
            setupTaskCompleted();
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        };
        var setupManagerInstance = KSSetupManager.getInstance();
        setupManagerInstance.setup(objServiceList, options, localSuccessCallback, localFailureCallback);
    }
    SyncEngine.prototype.drop = function(options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX + "Drop invoked.");
        if (KSRunningTasksManager.getInstance().isApplicationLevelOperationAllowed(KSTasks.DROP)) {
            KSRunningTasksManager.getInstance().updateRunningTaskContextWithApplicationTasks(KSTasks.DROP);
            dropOfflineDatabase(successCallback, failureCallback);
        } else {
            var errorMessage = "Drop cannot be performed as other Offline Object operations are in progress.";
            logger.error(LOG_PREFIX, errorMessage);
            kony.sdk.verifyAndCallClosure(failureCallback, new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage));
        }
    };
    SyncEngine.prototype.rollback = async function() {
        if (this.isRollbackOperationAllowed(KSInternalConstants.SYNCLEVEL_APPLICATION)) {
            this.updateRunningTaskContextWithRollbackTasks(KSInternalConstants.SYNCLEVEL_APPLICATION);
            var preparedStatementsForRollback = await KSSyncDatabaseHelper.buildPreparedStatementsForApplicationRollback();
            await KSSyncDatabaseHelper.executePreparedStatementsAsTransaction(preparedStatementsForRollback);
            await KSUploadCacheManager.getInstance().clearAll();
        } else {
            var errorMessage = "Rollback cannot be performed as other Offline Object operations are in progress.";
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage);
        }
    };

    function dropOfflineDatabase(successCallback, failureCallback) {
        function dropSuccess(result) {
            logger.debug(LOG_PREFIX + "Drop successful ");
            dropTaskCompleted();
            kony.sdk.verifyAndCallClosure(successCallback, result);
        }

        function dropFailure(dropException) {
            logger.error(LOG_PREFIX, "Drop failed with error: " + dropException);
            dropTaskCompleted();
            if (!kony.sdk.isNullOrUndefined(dropException) && (dropException.name === "NoSuchDatabaseError")) {
                kony.sdk.verifyAndCallClosure(successCallback, {});
            } else {
                if (!dropException.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                    dropException = new KSError(KSErrorConstants.DROP_DB_FAILED, dropException.stack);
                }
                kony.sdk.verifyAndCallClosure(failureCallback, dropException);
            }
        }
        KSSyncDatabaseHelper.dropDatabase().then(dropSuccess, dropFailure);
    }
    SyncEngine.prototype.reset = function(objServiceList, options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX + "Reset invoked.");

        function localSuccessCallback(response) {
            logger.debug(LOG_PREFIX + "Reset successful ");
            resetTaskCompleted();
            kony.sdk.verifyAndCallClosure(successCallback, response);
        }

        function localFailureCallback(error) {
            logger.error(LOG_PREFIX, "Reset failed with error: " + error);
            resetTaskCompleted();
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }

        function dropSucessCallback() {
            setupOfflineObjectServices(objServiceList, options, localSuccessCallback, localFailureCallback);
        }
        if (KSRunningTasksManager.getInstance().isApplicationLevelOperationAllowed(KSTasks.RESET)) {
            KSRunningTasksManager.getInstance().updateRunningTaskContextWithApplicationTasks(KSTasks.RESET);
            dropOfflineDatabase(dropSucessCallback, localFailureCallback);
        } else {
            var errorMessage = "Reset cannot be performed as other Offline Object operations are in progress.";
            logger.error(LOG_PREFIX, errorMessage);
            kony.sdk.verifyAndCallClosure(failureCallback, new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage));
        }
    };
    SyncEngine.prototype.startSyncSessionForObject = async function(options, object) {
        if (!kony.sdk.isNullOrUndefined(object)) {
            var response = await this.startSyncingTaskForObject(options, object);
            return (response);
        }
    };
    SyncEngine.prototype.startSyncingTaskForObject = async function(options, syncableObject) {
        if (KSRunningTasksManager.getInstance().isSyncOperationAllowed(syncableObject)) {
            KSRunningTasksManager.getInstance().updateRunningTaskContextWithSyncableTasks(syncableObject);
            syncableObject.prepareForSession();
            var syncingTaskInstance = new KSSyncingTask(syncableObject, options);
            try {
                var responseToBeSent = await syncingTaskInstance.execute();
                syncableObject.clearObjectsToPersist();
                KSRunningTasksManager.getInstance().removeSyncableTasksFromRunningTaskContext(syncableObject);
                return responseToBeSent;
            } catch (exception) {
                syncableObject.clearObjectsToPersist();
                KSRunningTasksManager.getInstance().removeSyncableTasksFromRunningTaskContext(syncableObject);
                throw exception;
            }
        } else {
            var errorMessage = "Sync cannot be performed as other Offline Object operations are in progress.";
            logger.error(LOG_PREFIX, syncableObject.getFullyQualifiedName() + " : " + errorMessage);
            throw new KSError(KSErrorConstants.SYNC_IN_PROGRESS, errorMessage);
        }
    };

    function dropTaskCompleted() {
        KSSetupManager.getInstance().reset();
        KSSDKObjectService.clearObjectServiceMap();
        KSRunningTasksManager.getInstance().removeApplicationTaskFromRunningTaskContext(KSTasks.DROP);
        kony.store.removeItem(KSInternalConstants.DB_SCHEMA_VERSION);
    }

    function resetTaskCompleted() {
        KSRunningTasksManager.getInstance().removeApplicationTaskFromRunningTaskContext(KSTasks.RESET);
    }

    function setupTaskCompleted() {
        KSRunningTasksManager.getInstance().removeApplicationTaskFromRunningTaskContext(KSTasks.SETUP);
    }
    SyncEngine.prototype.isRollbackOperationAllowed = function(rollbackLevel, rollbackObject) {
        return KSRunningTasksManager.getInstance().isRollbackOperationAllowed(rollbackLevel, rollbackObject);
    };
    SyncEngine.prototype.updateRunningTaskContextWithRollbackTasks = function(rollbackLevel, rollbackObject) {
        KSRunningTasksManager.getInstance().updateRunningTaskContextWithRollbackTasks(rollbackLevel, rollbackObject);
    };
    SyncEngine.prototype.rollbackTaskCompleted = function(rollbackLevel, rollbackObject) {
        KSRunningTasksManager.getInstance().removeRollbackTasksFromRunningTaskContext(rollbackLevel, rollbackObject);
    };
    /**
     * This method returns false if any blocking task to Application Sync is running
     * If empty, it adds Sync key to runningTaskContext
     *
     * @return boolean returns true if blocking tasks are none
     */
    SyncEngine.prototype.checkAndSetFlagForApplicationSync = function() {
        var isApplicationSyncAllowed = false;
        if (KSRunningTasksManager.getInstance().isApplicationLevelOperationAllowed(KSTasks.SYNC)) {
            isApplicationSyncAllowed = true;
            KSRunningTasksManager.getInstance().updateRunningTaskContextWithApplicationTasks(KSTasks.SYNC);
            logger.debug(LOG_PREFIX, "runningTaskKeyForApplicationSync is successfully put in runningTaskContext");
        } else {
            var errorMessage = "Could not start Application Sync, as another Offline objects operation is already in progress";
            logger.warn(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.APPLICATIONTASKS_IN_PROGRESS, errorMessage);
        }
        return isApplicationSyncAllowed;
    };
    /**
     * Removes Sync key from runningTaskContext
     */
    SyncEngine.prototype.applicationSyncCompleted = function() {
        logger.debug(LOG_PREFIX, "runningTaskKeyForApplicationSync removed from runningTaskContext");
        KSRunningTasksManager.getInstance().removeApplicationTaskFromRunningTaskContext(KSTasks.SYNC);
    };
    exports.getInstance = SyncEngine.getInstance;
});
define("SDKObjectServiceSync", ["exports", "KSSDKObjectService", "KSError", "SyncEngine", "KSCommonUtils"], function(exports, KSSDKObjectService, _KSError, SyncEngine, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var LOG_PREFIX = "SDKObjectServiceSync:";
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var syncEngineInstance = SyncEngine.getInstance();
    var syncObjectService;
    var SDKObjectServiceSync = function(name) {
        this.syncObjectService = KSSDKObjectService.getInstanceByName(name);
    };
    SDKObjectServiceSync.prototype.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
        logger.trace(LOG_PREFIX, "startSync is called in SDKObjectServiceSync.");
        var objSvcName = this.syncObjectService.getFullyQualifiedName();
        this.syncObjectService.startSync(syncConfig).then(onSuccess, onFailure);

        function onSuccess(result) {
            var message = "Sync successful on object service.";
            result[KSPublicConstants.STATUS] = KSErrorConstants.STATUS_SUCCESS;
            result[KSInternalConstants.OBJECT_SERVICE_NAME] = objSvcName;
            logger.info(LOG_PREFIX, message);
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Callbacks are not provided. " + message);
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Sync on object service failed with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.SYNC_GENERIC_ERROR, error.stack);
            }
            error[KSPublicConstants.STATUS] = KSErrorConstants.STATUS_FAILURE;
            error.userInfo = KSCommonUtils.getUserInfo(objSvcName, error);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Callbacks are not provided. Sync failed on object with error " + error.message);
            }
        }
    };
    SDKObjectServiceSync.prototype.cancelSync = function(options, successCallback, failureCallback) {};
    /**
     * Rollback an ObjectService to it's previous Sync State
     *
     * @param successCallback will be invoked on the Success of rollback.
     * @param failureCallback will be invoked at the time of any error.
     */
    SDKObjectServiceSync.prototype.rollback = function(successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects rollback called.");
        this.syncObjectService.rollback().then(onSuccess, onFailure);
        var self = this;

        function onSuccess() {
            kony.sdk.logsdk.info(LOG_PREFIX + "Offline objects rollback is success full.");
            syncEngineInstance.rollbackTaskCompleted(KSInternalConstants.SYNCLEVEL_OBJECTSERVICE, self.syncObjectService);
            kony.sdk.verifyAndCallClosure(successCallback, true);
        }

        function onFailure(error) {
            kony.sdk.logsdk.error(LOG_PREFIX + "Offline objects rollback has failed.");
            syncEngineInstance.rollbackTaskCompleted(KSInternalConstants.SYNCLEVEL_OBJECTSERVICE, self.syncObjectService);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.SYNC_GENERIC_ROLLBACK_ERROR, error.stack);
            }
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    };
    SDKObjectServiceSync.prototype.clearData = function(options, successCallback, failureCallback) {};
    exports.SDKObjectServiceSync = SDKObjectServiceSync;
});
define("SDKObjectSync", ["exports", "KSSDKObject", "KSSDKObjectRecord", "KSCommonUtils", "KSError", "SyncEngine"], function(exports, _KSSDKObject, KSSDKObjectRecord, KSCommonUtils, _KSError, SyncEngine) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "SDKObjectSync : ";
    var KSError = _KSError.KSError;
    var KSCRUDConstants = kony.sdk.OfflineObjects.KSCRUDConstants;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var SDKObjectRecord = KSSDKObjectRecord.KSSDKObjectRecord;
    var syncEngineInstance = SyncEngine.getInstance();
    var SDKObjectSync = function(sdkObjectName) {
        //validating the sdkObjectName i.e passed is not null or empty
        if (KSCommonUtils.isNullOrEmptyObject(sdkObjectName)) {
            var errorMessage = "Cannot create Offline Object with name as null or empty string";
            logger.error(LOG_PREFIX + errorMessage);
            throw new KSError(KSErrorConstants.METADATA_SDKOBJECT_SYNC_NAME_NULL_OR_EMPTY, errorMessage);
        }
        this.syncObject = new _KSSDKObject.KSSDKObject(sdkObjectName);
        logger.trace(LOG_PREFIX, "Initialized an instance of SDKObjectSync.");
    };
    SDKObjectSync.prototype.startSync = function(syncConfig, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked startSync in SDKObjectSync.");
        var objName = this.syncObject.getFullyQualifiedName();
        this.syncObject.startSync(syncConfig).then(onSuccess, onFailure);

        function onSuccess(result) {
            var message = "The object sync is successful.";
            result[KSPublicConstants.STATUS] = KSErrorConstants.STATUS_SUCCESS;
            logger.info(LOG_PREFIX, message);
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Callbacks are not provided. " + message);
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to sync object with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.SYNC_GENERIC_ERROR, error.stack);
            }
            error[KSPublicConstants.STATUS] = KSErrorConstants.STATUS_FAILURE;
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Callbacks are not provided. Failed to sync object with error " + error.message);
            }
        }
    };
    SDKObjectSync.prototype.create = function(record, options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked create record operation.");
        var sdkRecord = new SDKObjectRecord(record, this.syncObject);
        var objName = this.syncObject.getFullyQualifiedName();
        this.syncObject.createRecordsInDatabase(sdkRecord, options).then(onSuccess, onFailure);

        function onSuccess(result) {
            logger.info(LOG_PREFIX, "The record is created successfully with result: " + JSON.stringify(result));
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Success callback for create API is not provided.");
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to create record with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, error.stack);
            }
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Failure callback for create API is not provided.");
            }
        }
    };
    SDKObjectSync.prototype.update = function(record, options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked update record operation.");
        var sdkRecord = new SDKObjectRecord(record, this.syncObject);
        var objName = this.syncObject.getFullyQualifiedName();
        var optionsForUpdate = {};
        if (!kony.sdk.isNullOrUndefined(options)) {
            optionsForUpdate = kony.sdk.cloneObject(options);
        }
        optionsForUpdate[KSCRUDConstants.CRUD_OPTION_IS_UPDATE_BY_PK] = false;
        this.syncObject.updateRecordsInDatabase(sdkRecord, optionsForUpdate).then(onSuccess, onFailure);

        function onSuccess(result) {
            logger.debug(LOG_PREFIX, "The record was updated successfully with result: " + JSON.stringify(result));
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Success callback for update API is not provided.");
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to update record with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, error.stack);
            }
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Failure callback for update API is not provided.");
            }
        }
    };
    SDKObjectSync.prototype.updateByPK = function(record, options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked update record operation.");
        var sdkRecord = new SDKObjectRecord(record, this.syncObject);
        var objName = this.syncObject.getFullyQualifiedName();
        var optionsForUpdate = kony.sdk.cloneObject(options);
        if (kony.sdk.isNullOrUndefined(optionsForUpdate)) {
            optionsForUpdate = {};
        }
        optionsForUpdate[KSCRUDConstants.CRUD_OPTION_IS_UPDATE_BY_PK] = true;
        this.syncObject.updateRecordsInDatabase(sdkRecord, optionsForUpdate).then(onSuccess, onFailure);

        function onSuccess(result) {
            logger.debug(LOG_PREFIX, "The record was updated successfully with result: " + JSON.stringify(result));
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Success callback for updateByPK API is not provided.");
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to update record with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, error.stack);
            }
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Failure callback for updateByPK API is not provided.");
            }
        }
    };
    SDKObjectSync.prototype.delete = function(options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked delete record operation.");
        var objName = this.syncObject.getFullyQualifiedName();
        var optionsForDelete = kony.sdk.cloneObject(options);
        if (kony.sdk.isNullOrUndefined(optionsForDelete)) {
            optionsForDelete = {};
        }
        optionsForDelete[KSCRUDConstants.CRUD_OPTION_IS_DELETE_BY_PK] = false;
        this.syncObject.deleteRecordsInDatabase(optionsForDelete).then(onSuccess, onFailure);

        function onSuccess(result) {
            logger.info(LOG_PREFIX, "The record is deleted successfully with result: " + JSON.stringify(result));
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Success callback for delete API is not provided.");
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to delete record with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, error.stack);
            }
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Failure callback for delete API is not provided.");
            }
        }
    };
    SDKObjectSync.prototype.deleteByPK = function(options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked delete record operation.");
        var objName = this.syncObject.getFullyQualifiedName();
        var optionsForDelete = kony.sdk.cloneObject(options);
        if (kony.sdk.isNullOrUndefined(optionsForDelete)) {
            optionsForDelete = {};
        }
        optionsForDelete[KSCRUDConstants.CRUD_OPTION_IS_DELETE_BY_PK] = true;
        this.syncObject.deleteRecordsInDatabase(optionsForDelete).then(onSuccess, onFailure);

        function onSuccess(result) {
            logger.info(LOG_PREFIX, "The record is deleted successfully with result: " + JSON.stringify(result));
            if (successCallback) {
                successCallback(result);
            } else {
                logger.info(LOG_PREFIX, "Success callback for delete API is not provided.");
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to delete record with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, error.stack);
            }
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Failure callback for delete API is not provided.");
            }
        }
    };
    SDKObjectSync.prototype.get = function(options, successCallback, failureCallback) {
        logger.trace(LOG_PREFIX, "Invoked get record operation.");
        var objName = this.syncObject.getFullyQualifiedName();
        this.syncObject.readRecordsFromDatabase(options).then(onSuccess, onFailure);

        function onSuccess(recordsList) {
            logger.info(LOG_PREFIX, "The number of successfully fetched records are " + recordsList.length);
            if (successCallback) {
                successCallback(recordsList);
            } else {
                logger.info(LOG_PREFIX, "Success callback for get API is not provided.");
            }
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to read record with error " + error.message);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.CRUD_GENERIC_ERROR, error.stack);
            }
            error.userInfo = KSCommonUtils.getUserInfo(objName, error, true);
            if (failureCallback) {
                failureCallback(error);
            } else {
                logger.info(LOG_PREFIX, "Failure callback for get API is not provided.");
            }
        }
    };
    /**
     * Rollback an Object to it's previous Sync State
     *
     * @param primaryKeyValueMap of record only for which rollback should happen
     * @param successCallback will be invoked on the Success of rollback.
     * @param failureCallback will be invoked at the time of any error.
     */
    SDKObjectSync.prototype.rollback = function(primaryKeyValueMap, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects rollback called.");
        this.syncObject.rollback(primaryKeyValueMap).then(onSuccess, onFailure);
        var self = this;

        function onSuccess() {
            kony.sdk.logsdk.info(LOG_PREFIX + "Offline objects rollback is successfull.");
            syncEngineInstance.rollbackTaskCompleted(KSInternalConstants.SYNCLEVEL_OBJECT, self.syncObject);
            kony.sdk.verifyAndCallClosure(successCallback, true);
        }

        function onFailure(error) {
            kony.sdk.logsdk.error(LOG_PREFIX + "Offline objects rollback has failed.");
            syncEngineInstance.rollbackTaskCompleted(KSInternalConstants.SYNCLEVEL_OBJECT, self.syncObject);
            if (!error.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
                error = new KSError(KSErrorConstants.SYNC_GENERIC_ROLLBACK_ERROR, error.stack);
            }
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    };
    /**
     * Fetches the list of records yet to be uploaded in the object
     *
     * @param options - user defined options reserved for future use
     * @param successCallback will be invoked on the success of getPendingRecordsForUpload
     * @param failureCallback will be invoked on the failure of getPendingRecordsForUpload
     */
    SDKObjectSync.prototype.getPendingRecordsForUpload = function(options, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX, " getPendingRecordsForUpload : ", "Enter.");
        this.syncObject.getPendingRecordsForUpload(options).then(onResolve, onReject);

        function onResolve(recordsList) {
            kony.sdk.logsdk.info(LOG_PREFIX, "Offline objects getPendingRecordsForUpload is successful.");
            kony.sdk.logsdk.info(LOG_PREFIX, "The number of pending records are " + recordsList.length);
            var records = {};
            records[KSPublicConstants.SYNC_PENDING_RECORDS] = recordsList;
            kony.sdk.verifyAndCallClosure(successCallback, records);
        }

        function onReject(error) {
            kony.sdk.logsdk.error(LOG_PREFIX, "Failed to get pending records with error " + error.message);
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    };
    /* Mark for upload method provides ability to mark a record for upload from local Database
     *
     * @param options  Primary key of record, markForUpload
     * @param successCallback  will be invoked on the Success of markForUpload.
     * @param failureCallback will be invoked at the time of any error.
     */
    SDKObjectSync.prototype.markForUpload = function(options, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects markForUpload called.");
        this.syncObject.markForUploadInDatabase(options).then(onSuccess, onFailure);

        function onSuccess(result) {
            logger.info(LOG_PREFIX, "Record marked for upload successfully :" + result);
            kony.sdk.verifyAndCallClosure(successCallback, true);
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Record markForUpload failed with error " + error.message);
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    };
    /**
     * Get primary keys deferred from upload
     *
     * @param successCallback will be invoked on the Success of getUploadDeferredRecordKeys.
     * @param failureCallback will be invoked at the time of any error.
     */
    SDKObjectSync.prototype.getUploadDeferredRecordKeys = function(successCallback, failureCallback) {
        kony.sdk.logsdk.trace(LOG_PREFIX + "Offline objects getUploadDeferredRecordKeys called.");
        this.syncObject.getDeferredRecordsFromDatabase().then(onSuccess, onFailure);

        function onSuccess(primaryKeysList) {
            logger.info(LOG_PREFIX, "The number of successfully fetched upload deferred primary keys are " + primaryKeysList.length);
            kony.sdk.verifyAndCallClosure(successCallback, primaryKeysList);
        }

        function onFailure(error) {
            logger.error(LOG_PREFIX, "Failed to fetch primary keys with error " + error.message);
            kony.sdk.verifyAndCallClosure(failureCallback, error);
        }
    };
    exports.SDKObjectSync = SDKObjectSync;
});
/**
 * Module to perform the download operation in Offline Objects.
 */
define("KSBatchDownloadTask", ["exports", "KSError", "KSCommonUtils"], function(exports, _KSError, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSBatchDownloadTask : ";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     *  Creates a KSBatchDownloadTask
     * @param downloadTaskInstance KSSyncDownloadTask Object passed
     * @param isStatsEnabled boolean value to determine if stats are enabled
     * @param syncObject contains syncObject
     * @constructor
     */
    function KSBatchDownloadTask(downloadTaskInstance, isStatsEnabled, syncObject) {
        logger.trace(LOG_PREFIX + "Creating KSBatchDownloadTask.");
        this.downloadTaskInstance = downloadTaskInstance;
        this.syncObject = syncObject;
        this.response = {};
        this.response[KSPublicConstants.SYNC_ERRORS] = {};
        this.isStatsEnabled = isStatsEnabled;
        if (this.isStatsEnabled === true) {
            logger.debug(LOG_PREFIX + "stats are enabled");
            this.totalDownloadedRecords = 0;
            this.response[KSPublicConstants.SYNC_STATS] = {};
            this.response[KSPublicConstants.SYNC_STATS][KSPublicConstants.DOWNLOAD_STATS] = [];
            this.response[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_DOWNLOADED_RECORDS] = 0;
        }
    }
    /**
     *  Executes the KSBatchDownloadTask
     * @returns {Promise<Array> an array containing stats}
     */
    KSBatchDownloadTask.prototype.execute = async function() {
        logger.debug(LOG_PREFIX + "Starting batch download task for batch number " + this.downloadTaskInstance.downloadBatchNumber);
        var downloadResponseReceived;
        do {
            downloadResponseReceived = {};
            downloadResponseReceived = await this.downloadTaskInstance.execute();
            KSCommonUtils.mergeTwoJSONMaps(this.downloadTaskInstance.inputContext, this.downloadTaskInstance.outputContext);
            var downloadSyncErrors = downloadResponseReceived[KSInternalConstants.DOWNLOAD_SYNC_ERRORS];
            if (!KSCommonUtils.isNullOrEmptyObject(downloadSyncErrors)) {
                this.response[KSPublicConstants.SYNC_ERRORS][KSPublicConstants.DOWNLOAD_TAG] = downloadSyncErrors;
            }
            delete downloadResponseReceived[KSInternalConstants.DOWNLOAD_SYNC_ERRORS];
            if (this.isStatsEnabled) {
                logger.debug(LOG_PREFIX + "stats are enabled");
                var downloadBatchStats = {};
                downloadBatchStats.totalDownloadedRecords = 0;
                var downloadResponseMetaData = downloadResponseReceived[KSInternalConstants.DOWNLOAD_RESPONSE_METADATA];
                if (!KSCommonUtils.isNullOrEmptyObject(downloadResponseMetaData)) {
                    if (this.syncObject.getSyncLevel() === KSInternalConstants.SYNCLEVEL_OBJECT) {
                        this.totalDownloadedRecords += downloadResponseMetaData[KSInternalConstants.RECORD_COUNT];
                        downloadBatchStats.totalDownloadedRecords = downloadResponseMetaData[KSInternalConstants.RECORD_COUNT];
                        downloadBatchStats.batchNumber = this.downloadTaskInstance.downloadBatchNumber;
                    } else {
                        for (var key in downloadResponseMetaData) {
                            if (downloadResponseMetaData[key].hasOwnProperty(KSInternalConstants.METADATA)) {
                                this.totalDownloadedRecords += downloadResponseMetaData[key][KSInternalConstants.METADATA][KSInternalConstants.RECORD_COUNT];
                                downloadBatchStats.totalDownloadedRecords += downloadResponseMetaData[key][KSInternalConstants.METADATA][KSInternalConstants.RECORD_COUNT];
                                downloadBatchStats.batchNumber = this.downloadTaskInstance.downloadBatchNumber;
                            }
                        }
                    }
                } else {
                    var errorMessage = "downloadResponseMetaData found to be null from server response";
                    logger.warn(LOG_PREFIX + errorMessage);
                }
                this.response[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_DOWNLOADED_RECORDS] = this.totalDownloadedRecords;
                this.response[KSPublicConstants.SYNC_STATS][KSPublicConstants.DOWNLOAD_STATS].push(downloadBatchStats);
            }
            this.downloadTaskInstance.downloadBatchNumber++;
        } while (downloadResponseReceived[KSInternalConstants.HAS_MORE_RECORDS] === KSInternalConstants.TRUE_STRING);
        return this.response;
    };
    exports.KSBatchDownloadTask = KSBatchDownloadTask;
});
/**
 * Module to perform the download operation in Offline Objects.
 */
define("KSSyncDownloadTask", ["exports", "KSNetworkUtils", "KSCommonUtils"], function(exports, KSNetworkUtils, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "KSSyncDownloadTask : ";
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    /**
     *  Creates a KSSyncDownloadTask
     * @param syncableObject syncable Object passed
     * @param options options config
     * @constructor
     */
    function KSSyncDownloadTask(syncableObject, options) {
        logger.trace(LOG_PREFIX + "Creating KSSyncDownloadTask.");
        this.inputContext = options;
        this.outputContext = {};
        this.syncableObject = syncableObject;
        this.downloadBatchNumber = KSInternalConstants.DEFAULT_BATCH_NUMBER;
    }
    /**
     *  Executes the KSSyncDownloadTask
     * @returns {Promise<void>}
     */
    KSSyncDownloadTask.prototype.execute = async function() {
        logger.trace(LOG_PREFIX + "Starting download task.");
        var request = await this.syncableObject.createDownloadRequest(this.inputContext);
        //Make a network request..
        var networkResponse = await KSNetworkUtils.post(request[KSInternalConstants.URL], request[KSInternalConstants.QUERY_PARAMS], request[KSInternalConstants.HEADERS], request[KSInternalConstants.BODY], {});
        //Contains DATA_OBJECTS, METADATA_OBJECT, DOWNLOAD_BATCH_ERRORS
        var downloadResponseMetadata = await this.syncableObject.parseDownloadResponse(networkResponse);
        var responseToBeSent = {};
        responseToBeSent[KSInternalConstants.DOWNLOAD_RESPONSE_METADATA] = downloadResponseMetadata[KSInternalConstants.METADATA_OBJECT][KSInternalConstants.METADATA];
        responseToBeSent[KSInternalConstants.DOWNLOAD_SYNC_ERRORS] = downloadResponseMetadata[KSInternalConstants.DOWNLOAD_SYNC_ERRORS];
        var deltaContextInformation;
        if (networkResponse[KSInternalConstants.HAS_MORE_RECORDS] !== KSInternalConstants.TRUE_STRING) {
            deltaContextInformation = downloadResponseMetadata[KSInternalConstants.METADATA_OBJECT][KSInternalConstants.DELTA_CONTEXT];
        } else {
            this.outputContext[KSInternalConstants.BATCH_CONTEXT] = downloadResponseMetadata[KSInternalConstants.METADATA_OBJECT][KSInternalConstants.DELTA_CONTEXT];
        }
        await this.syncableObject.persistDownloadChanges(deltaContextInformation);
        responseToBeSent[KSInternalConstants.HAS_MORE_RECORDS] = networkResponse[KSInternalConstants.HAS_MORE_RECORDS];
        logger.info(LOG_PREFIX + "Successfully completed the batch " + this.downloadBatchNumber + "download task with the following status : " + JSON.stringify(responseToBeSent));
        return responseToBeSent;
    };
    exports.KSSyncDownloadTask = KSSyncDownloadTask;
});
/**
 * Module to perform the upload operation in Offline Objects.
 */
define("KSSyncUploadTask", ["exports", "KSNetworkUtils", "KSSetupManager", "KSCommonUtils", "KSUploadCacheManager", "KSUploadCacheObject"], function(exports, KSNetworkUtils, KSSetupManager, KSCommonUtils, KSUploadCacheManager, _KSUploadCacheObject) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var isUploadCacheEnabled = false;
    var LOG_PREFIX = "KSSyncUploadTask : ";
    var KSUploadCacheObject = _KSUploadCacheObject.KSUploadCacheObject;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Creates a KSSyncUploadTask
     * @param syncableObject syncable Object passed
     * @param options options config
     * @constructor
     */
    function KSSyncUploadTask(syncableObject, options) {
        logger.trace(LOG_PREFIX + "Creating KSSyncUploadTask");
        this.options = options;
        this.syncableObject = syncableObject;
    }
    /**
     *  Executes the KSSyncUploadTask
     * @returns {Promise<void>}
     */
    KSSyncUploadTask.prototype.execute = async function() {
        logger.trace(LOG_PREFIX + "Starting upload task.");
        var request = await this.syncableObject.createUploadRequest(this.options);
        var responseToBeSent = {};
        //Make a network request..
        if (request[KSInternalConstants.ARE_THERE_CHANGES_TO_UPLOAD]) {
            responseToBeSent = await uploadDataForObject(this.syncableObject, request[KSInternalConstants.REQUEST_HEADERS], request[KSInternalConstants.REQUEST_BODY], request[KSInternalConstants.QUERY_PARAMS], request[KSInternalConstants.URL]);
        }
        return responseToBeSent;
    };
    async function uploadDataForObject(syncObject, headers, body, queryParams, url) {
        var uploadResponse = null;
        var syncableObjectName = syncObject.getFullyQualifiedName();
        //Persist upload request in UploadCache
        await checkAndPersistUploadRequest(syncObject, headers, queryParams, body);
        //post network request
        try {
            uploadResponse = await KSNetworkUtils.post(url, queryParams, headers, body, {});
        } catch (networkException) {
            logger.error(LOG_PREFIX, "Upload failed for object/objectService: " + syncableObjectName + " due to exception: " + networkException.message);
            // Remove the current request from upload cache if the current upload fails
            // with a complete (sync) failure error code.
            if (isUploadCacheEnabled) {
                // clear the cache if there is a network exception other than timeouts
                if (!(networkException.code === KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR.code || networkException.code === KSErrorConstants.NW_SOCKET_TIMEOUT.code)) {
                    await KSUploadCacheManager.getInstance().removeRecord(syncableObjectName);
                }
            }
            throw networkException;
        }
        var uploadMetadata = uploadResponse[KSInternalConstants._METADATA];
        var uploadResponse = await syncObject.parseUploadResponse(uploadResponse);
        await syncObject.persistUploadChanges(uploadResponse[KSInternalConstants.DATA_OBJECTS]);
        //Remove upload request from UploadCache
        await KSUploadCacheManager.getInstance().removeRecord(syncableObjectName);
        delete uploadResponse[KSInternalConstants.DATA_OBJECTS];
        logger.info(LOG_PREFIX, "Successfully completed the upload task for object/objectService: " + syncableObjectName);
        var responseToBeSent = uploadResponse;
        responseToBeSent[KSInternalConstants.UPLOAD_RESPONSE_METADATA] = uploadMetadata;
        return responseToBeSent;
    }
    async function checkAndPersistUploadRequest(syncObject, headers, queryParams, body) {
        isUploadCacheEnabled = KSSetupManager.getInstance().isUploadCacheEnabledForObject(syncObject);
        if (isUploadCacheEnabled) {
            var requestId = KSCommonUtils.generateUniqueUUIDString();
            headers[KSInternalConstants.X_KONY_REQUEST_CACHE_ID] = requestId;
            var requestContextJson = {
                [KSInternalConstants.REQUEST_HEADERS]: headers,
                [KSInternalConstants.REQUEST_QUERY_PARAMS]: queryParams
            };
            var uploadCacheSyncObjectContext = syncObject;
            var uploadCacheObject = new KSUploadCacheObject(uploadCacheSyncObjectContext, body, requestId, requestContextJson);
            await KSUploadCacheManager.getInstance().persist(uploadCacheObject);
        }
    }
    exports.KSSyncUploadTask = KSSyncUploadTask;
});
/**
 * Module encapsulating the upload and the download tasks.
 */
define("KSSyncingTask", ["exports", "KSSyncDownloadTask", "KSCommonUtils", "KSSyncUploadTask", "KSBatchDownloadTask", "KSSetupManager", "KSUploadCacheProcessingTask"], function(exports, _KSSyncDownloadTask, KSCommonUtils, _KSSyncUploadTask, _KSBatchDownloadTask, KSSetupManager, _KSUploadCacheProcessingTask) {
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "KSSyncingTask : ";
    var KSSyncUploadTask = _KSSyncUploadTask.KSSyncUploadTask;
    var KSSyncDownloadTask = _KSSyncDownloadTask.KSSyncDownloadTask;
    var KSBatchDownloadTask = _KSBatchDownloadTask.KSBatchDownloadTask;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSUploadCacheProcessingTask = _KSUploadCacheProcessingTask.KSUploadCacheProcessingTask;
    /**
     * Constructor for KSSyncingTask.
     * @param object Synable object.
     * @param options Options for sync.
     * @constructor Returns a KSSyncingTask.
     */
    function KSSyncingTask(object, options) {
        logger.trace(LOG_PREFIX + "Creating Syncing Task for " + object.name);
        this.syncObject = object;
        this.isStatsEnabled = false;
        this.isUploadEnabled = true;
        this.isDownloadEnabled = true;
        this.isUploadCacheEnabled = false;
        this.inputContext = {};
        this.cacheProcessingTask = null;
        this.options = options;
        if (!KSCommonUtils.isNullOrEmptyObject(options)) {
            this.inputContext[KSInternalConstants.SYNC_OPTIONS] = options;
        }
        this.populateTaskStructureFlags(options);
        this.setupSubTasks();
    }
    /**
     * Method to populate task structure flags depending in the options sent by user.
     * @param options Options sent for sync.
     */
    KSSyncingTask.prototype.populateTaskStructureFlags = function(options) {
        if (options.hasOwnProperty(KSPublicConstants.SYNC_TYPE)) {
            var syncType = options[KSPublicConstants.SYNC_TYPE];
            if (syncType === KSPublicConstants.DOWNLOAD_ONLY) {
                this.isUploadEnabled = false;
            } else if (syncType === KSPublicConstants.UPLOAD_ONLY) {
                this.isDownloadEnabled = false;
            }
        }
        if (options.hasOwnProperty(KSPublicConstants.GET_SYNC_STATS)) {
            this.isStatsEnabled = true;
        }
        this.isUploadCacheEnabled = KSSetupManager.getInstance().isUploadCacheEnabledForObject(this.syncObject);
    };
    /**
     * Method for setting up subtasks within syncing task.
     */
    KSSyncingTask.prototype.setupSubTasks = function() {
        if (this.isUploadCacheEnabled) {
            this.cacheProcessingTask = new KSUploadCacheProcessingTask(this.syncObject);
        }
        if (this.isUploadEnabled) {
            this.syncUploadTaskInstance = new KSSyncUploadTask(this.syncObject, this.options);
        }
        if (this.isDownloadEnabled) {
            var downloadTaskInstance = new KSSyncDownloadTask(this.syncObject, this.inputContext);
            this.syncDownloadTaskInstance = new KSBatchDownloadTask(downloadTaskInstance, this.isStatsEnabled, this.syncObject);
        }
    };
    /**
     * Method to start execution of the syncing task.
     */
    KSSyncingTask.prototype.execute = async function() {
        var responseToBeSent = {};
        var totalUploadedRecords = 0;
        var totalDownloadedRecords = 0;
        if (this.isStatsEnabled) {
            responseToBeSent[KSPublicConstants.SYNC_STATS] = {};
            responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_UPLOADED_RECORDS] = 0;
            responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_DOWNLOADED_RECORDS] = 0;
        }
        responseToBeSent[KSPublicConstants.SYNC_ERRORS] = {};
        if (this.isUploadCacheEnabled) {
            logger.trace(LOG_PREFIX, "Starting UploadCacheProcessingTask.");
            var uploadResponseReceived = await this.cacheProcessingTask.execute();
            if (!KSCommonUtils.isNullOrEmptyObject(uploadResponseReceived)) {
                var uploadSyncErrors = uploadResponseReceived[KSInternalConstants.UPLOAD_SYNC_ERRORS];
                if (!KSCommonUtils.isNullOrEmptyObject(uploadSyncErrors)) {
                    responseToBeSent[KSPublicConstants.SYNC_ERRORS][KSPublicConstants.UPLOAD_TAG] = uploadSyncErrors;
                }
                delete uploadResponseReceived[KSInternalConstants.UPLOAD_SYNC_ERRORS];
            }
        }
        if (this.isUploadEnabled) {
            logger.debug(LOG_PREFIX + "Starting Upload task.");
            var uploadResponseReceived = await this.syncUploadTaskInstance.execute();
            if (!KSCommonUtils.isNullOrEmptyObject(uploadResponseReceived)) {
                var uploadSyncErrors = uploadResponseReceived[KSInternalConstants.UPLOAD_SYNC_ERRORS];
                if (!KSCommonUtils.isNullOrEmptyObject(uploadSyncErrors)) {
                    var existingSyncErrorsFromCachedUploadRequests = responseToBeSent[KSPublicConstants.SYNC_ERRORS][KSPublicConstants.UPLOAD_TAG];
                    if (KSCommonUtils.isNullOrEmptyObject(existingSyncErrorsFromCachedUploadRequests)) {
                        responseToBeSent[KSPublicConstants.SYNC_ERRORS][KSPublicConstants.UPLOAD_TAG] = uploadSyncErrors;
                    } else {
                        responseToBeSent[KSPublicConstants.SYNC_ERRORS][KSPublicConstants.UPLOAD_TAG] = existingSyncErrorsFromCachedUploadRequests.concat(uploadSyncErrors);
                    }
                }
                delete uploadResponseReceived[KSInternalConstants.UPLOAD_SYNC_ERRORS];
                if (this.isStatsEnabled) {
                    var uploadResponseMetadata = uploadResponseReceived[KSInternalConstants.UPLOAD_RESPONSE_METADATA];
                    if (!KSCommonUtils.isNullOrEmptyObject(uploadResponseMetadata)) {
                        totalUploadedRecords = uploadResponseMetadata[KSInternalConstants.SUCCESS_COUNT];
                    }
                    responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_UPLOADED_RECORDS] = totalUploadedRecords;
                    responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_DOWNLOADED_RECORDS] = totalDownloadedRecords;
                }
            }
        }
        if (this.isDownloadEnabled) {
            logger.debug(LOG_PREFIX + "Starting Download task.");
            var downloadResponse = await this.syncDownloadTaskInstance.execute();
            if (this.isStatsEnabled) {
                KSCommonUtils.mergeTwoJSONMaps(responseToBeSent[KSPublicConstants.SYNC_STATS], downloadResponse[KSPublicConstants.SYNC_STATS]);
            }
            KSCommonUtils.mergeTwoJSONMaps(responseToBeSent[KSPublicConstants.SYNC_ERRORS], downloadResponse[KSPublicConstants.SYNC_ERRORS]);
        }
        if (this.isStatsEnabled) {
            responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.NUMBER_OF_RECORDS_SYNCED] = (totalUploadedRecords + responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.TOTAL_DOWNLOADED_RECORDS]);
            responseToBeSent[KSPublicConstants.SYNC_STATS][KSInternalConstants.SYNC_OBJECT_NAME] = this.syncObject.getFullyQualifiedName();
            if (this.syncObject.getSyncLevel() === KSInternalConstants.SYNCLEVEL_OBJECT) {
                responseToBeSent[KSInternalConstants.NAME] = this.syncObject.getFullyQualifiedName();
            } else {
                responseToBeSent[KSInternalConstants.OBJECT_SERVICE_NAME] = this.syncObject.getFullyQualifiedName();
            }
        }
        if (kony.sdk.isEmptyObject(responseToBeSent[KSPublicConstants.SYNC_ERRORS])) {
            delete responseToBeSent[KSPublicConstants.SYNC_ERRORS];
        }
        if (kony.sdk.isEmptyObject(responseToBeSent[KSPublicConstants.SYNC_STATS])) {
            delete responseToBeSent[KSPublicConstants.SYNC_STATS];
        }
        logger.info(LOG_PREFIX + "Successfully executed Syncing Task on Syncable object named : " + this.syncObject.name);
        /**
         * JSON format received at interface level for sync call.
         *  {
         *    "syncStats" : {
         *                       "uploadStats" : { upload stats},
         *                       "downloadStats" : { download stats}
         *                    },
         *    "syncErrors" : {
         *                      "upload" : [],
         *                      "download" : []
         *                    }
         *   }
         */
        return responseToBeSent;
    };
    exports.KSSyncingTask = KSSyncingTask;
});
/**
 * KSUploadCacheProcessingTask
 * Created by Harshini Bonam on 18/04/19.
 * Copyright  2019 Kony. All rights reserved.
 */
define("KSUploadCacheProcessingTask", ["exports", "KSUploadCacheSQLQueryGenerator", "KSDatabaseAPI", "KSUploadCacheManager", "KSCommonUtils", "KSSDKObjectService", "KSSDKObject"], function(exports, KSUploadCacheSQLQueryGenerator, _KSDatabaseAPI, KSUploadCacheManager, KSCommonUtils, KSSDKObjectService, _KSSDKObject) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "KSUploadCacheProcessingTask : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Constructor for KSUploadCacheProcessingTask.
     * @param sdkobject Syncable sdkobject.
     * @constructor Returns a KSUploadCacheProcessingTask.
     */
    function KSUploadCacheProcessingTask(sdkobject) {
        logger.trace(LOG_PREFIX + "Creating Upload Cache Processing Task for " + sdkobject.name);
        this.syncableObjectsToRetry = [];
        this.inputContext = {};
        this.outputContext = {};
        this.inputContext[KSInternalConstants.SYNC_OBJECT] = sdkobject;
    }

    function unpackInputs() {
        this.syncObject = this.inputContext[KSInternalConstants.SYNC_OBJECT];
    }

    function populateOutputContext(syncErrors) {
        if (!kony.sdk.isNullOrUndefined(syncErrors)) {
            var syncErrorsInOutputContext = this.outputContext[KSInternalConstants.CACHE_UPLOAD_ERRORS];
            if (!kony.sdk.isNullOrUndefined(syncErrorsInOutputContext)) {
                this.outputContext[KSInternalConstants.CACHE_UPLOAD_ERRORS] = syncErrorsInOutputContext.concat(syncErrors);
            } else {
                this.outputContext[KSInternalConstants.CACHE_UPLOAD_ERRORS] = syncErrors;
            }
        }
    }
    async function getSyncObjectForRelatedCacheEntries(syncObject) {
        var syncableObjects = [];
        var objectNames = syncObject.getObjectNames();
        var preparedStatementToGetRelatedCacheEntries = KSUploadCacheSQLQueryGenerator.getQueryForGettingUploadCacheEntriesInOrder(objectNames);
        var objectNamesWithTypeInCache = await KSDatabaseAPI.executeQuery(preparedStatementToGetRelatedCacheEntries);
        var objectsCount = objectNamesWithTypeInCache.length;
        for (var recordIndex = 0; recordIndex < objectsCount; recordIndex++) {
            var record = objectNamesWithTypeInCache[recordIndex];
            var objectName = record[KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME];
            var objectType = record[KSDatabaseConstants.UPLOAD_CACHE_OBJECT_TYPE];
            if (objectType === KSInternalConstants.SYNCLEVEL_OBJECT) {
                syncableObjects.push(new _KSSDKObject.KSSDKObject(objectName));
            }
        }
        return syncableObjects;
    }
    async function retryCacheInOrder(indexToBeProcessed) {
        if (indexToBeProcessed < this.syncableObjectsToRetry.length) {
            var syncableObject = this.syncableObjectsToRetry[indexToBeProcessed];
            try {
                var result = await KSUploadCacheManager.getInstance().retryCachedRequests(syncableObject);
                var syncErrors = result[KSInternalConstants.CACHE_UPLOAD_ERRORS];
                populateOutputContext.call(this, syncErrors);
                await retryCacheInOrder.call(this, indexToBeProcessed + 1);
            } catch (retryException) {
                logger.error(LOG_PREFIX, "Error in upload cache processing task: " + retryException.message);
                throw retryException;
            }
        } else {
            logger.debug(LOG_PREFIX, "Successfully completed the upload cache processing task");
            KSCommonUtils.mergeTwoJSONMaps(this.outputContext, this.inputContext);
        }
    }
    KSUploadCacheProcessingTask.prototype.execute = async function() {
        unpackInputs.call(this);
        try {
            if (this.syncObject.getSyncLevel() === KSInternalConstants.SYNCLEVEL_OBJECTSERVICE) {
                this.syncableObjectsToRetry = this.syncableObjectsToRetry.concat(await getSyncObjectForRelatedCacheEntries(this.syncObject));
            } else if (this.syncObject.getSyncLevel() === KSInternalConstants.SYNCLEVEL_OBJECT) {
                this.syncableObjectsToRetry.push(KSSDKObjectService.getInstanceByName(this.syncObject.getObjectServiceName()))
            }
            this.syncableObjectsToRetry.push(this.syncObject);
            await retryCacheInOrder.call(this, 0);
            return this.outputContext;
        } catch (cacheProcessingException) {
            logger.error(LOG_PREFIX, "Error in upload cache processing task: " + cacheProcessingException.message);
            throw cacheProcessingException;
        }
    };
    exports.KSUploadCacheProcessingTask = KSUploadCacheProcessingTask;
});
/**
 * KSUploadCacheManager
 * Created by Harshini Bonam on 18/04/19.
 * Copyright  2019 Kony. All rights reserved.
 */
define("KSUploadCacheManager", ["exports", "KSUploadCacheSQLQueryGenerator", "KSUploadCacheObject", "KSDatabaseAPI", "KSNetworkUtils", "KSCommonUtils", "KSError"], function(exports, KSUploadCacheSQLQueryGenerator, _KSUploadCacheObject, _KSDatabaseAPI, KSNetworkUtils, KSCommonUtils, _KSError) {
    "use strict";
    var sdk = kony.sdk;
    var logger = sdk.logsdk;
    exports._esModule = true;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSUploadCacheManager : ";
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var KSErrorConstants = sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = sdk.OfflineObjects.KSDatabaseConstants;
    var KSUploadCacheObject = _KSUploadCacheObject.KSUploadCacheObject;
    var instance = null;
    /**
     * Instantiates an instance of KSUploadCacheManager class.
     * @constructor
     */
    function KSUploadCacheManager() {}
    /**
     * Method to enforce singleton instance of KSUploadCacheManager.
     * @returns {singleton instance of KSUploadCacheManager}
     */
    KSUploadCacheManager.getInstance = function() {
        if (instance == null) {
            instance = new KSUploadCacheManager();
        }
        return instance;
    };
    /**
     * The method can be used to create cache entry against a sync object
     *
     * @param uploadCacheObject The sync object against which cache entry should be done
     */
    KSUploadCacheManager.prototype.persist = async function(uploadCacheObject) {
        logger.trace(LOG_PREFIX + "Persisting into upload cache manager.");
        var query = KSUploadCacheSQLQueryGenerator.getPreparedStatementForCreate(uploadCacheObject.getUploadCacheObjectAsKeyValuePairs());
        await KSDatabaseAPI.executeQuery(query);
    };
    /**
     * The method used for getting a cached request
     *
     * @param syncableObjectName The object for which cache entry is to be returned
     * @return the upload cache object
     */
    KSUploadCacheManager.prototype.getRecord = async function(syncableObjectName) {
        var result = await KSDatabaseAPI.executeQuery(KSUploadCacheSQLQueryGenerator.getPreparedStatementForSelect(syncableObjectName));
        if (result.length === 0) {
            logger.debug(LOG_PREFIX, "No cache entry for given object/objectService: " + syncableObjectName + " in upload cache.");
            return null;
        }
        if (result.length > 1) {
            logger.fatal(LOG_PREFIX, "Duplicate entry for object/objectService name: " + syncableObjectName + " in upload cache.");
            throw new KSError(KSErrorConstants.INTERNAL_UPLOAD_CACHE_DUPLICATE_ENTRY_FOR_SAME_OBJECT);
        }
        var record = result[0];
        var uploadCacheSyncObjectContext = {
            [KSInternalConstants.OBJECT_NAME]: record[KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME],
            [KSInternalConstants.TYPE]: record[KSDatabaseConstants.UPLOAD_CACHE_OBJECT_TYPE]
        };
        return new KSUploadCacheObject(uploadCacheSyncObjectContext, record[KSDatabaseConstants.UPLOAD_CACHE_REQUEST_BODY], record[KSDatabaseConstants.UPLOAD_CACHE_REQUEST_ID], record[KSDatabaseConstants.UPLOAD_CACHE_REQUEST_CONTEXT]);
    };
    /**
     * The method can perform retry on cache objects
     *
     * @param syncableObject The object for which cache retry is to be done
     */
    KSUploadCacheManager.prototype.retryCachedRequests = async function(syncableObject) {
        try {
            var result;
            var objectName = syncableObject.getFullyQualifiedName();
            var cachedObject = await this.getRecord(objectName);
            if (cachedObject === null) {
                logger.debug(LOG_PREFIX, "No cached requests found for object: " + objectName);
                return {};
            } else {
                await this.updateDateAndReAttemptCountForCacheObject(cachedObject);
                result = await retryUploadWithUploadCacheObject(syncableObject, cachedObject);
                await this.removeRecord(objectName);
                return result;
            }
        } catch (retryException) {
            logger.error(LOG_PREFIX, "Error while updating cache entry for: " + objectName + " with error : " + retryException.message);
            var httpStatus;
            if (retryException.hasOwnProperty("userInfo")) {
                httpStatus = retryException.userInfo[KSInternalConstants.HTTP_STATUS];
            }
            if (!kony.sdk.isNullOrUndefined(retryException.code)) {
                // not clearing cache for timeouts or if their is a throttling error thrown from the server
                if (!(retryException.code === KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR.code || retryException.code === KSErrorConstants.NW_SOCKET_TIMEOUT.code || retryException.code === KSErrorConstants.NW_REQUEST_ALREADY_IN_PROGRESS.code || httpStatus === KSInternalConstants.HTTP_TOO_MANY_REQUESTS)) {
                    await this.removeRecord(objectName);
                }
            }
            throw retryException;
        }
    };
    /**
     * Method can remove a cache entry
     *
     * @param syncableObjectName The key for object to be removed
     */
    KSUploadCacheManager.prototype.removeRecord = async function(syncableObjectName) {
        var query = KSUploadCacheSQLQueryGenerator.getPreparedStatementForDelete(syncableObjectName);
        await KSDatabaseAPI.executeQuery(query);
        logger.debug(LOG_PREFIX, "Successfully cleared upload cache entry for the sync object: " + syncableObjectName);
    };
    /**
     * Clearing all the entries in cache
     */
    KSUploadCacheManager.prototype.clearAll = async function() {
        var query = KSUploadCacheSQLQueryGenerator.getPreparedStatementForDelete();
        await KSDatabaseAPI.executeQuery(query);
    };
    /**
     * Method updates the reattempt date and no of retries
     *
     * @param uploadCacheObject The cache object for which it should be updated
     */
    KSUploadCacheManager.prototype.updateDateAndReAttemptCountForCacheObject = async function(uploadCacheObject) {
        var cacheRequestId = uploadCacheObject.getRequestCacheId();
        var queryToGetExistingNumberOfReattempts = KSUploadCacheSQLQueryGenerator.getQueryForGettingExistingNumberOfReattempts(cacheRequestId);
        var result = await KSDatabaseAPI.executeQuery(queryToGetExistingNumberOfReattempts);
        var existingNumberOfReattempts = result[0][KSDatabaseConstants.UPLOAD_CACHE_NO_OF_REATTEMPTS];
        var query = KSUploadCacheSQLQueryGenerator.getQueryForUpdatingLastAttemptDetails(cacheRequestId, existingNumberOfReattempts);
        await KSDatabaseAPI.executeQuery(query);
        logger.debug(LOG_PREFIX, "Successfully updated date and number of reattempts count cache." + uploadCacheObject.getObjectName());
    };
    /**
     * The method retries a request from upload cache and calls the processParsedUploadResponse method
     *
     * @param syncableObject The sync object for which cache retry needs to be done
     * @param uploadCacheObject The upload cache object
     */
    async function retryUploadWithUploadCacheObject(syncableObject, uploadCacheObject) {
        //URL
        var url = syncableObject.getMetadata()[KSInternalConstants.ENDPOINT_URL];
        //Request headers
        var requestHeaders = {
            [KSInternalConstants.X_HTTP_METHOD_OVERRIDE]: KSInternalConstants.HTTP_OVERRIDE_UPLOAD,
            [KSInternalConstants.X_KONY_REQUEST_CACHE_ID]: uploadCacheObject.getRequestCacheId(),
        };
        var version = syncableObject.metadata[KSInternalConstants.VERSION];
        if (!kony.sdk.isNullOrUndefined(version)) {
            requestHeaders[KSInternalConstants.X_KONY_API_VERSION] = version;
        }
        //Request body
        var requestBody = uploadCacheObject.getRequestBody();
        var requestContext = uploadCacheObject.getRequestContext();
        var queryParams = requestContext[KSInternalConstants.REQUEST_QUERY_PARAMS];
        var networkResponse = await KSNetworkUtils.post(url, queryParams, requestHeaders, requestBody, {});
        if (kony.sdk.util.isNullOrEmptyString(networkResponse)) {
            logger.error(LOG_PREFIX, "Empty response received for cached upload request." + syncableObject.getFullyQualifiedName());
            throw new KSError(KSErrorConstants.SYNC_CACHE_UPLOAD_ERROR);
        } else {
            var response = await processParsedUploadResponse(syncableObject, networkResponse);
            var uploadResponseErrorList = response[KSInternalConstants.UPLOAD_SYNC_ERRORS];
            return {
                [KSInternalConstants.CACHE_UPLOAD_ERRORS]: uploadResponseErrorList
            };
        }
    }
    /**
     * The method processes parsed upload response and persists them to db
     *
     * @param syncableObject The sync object
     * @param response parsed upload response
     */
    async function processParsedUploadResponse(syncableObject, response) {
        if (response.hasOwnProperty(KSInternalConstants._METADATA)) {
            var uploadMetadata = response[KSInternalConstants._METADATA];
            var uploadResponse = await syncableObject.parseUploadResponse(response);
            await syncableObject.persistUploadChanges(uploadResponse[KSInternalConstants.DATA_OBJECTS]);
            delete uploadResponse[KSInternalConstants.DATA_OBJECTS];
            logger.debug(LOG_PREFIX + "Successfully completed the cached upload processing task.");
            var responseToSent = uploadResponse;
            responseToSent[KSInternalConstants.UPLOAD_RESPONSE_METADATA] = uploadMetadata;
            return responseToSent;
        } else {
            logger.error(LOG_PREFIX, "Invalid response received from cached upload request.");
            throw new KSError(KSErrorConstants.SYNC_UPLOAD_ERROR, {
                [KSInternalConstants.INTERNAL_USER_INFO]: "Error while retrieving objects from parsed cached upload response."
            });
        }
    }
    exports.getInstance = KSUploadCacheManager.getInstance;
});
/**
 * KSUploadCacheObject
 * Created by Harshini Bonam on 18/04/19.
 * Copyright  2019 Kony. All rights reserved.
 */
define("KSUploadCacheObject", ["exports", "KSCommonUtils"], function(exports, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var sdk = kony.sdk;
    var logger = sdk.logsdk;
    var LOG_PREFIX = "KSUploadCacheObject : ";
    var KSInternalConstants = sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = sdk.OfflineObjects.KSDatabaseConstants;
    /**
     * Constructor for KSUploadCacheObject.
     * @param sdkObjectContext JSON object containing:
     *      objectName The object for which cache retry has to be done.
     *      objectType Type of object for which upload cache entry is needed.
     *      or,
     *      syncableObject The object for which cache retry has to be done.
     * @param requestBody Request body of upload cache.
     * @param requestCacheId Request Id of upload cache.
     * @param requestContext Request Context of upload cache.
     * @constructor Return the SDKObject.
     */
    function KSUploadCacheObject(sdkObjectContext, requestBody, requestCacheId, requestContext) {
        if (sdkObjectContext.hasOwnProperty(KSInternalConstants.OBJECT_NAME) && sdkObjectContext.hasOwnProperty(KSInternalConstants.TYPE)) {
            this.objectName = sdkObjectContext[KSInternalConstants.OBJECT_NAME];
            this.objectType = sdkObjectContext[KSInternalConstants.TYPE];
        } else {
            var sdkObject = sdkObjectContext;
            this.objectName = sdkObject.getFullyQualifiedName();
            this.objectType = sdkObject.getSyncLevel();
        }
        this.requestBody = requestBody;
        this.requestCacheId = requestCacheId;
        this.requestContext = requestContext;
        logger.trace(LOG_PREFIX, "Initialized an instance of KSUploadCacheObject with name: " + this.objectName + " and type: " + this.objectType);
    }
    //------------------------------------
    // PROTOTYPE GETTER AND SETTER METHODS
    //------------------------------------
    KSUploadCacheObject.prototype.getObjectName = function() {
        return this.objectName;
    };
    KSUploadCacheObject.prototype.setObjectName = function(objectName) {
        this.objectName = objectName;
    };
    KSUploadCacheObject.prototype.getObjectType = function() {
        return this.objectType;
    };
    KSUploadCacheObject.prototype.setObjectType = function(objectType) {
        this.objectType = objectType;
    };
    KSUploadCacheObject.prototype.getRequestBody = function() {
        return this.requestBody;
    };
    KSUploadCacheObject.prototype.setRequestBody = function(requestBody) {
        this.requestBody = requestBody;
    };
    KSUploadCacheObject.prototype.getRequestCacheId = function() {
        return this.requestCacheId;
    };
    KSUploadCacheObject.prototype.setRequestCacheId = function(requestCacheId) {
        this.requestCacheId = requestCacheId;
    };
    KSUploadCacheObject.prototype.getRequestContext = function() {
        return this.requestContext;
    };
    KSUploadCacheObject.prototype.setRequestContext = function(requestContext) {
        this.requestContext = requestContext;
    };
    KSUploadCacheObject.prototype.getUploadCacheObjectAsKeyValuePairs = function() {
        return {
            [KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME]: this.objectName,
            [KSDatabaseConstants.UPLOAD_CACHE_OBJECT_TYPE]: this.objectType,
            [KSDatabaseConstants.UPLOAD_CACHE_REQUEST_BODY]: this.requestBody,
            [KSDatabaseConstants.UPLOAD_CACHE_REQUEST_ID]: this.requestCacheId,
            [KSDatabaseConstants.UPLOAD_CACHE_REQUEST_CONTEXT]: this.requestContext,
            [KSDatabaseConstants.UPLOAD_CACHE_NO_OF_REATTEMPTS]: 0,
            [KSDatabaseConstants.UPLOAD_CACHE_LAST_ATTEMPTED]: KSCommonUtils.getCurrentDateTime()
        };
    };
    exports.KSUploadCacheObject = KSUploadCacheObject;
});
/**
 * KSUploadCacheSQLQueryGenerator
 * Created by Harshini Bonam on 18/04/19.
 * Copyright  2019 Kony. All rights reserved.
 */
define("KSUploadCacheSQLQueryGenerator", ["exports", "KSQueryObjectBuilder", "KSCommonUtils"], function(exports, KSQueryObjectBuilder, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var sdk = kony.sdk;
    var logger = sdk.logsdk;
    var LOG_PREFIX = "KSUploadCacheSQLQueryGenerator : ";
    var KSPublicConstants = sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = sdk.OfflineObjects.KSDatabaseConstants;
    var KSDatabaseOperation = KSDatabaseConstants.KSDatabaseOperations;
    /**
     * The method prepares the prepared statement for creating entry in konysyncUPLOADCACHE table
     * @param record to be inserted
     * @returns {queryBuilderObject}
     */
    function getPreparedStatementForCreate(record) {
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE, KSDatabaseOperation.INSERT_OR_REPLACE).addInsertValues(record).build();
    }
    /**
     * The method returns the required prepared statement for selecting cached requests
     *
     * @param syncableObjectName The object name for which we require cached requests
     * @return {queryBuilderObject}
     */
    function getPreparedStatementForSelect(syncableObjectName) {
        var whereClause = {
            [KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME]: syncableObjectName
        };
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE, KSDatabaseOperation.SELECT).setWhereClause(whereClause).build();
    }
    /**
     * This method returns the query to delete records from konysyncUPLOADCACHE table
     * @param syncableObjectName the object/objectservice name
     * @return {queryBuilderObject}
     */
    function getPreparedStatementForDelete(syncableObjectName) {
        var query = KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE, KSDatabaseOperation.DELETE);
        if (!kony.sdk.util.isNullOrEmptyString(syncableObjectName)) {
            var whereClause = {
                [KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME]: syncableObjectName
            };
            query.setWhereClause(whereClause);
        }
        return query.build();
    }
    /**
     * Method to create query for updating last attempted date time and number of reattempts
     *
     * @param requestCacheId the generated Unique UUID String
     * @param existingNumberOfReattempts the number of times retry was attempted on the object
     * @return {queryBuilderObject}
     */
    function getQueryForUpdatingLastAttemptDetails(requestCacheId, existingNumberOfReattempts) {
        var updateMap = {
            [KSDatabaseConstants.UPLOAD_CACHE_LAST_ATTEMPTED]: KSCommonUtils.getCurrentDateTime(),
            [KSDatabaseConstants.UPLOAD_CACHE_NO_OF_REATTEMPTS]: existingNumberOfReattempts + 1
        };
        var whereClause = {
            [KSDatabaseConstants.UPLOAD_CACHE_REQUEST_ID]: requestCacheId
        };
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE, KSDatabaseOperation.UPDATE).setUpdatedData(updateMap).setWhereClause(whereClause).build()
    }
    /**
     * Query to get entries in cache with order by object name
     *
     * @param syncableObjectNames The list of object names
     * @return {queryBuilderObject}
     */
    function getQueryForGettingUploadCacheEntriesInOrder(syncableObjectNames) {
        var whereClauseAsString = "";
        var objectNamesLength = syncableObjectNames.length;
        for (var index = 0; index < objectNamesLength; index++) {
            whereClauseAsString += KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME + " " + KSInternalConstants.EQUALS + " " + syncableObjectNames[index];
            if (index + 1 !== objectNamesLength) {
                whereClauseAsString += " " + KSDatabaseConstants.LOGICAL_OR + " ";
            }
        }
        var orderBy = {
            [KSDatabaseConstants.UPLOAD_CACHE_LAST_ATTEMPTED]: KSPublicConstants.ORDER_BY_ASCENDING
        };
        var projectionColumns = [KSDatabaseConstants.UPLOAD_CACHE_OBJECT_NAME, KSDatabaseConstants.UPLOAD_CACHE_OBJECT_TYPE];
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE, KSDatabaseOperation.SELECT).setProjectionColumns(projectionColumns).setWhereClauseAsString(whereClauseAsString).addOrderByMap(orderBy).build();
    }
    /**
     * Method creates the query for updating last attempted date time and number of reattempts
     * @param cacheRequestId the generated Unique UUID String
     * @return {queryBuilderObject}
     */
    function getQueryForGettingExistingNumberOfReattempts(cacheRequestId) {
        var whereClause = {
            [KSDatabaseConstants.UPLOAD_CACHE_REQUEST_ID]: cacheRequestId
        };
        var projectionColumns = [KSDatabaseConstants.UPLOAD_CACHE_NO_OF_REATTEMPTS];
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE, KSDatabaseOperation.SELECT).setWhereClause(whereClause).setProjectionColumns(projectionColumns).build();
    }
    exports.getPreparedStatementForCreate = getPreparedStatementForCreate;
    exports.getPreparedStatementForSelect = getPreparedStatementForSelect;
    exports.getPreparedStatementForDelete = getPreparedStatementForDelete;
    exports.getQueryForUpdatingLastAttemptDetails = getQueryForUpdatingLastAttemptDetails;
    exports.getQueryForGettingExistingNumberOfReattempts = getQueryForGettingExistingNumberOfReattempts;
    exports.getQueryForGettingUploadCacheEntriesInOrder = getQueryForGettingUploadCacheEntriesInOrder;
});
define("KSCommonUtils", ["exports", "KSError", "KSRunningTasksManager"], function(exports, _KSError, KSRunningTasksManager) {
    var LOG_PREFIX = "KSCommonUtils : ";
    var KSError = _KSError.KSError;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSDBSchemaVersion = kony.sdk.OfflineObjects.KSDBSchemaVersion;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    /**
     * isNullOrEmptyObject - checks of the object is null/undefined or empty
     * @param object of type boolean/string/JSON
     * @returns {boolean}
     */
    function isNullOrEmptyObject(object) {
        return (kony.sdk.isNullOrUndefined(object) || kony.sdk.isEmptyObject(object));
    }
    /**
     * clearObject - deletes all key value pairs inside a JSON object
     * @param object of type JSON
     */
    function clearJSONObject(object) {
        for (var prop in object) {
            if (object.hasOwnProperty(prop)) {
                delete object[prop];
            }
        }
    }
    /**
     * Method to clear the objects inside an array.
     * @param array Array to be cleared.
     */
    function clearArrayObject(array) {
        array.length = 0;
    }
    /**
     * Merge two json objects
     *
     * @param Obj1
     * @param Obj2 which is added to Obj1
     */
    function mergeTwoJSONMaps(Obj1, Obj2) {
        for (var key in Obj2) {
            if (Obj2.hasOwnProperty(key)) {
                Obj1[key] = Obj2[key];
            }
        }
    }
    //Setup constants
    function getOfflineObjectsDatabaseName() {
        //AppID is prefixed by konynosql API.
        return "OfflineObjects";
    }
    /**
     * Function to check if an EXCEPTION object is enumerable or not
     * Usage: We cannot stringify native JS exception objects, as the [[Enumerable]] is set false.
     *        And, JSON.stringify(exception) would give "{}" empty, and exception.toString() gives respective string.
     *        Hence, before trying to stringify any exception, it is better to check this property and do corresponding action.
     * Caveats: This function may return false for array objects, as "length" is not enumerable.
     * @param exception
     * @returns {boolean}
     */
    function isExceptionObjectEnumerable(exception) {
        var exceptionPropertyDescriptors = Object.getOwnPropertyDescriptors(exception);
        for (var property in exceptionPropertyDescriptors) {
            if (exceptionPropertyDescriptors.hasOwnProperty(property)) {
                var propertyValue = exceptionPropertyDescriptors[property];
                if (propertyValue["enumerable"] === false) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Validates whether the object passed is an instance of map or not
     * @param map
     * @returns {boolean}
     */
    function isInstanceOfMap(map) {
        if (kony.sdk.isNullOrUndefined(map)) {
            return false;
        }
        return map.constructor === {}.constructor;
    }
    /**
     * Validates whether all primaryKeys present in the options
     * @param primaryKeyValueMap key value pair of primaryKeys and values
     * @param metadata of the sdkObject which needs for validation
     */
    function arePrimaryKeyAttributeValuesPresent(primaryKeyValueMap, metadata) {
        var primaryKeys = Object.keys(metadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS]);
        for (var index = primaryKeys.length - 1; index >= 0; index--) {
            if (!primaryKeyValueMap.hasOwnProperty(primaryKeys[index])) {
                var errorMessage = "Primary key " + primaryKeys[index] + " value is not provided in options.";
                kony.sdk.logsdk.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_NULL_OR_EMPTY_PRIMARY_KEY_VALUE, errorMessage);
            }
        }
        return true;
    }
    /**
     * Method to remove columns not in metadata.
     *
     * @param metadata the object metada
     * @param recordCreated from which unwanted columns are removed
     */
    function removeUnwantedColumns(metadata, recordCreated) {
        var projectionColumns = Object.keys(metadata[KSInternalConstants.ATTRIBUTES]);
        for (var column in recordCreated) {
            if (projectionColumns.indexOf(column) === -1) {
                delete recordCreated[column];
            }
        }
    }
    /**
     * Method to remove columns with null values.
     *
     * @param record from which null value columns are removed
     */
    function removeColumnsWithNullValues(record) {
        for (var column in record) {
            if (kony.sdk.isNullOrUndefined(record[column])) {
                delete record[column];
            }
        }
    }
    /**
     * It gives the map of ForeignKey Pk name as key  with its value from autoGenKeyValuePair
     * @param autoGenKeyValuePair    is list of pk's and value's from source object
     * @param targetObjectAttributes attributes which are related to targetObject
     * @param sourceObjectAttributes attributes which are related to sourceObject
     * @return the map of primary-key value pairs.
     */
    function getForeignKeyValueMap(autoGenKeyValuePair, targetObjectAttributes, sourceObjectAttributes) {
        var foreignKeyValueMap = {};
        var sourceObjectAttributesLen = sourceObjectAttributes.length;
        for (var index = 0; index < sourceObjectAttributesLen; index++) {
            var sourceObjectAttribute = sourceObjectAttributes[index];
            var sourceAttributeValue = autoGenKeyValuePair[sourceObjectAttribute.name];
            var targetObjectAttribute = targetObjectAttributes[index];
            if (sourceAttributeValue != null) {
                foreignKeyValueMap[targetObjectAttribute.name] = sourceAttributeValue;
            }
        }
        return foreignKeyValueMap;
    }
    /**
     * It gives the base ORM action from sdk record action
     *
     * @param recordActionType sdk record action
     * @returns {Number} base ORM action
     */
    function getBaseORMActionFromRecordActionCode(recordActionType) {
        var toBeUpdatedActionType;
        switch (recordActionType) {
            case KSSDKObjectRecordAction.DO_NOT_TRACK_INTERMEDIATE_UPDATES:
            case KSSDKObjectRecordAction.DEFERRED_UPDATE:
                toBeUpdatedActionType = KSSDKObjectRecordAction.UPDATE;
                break;
            case KSSDKObjectRecordAction.DEFERRED_CREATE:
                toBeUpdatedActionType = KSSDKObjectRecordAction.CREATE;
                break;
            case KSSDKObjectRecordAction.DEFERRED_DELETE:
                toBeUpdatedActionType = KSSDKObjectRecordAction.DELETE;
                break;
            default:
                toBeUpdatedActionType = recordActionType;
                break;
        }
        return toBeUpdatedActionType;
    }
    /** An utility to build userInfo object that is provided to an error
     *
     * @param name Name of the object service or object
     * @param error error from which the existing userInfo is retrieved
     * @param isObject true for object and false or undefined for objectservice.
     * @return A JSON containing userInfo details
     */
    function getUserInfo(name, error, isObject) {
        var userInfo = {};
        if (!kony.sdk.isNullOrUndefined(error.userInfo)) {
            if (kony.sdk.util.isJsonObject(error.userInfo)) {
                userInfo = error.userInfo;
            } else {
                userInfo[KSInternalConstants.INTERNAL_USER_INFO] = error.userInfo;
            }
        }
        if (isObject) {
            userInfo[KSInternalConstants.OBJECT_NAME] = name;
        } else {
            userInfo[KSInternalConstants.OBJECT_SERVICE_NAME] = name;
        }
        return userInfo;
    }
    /**
     * This method fetches the latest DB version
     * @return db Version
     */
    function getLatestDBVersion() {
        return (Object.keys(KSDBSchemaVersion).length - 1);
    }
    /**
     * Method to fetch the KSRunningTasksContext from the local storage.
     * @returns KSRunningTasksContext which is stored in the local storage.
     */
    function getRunningTasksContext() {
        return kony.store.getItem(KSPublicConstants.RUNNING_TASKS_CONTEXT);
    }
    /**
     * Method to set the KSRunningTasksContext in the local storage.
     * @param runningTasksContext KSRunningTasksContext which needs to be stored in the local storage.
     */
    function setRunningTasksContext(runningTasksContext) {
        kony.store.setItem(KSPublicConstants.RUNNING_TASKS_CONTEXT, runningTasksContext);
    }
    /**
     * A utility method to reset the running tasks context upon page refresh/reload
     */
    function resetLocksOnPageReload() {
        KSRunningTasksManager.getInstance();
        var appLaunchParams = kony.ds.read(KSPublicConstants.APP_LAUNCH);
        var appLaunch = (!isNullOrEmptyObject(appLaunchParams)) ? appLaunchParams[0] : appLaunchParams;
        var currentRunningTasksContext = getRunningTasksContext();
        if (!isNullOrEmptyObject(currentRunningTasksContext) && currentRunningTasksContext.APPLICATION_LEVEL != 0) {
            if (!isNullOrEmptyObject(appLaunch) && appLaunch === true) {
                var runningTasksContext = {
                    APPLICATION_LEVEL: 0
                };
                setRunningTasksContext(runningTasksContext);
            }
        }
        kony.ds.save([false], KSPublicConstants.APP_LAUNCH);
    }

    function generateUniqueUUIDString() {
        var uuid = function() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (new Date().getTime() + '-' + uuid() + '-' + uuid() + '-' + uuid());
    }

    function getCurrentDateTime() {
        var nowDate, month, formatDate;
        nowDate = new Date();
        month = nowDate.getUTCMonth() + 1;
        formatDate = (("00" + nowDate.getUTCFullYear()).slice(-4)) + "-" + (("00" + month).slice(-2)) + "-" + (("00" + nowDate.getUTCDate()).slice(-2)) + " " + (("00" + nowDate.getUTCHours()).slice(-2)) + ":" + (("00" + nowDate.getUTCMinutes()).slice(-2)) + ":" + (("00" + nowDate.getUTCSeconds()).slice(-2));
        return formatDate;
    }
    exports.getUserInfo = getUserInfo;
    exports.clearJSONObject = clearJSONObject;
    exports.isInstanceOfMap = isInstanceOfMap;
    exports.clearArrayObject = clearArrayObject;
    exports.mergeTwoJSONMaps = mergeTwoJSONMaps;
    exports.getLatestDBVersion = getLatestDBVersion;
    exports.getCurrentDateTime = getCurrentDateTime;
    exports.isNullOrEmptyObject = isNullOrEmptyObject;
    exports.removeUnwantedColumns = removeUnwantedColumns;
    exports.getForeignKeyValueMap = getForeignKeyValueMap;
    exports.getRunningTasksContext = getRunningTasksContext;
    exports.setRunningTasksContext = setRunningTasksContext;
    exports.resetLocksOnPageReload = resetLocksOnPageReload;
    exports.generateUniqueUUIDString = generateUniqueUUIDString;
    exports.isExceptionObjectEnumerable = isExceptionObjectEnumerable;
    exports.removeColumnsWithNullValues = removeColumnsWithNullValues;
    exports.getOfflineObjectsDatabaseName = getOfflineObjectsDatabaseName;
    exports.arePrimaryKeyAttributeValuesPresent = arePrimaryKeyAttributeValuesPresent;
    exports.getBaseORMActionFromRecordActionCode = getBaseORMActionFromRecordActionCode;
});
/**
 * Module to help build and retrieve delta context.
 */
define("KSDeltaContextUtils", ["exports", "KSDatabaseAPI", "KSQueryObjectBuilder"], function(exports, _KSDatabaseAPI, KSQueryObjectBuilder) {
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "KSDeltaContextUtils : ";
    var KSDbConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSDatabaseOperation = KSDbConstants.KSDatabaseOperations;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var deltaContextTableName = KSDbConstants.SQL_TABLE_KONY_SYNC_OBJECT_DELTA_CONTEXT;
    /**
     * Method to build insert query object for delta context.
     * @param deltaContext Delta context string.
     * @param filter Filter string.
     * @returns {Array} Array of query objects.
     */
    function buildDeltaContextQuery(deltaContext, filter) {
        logger.trace(LOG_PREFIX, "Building query object for inserting delta context into table.");
        var queryObj = [];
        if (!kony.sdk.isNullOrUndefined(deltaContext) && deltaContext.hasOwnProperty(KSInternalConstants.OBJS)) {
            var objects = deltaContext[KSInternalConstants.OBJS];
            var builder = KSQueryObjectBuilder.getQueryObjectForTableName(deltaContextTableName, KSDatabaseOperation.INSERT_OR_REPLACE);
            for (var objectName in objects) {
                if (objects.hasOwnProperty(objectName)) {
                    var object = objects[objectName];
                    var insertValueMap = {};
                    insertValueMap[KSInternalConstants.OBJECT_NAME] = objectName;
                    insertValueMap[KSInternalConstants.FILTER] = filter[objectName];
                    insertValueMap[KSInternalConstants.DELTACONTEXT] = object[KSInternalConstants.DELTA];
                    builder.addInsertValues(insertValueMap);
                }
            }
            queryObj.push(builder.build());
        }
        return queryObj;
    }
    /**
     * Method to fetch the delta context associated with given objects and their respective filters.
     * @param listOfObjectNamesAndFilters List of object names and their respective filters.
     * @returns {*} Array of delta context.
     */
    async function getDeltaContextForGivenObjectNamesAndFilters(listOfObjectNamesAndFilters) {
        logger.trace(LOG_PREFIX, "Building delta context query for download request.");
        var selectedRecords = [];
        if (!kony.sdk.isNullOrUndefined(listOfObjectNamesAndFilters)) {
            var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(deltaContextTableName, KSDatabaseOperation.SELECT);
            for (var i = 0; i < listOfObjectNamesAndFilters.length; i++) {
                //Add object name..
                var whereConditionMap = listOfObjectNamesAndFilters[i];
                var queryObj = statementBuilder.setWhereClause(whereConditionMap).build();
                var result = await _KSDatabaseAPI.KSDatabaseAPI.executeQuery(queryObj);
                Array.prototype.push.apply(selectedRecords, result);
            }
        }
        return selectedRecords;
    }
    exports.buildDeltaContextQuery = buildDeltaContextQuery;
    exports.getDeltaContextForGivenObjectNamesAndFilters = getDeltaContextForGivenObjectNamesAndFilters;
});
/**
 * Exception Wrapper Utils in Offline objects.
 */
define("KSExceptionWrapperUtils", ["exports", "KSError", "KSCommonUtils"], function(exports, _KSError, KSCommonUtils) {
    "use strict";
    exports._esModule = true;
    var LOG_PREFIX = "KSExceptionWrapperUtils : ";
    var KSError = _KSError.KSError;
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Method to get a KSError object wrapping the native uncaught exception
     * @param DBException is the native error object
     * @returns {_KSError.KSError} DB error object
     */
    exports.wrapDBException = function(DBException) {
        if (KSCommonUtils.isNullOrEmptyObject(DBException)) {
            return new KSError(KSErrorConstants.DB_GENERIC_ERROR);
        }
        if (!DBException.hasOwnProperty(KSInternalConstants.ERROR_DOMAIN)) {
            var userInfo = "";
            if (DBException.hasOwnProperty("message") || !KSCommonUtils.isNullOrEmptyObject(DBException.message)) {
                userInfo += DBException.message;
            }
            if (DBException.hasOwnProperty("stack") || !KSCommonUtils.isNullOrEmptyObject(DBException.stack)) {
                userInfo += DBException.stack;
            }
            kony.sdk.logsdk.error(LOG_PREFIX, userInfo);
            return new KSError(KSErrorConstants.DB_GENERIC_ERROR, userInfo);
        }
        return DBException;
    }
});
/**
 * KSMarkForUploadUtils
 * Created by Nikhil Kolhe on 04/03/2019.
 * Copyright  2019 Kony. All rights reserved.
 */
define("KSMarkForUploadUtils", ["exports", "KSError", "KSQueryObjectBuilder", "KSSQLQueryGenerator", "KSCommonUtils"], function(exports, _KSError, KSQueryObjectBuilder, KSSQLQueryGenerator, KSCommonUtils) {
    var LOG_PREFIX = "KSMarkForUploadUtils : ";
    var KSSyncDatabaseHelper = require("KSSyncDatabaseHelper");
    var logger = kony.sdk.logsdk;
    var KSTableType = kony.sdk.OfflineObjects.KSTableType;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    var deferredActionCodes = [];
    deferredActionCodes.push(KSSDKObjectRecordAction.DEFERRED_CREATE);
    deferredActionCodes.push(KSSDKObjectRecordAction.DEFERRED_UPDATE);
    deferredActionCodes.push(KSSDKObjectRecordAction.DEFERRED_DELETE);
    deferredActionCodes.push(KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES);
    /**
     * Gets prepared statements to mark upload true for the user specified records in history table
     *
     * @param options containing criteria, metadata.
     * @param tableType tableType to execute queries
     * @returns {Array} returns prepared statements for markForUpload
     */
    function getPreparedStatementForMarkForUpload(options, tableType) {
        var queries = [];
        var criteria = {};
        var metadata = options[KSInternalConstants.METADATA];
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS)) {
            criteria = options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS];
        }
        var fullyQualifiedName = metadata[KSInternalConstants.FULLY_QUALIFIED_NAME];
        var tableName = KSSQLQueryGenerator.getTableNameWithType(fullyQualifiedName, tableType);
        for (var recordActionType in deferredActionCodes) {
            var actionTypeToBeUpdated;
            if (deferredActionCodes[recordActionType] === KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES) {
                actionTypeToBeUpdated = KSSDKObjectRecordAction.DO_NOT_TRACK_INTERMEDIATE_UPDATES;
            } else {
                actionTypeToBeUpdated = KSCommonUtils.getBaseORMActionFromRecordActionCode(deferredActionCodes[recordActionType]);
            }
            var updatePreparedStatementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseConstants.KSDatabaseOperations.UPDATE);
            var updateColumnMaps = {};
            updateColumnMaps[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = actionTypeToBeUpdated;
            var clause = {};
            clause[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = deferredActionCodes[recordActionType];
            KSCommonUtils.mergeTwoJSONMaps(criteria, clause);
            var whereClause = kony.sdk.cloneObject(criteria);
            updatePreparedStatementBuilder.setWhereClause(whereClause).setUpdatedData(updateColumnMaps);
            var preparedStatements = updatePreparedStatementBuilder.build();
            queries.push(preparedStatements);
            delete criteria[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE];
        }
        return queries;
    }
    /**
     * Gives prepared statements for fetching records deferred for upload
     *
     * @param options options containing metadata
     * @param primaryKeyList primary keys deferred from upload
     */
    function getSelectPreparedStatementForDeferredRecords(options, primaryKeyList) {
        logger.trace(LOG_PREFIX, "getSelectPreparedStatementForDeferredRecords" + "Start:");
        var metadata = options[KSInternalConstants.METADATA];
        var whereCondition = whereClauseForDeferredRecords();
        var tableName = KSSQLQueryGenerator.getTableNameWithType(metadata[KSInternalConstants.FULLY_QUALIFIED_NAME], KSTableType.HISTORY);
        var statementBuilder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseConstants.KSDatabaseOperations.SELECT);
        return statementBuilder.setProjectionColumns(primaryKeyList).setWhereClause(whereCondition).build();
    }
    /**
     * Builds where condition for deferred records
     *
     * @param primaryKeyValues primary key value pairs
     * @returns {Array} whereClause for deferred records
     */
    function buildWhereConditionForDeferredRecords(primaryKeyValues) {
        var whereClause = KSSyncDatabaseHelper.buildWhereConditionAsString(primaryKeyValues);
        whereClause.push([KSDatabaseConstants.LOGICAL_AND]);
        return whereClause.concat(whereClauseForDeferredRecords(primaryKeyValues));
    }

    function whereClauseForDeferredRecords(primaryKeyValues) {
        var whereCondition = [];
        var ruleForDeferredUpdate = [];
        var ruleForDeferredDelete = [];
        var ruleForDeferredAndTrackUpdates = [];
        ruleForDeferredUpdate.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE);
        ruleForDeferredUpdate.push(KSInternalConstants.GREATER_THAN_EQUALS_TO);
        ruleForDeferredUpdate.push(KSSDKObjectRecordAction.DEFERRED_UPDATE);
        whereCondition.push(ruleForDeferredUpdate);
        whereCondition.push([KSDatabaseConstants.LOGICAL_AND]);
        ruleForDeferredDelete.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE);
        ruleForDeferredDelete.push(KSInternalConstants.LESS_THAN_EQUALS_TO);
        ruleForDeferredDelete.push(KSSDKObjectRecordAction.DEFERRED_DELETE);
        whereCondition.push(ruleForDeferredDelete);
        whereCondition.push([KSDatabaseConstants.LOGICAL_OR]);
        if (!KSCommonUtils.isNullOrEmptyObject(primaryKeyValues)) {
            var ruleForPrimaryKeyValues = KSSyncDatabaseHelper.buildWhereConditionAsString(primaryKeyValues);
            for (var index = 0; index < ruleForPrimaryKeyValues.length; index++) {
                whereCondition.push(ruleForPrimaryKeyValues[index]);
            }
            whereCondition.push([KSDatabaseConstants.LOGICAL_AND]);
        }
        ruleForDeferredAndTrackUpdates.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE);
        ruleForDeferredAndTrackUpdates.push(KSInternalConstants.EQUALS);
        ruleForDeferredAndTrackUpdates.push(KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES);
        whereCondition.push(ruleForDeferredAndTrackUpdates);
        /* Query :  konysyncchangetype >= 90 AND konysyncchangetype <= 93 OR userID = -1 AND konysyncchangetype = 70 */
        return whereCondition;
    }
    /**
     * Gives deferred action codes as String
     *
     * @return {string} of deferred actions codes
     */
    function getDeferredActionCodesAsString() {
        var deferredActionCodeString = KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE + ' ' + "!=" + ' ' + KSSDKObjectRecordAction.DEFERRED_UPDATE + ' ' + KSDatabaseConstants.LOGICAL_AND + ' ' + KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE + ' ' + "!=" + ' ' + KSSDKObjectRecordAction.DEFERRED_CREATE + ' ' + KSDatabaseConstants.LOGICAL_AND + ' ' + KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE + ' ' + "!=" + ' ' + KSSDKObjectRecordAction.DEFERRED_DELETE + ' ' + KSDatabaseConstants.LOGICAL_AND + ' ' + KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE + ' ' + "!=" + ' ' + KSSDKObjectRecordAction.DEFERRED_AND_DO_NOT_TRACK_INTERMEDIATE_UPDATES;
        /* Query : konysyncchangetype != 90 AND konysyncchangetype != 91 AND konysyncchangetype != 93 AND konysyncchangetype != 70 */
        return deferredActionCodeString;
    }
    exports.getDeferredActionCodesAsString = getDeferredActionCodesAsString;
    exports.getPreparedStatementForMarkForUpload = getPreparedStatementForMarkForUpload;
    exports.buildWhereConditionForDeferredRecords = buildWhereConditionForDeferredRecords;
    exports.getSelectPreparedStatementForDeferredRecords = getSelectPreparedStatementForDeferredRecords;
});
/**
 * KSMetadataUtils
 * Created by Harshini Bonam on 24/05/18.
 * Copyright  2018 Kony. All rights reserved.
 */
define("KSMetadataUtils", ["exports", "KSCommonUtils", "KSSQLQueryGenerator", "KSDatabaseAPI", "KSError"], function(exports, KSCommonUtils, KSSQLQueryGenerator, _KSDatabaseAPI, _KSError) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var KSDatabaseAPI = _KSDatabaseAPI.KSDatabaseAPI;
    var LOG_PREFIX = "KSMetadataUtils : ";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    /**
     * Method to parse metadata network response and generate rootMetadataObject
     * @param objectServiceMetadataContext
     * @param metadataJSON
     * @return {rootMetadataObject}
     */
    function parseSetupMetadataJSON(objectServiceMetadataContext, metadataJSON) {
        //local require is implemented as KSMetadataJSONParser depends on KSMetadataUtils.
        var KSMetadataJSONParser = require("KSMetadataJSONParser");
        if (validateMetadataJSON(objectServiceMetadataContext, metadataJSON)) {
            logger.trace(LOG_PREFIX, "Began to parse metadata JSON for object service " + objectServiceMetadataContext.name);
            var rootMetadataObject = KSMetadataJSONParser.parse(objectServiceMetadataContext, metadataJSON);
            logger.debug(LOG_PREFIX, "Successfully parsed metadata JSON for object service " + objectServiceMetadataContext.name);
            return rootMetadataObject;
        }
    }
    /**
     * Method to get create table queries for konysyncProperties, konysyncMetadata, konysyncObjectDeltaContext
     * and konysyncMetaInfo.
     * @returns {tableName: createQueryString, *}
     */
    function getMetaTableCreateQueries() {
        var createTableQueries = {};
        logger.trace(LOG_PREFIX, "Began to generate create queries for meta tables.");
        createTableQueries[KSDatabaseConstants.SQL_TABLE_KONY_PROPERTIES] = "&" + KSDatabaseConstants.PROPERTIES_TABLE_KEY_COLUMN + "," + KSDatabaseConstants.PROPERTIES_TABLE_VALUE_COLUMN;
        createTableQueries[KSDatabaseConstants.SQL_TABLE_KONY_SYNC_OBJECT_DELTA_CONTEXT] = "[objectname+filter],objectname,filter,deltacontext";
        //NOTE: Made scopename as primary key as it will always be unique.
        createTableQueries[KSDatabaseConstants.SQL_TABLE_KONY_SYNC_META_INFO] = "&scopename,uploadsessionno,filtervalue,replaysequencenumber,lastgeneratedid";
        createTableQueries[KSDatabaseConstants.SQL_TABLE_KONY_SYNC_METADATA] = "&" + KSDatabaseConstants.METADATA_TABLE_OBJECT_SERVICE_NAME + "," + KSDatabaseConstants.METADATA_TABLE_METADATA_JSON + "," + KSDatabaseConstants.METADATA_TABLE_DELTA_CONTEXT + "," + KSDatabaseConstants.METADATA_TABLE_VERSION;
        createTableQueries[KSDatabaseConstants.SQL_TABLE_KONY_SYNC_UPLOAD_CACHE] = KSDatabaseConstants.QUERY_KONY_SYNC_UPLOAD_CACHE_TABLE;
        logger.trace(LOG_PREFIX, "Successfully generated create queries for meta tables.");
        return createTableQueries;
    }
    /**
     * Method to get create table queries for all objects in given object service rootMetadata.
     * @param objectServiceName
     * @param rootMetadataObject
     * @returns {tableName: createQueryString, *}
     */
    function getQueriesToCreateTablesForObjectService(objectServiceName, rootMetadataObject) {
        var queries = {};
        var namespaces = rootMetadataObject[KSInternalConstants.NAMESPACE_METADATA_DICTIONARY];
        logger.debug(LOG_PREFIX, "Began to generate create table queries for object service: " + objectServiceName);
        for (var namespaceName in namespaces) {
            if (namespaces.hasOwnProperty(namespaceName)) {
                var objectsMetadataDict = namespaces[namespaceName][KSInternalConstants.OBJECT_METADATA_DICTIONARY];
                for (var objectName in objectsMetadataDict) {
                    if (objectsMetadataDict.hasOwnProperty(objectName)) {
                        var tableQueries = KSSQLQueryGenerator.getQueriesToCreateTableForObject(objectsMetadataDict[objectName]);
                        mergeJSONObjects(tableQueries, queries);
                    }
                }
            }
        }
        logger.debug(LOG_PREFIX, "Successfully generated create table queries for object service: " + objectServiceName);
        return queries;
    }
    /**
     * Method to create tables for all object services in SetupManager's newSetupContext
     * @param objectServiceObjectsDDLQueries
     * @return {Promise<void>}
     * @throws DatabaseException
     */
    async function createTablesForAllObjectServices(objectServiceObjectsDDLQueries) {
        var dbName = KSCommonUtils.getOfflineObjectsDatabaseName();
        try {
            await KSDatabaseAPI.initializeDatabase(dbName, objectServiceObjectsDDLQueries);
        } catch (dbException) {
            logger.error(LOG_PREFIX, "Failed to initialize DB Connection.");
            throw dbException;
        }
    }
    /**
     * Method to insert initial values into meta tables (konysyncProperties, konysyncMetadata and konysyncMetaInfo)
     * @param objectServiceMetadataContext
     * @return {Promise<void>}
     * @throws DatabaseException
     */
    async function insertIntoMetadataAndMetaInfoTables(objectServiceMetadataContext) {
        var queries = [];
        queries.push(KSSQLQueryGenerator.getPropertiesTableInsertQuery());
        for (var objectServiceName in objectServiceMetadataContext) {
            if (objectServiceMetadataContext.hasOwnProperty(objectServiceName)) {
                queries.push(KSSQLQueryGenerator.getMetaInfoTableInsertQueryForObjectService(objectServiceName));
                queries.push(KSSQLQueryGenerator.getMetaDataTableInsertQuery(objectServiceMetadataContext[objectServiceName]));
            }
        }
        await KSDatabaseAPI.executeQueriesAsTransaction(queries, [KSDatabaseConstants.SQL_TABLE_KONY_PROPERTIES, KSDatabaseConstants.SQL_TABLE_KONY_SYNC_META_INFO, KSDatabaseConstants.SQL_TABLE_KONY_SYNC_METADATA]);
    }
    /**
     * Normalizes the namespace name to kony_unnamed if it is null or empty
     *
     * @param namespaceName Namespace name
     * @return Normalized namespace name
     */
    function normalizedNamespaceName(namespaceName) {
        return KSCommonUtils.isNullOrEmptyObject(namespaceName) ? KSInternalConstants.UNNAMED_NAMESPACE : namespaceName;
    }
    /**
     * Removes kony_unnamed from the fullyQualifiedName if it exists,
     * if the input fullyQualifiedName has no namespaceName
     * @param fullyQualifiedName
     * @return Normalized fully qualified name
     */
    function normalizedFullyQualifiedName(fullyQualifiedName) {
        var namespaceName = namespaceNameFromFullyQualifiedName(fullyQualifiedName);
        var objectName = objectNameFromFullyQualifiedName(fullyQualifiedName);
        return normalizedFullyQualifiedNameForNamespaceNameAndObjectName(namespaceName, objectName);
    }
    /**
     * Removes kony_unnamed from the fullyQualifiedName if it exists,
     *
     * @param namespaceName
     * @param objectName
     * @return Normalized fully qualified name
     */
    function normalizedFullyQualifiedNameForNamespaceNameAndObjectName(namespaceName, objectName) {
        var fullyQualifiedName;
        if (!KSCommonUtils.isNullOrEmptyObject(objectName)) {
            if (KSCommonUtils.isNullOrEmptyObject(namespaceName) || namespaceName === KSInternalConstants.UNNAMED_NAMESPACE) {
                fullyQualifiedName = objectName;
            } else {
                fullyQualifiedName = namespaceName + KSDatabaseConstants.NAMESPACE_SUFFIX_CHARACTER + objectName;
            }
        }
        return fullyQualifiedName;
    }
    /**
     * returns namespaceName, given a fully qualified name
     *
     * @param fullyQualifiedName
     * @return namespaceName
     */
    function namespaceNameFromFullyQualifiedName(fullyQualifiedName) {
        return componentAtIndex(0, fullyQualifiedName);
    }
    /**
     * returns objectName, given a fully qualified name
     *
     * @param fullyQualifiedName
     * @return objectName
     */
    function objectNameFromFullyQualifiedName(fullyQualifiedName) {
        return componentAtIndex(1, fullyQualifiedName);
    }
    /**
     * Test cases:
     * <p>
     * index  = 0 fqn = a.b ==> a
     * index  = 1 fqn = a.b ==> b
     * index >= 2 fqn = a.b ==> nil
     * <p>
     * index  = 0 fqn = a ==> unnamed
     * index  = 1 fqn = a ==> a
     * index >= 2 fqn = a ==> nil
     * <p>
     * index  = 0 fqn = nil ==> nil
     * index  = 1 fqn = nil ==> nil
     * index >= 2 fqn = nil ==> nil
     * <p>
     * index  = 0 fqn = emptystring ==> nil
     * index  = 1 fqn = emptystring ==> nil
     * index >= 2 fqn = emptystring ==> nil
     * <p>
     * index  = 0 fqn = a.b.c ==> nil
     * index  = 1 fqn = a.b.c ==> nil
     * index >= 2 fqn = a.b.c ==> nil
     */
    function componentAtIndex(index, fullyQualifiedName) {
        var component = "";
        if (index < 2) {
            if (!KSCommonUtils.isNullOrEmptyObject(fullyQualifiedName)) {
                var components = componentsOfFullyQualifiedName(fullyQualifiedName);
                var componentCount = components.length;
                //Assuming fullyQualifiedName will not contain more than one dot...
                if (componentCount <= 2) {
                    if (componentCount === 2) {
                        component = components[index];
                    } else if (componentCount === 1) {
                        if (index === 1) {
                            component = components[0];
                        }
                    }
                }
            }
        }
        return component;
    }
    /**
     * returns the components seperated by "." in a fully qualified name
     *
     * @param fullyQualifiedName
     * @return components of fully qualified name
     */
    function componentsOfFullyQualifiedName(fullyQualifiedName) {
        return fullyQualifiedName.split(".");
    }
    /**
     * Method to validate network metadata JSON object.
     * @param objectServiceMetadataContext
     * @param metadataJSON
     * @return {boolean}
     */
    function validateMetadataJSON(objectServiceMetadataContext, metadataJSON) {
        if (KSCommonUtils.isNullOrEmptyObject(metadataJSON)) {
            var errorMessage = "Invalid metadata JSON received for object service " + objectServiceMetadataContext.name;
            logger.error(LOG_PREFIX, errorMessage);
            throw new KSError(KSErrorConstants.INVALID_METADATA_JSON, errorMessage);
        }
        return true;
    }
    /**
     * Method to merge fromJSON object key-value pairs into toObject
     * NOTE: this is a redundant method from KSCommonUtils, and would be removed.
     * @param fromObject
     * @param toObject
     */
    function mergeJSONObjects(fromObject, toObject) {
        for (var key in fromObject) {
            if (fromObject.hasOwnProperty(key)) {
                toObject[key] = fromObject[key];
            }
        }
    }
    /**
     * Method to get attribute metadata from objectMetadata.
     * @param objectMetadata
     * @param attributeName
     * @return {attributeMetadata}/null if not found.
     */
    function getAttributeMetadataForObjectAndAttributeName(objectMetadata, attributeName) {
        return objectMetadata[KSInternalConstants.ATTRIBUTES][attributeName];
    }
    exports.mergeJSONObjects = mergeJSONObjects;
    exports.parseSetupMetadataJSON = parseSetupMetadataJSON;
    exports.normalizedNamespaceName = normalizedNamespaceName;
    exports.getMetaTableCreateQueries = getMetaTableCreateQueries;
    exports.normalizedFullyQualifiedName = normalizedFullyQualifiedName;
    exports.createTablesForAllObjectServices = createTablesForAllObjectServices;
    exports.objectNameFromFullyQualifiedName = objectNameFromFullyQualifiedName;
    exports.insertIntoMetadataAndMetaInfoTables = insertIntoMetadataAndMetaInfoTables;
    exports.namespaceNameFromFullyQualifiedName = namespaceNameFromFullyQualifiedName;
    exports.getQueriesToCreateTablesForObjectService = getQueriesToCreateTablesForObjectService;
    exports.getAttributeMetadataForObjectAndAttributeName = getAttributeMetadataForObjectAndAttributeName;
    exports.normalizedFullyQualifiedNameForNamespaceNameAndObjectName = normalizedFullyQualifiedNameForNamespaceNameAndObjectName;
});
/**
 * Network wrapper for Offline objects.
 */
define("KSNetworkUtils", ["exports", "KSSyncMFUtils", "KSCommonUtils", "KSError"], function(exports, KSSyncMFUtils, KSCommonUtils, _KSError) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSNetworkUtils : ";
    var networkProvider = new konyNetworkProvider();
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    /**
     * Method to make GET calls to the server.
     * @param {string} syncServerAddress URL from where the download should occur.
     * @param {Object} queryParams JSON object containing URL query parameters, if any.
     * @param {Object} headers JSON object containing the headers to be sent.
     * @param {Object} options JSON object containing options to make the call.
     * @param {function} successCallback Function for success scenario.
     * @param {function} failureCallback Function for error scenario.
     */
    var get = function(syncServerAddress, queryParams, headers, options, successCallback, failureCallback) {
        var consolidatedHeaders = getConsolidatedHeaders(headers);
        var url = syncServerAddress;
        if (!kony.sdk.isNullOrUndefined(queryParams)) {
            validateParamKeysAndValues(queryParams);
            options[KSPublicConstants.QUERY_PARAMS] = queryParams;
        }
        var networkSuccessCallback = function(response) {
            logger.debug(LOG_PREFIX + "Response body of network call : " + JSON.stringify(response));
            successCallback(response);
        };
        var networkFailureCallback = function(errorObj) {
            var error;
            if (errorObj.errcode === kony.sdk.errorcodes.invalid_json_code) {
                error = new KSError(KSErrorConstants.NW_INVALID_RESPONSE_OBJECT, errorObj);
            } else if (errorObj.errcode === kony.sdk.errorcodes.connectivity_error_code) {
                error = new KSError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
            } else if (errorObj.errcode === kony.sdk.errorcodes.integrity_check_failed) {
                error = new KSError(KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE, errorObj);
            } else {
                error = new KSError(KSErrorConstants.GENERIC_NETWORK_ERROR, errorObj);
            }
            failureCallback(error);
        };
        logger.debug(LOG_PREFIX + "URL : " + url);
        //Sending null for params and konyContentType for the GET call..
        networkProvider.get(url, null, consolidatedHeaders, networkSuccessCallback, networkFailureCallback, null, options);
    };
    /**
     * Method to make POST calls to the server.
     * @param {string} syncServerAddress URL from where the download should occur.
     * @param {Object} queryParams JSON object containing URL query parameters, if any.
     * @param {Object} headers JSON object containing the headers to be sent.
     * @param {Object} body JSON object containing the body to be posted to the server.
     * @param {Object} options JSON object containing options to make the call.
     */
    var post = function(syncServerAddress, queryParams, headers, body, options) {
        var consolidatedHeaders = getConsolidatedHeaders(headers);
        var url = syncServerAddress;
        if (!kony.sdk.isNullOrUndefined(queryParams)) {
            validateParamKeysAndValues(queryParams);
            options[KSPublicConstants.QUERY_PARAMS] = queryParams;
        }
        //Check and add empty object..
        if (kony.sdk.isNullOrUndefined(body)) {
            body = {};
        }
        var networkPromise = new Promise(function(resolve, reject) {
            function networkSuccessCallback(response) {
                logger.debug(LOG_PREFIX + "Response body of network call : " + JSON.stringify(response));
                resolve(response);
            }

            function networkFailureCallback(errorObj) {
                var error;
                if (errorObj.errcode === kony.sdk.errorcodes.invalid_json_code) {
                    error = new KSError(KSErrorConstants.NW_INVALID_RESPONSE_OBJECT, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.connectivity_error_code) {
                    error = new KSError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.integrity_check_failed) {
                    error = new KSError(KSErrorConstants.NW_MESSAGE_INTEGRITY_FAILURE, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.connection_timeout) {
                    error = new KSError(KSErrorConstants.NW_CONNECTION_TIMEOUT_ERROR, errorObj);
                } else if (errorObj.errcode === kony.sdk.errorcodes.request_timed_out_code) {
                    error = new KSError(KSErrorConstants.NW_SOCKET_TIMEOUT, errorObj);
                } else {
                    error = new KSError(KSErrorConstants.GENERIC_NETWORK_ERROR, errorObj);
                }
                reject(error);
            }
            logger.debug(LOG_PREFIX + "URL : " + url);
            //Sending 'application/json' as konyContentType to the network layer by default..
            networkProvider.post(url, body, consolidatedHeaders, networkSuccessCallback, networkFailureCallback, "application/json", options);
        });
        return networkPromise;
    };
    /**
     * Method to combine the default and user sent headers.
     * @param {Object} headers JSON object containing user sent headers.
     */
    function getConsolidatedHeaders(headers) {
        var consolidatedHeaders = {};
        //Adding the default headers..
        consolidatedHeaders[KSInternalConstants.CONTENT_TYPE] = KSInternalConstants.APPLICATION_JSON;
        consolidatedHeaders[KSInternalConstants.X_HTTP_METHOD_OVERRIDE] = KSInternalConstants.HTTP_METHOD_GET;
        //Set the reporting params..
        var reportingParams = KSSyncMFUtils.getReportingParams();
        if (KSCommonUtils.isNullOrEmptyObject(reportingParams)) {
            kony.sdk.logsdk.warn(LOG_PREFIX + "ReportingParams are either null or empty.");
        } else {
            consolidatedHeaders[KSInternalConstants.X_KONY_REPORTINGPARAMS] = reportingParams;
        }
        //Add the claims token..
        var token = KSSyncMFUtils.getToken();
        if (KSCommonUtils.isNullOrEmptyObject(token)) {
            kony.sdk.logsdk.warn(LOG_PREFIX + "Token sent is either null or empty.");
        } else {
            consolidatedHeaders[KSInternalConstants.X_KONY_AUTHORIZATION] = token;
        }
        //Merge the user sent headers..
        for (var key in headers) {
            consolidatedHeaders[key] = headers[key];
        }
        return consolidatedHeaders;
    }
    /**
     * Method to validate the queryParam key and value
     * @param key queryParam key
     * @param value value for the queryParamkey
     * @returns boolean returns true if valid else invalid
     */
    function isQueryParamKeyAndValueValid(key, value) {
        return kony.sdk.util.isValidString(key) && (kony.sdk.util.isValidString(value) || kony.sdk.util.isValidNumberType(value));
    }
    /**
     * Method to validate the query parameters to send them to the sdk network layer.
     * @param {Object} queryParams JSON object containing the query parameters.
     */
    function validateParamKeysAndValues(queryParams) {
        if (queryParams && Object.keys(queryParams).length > 0) {
            for (var key in queryParams) {
                if (!isQueryParamKeyAndValueValid(key, queryParams[key])) {
                    throw new KSError(KSErrorConstants.GENERIC_NETWORK_ERROR, "Null or empty string value found for query param : " + key);
                }
            }
        }
    }
    exports.get = get;
    exports.post = post;
});
/**
 * KSOptionsHelper
 * Created by Prasanthi Bonam on 29-05-2018.
 * Copyright  2017 Kony. All rights reserved.
 */
define("KSOptionsHelper", ["exports", "KSError", "KSCommonUtils"], function(exports, _KSError, KSCommonUtils) {
    "use strict";
    exports._esModules = true;
    var logger = kony.sdk.logsdk;
    var KSError = _KSError.KSError;
    var LOG_PREFIX = "KSOptionsHelper : ";
    var KSErrorConstants = kony.sdk.OfflineObjects.KSErrorConstants;
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSDataTypes = kony.sdk.OfflineObjects.KSDatabaseConstants.KSDataTypes;

    function validateSyncConfigPolicy(options) {
        var errorMessage;
        if (!options.hasOwnProperty(KSPublicConstants.SYNC_TYPE) || options[KSPublicConstants.SYNC_TYPE] == KSPublicConstants.FULL_SYNC) {
            // If SyncType key is absent or the value for Sync Type is FullSync
            logger.info(LOG_PREFIX + "Enabling upload and Download for current Sync session.");
            validateSyncDownloadOptions(options);
        } else if (kony.sdk.isNullOrUndefined(options[KSPublicConstants.SYNC_TYPE])) {
            errorMessage = "Invalid value found for syncType option. It's either empty or null.";
            logger.error(LOG_PREFIX + errorMessage);
            throw new KSError(KSErrorConstants.SYNC_INVALID_SYNC_TYPE, errorMessage);
        } else if (options[KSPublicConstants.SYNC_TYPE] == KSPublicConstants.DOWNLOAD_ONLY) {
            logger.info(LOG_PREFIX + "Enabling Download only for current Sync session.");
            validateSyncDownloadOptions(options);
        } else if (options[KSPublicConstants.SYNC_TYPE] == KSPublicConstants.UPLOAD_ONLY) {
            logger.info(LOG_PREFIX + "Enabling Upload only for current Sync session.");
            //Call validateSyncUploadOptions(options);
        } else {
            errorMessage = "Invalid value found for syncType option " + options[KSPublicConstants.SYNC_TYPE];
            logger.error(LOG_PREFIX + errorMessage);
            throw new KSError(KSErrorConstants.SYNC_INVALID_SYNC_TYPE, errorMessage);
        }
        logger.info(LOG_PREFIX, "Sync config policy validated.");
    }
    /**
     * Method to validate the user given options
     *
     * @param options Map containing primaryKeys map
     * @return {boolean} True if validation is successful, else false.
     */
    function arePrimaryKeysSentInOptionsValid(options) {
        logger.trace(LOG_PREFIX + "arePrimaryKeysSentInOptionsValid : ", "Start.");
        if (KSCommonUtils.isNullOrEmptyObject(options)) {
            logger.error(LOG_PREFIX, "Options cannot be null/empty. It must contain the primary key(s) of the record.");
            throw new KSError(KSErrorConstants.CRUD_NULL_OR_EMPTY_OPTIONS);
        }
        if (KSCommonUtils.isNullOrEmptyObject(options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS])) {
            logger.error(LOG_PREFIX, "Primary keys supplied through options are either null or empty.");
            throw new KSError(KSErrorConstants.CRUD_NULL_OR_EMPTY_PRIMARY_KEY_VALUE);
        }
        //Validating primaryKeys
        if (arePrimaryKeysValid(options)) {
            logger.info(LOG_PREFIX, "PrimaryKeys validation is successful");
        }
        return true;
    }
    /**
     * Checks whether the validations have to be skipped or not
     *
     * @param options which contains skipValidation flag
     * @return true/false (true if flag is true else false)
     */
    function skipValidation(options) {
        var isSkipped = options && options[kony.sdk.OfflineObjects.KSCRUDConstants.CRUD_OPTION_SKIP_VALIDATION];
        if (isSkipped) {
            logger.info(LOG_PREFIX, "Validations are skipped.");
        }
        return isSkipped;
    }
    /**
     * Validates sdk object record attribute
     *
     * @param objectAttribute attribute object
     * @param value           sdk object record attribute value
     */
    function isValidAttribute(objectAttribute, value) {
        logger.trace(LOG_PREFIX + "isValidAttribute : ", "Start");
        logger.debug(LOG_PREFIX, "Validating SDK object record attribute " + objectAttribute[KSInternalConstants.ATTRIBUTES_NAME] + " with value " + value);
        var dataType = objectAttribute[KSInternalConstants.ATTRIBUTES_DATATYPE];
        var errorMessage;
        switch (dataType) {
            case KSDataTypes.NUMBER:
                {
                    if (typeof value !== KSDataTypes.NUMBER) {
                        errorMessage = "Expected dataType for attribute " + objectAttribute[KSInternalConstants.ATTRIBUTES_NAME] + " is " + objectAttribute[KSInternalConstants.ATTRIBUTES_DATATYPE] + " but actual dataType sent is " + typeof value;
                        logger.error(LOG_PREFIX, errorMessage);
                        throw new KSError(KSErrorConstants.CRUD_DATATYPE_OR_LENGTH_MISMATCH, errorMessage);
                    }
                    break;
                }
            case KSDataTypes.BOOLEAN:
                {
                    if (typeof value !== KSDataTypes.BOOLEAN) {
                        errorMessage = "Expected dataType for attribute " + objectAttribute[KSInternalConstants.ATTRIBUTES_NAME] + " is " + objectAttribute[KSInternalConstants.ATTRIBUTES_DATATYPE] + " but actual dataType sent is " + typeof value;
                        logger.error(LOG_PREFIX, errorMessage);
                        throw new KSError(KSErrorConstants.CRUD_DATATYPE_OR_LENGTH_MISMATCH, errorMessage);
                    }
                    break;
                }
            case KSDataTypes.STRING:
                {
                    if (typeof value !== KSDataTypes.STRING) {
                        errorMessage = "Expected dataType for attribute " + objectAttribute[KSInternalConstants.ATTRIBUTES_NAME] + " is " + objectAttribute[KSInternalConstants.ATTRIBUTES_DATATYPE] + " but actual dataType sent is " + typeof value;
                        logger.error(LOG_PREFIX, errorMessage);
                        throw new KSError(KSErrorConstants.CRUD_DATATYPE_OR_LENGTH_MISMATCH, errorMessage);
                    }
                    if (!objectAttribute[KSInternalConstants.ATTRIBUTES_AUTO_GENERATED]) {
                        var length = value.length;
                        var objectAttributeLength = objectAttribute[KSInternalConstants.ATTRIBUTES_LENGTH];
                        if ((objectAttributeLength > 0) && (length > objectAttributeLength)) {
                            errorMessage = "The validation for length failed for attribute with key " + objectAttribute[KSInternalConstants.ATTRIBUTES_NAME] + " expected length " + objectAttributeLength + " actual length " + length;
                            logger.error(LOG_PREFIX, errorMessage);
                            throw new KSError(KSErrorConstants.CRUD_DATATYPE_OR_LENGTH_MISMATCH, errorMessage);
                        }
                    }
                    break;
                }
            case KSDataTypes.DATE:
                break;
            case KSDataTypes.BINARY:
                break;
        }
        logger.debug(LOG_PREFIX, "Attribute " + objectAttribute[KSInternalConstants.ATTRIBUTES_NAME] + " of type " + dataType + " is valid.");
    }
    /**
     * Validates primaryKeys
     * @param options Map containing the primaryKeysMap
     */
    function arePrimaryKeysValid(options) {
        logger.trace(LOG_PREFIX, "Start");
        if (options.hasOwnProperty(KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS)) {
            var errorMessage;
            var primaryKeyValueMap = options[KSPublicConstants.CRUD_OPTION_PRIMARY_KEYS];
            //Check if primaryKeys is passed as null
            if (kony.sdk.isNullOrUndefined(primaryKeyValueMap)) {
                errorMessage = "primaryKeys is passed as null or undefined";
                logger.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_NULL_OR_EMPTY_PRIMARY_KEY_VALUE, errorMessage);
            }
            if (KSCommonUtils.isInstanceOfMap(primaryKeyValueMap)) {
                logger.debug("Validating primary keys " + JSON.stringify(primaryKeyValueMap));
                if (Object.keys(primaryKeyValueMap).length > 0) {
                    var metadata = options[KSInternalConstants.OBJECT_METADATA];
                    KSCommonUtils.arePrimaryKeyAttributeValuesPresent(primaryKeyValueMap, metadata);
                    var primaryKeyAttributes = metadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS];
                    for (var key in primaryKeyValueMap) {
                        if (primaryKeyValueMap.hasOwnProperty(key)) {
                            if (primaryKeyAttributes.hasOwnProperty(key)) {
                                var value = primaryKeyValueMap[key];
                                var attribute = metadata[KSInternalConstants.ATTRIBUTES][key];
                                isValidAttribute(attribute, value);
                            } else {
                                errorMessage = "primary key with name " + key + " is not a valid primary key";
                                logger.error(LOG_PREFIX, errorMessage);
                                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
                            }
                        }
                    }
                }
            } else {
                errorMessage = "primaryKeys should be of type map";
                logger.error(LOG_PREFIX, errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
        }
        return true;
    }
    /**
     * Check if the value for given key is valid
     * which accepts boolean true/false and String "true"/"false"
     *
     * @param options the crud options
     * @param key     to get the value for the given key
     * @return {boolean} In case of valid options return true, else false
     */
    function isValidBoolTypeOption(options, key) {
        logger.trace(LOG_PREFIX, "isValidBoolTypeOption: " + "Start");
        var isValid = false;
        var errorMessage = "";
        if (!KSCommonUtils.isNullOrEmptyObject(options) && options.hasOwnProperty(key)) {
            var value = options[key];
            if (typeof value === KSInternalConstants.DATA_TYPE_BOOLEAN || (typeof value === KSInternalConstants.DATA_TYPE_STRING && (value === KSInternalConstants.BOOLEAN_VALUE_TRUE || value === KSInternalConstants.BOOLEAN_VALUE_FALSE))) {
                isValid = true;
                logger.debug(LOG_PREFIX + " : isValidBoolTypeOption", "The option " + key + " is set to " + value);
            } else {
                errorMessage = " The value for key " + key + " is invalid";
                logger.error(LOG_PREFIX + " : isValidBoolTypeOption", errorMessage);
                throw new KSError(KSErrorConstants.CRUD_INVALID_OPTIONS, errorMessage);
            }
        }
        return isValid;
    }
    /**
     * Gets the boolean value for the given key
     *
     * @param options      the crud options
     * @param key          to get the value for the given key
     * @param defaultValue is the default value of the key
     * @return the value for key if found, else the default value
     */
    function getOptionValueOrDefaultForGivenKey(options, key, defaultValue) {
        var valueForKey = defaultValue;
        if (!KSCommonUtils.isNullOrEmptyObject(options) && options.hasOwnProperty(key)) {
            valueForKey = (options[key].toString() === KSInternalConstants.BOOLEAN_VALUE_TRUE);
        }
        return valueForKey;
    }
    /**
     * Building queryParams to be sent during request.
     * @param options options sent during sync.
     * @param queryParamsKey key which can be "uploadQueryParams" or "downloadQueryParams"
     */
    function validateAndGetQueryParams(options, queryParamsKey) {
        var queryParams = {};
        if (!KSCommonUtils.isNullOrEmptyObject(options) && !KSCommonUtils.isNullOrEmptyObject(options[queryParamsKey]) && kony.sdk.util.isJsonObject(options[queryParamsKey])) {
            KSCommonUtils.mergeTwoJSONMaps(queryParams, options[queryParamsKey]);
        }
        return queryParams;
    }
    /**
     * Method to validate download options
     * @param syncConfig configuration passed while performing download sync operation
     */
    function validateSyncDownloadOptions(syncConfig) {
        validateDownloadBatchSize(syncConfig);
    }
    /**
     * Method to validate download batch size
     * @param syncConfig configuration passed while performing download sync operation
     */
    function validateDownloadBatchSize(syncConfig) {
        logger.debug(LOG_PREFIX, "validating download batchSize");
        var downloadBatchSize = syncConfig[KSPublicConstants.DOWNLOAD_BATCH_SIZE];
        switch (typeof downloadBatchSize) {
            case "string":
            case "number":
                downloadBatchSize = parseInt(downloadBatchSize);
                downloadBatchSize = isNaN(downloadBatchSize) ? KSInternalConstants.DEFAULT_DOWNLOAD_BATCH_SIZE : downloadBatchSize;
                downloadBatchSize = (downloadBatchSize < 0) ? KSInternalConstants.DEFAULT_DOWNLOAD_BATCH_SIZE : downloadBatchSize;
                break;
            default:
                logger.debug(LOG_PREFIX + "resetting to default batchSize");
                downloadBatchSize = KSInternalConstants.DEFAULT_DOWNLOAD_BATCH_SIZE;
        }
        syncConfig[KSPublicConstants.DOWNLOAD_BATCH_SIZE] = downloadBatchSize;
    }
    /* Method to validate the options provided to Application level sync API
     * @param options                   Options provided to Application level sync API
     * @param objectServiceNamesList    List of ObjectService names from KSSetupManager
     * @return areOptionsValid          True if options are valid
     * @throws error                    error thrown if options are invalid
     */
    function areApplicationSyncOptionsValid(options, objectServiceNamesList) {
        var areOptionsValid = true;
        var errorMessage = null;
        checkAndSetApplicationSyncMode(options);
        var objectServicesOptionsKey = KSPublicConstants.APPLICATION_SYNC_OBJECT_SERVICES_OPTIONS;
        var value = (options.hasOwnProperty(objectServicesOptionsKey)) ? options[objectServicesOptionsKey] : null;
        if (kony.sdk.util.isJsonObject(value)) {
            var objectServicesOptions = value;
            for (var objectServiceName in objectServicesOptions) {
                if (!objectServiceNamesList.contains(objectServiceName)) {
                    errorMessage = "Invalid SDKObjectServiceName " + objectServiceName;
                    areOptionsValid = false;
                    break;
                }
                var objectServiceOption = objectServicesOptions[objectServiceName];
                if (!kony.sdk.util.isJsonObject(objectServiceOption)) {
                    errorMessage = "Options provided for Object Service :" + objectServiceName + ". Expected JSON, found " + typeof(objectServiceOption);
                    areOptionsValid = false;
                    break;
                }
            }
        } else if (!kony.sdk.isNullOrUndefined(value)) {
            errorMessage = "Invalid data type sent for objectServicesOptions. Expected JSON, found " + typeof(value);
            areOptionsValid = false;
        }
        if (!areOptionsValid) {
            logger.error(LOG_PREFIX + "Application sync options provided are invalid." + errorMessage);
            throw new KSError(KSErrorConstants.APPLICATION_SYNC_INVALID_OPTIONS, errorMessage);
        }
        return areOptionsValid;
    }
    /**
     * Method to validate the application sync mode in the options
     * and set it to default option if invalid.
     *
     * @param options Options Provided to Application Sync API
     */
    function checkAndSetApplicationSyncMode(options) {
        var isValid = false;
        var syncModeKey = KSPublicConstants.APPLICATION_SYNC_MODE;
        var value = options.hasOwnProperty(syncModeKey) ? options[syncModeKey] : null;
        if (kony.sdk.util.isValidString(value)) {
            var syncMode = value.toLowerCase();
            if (syncMode === KSPublicConstants.APPLICATION_SYNC_PARALLEL || syncMode === KSPublicConstants.APPLICATION_SYNC_SEQUENTIAL) {
                options[syncModeKey] = syncMode;
                isValid = true;
                logger.debug(LOG_PREFIX, " : isSyncModeValid", "The option " + syncModeKey + " is valid and is set to " + syncMode);
            }
        }
        if (!isValid) {
            options[syncModeKey] = KSPublicConstants.APPLICATION_SYNC_PARALLEL;
            logger.warn(LOG_PREFIX, "Empty or invalid value sent for " + syncModeKey + " option. Falling back to default value as " + KSPublicConstants.APPLICATION_SYNC_PARALLEL);
        }
    }
    exports.skipValidation = skipValidation;
    exports.isValidAttribute = isValidAttribute;
    exports.arePrimaryKeysValid = arePrimaryKeysValid;
    exports.isValidBoolTypeOption = isValidBoolTypeOption;
    exports.validateSyncConfigPolicy = validateSyncConfigPolicy;
    exports.validateAndGetQueryParams = validateAndGetQueryParams;
    exports.arePrimaryKeysSentInOptionsValid = arePrimaryKeysSentInOptionsValid;
    exports.getOptionValueOrDefaultForGivenKey = getOptionValueOrDefaultForGivenKey;
    exports.areApplicationSyncOptionsValid = areApplicationSyncOptionsValid;
    exports.checkAndSetApplicationSyncMode = checkAndSetApplicationSyncMode;
});
/**
 * Module to help build request and process response.
 */
define("KSRequestResponseUtils", ["exports", "KSDownloadResponseParser", "KSCommonUtils", "KSUploadResponseParser"], function(exports, _KSDownloadResponseParser, KSCommonUtils, _KSUploadResponseParser) {
    "use strict";
    exports._esModule = true;
    var logger = kony.sdk.logsdk;
    var LOG_PREFIX = "KSRequestResponseUtils : ";
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSUploadResponseParser = _KSUploadResponseParser.KSUploadResponseParser;
    var KSDownloadResponseParser = _KSDownloadResponseParser.KSDownloadResponseParser;
    //------------------------------
    // OBJECT DOWNLOAD UTIL METHODS
    //------------------------------
    /**
     * Method to build the response object dictionary for object download response.
     * @param downloadResponse Response received from the network.
     * @param objectName Name of the object.
     * @param objectServiceName Name of the object service.
     * @returns {{}} Dictionary of objects containing parsed data, metadata.
     */
    function getObjectDownloadResponseDictionaryFromNetworkResponse(downloadResponse, objectName, objectServiceName) {
        logger.trace(LOG_PREFIX, "Building the object download response dictionary for object : " + objectName);
        var downloadResponseParser = new KSDownloadResponseParser();
        var sdkObjects = downloadResponseParser.getSDKObjectsListFromObjectDownloadResponse(downloadResponse, objectName, objectServiceName);
        var downloadSyncErrors = downloadResponseParser.getDownloadSyncErrors();
        //This gives ERR_MSG, ERR_CODE , OPSTATUS, HTTPSTATUS CODE, DELTACONTEXT
        var metadata = downloadResponseMetadataFromDownloadResponseObject(downloadResponse);
        var objectsDictionary = {};
        objectsDictionary[KSInternalConstants.DATA_OBJECTS] = sdkObjects;
        objectsDictionary[KSInternalConstants.METADATA_OBJECT] = metadata;
        if (!KSCommonUtils.isNullOrEmptyObject(downloadSyncErrors)) {
            objectsDictionary[KSInternalConstants.DOWNLOAD_SYNC_ERRORS] = downloadSyncErrors;
        }
        logger.debug(LOG_PREFIX, "Successfully built the object download response dictionary for object : " + objectName + " in object service: " + objectServiceName);
        return objectsDictionary;
    }
    /**
     * Method to build the metadata dictionary from download response.
     * @param downloadResponse Response obtained from network.
     * @returns {{}} Dictionary containing download metadata.
     */
    function downloadResponseMetadataFromDownloadResponseObject(downloadResponse) {
        logger.trace(LOG_PREFIX, "Building the response metadata dictionary for object download response.");
        var downloadResponseMetadata = {};
        downloadResponseMetadata[KSInternalConstants.METADATA] = downloadResponse[KSInternalConstants._METADATA];
        downloadResponseMetadata[KSInternalConstants.DELTA_CONTEXT] = downloadResponse[KSInternalConstants.DELTA_CONTEXT];
        downloadResponseMetadata[KSInternalConstants.OP_STATUS] = downloadResponse[KSInternalConstants.OP_STATUS];
        downloadResponseMetadata[KSInternalConstants.HTTP_STATUS_CODE] = downloadResponse[KSInternalConstants.HTTP_STATUS_CODE];
        if (!KSCommonUtils.isNullOrEmptyObject(downloadResponse[KSInternalConstants.ERR_CODE])) {
            downloadResponseMetadata[KSInternalConstants.ERR_CODE] = downloadResponse[KSInternalConstants.ERR_CODE];
        }
        if (!KSCommonUtils.isNullOrEmptyObject(downloadResponse[KSInternalConstants.ERR_MSG])) {
            downloadResponseMetadata[KSInternalConstants.ERR_MSG] = downloadResponse[KSInternalConstants.ERR_MSG];
        }
        return downloadResponseMetadata;
    }
    //--------------------------------------
    // OBJECT SERVICE DOWNLOAD UTIL METHODS
    //--------------------------------------
    /**
     * Method to build the response object dictionary for object service download response.
     * @param downloadResponse Response received from the network.
     * @param objectServiceName Name of the object service.
     * @returns {{}} Dictionary of objects containing parsed data, metadata.
     */
    function getObjectServiceDownloadResponseDictionaryFromNetworkResponse(downloadResponse, objectServiceName) {
        var downloadResponseParser = new KSDownloadResponseParser();
        var sdkObjects = downloadResponseParser.getSDKObjectsListFromObjectServiceDownloadResponse(downloadResponse, objectServiceName);
        var metadata = getDownloadResponseMetadataFromObjectServiceDownloadResponse(downloadResponse);
        var objectsDictionary = {};
        objectsDictionary[KSInternalConstants.DATA_OBJECTS] = sdkObjects;
        objectsDictionary[KSInternalConstants.METADATA_OBJECT] = metadata;
        var syncErrors = downloadResponseParser.getDownloadSyncErrors();
        if (!KSCommonUtils.isNullOrEmptyObject(syncErrors)) {
            objectsDictionary[KSInternalConstants.DOWNLOAD_SYNC_ERRORS] = syncErrors;
        }
        return objectsDictionary;
    }
    /**
     * Method to build the metadata dictionary from download response.
     * @param downloadResponse Response obtained from network.
     * @returns {{}} Dictionary containing download metadata.
     */
    function getDownloadResponseMetadataFromObjectServiceDownloadResponse(downloadResponse) {
        logger.trace(LOG_PREFIX, "Building the response metadata dictionary for object service download response.");
        var downloadResponseMetadata = {};
        downloadResponseMetadata[KSInternalConstants.METADATA] = getMetadataForObjectsFromDownloadResponse(downloadResponse);
        downloadResponseMetadata[KSInternalConstants.DELTA_CONTEXT] = downloadResponse[KSInternalConstants.DELTA_CONTEXT];
        downloadResponseMetadata[KSInternalConstants.OP_STATUS] = downloadResponse[KSInternalConstants.OP_STATUS];
        downloadResponseMetadata[KSInternalConstants.HTTP_STATUS_CODE] = downloadResponse[KSInternalConstants.HTTP_STATUS_CODE];
        return downloadResponseMetadata;
    }
    /**
     * Method to parse through the object metadata received in the object service download response.
     * @param downloadResponse Response obtained from network.
     * @returns {{}} Dictionary containing download metadata of each object.
     */
    function getMetadataForObjectsFromDownloadResponse(downloadResponse) {
        logger.trace(LOG_PREFIX, "Building the object metadata dictionary for object service download response.");
        var objectMetadataDictionary = {};
        var objects = downloadResponse[KSInternalConstants.OBJECTS_IN_RESPONSE];
        if (!kony.sdk.isNullOrUndefined(objects)) {
            for (var i = 0; i < objects.length; i++) {
                var object = objects[i];
                var objectDictionary = {};
                var metadata = object[KSInternalConstants._METADATA];
                if (!kony.sdk.isNullOrUndefined(metadata)) {
                    objectDictionary[KSInternalConstants.METADATA] = metadata;
                }
                objectDictionary[KSInternalConstants.OP_STATUS] = object[KSInternalConstants.OP_STATUS];
                objectDictionary[KSInternalConstants.HTTP_STATUS_CODE] = object[KSInternalConstants.HTTP_STATUS_CODE];
                if (!KSCommonUtils.isNullOrEmptyObject(object[KSInternalConstants.ERR_CODE])) {
                    objectDictionary[KSInternalConstants.ERR_CODE] = object[KSInternalConstants.ERR_CODE];
                }
                if (!KSCommonUtils.isNullOrEmptyObject(object[KSInternalConstants.ERR_MSG])) {
                    objectDictionary[KSInternalConstants.ERR_MSG] = object[KSInternalConstants.ERR_MSG];
                }
                objectMetadataDictionary[object[KSInternalConstants.NAME]] = objectDictionary;
            }
        }
        return objectMetadataDictionary;
    }
    /**
     * Constructs the upload payload from given SDKObjectRecords.
     * @param SDKObjectRecords  values to be populated in upload payload.
     * @return JSON of upload payload.
     */
    function buildUploadPayloadFromObjects(SDKObjectRecords) {
        var uploadRequestPayload = {};
        uploadRequestPayload[KSInternalConstants.CHECKSUM] = "";
        uploadRequestPayload[KSInternalConstants.SESSION_ID] = "";
        uploadRequestPayload[KSInternalConstants.ECHO] = [];
        uploadRequestPayload[KSInternalConstants.HAS_MORE_RECORDS] = "false";
        uploadRequestPayload[KSInternalConstants.ABORT_ON_ERROR] = "false";
        uploadRequestPayload[KSInternalConstants._METADATA] = {
            [KSInternalConstants.TOTAL_NAMESPACES]: "0",
            [KSInternalConstants.TOTAL_RECORDS]: "0",
            [KSInternalConstants.TOTAL_OBJECTS]: "0",
            [KSInternalConstants.RECORD_COUNT]: "0"
        };
        uploadRequestPayload[KSInternalConstants.RECORDS] = getRecordsJsonFromSDKObjectRecords(SDKObjectRecords);
        return uploadRequestPayload;
    }
    /**
     * Constructs a JSON array with element as record to upload.
     * @param SDKObjectRecords values to be populated in JSON array.
     * @return {Array} returns the JSON array
     */
    function getRecordsJsonFromSDKObjectRecords(SDKObjectRecords) {
        var jsonarray = [];
        var sdkRecordsLength = SDKObjectRecords.length;
        for (var index = 0; index < sdkRecordsLength; index++) {
            jsonarray.push(buildSDKObjectRecordJson(SDKObjectRecords[index]));
        }
        return jsonarray;
    }
    /**
     * Constructs a JSON from given SDKObjectRecord data.
     * @param SDKObjectRecord
     * @return {*} JSON of SDKObjectRecord data.
     */
    function buildSDKObjectRecordJson(SDKObjectRecord) {
        var dataJson = {};
        KSCommonUtils.mergeTwoJSONMaps(dataJson, SDKObjectRecord.getData());
        dataJson[KSInternalConstants._METADATA] = {
            [KSInternalConstants.OBJECT]: SDKObjectRecord.getParentObject().name,
            [KSInternalConstants.CHECKSUM]: SDKObjectRecord.getCheckSum(),
            [KSInternalConstants.ACTION]: SDKObjectRecord.getAction(),
            [KSInternalConstants.ROW_ID]: SDKObjectRecord.getRowId(),
            [KSInternalConstants.IGNORE_DUPLICATES]: "false",
        };
        return dataJson;
    }
    /**
     * This will parse the upload response and return the JSON which has DATA_OBJECTS and SYNC_ERRORS.
     * @param response  upload network response.
     * @return {*} JSON which has DATA_OBJECTS and SYNC_ERRORS.
     */
    function uploadResponseObjectsDictionaryFromJSONString(response) {
        var responseObjects = response[KSInternalConstants.OBJECTS];
        var uploadResponseParser = new KSUploadResponseParser(responseObjects);
        return uploadResponseParser.getRecordsToPersist();
    }
    /**
     * Returns $expand value available in the operation
     * $expand value will be available in only GET operation of the object
     * @param objectMetadata is metadata object containing operations defined on that KSSDKObject
     * @returns $expand string if defined in "get" operation, empty string otherwise
     */
    function getDollarExpandValueFromObjectOperations(objectMetadata) {
        var objectOperations = objectMetadata[KSInternalConstants.OBJECTS_OPERATIONS];
        if (!KSCommonUtils.isNullOrEmptyObject(objectOperations)) {
            var getOperationObject = objectOperations[KSInternalConstants.KSObjectOperationType.get];
            if (!KSCommonUtils.isNullOrEmptyObject(getOperationObject) && !KSCommonUtils.isNullOrEmptyObject(getOperationObject[KSInternalConstants.DOLLAR_EXPAND])) {
                return getOperationObject[KSInternalConstants.DOLLAR_EXPAND];
            }
        }
        return KSInternalConstants.EMPTY_STRING;
    }
    exports.buildUploadPayloadFromObjects = buildUploadPayloadFromObjects;
    exports.getDollarExpandValueFromObjectOperations = getDollarExpandValueFromObjectOperations;
    exports.uploadResponseObjectsDictionaryFromJSONString = uploadResponseObjectsDictionaryFromJSONString;
    exports.getObjectDownloadResponseDictionaryFromNetworkResponse = getObjectDownloadResponseDictionaryFromNetworkResponse;
    exports.getObjectServiceDownloadResponseDictionaryFromNetworkResponse = getObjectServiceDownloadResponseDictionaryFromNetworkResponse;
});
/**
 * Module to create query objects to perform operations on the indexed DB.
 */
define("KSSQLQueryGenerator", ["exports", "KSQueryObjectBuilder", "KSCommonUtils"], function(exports, KSQueryObjectBuilder, KSCommonUtils) {
    "use strict";
    var LOG_PREFIX = "KSSQLQueryGenerator : ";
    var logger = kony.sdk.logsdk;
    var KSTableType = kony.sdk.OfflineObjects.KSTableType;
    var KSDatabaseConstants = kony.sdk.OfflineObjects.KSDatabaseConstants;
    var KSDatabaseOperation = KSDatabaseConstants.KSDatabaseOperations;
    var KSInternalConstants = kony.sdk.OfflineObjects.KSInternalConstants;
    var KSSDKObjectRecordAction = kony.sdk.OfflineObjects.KSSDKObjectRecordAction;
    var KSDatabaseSchemaVersion = kony.sdk.OfflineObjects.KSDatabaseSchemaVersion;
    /**
     * Method to fetch a record from konysyncMetadataTable with PK objectServiceName.
     * @param objectServiceName
     * @returns {queryBuilderObject}
     */
    function getSQLSelectQueryForMetadataTableProperties(objectServiceName) {
        var whereClause = {};
        whereClause[KSDatabaseConstants.METADATA_TABLE_OBJECT_SERVICE_NAME] = objectServiceName;
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_METADATA, KSDatabaseOperation.SELECT).setWhereClause(whereClause).build();
    }
    /**
     * Method to insert into konysyncMetadataTable.
     * @param objectServiceContext
     * @returns {queryBuilderObject}
     */
    function getMetaDataTableInsertQuery(objectServiceContext) {
        var info = {
            [KSDatabaseConstants.METADATA_TABLE_OBJECT_SERVICE_NAME]: objectServiceContext.name,
            [KSDatabaseConstants.METADATA_TABLE_DELTA_CONTEXT]: objectServiceContext.deltaContext,
            [KSDatabaseConstants.METADATA_TABLE_METADATA_JSON]: objectServiceContext.rootMetadataObject,
            [KSDatabaseConstants.METADATA_TABLE_VERSION]: objectServiceContext.objectServiceVersion
        };
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_METADATA, KSDatabaseOperation.INSERT).addInsertValues(info).build();
    }
    /**
     * Method to insert DBSchemaVersion with latest version number into konysyncProperties table.
     * @returns {queryBuilderObject}
     */
    function getPropertiesTableInsertQuery() {
        var info = {
            [KSDatabaseConstants.PROPERTIES_TABLE_KEY_COLUMN]: KSDatabaseConstants.DB_SCHEMA_VERSION,
            [KSDatabaseConstants.PROPERTIES_TABLE_VALUE_COLUMN]: KSDatabaseSchemaVersion.getLatestVersion()
        };
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_PROPERTIES, KSDatabaseOperation.INSERT).addInsertValues(info).build();
    }
    /**
     * Method to generate create 3 table queries(main, history and original) for an object metadata.
     * @param objectMetadata
     * @return {objectTableName: createQueryString,*}
     */
    function getQueriesToCreateTableForObject(objectMetadata) {
        var queries = {};
        var tableName = objectMetadata[KSInternalConstants.FULLY_QUALIFIED_NAME];
        var historyTableName = getTableNameWithType(tableName, KSTableType.HISTORY);
        var originalTableName = getTableNameWithType(tableName, KSTableType.ORIGINAL);
        logger.trace(LOG_PREFIX, "Began to generate create queries for object: " + tableName);
        queries[tableName] = getQueryToCreateTableForMainTable(objectMetadata);
        queries[historyTableName] = getQueryToCreateTableForHistoryTable(objectMetadata);
        //Since, original table contains same schema as main table.
        queries[originalTableName] = queries[tableName];
        logger.debug(LOG_PREFIX, "Successfully generated create queries for object: " + tableName);
        return queries;
    }
    /**
     * Method to create main table query for given objectMetadata
     * @param objectMetadata
     * @returns {string}
     */
    function getQueryToCreateTableForMainTable(objectMetadata) {
        var query = "" + getPrimaryKeyClauseForCreateQueryMainTable(objectMetadata);
        query += "," + getNonPrimaryKeyAttributes(objectMetadata) + "," + getAttributeFragmentForMainTable();
        return query;
    }
    /**
     * Method to create history table query for given objectMetadata
     * @param objectMetadata
     * @returns {string}
     */
    function getQueryToCreateTableForHistoryTable(objectMetadata) {
        var query = "" + getPrimaryKeyClauseForCreateQueryHistoryTable();
        var attributes = Object.keys(objectMetadata[KSInternalConstants.ATTRIBUTES]);
        query += "," + attributes + "," + getAttributeFragmentForHistoryTable();
        return query;
    }
    /**
     * Method to get primary key clause for create main table query for given objectMetadata
     * @param objectMetadata
     * @returns {string}
     */
    function getPrimaryKeyClauseForCreateQueryMainTable(objectMetadata) {
        var primaryKeyClause = "";
        var primaryKeys = objectMetadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS];
        var keyNames = Object.keys(primaryKeys);
        if (keyNames.length > 1) {
            //For compound primary keys, the first param in [] is the honoured as PK,
            //and the repeated key names get indexed.
            primaryKeyClause += "[" + keyNames.join(KSDatabaseConstants.TABLE_COMPOSITE_PRIMARY_KEY_CONNECTOR) + "]";
            primaryKeyClause += "," + keyNames;
        } else {
            primaryKeyClause += "&" + keyNames;
        }
        return primaryKeyClause;
    }
    /**
     * Method to get primary key clause for create history table query for given objectMetadata
     * @returns {string}
     */
    function getPrimaryKeyClauseForCreateQueryHistoryTable() {
        return "&" + KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER;
    }
    /**
     * Method to get non primary key attributes for create table query for given objectMetadata
     * @param objectMetadata
     * @returns {string[]}
     */
    function getNonPrimaryKeyAttributes(objectMetadata) {
        var attributes = Object.keys(objectMetadata[KSInternalConstants.ATTRIBUTES]);
        var primaryKeyAttributes = Object.keys(objectMetadata[KSInternalConstants.OBJECTS_PRIMARY_KEYS]);
        var nonPrimaryKeyAttributes = attributes;
        for (var primaryKeyIndex in primaryKeyAttributes) {
            var index = nonPrimaryKeyAttributes.indexOf(primaryKeyAttributes[primaryKeyIndex]);
            if (index !== -1) {
                nonPrimaryKeyAttributes.splice(index, 1);
            }
        }
        return nonPrimaryKeyAttributes;
    }
    //----------------------------------------------
    // Attribute fragments
    //----------------------------------------------
    function getAttributeFragmentForMainTable() {
        return [KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE, KSDatabaseConstants.UPLOAD_SESSION_NO, KSDatabaseConstants.KONY_SYNC_HASH_SUM];
    }

    function getAttributeFragmentForHistoryTable() {
        return [KSDatabaseConstants.UPLOAD_SESSION_NO, KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE,
            KSDatabaseConstants.KONY_SYNC_CHANGE_TIME, KSDatabaseConstants.KONY_SYNC_HASH_SUM
        ];
    }

    function getSelectQueryForMetaInfoTable(objectServiceName) {
        var whereClause = {};
        whereClause[KSInternalConstants.SCOPE_NAME] = objectServiceName;
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_META_INFO, KSDatabaseOperation.SELECT).setWhereClause(whereClause).build();
    }

    function getUpdateQueryForMetaInfoTable(objectServiceName, metaInfo) {
        var whereClause = {};
        whereClause[KSInternalConstants.SCOPE_NAME] = objectServiceName;
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_META_INFO, KSDatabaseOperation.UPDATE).setUpdatedData(metaInfo).setWhereClause(whereClause).build();
    }

    function getInsertQueryForMetaInfoTable(metaInfo) {
        return KSQueryObjectBuilder.getQueryObjectForTableName(KSDatabaseConstants.SQL_TABLE_KONY_SYNC_META_INFO, KSDatabaseOperation.INSERT).addInsertValues(metaInfo).build();
    }

    function getMetaInfoTableInsertQueryForObjectService(objectServiceName) {
        var metaInfo = {};
        metaInfo[KSDatabaseConstants.UPLOAD_SESSION_NO] = 0;
        metaInfo[KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER] = 0;
        metaInfo[KSDatabaseConstants.LAST_GENERATED_ID] = -1;
        metaInfo[KSInternalConstants.SCOPE_NAME] = objectServiceName;
        return getInsertQueryForMetaInfoTable(metaInfo);
    }
    /**
     * Method to build queryObjects for the classified records for upload/download flow.
     * @param classifiedRecords Dictionary of records classified according to record action type.
     * @param forUploadSuccess Boolean which states if the query if for upload/download.
     * @returns {Array} Array of query objects to be persisted.
     */
    function getSQLDataQueries(classifiedRecords, forUploadSuccess) {
        var queryObjects = [];
        for (var recordAction in classifiedRecords) {
            var recordArray = classifiedRecords[recordAction];
            if (!KSCommonUtils.isNullOrEmptyObject(recordArray)) {
                Array.prototype.push.apply(queryObjects, getSQLDataBulkQueriesForRecords(recordArray, KSTableType.MAIN, forUploadSuccess));
            }
        }
        return queryObjects;
    }
    /**
     * Method to build the insert query object on original table.
     * @param record Record to be inserted.
     * @param actionType Record action type.
     */
    function getInsertQueryObjectForOriginalTable(record, actionType) {
        var insertData = {};
        KSCommonUtils.mergeTwoJSONMaps(insertData, record.getData());
        insertData[KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE] = actionType;
        insertData[KSDatabaseConstants.KONY_SYNC_HASH_SUM] = record.getCheckSum();
        var tableName = getTableNameWithType(record.parentObject.metadata.name, KSTableType.ORIGINAL);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.INSERT_OR_REPLACE);
        return builder.addInsertValues(insertData).build();
    }
    /**
     * Method to get the update queries for checksum during download flow.
     * @param records Records for which the checksum needs to be updated.
     * @param tableType Type of the table in which the updation should occur.
     * @returns {Array} Array of update query objects.
     */
    function getUpdateChecksumQueryObject(records, tableType) {
        var queryObjects = [];
        if (!KSCommonUtils.isNullOrEmptyObject(records)) {
            var tableName = getTableNameWithType(records[0].parentObject.metadata.name, tableType);
            var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.UPDATE);
            for (var i = 0; i < records.length; i++) {
                var updateMap = {};
                updateMap[KSDatabaseConstants.KONY_SYNC_HASH_SUM] = records[i].getCheckSum();
                var primaryKeys = records[i].getPrimaryKeyValueMapOfRecord(records[i].getParentObject().getPrimaryKeys());
                queryObjects.push(builder.setUpdatedData(updateMap).setWhereClause(primaryKeys).build());
            }
        }
        return queryObjects;
    }
    /**
     * Method to build select queryObjects.
     * @param tableName Name of the table from which a record needs to be READ.
     * @param tableType Type of the table to be READ from.
     * @param whereClause Dictionary containing the where clause.
     * @param orderBy Dictionary for reading in a order.
     */
    function buildPreparedStatementsOfTypeRead(tableName, tableType, whereClause, orderBy) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.SELECT);
        return builder.setWhereClause(whereClause).addOrderByMap(orderBy).build();
    }
    /**
     * Method to build select queryObjects.
     * @param tableName Name of the table from which a record needs to be READ.
     * @param tableType Type of the table to be READ from.
     * @param whereClause String containing the where clause.
     * @param orderBy Dictionary for reading in a order.
     */
    function buildStatementOfTypeReadWithWhereConditionAsString(tableName, tableType, whereClause, orderBy) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.SELECT);
        return builder.setWhereClauseAsString(whereClause).addOrderByMap(orderBy).build();
    }
    /**
     * Method to build delete queryObjects.
     * @param tableName Name of the table from which a record needs to be Deleted.
     * @param tableType Type of the table to be Deleted.
     * @param whereClause Dictionary containing the where clause.
     */
    function buildPreparedStatementsOfTypeDelete(tableName, tableType, whereClause) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.DELETE);
        return builder.setWhereClause(whereClause).build();
    }
    /**
     * Method to build delete queryObjects.
     * @param tableName Name of the table from which a record needs to be Deleted.
     * @param tableType Type of the table to be Deleted.
     * @param whereClause String containing the where clause.
     */
    function buildStatementsOfTypeDeleteWithWhereConditionAsString(tableName, tableType, whereClause) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.DELETE);
        return builder.setWhereClauseAsString(whereClause).build();
    }
    /**
     * Method to build update queryObjects.
     * @param tableName Name of the table from which a record needs to be Updated.
     * @param tableType Type of the table to be Updated.
     * @param whereMap Dictionary containing the where clause.
     * @param updateMap Dictionary containing the update clause.
     */
    function buildPreparedStatementsOfTypeUpdate(tableName, tableType, whereMap, updateMap) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.UPDATE);
        return builder.setUpdatedData(updateMap).setWhereClause(whereMap).build();
    }
    /**
     * Method to build update queryObjects.
     * @param tableName Name of the table from which a record needs to be Updated.
     * @param tableType Type of the table to be Updated.
     * @param whereMap String containing the where clause.
     * @param updateMap Dictionary containing the update clause.
     */
    function buildStatementsOfTypeUpdateWithWhereConditionAsString(tableName, tableType, whereMap, updateMap) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.UPDATE);
        return builder.setUpdatedData(updateMap).setWhereClauseAsString(whereMap).build();
    }
    /**
     * Method to build insert queryObjects.
     * @param tableName Name of the table from which a record needs to be Inserted.
     * @param tableType Type of the table to be Inserted.
     * @param insertValueMap Dictionary containing the insert map.
     */
    function buildPreparedStatementsOfTypeCreate(tableName, tableType, insertValueMap) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.INSERT);
        return builder.addInsertValues(insertValueMap).build();
    }
    /**
     * Method to build insert or replace queryObjects.
     * @param tableName Name of the table from which a record needs to be Inserted or Replaced.
     * @param tableType Type of the table to be Inserted or Replace.
     * @param insertValueMap Dictionary containing the insert map.
     */
    function buildQueryObjectsOfTypeInsertOrReplace(tableName, tableType, insertValueMap) {
        tableName = getTableNameWithType(tableName, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.INSERT_OR_REPLACE);
        return builder.addInsertValues(insertValueMap).build();
    }
    /**
     * Method which generates queryObjects for records to be persisted.
     * @param {Array} recordsToPersist Array of records to be persisted.
     * @param {KSTableType} tableType Type of table in which the persistence should take place.
     * @param {Boolean} forUploadSuccess Boolean which states if this if the queries are for upload or download flow.
     * @returns {Array} Array of query objects generated.
     */
    function getSQLDataBulkQueriesForRecords(recordsToPersist, tableType, forUploadSuccess) {
        var queryObjects = [];
        if (!KSCommonUtils.isNullOrEmptyObject(recordsToPersist)) {
            var recordAction = recordsToPersist[0].getAction();
            switch (recordAction) {
                case KSSDKObjectRecordAction.CREATE:
                    queryObjects = getBulkCreateQueryForRecords(recordsToPersist, tableType);
                    break;
                case KSSDKObjectRecordAction.UPDATE:
                    queryObjects = getBulkUpdateQueryForRecords(recordsToPersist, tableType, forUploadSuccess);
                    break;
                case KSSDKObjectRecordAction.PARTIAL_UPDATE:
                    queryObjects = getPartialUpdateQueriesForRecords(recordsToPersist, tableType);
                    break;
                case KSSDKObjectRecordAction.DELETE:
                    queryObjects = getDeleteQueriesForRecords(recordsToPersist, tableType);
                    break;
                default:
                    logger.debug(LOG_PREFIX, "No queryObjects can be created for given record action.");
            }
        }
        return queryObjects;
    }
    /**
     * Method to create queryObject for bulk create operation.
     * @param recordsToPersist Array of records to be created.
     * @param tableType Type of table in which the creation should occur.
     */
    function getBulkCreateQueryForRecords(recordsToPersist, tableType) {
        var tableName = getTableNameWithType(recordsToPersist[0].getParentObject().name, tableType);
        var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.INSERT);
        for (var i = 0; i < recordsToPersist.length; i++) {
            var dataForInsertion = getDataForInsertion(recordsToPersist[i], tableType);
            builder.addInsertValues(dataForInsertion);
        }
        return [builder.build()];
    }
    /**
     * Method to create queryObject for bulk UPDATE operation.
     * @param recordsToPersist Array of records to be updated.
     * @param tableType Type of table in which the updation should occur.
     * @param forUploadSuccess Boolean depicting upload or download flow.
     * @returns [] object with bulk UPDATE values.
     */
    function getBulkUpdateQueryForRecords(recordsToPersist, tableType, forUploadSuccess) {
        var tableName = getTableNameWithType(recordsToPersist[0].getParentObject().name, tableType);
        if (forUploadSuccess) {
            //Reconcile auto gen PKs for upload..
        } else {
            var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.INSERT_OR_REPLACE);
            for (var i = 0; i < recordsToPersist.length; i++) {
                var dataForInsertion = getDataForInsertion(recordsToPersist[i], tableType);
                builder.addInsertValues(dataForInsertion);
            }
            return [builder.build()];
        }
    }
    /**
     * Method to build the query objects for DELETE.
     * @param recordsToPersist Array of records to be deleted.
     * @param tableType Type of the table on which DELETE should happen.
     * @returns {Array} Array of query objects.
     */
    function getDeleteQueriesForRecords(recordsToPersist, tableType) {
        var queryObjects = [];
        var tableName = getTableNameWithType(recordsToPersist[0].getParentObject().name, tableType);
        for (var i = 0; i < recordsToPersist.length; i++) {
            var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.DELETE);
            var primaryKeyValueMap = recordsToPersist[i].getPrimaryKeyValueMapOfRecord(recordsToPersist[i].getParentObject().getPrimaryKeys());
            queryObjects.push(builder.setWhereClause(primaryKeyValueMap).build());
        }
        return queryObjects;
    }
    /**
     * Method to build query objects for partial updates.
     * @param recordsToPersist Array of records to be partially updated.
     * @param tableType Type of the table on which partial UPDATE should happen.
     * @returns {Array} Array of query objects.
     */
    function getPartialUpdateQueriesForRecords(recordsToPersist, tableType) {
        var queryObjects = [];
        var tableName = getTableNameWithType(recordsToPersist[0].getParentObject().name, tableType);
        for (var i = 0; i < recordsToPersist.length; i++) {
            var builder = KSQueryObjectBuilder.getQueryObjectForTableName(tableName, KSDatabaseOperation.UPDATE);
            var primaryKeyValueMap = recordsToPersist[i].getPrimaryKeyValueMapOfRecord(recordsToPersist[i].getParentObject().getPrimaryKeys());
            queryObjects.push(builder.setUpdatedData(recordsToPersist.getData()).setWhereClause(primaryKeyValueMap).build());
        }
        return queryObjects;
    }
    /**
     * Method to fetch the table name with the type.
     * @param {String} tableName Name of the table.
     * @param {KSTableType} tableType Type of the table.
     */
    function getTableNameWithType(tableName, tableType) {
        if (tableType === KSTableType.HISTORY) {
            return tableName + KSDatabaseConstants.TABLE_TYPE_CONNECTOR_CHARACTER + KSDatabaseConstants.TABLE_TYPE_HISTORY;
        } else if (tableType === KSTableType.ORIGINAL) {
            return tableName + KSDatabaseConstants.TABLE_TYPE_CONNECTOR_CHARACTER + KSDatabaseConstants.TABLE_TYPE_ORIGINAL;
        } else {
            return tableName;
        }
    }
    /**
     * Gives list of table names of main, history and original tables of given table
     * @param tableName
     * @returns {*[]} list of table names of main, history and original tables of given table
     */
    function getAllTableNames(tableName) {
        return [tableName,
            getTableNameWithType(tableName, KSTableType.HISTORY),
            getTableNameWithType(tableName, KSTableType.ORIGINAL)
        ];
    }

    function getPreparedStatementToPerformActionOnMainTable(sdkObjectRecord, primaryKeyValue) {
        var action = sdkObjectRecord.getAction();
        var tableName = sdkObjectRecord.getParentObject().getFullyQualifiedName();
        switch (action) {
            case KSSDKObjectRecordAction.CREATE:
                return buildQueryObjectsOfTypeInsertOrReplace(tableName, KSTableType.MAIN, sdkObjectRecord.getData());
            case KSSDKObjectRecordAction.DELETE:
                return buildPreparedStatementsOfTypeDelete(tableName, KSTableType.MAIN, primaryKeyValue);
            case KSSDKObjectRecordAction.PARTIAL_UPDATE:
            case KSSDKObjectRecordAction.UPDATE:
                var dataToUpdate = {};
                KSCommonUtils.mergeTwoJSONMaps(dataToUpdate, sdkObjectRecord.getData());
                dataToUpdate[KSDatabaseConstants.KONY_SYNC_HASH_SUM] = sdkObjectRecord.getCheckSum();
                return buildPreparedStatementsOfTypeUpdate(tableName, KSTableType.MAIN, primaryKeyValue, dataToUpdate);
            default:
                break;
        }
    }
    /**
     * Method to fetch the meta columns according to the table type.
     * @param tableType Type of the table.
     * @returns {Array} Array of meta columns.
     */
    function getMetaColumnNames(tableType) {
        var metaColumnNames = [];
        //Adding konysynchashsum for all the tables..
        metaColumnNames.push(KSDatabaseConstants.KONY_SYNC_HASH_SUM);
        //Adding uploadsessionno and konysyncchangetype for original table..
        if (tableType !== KSTableType.MAIN) {
            metaColumnNames.push(KSDatabaseConstants.UPLOAD_SESSION_NO);
            metaColumnNames.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE);
        }
        //Adding konysyncchangetime and replaysequencenumber for history table..
        if (tableType === KSTableType.HISTORY) {
            metaColumnNames.push(KSDatabaseConstants.KONY_SYNC_CHANGE_TIME);
            metaColumnNames.push(KSDatabaseConstants.REPLAY_SEQUENCE_NUMBER);
        }
        return metaColumnNames;
    }
    /**
     * Method to build the data for insertion.
     * @param record KSSDKRecord object.
     * @param tableType Type of the table on which the insertion data needs to me built.
     */
    function getDataForInsertion(record, tableType) {
        var metadata = record.getParentObject().getMetadata();
        var columnNames = Object.keys(metadata[KSInternalConstants.ATTRIBUTES]);
        Array.prototype.push.apply(columnNames, getMetaColumnNames(tableType));
        var dataForInsertion = {};
        for (var index = columnNames.length - 1; index >= 0; index--) {
            if (columnNames[index] === KSDatabaseConstants.KONY_SYNC_HASH_SUM) {
                dataForInsertion[columnNames[index]] = record.getCheckSum();
            } else if (columnNames[index] === KSDatabaseConstants.KONY_SYNC_CHANGE_TYPE) {
                dataForInsertion[columnNames[index]] = record.getAction();
            } else if (columnNames[index] === KSDatabaseConstants.UPLOAD_SESSION_NO) {
                dataForInsertion[columnNames[index]] = 0;
            } else {
                var data = record.getData()[columnNames[index]];
                if (typeof data !== 'undefined') {
                    dataForInsertion[columnNames[index]] = data;
                }
            }
        }
        return dataForInsertion;
    }
    exports.getAllTableNames = getAllTableNames;
    exports.getSQLDataQueries = getSQLDataQueries;
    exports.getTableNameWithType = getTableNameWithType;
    exports.getMetaDataTableInsertQuery = getMetaDataTableInsertQuery;
    exports.getUpdateChecksumQueryObject = getUpdateChecksumQueryObject;
    exports.getPropertiesTableInsertQuery = getPropertiesTableInsertQuery;
    exports.getSelectQueryForMetaInfoTable = getSelectQueryForMetaInfoTable;
    exports.getUpdateQueryForMetaInfoTable = getUpdateQueryForMetaInfoTable;
    exports.getInsertQueryForMetaInfoTable = getInsertQueryForMetaInfoTable;
    exports.getQueriesToCreateTableForObject = getQueriesToCreateTableForObject;
    exports.buildPreparedStatementsOfTypeRead = buildPreparedStatementsOfTypeRead;
    exports.buildPreparedStatementsOfTypeDelete = buildPreparedStatementsOfTypeDelete;
    exports.buildPreparedStatementsOfTypeUpdate = buildPreparedStatementsOfTypeUpdate;
    exports.buildPreparedStatementsOfTypeCreate = buildPreparedStatementsOfTypeCreate;
    exports.getInsertQueryObjectForOriginalTable = getInsertQueryObjectForOriginalTable;
    exports.buildQueryObjectsOfTypeInsertOrReplace = buildQueryObjectsOfTypeInsertOrReplace;
    exports.getSQLSelectQueryForMetadataTableProperties = getSQLSelectQueryForMetadataTableProperties;
    exports.getMetaInfoTableInsertQueryForObjectService = getMetaInfoTableInsertQueryForObjectService;
    exports.getPreparedStatementToPerformActionOnMainTable = getPreparedStatementToPerformActionOnMainTable;
    exports.buildStatementOfTypeReadWithWhereConditionAsString = buildStatementOfTypeReadWithWhereConditionAsString;
    exports.buildStatementsOfTypeDeleteWithWhereConditionAsString = buildStatementsOfTypeDeleteWithWhereConditionAsString;
    exports.buildStatementsOfTypeUpdateWithWhereConditionAsString = buildStatementsOfTypeUpdateWithWhereConditionAsString;
});
define("KSSyncErrorUtils", ["exports", "KSCommonUtils"], function(exports, KSCommonUtils) {
    exports._esModule = true;
    "use strict";
    var KSPublicConstants = kony.sdk.OfflineObjects.KSPublicConstants;
    /**
     * Returns the list of error messages in given format ObjectService:<>#Object:<>#Keys: PK1~ PK2#Error: error message
     * @param objectServiceName The Object Service Name
     * @param objectName  The Object Name
     * @param primaryKeyValueMap  Primary Key Value in a map
     * @param opstatus  opstatus from the request
     * @param errorMessages  ErrorMessages List
     * @returns {Array}
     */
    function getSyncErrorsForObject(objectServiceName, objectName, primaryKeyValueMap, opstatus, errorMessages) {
        var syncErrors = {};
        if (!KSCommonUtils.isNullOrEmptyObject(objectServiceName)) {
            syncErrors[KSPublicConstants.OBJECT_SERVICE] = objectServiceName;
        }
        if (!KSCommonUtils.isNullOrEmptyObject(objectName)) {
            syncErrors[KSPublicConstants.OBJECT] = objectName;
        }
        if (!KSCommonUtils.isNullOrEmptyObject(primaryKeyValueMap)) {
            syncErrors[KSPublicConstants.PRIMARY_KEYS] = primaryKeyValueMap;
        }
        if (!KSCommonUtils.isNullOrEmptyObject(opstatus)) {
            syncErrors[KSPublicConstants.OPSTATUS] = opstatus;
        }
        var errorList = [];
        if (!KSCommonUtils.isNullOrEmptyObject(errorMessages)) {
            for (var index = errorMessages.length - 1; index >= 0; index--) {
                syncErrors[KSPublicConstants.ERRMSG] = errorMessages[index];
                errorList.push(syncErrors);
            }
        }
        return errorList;
    }
    /**
     * Returns the list of strings in a format
     *
     * @param objectServiceName The Object Service Name
     * @param errorMessageForGivenObject The errorMessage for the given Object
     * @param primaryKeyValuePair   The Primary Key Value Pair
     * @param opStatus  The opStatus
     * @param objectName  The ObjectName
     * @returns {Array}
     */
    function formatSyncErrors(objectServiceName, errorMessageForGivenObject, primaryKeyValuePair, opStatus, objectName) {
        if (!KSCommonUtils.isNullOrEmptyObject(errorMessageForGivenObject)) {
            return getSyncErrorsForObject(objectServiceName, objectName, primaryKeyValuePair, opStatus, errorMessageForGivenObject);
        }
        return [];
    }
    exports.formatSyncErrors = formatSyncErrors;
});
/**
 * Class to set the MF token and reporting parameters.
 */
define("KSSyncMFUtils", ["exports"], function(exports) {
    "use strict";
    var _token;
    var _reportingParams;
    //TODO: should we clone these properties?
    var setToken = function(token) {
        _token = token;
    };
    var getToken = function() {
        return _token;
    };
    var setReportingParams = function(reportingParams) {
        _reportingParams = reportingParams;
    };
    var getReportingParams = function() {
        return _reportingParams;
    };
    exports.setToken = setToken;
    exports.getToken = getToken;
    exports.setReportingParams = setReportingParams;
    exports.getReportingParams = getReportingParams;
});
define("OfflineObjectsSPA", ["KSApplicationSync", "SDKObjectSync", "SDKObjectServiceSync"], function(KSApplicationSync, _SDKObjectSync, _SDKObjectServiceSync) {
    kony.sdk.OfflineObjects.setup = KSApplicationSync.setup;
    kony.sdk.OfflineObjects.drop = KSApplicationSync.drop;
    kony.sdk.OfflineObjects.reset = KSApplicationSync.reset;
    kony.sdk.OfflineObjects.setToken = KSApplicationSync.setToken;
    kony.sdk.OfflineObjects.setReportingParams = KSApplicationSync.setReportingParams;
    kony.sdk.OfflineObjects.rollback = KSApplicationSync.rollback;
    kony.sdk.OfflineObjects.startSync = KSApplicationSync.startSync;
    kony.sdk.KNYObj.startSync = function(knyObj, syncConfig, successCallback, failureCallback, progressCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.startSync";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.startSync(syncConfig, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.createSDKObjectSync = function(name) {
        var LOG_PREFIX = "kony.sdk.KNYObj.createSDKObjectSync";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSyncInstance = _SDKObjectSync.SDKObjectSync;
        var sdkObjectSync = new sdkObjectSyncInstance(name);
        return sdkObjectSync;
    };
    kony.sdk.KNYObj.create = function(knyObj, record, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.create";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.create(record, options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.update = function(knyObj, record, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.update";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.update(record, options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.updateByPK = function(knyObj, record, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.updateByPK";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.updateByPK(record, options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.deleteByPK = function(knyObj, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.deleteByPK";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.deleteByPK(options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.delete = function(knyObj, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.delete";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.delete(options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.get = function(knyObj, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.get";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.get(options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.getBinary = function(knyObj, options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {};
    kony.sdk.KNYObj.rollback = function(knyObj, primaryKeyValueMap, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.rollback";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.rollback(primaryKeyValueMap, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.markForUpload = function(knyObj, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.markForUpload";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.markForUpload(options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.getUploadDeferredRecordKeys = function(knyObj, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObj.getUploadDeferredRecordKeys";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.getUploadDeferredRecordKeys(successCallback, failureCallback);
    };
    kony.sdk.KNYObj.getPendingRecordsForUpload = function(knyObj, options, successCallback, failureCallback) {
        kony.sdk.logsdk.trace(" Entering kony.sdk.KNYObj.getPendingRecordsForUpload");
        var sdkObjectSync = knyObj.getSdkObjectSync();
        sdkObjectSync.getPendingRecordsForUpload(options, successCallback, failureCallback);
    };
    kony.sdk.KNYObj.cancelSync = function(knyObj, options, successCallback, failureCallback) {};
    kony.sdk.KNYObjSvc.createSDKObjectServiceSync = function(name) {
        var LOG_PREFIX = "kony.sdk.KNYObjSvc.createSDKObjectServiceSync";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectServiceSyncInstance = _SDKObjectServiceSync.SDKObjectServiceSync;
        var sdkObjectServiceSync = new sdkObjectServiceSyncInstance(name);
        return sdkObjectServiceSync;
    };
    kony.sdk.KNYObjSvc.startSync = function(knyObjSvc, syncConfig, successCallback, failureCallback, progressCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObjSvc.startSync";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectServiceSync = knyObjSvc.getSdkObjectServiceSync();
        sdkObjectServiceSync.startSync(syncConfig, successCallback, failureCallback, progressCallback);
    };
    kony.sdk.KNYObjSvc.cancelSync = function(knyObjSvc, options, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObjSvc.cancelSync";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectServiceSync = knyObjSvc.getSdkObjectServiceSync();
        sdkObjectServiceSync.cancelSync(options, successCallback, failureCallback);
    };
    kony.sdk.KNYObjSvc.clearOfflineData = function(knyObjSvc, options, successCallback, failureCallback) {};
    kony.sdk.KNYObjSvc.rollback = function(knyObjSvc, successCallback, failureCallback) {
        var LOG_PREFIX = "kony.sdk.KNYObjSvc.rollback";
        kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
        var sdkObjectServiceSync = knyObjSvc.getSdkObjectServiceSync();
        sdkObjectServiceSync.rollback(successCallback, failureCallback);
    };
});
require(["OfflineObjectsSPA"]);
kony.decrement = function(num) {
    if (typeof(num) === "number") {
        return num - 1;
    } else {
        return num;
    }
};
kony.increment = function(num) {
    if (typeof(num) === "number") {
        return num + 1;
    } else {
        return num;
    }
};
kony.decrementIndices = function(arr) {
    var tArr = [];
    for (var i = 0; i < arr.length; i++) {
        tArr[i] = arr[i] - 1;
    }
    return tArr;
};
kony.incrementIndices = function(arr) {
    var tArr = [];
    for (var i = 0; i < arr.length; i++) {
        tArr[i] = arr[i] + 1;
    }
    return tArr;
};
/**The Math Library has APIs that you can use to perform mathematical operations.*/
kony.math = {
        /**@Deprecated. This API returns the value of pi. Note: math.pi is not a function, but a property in math namespace.*/
        pi: Math.PI,
        /**@Deprecated. This API generates pseudo-random numbers which are uniformly distributed. This API generates a real number between 0 and 1.*/
        random: function() {
            return (Math.random());
            /*var result = Math.random();
	
		if (0 === args.length) {
			return result;
		} else if (1 === args.length) {
			args[0] -= 0;
			if (isNaN(args[0])) {
				throw new Error("Invalid argument to math.random");
			}
	
			result = Math.floor(result * args[0]) + 1;
		} else if (2 === args.length) {
			args[0] -= 0; args[1] -= 0;
			if (isNaN(args[0]) || isNaN(args[1])) {
				throw new Error("Invalid argument(s) to math.random");
			}
	
			result = Math.floor(result * (args[1] - args[0] + 1)) + args[0];
		} else {
			throw new Error("Invalid number of arguments to math.random");
		}
	
		return result;*/
        },
        /*
        randomseed: function (args) {
        	return null;
        },
        */
        /**@Deprecated. This API sets the input parameter as the "seed" for the pseudo-random generator.
        Note: Equal seeds produce equal sequences of numbers.*/
        randomSeed: function(num) {
            pseudoRandomArray = [];
            if (isNaN(num)) throw new Error("Invalid argument to math.randomseed");
            if (!pseudoRandomArray[num]) {
                pseudoRandomArray[num] = Math.random();
            }
            return pseudoRandomArray[num];
        },
        /**@Deprecated. This API converts the float value to an integer. The converted integer value is always the integer part of the specified float number (number before the decimal).*/
        toInteger: function(num) {
            num -= 0;
            if (isNaN(num)) {
                throw new Error("Invalid argument to math.tointeger");
            }
            return Math.floor(num);
        },
        /**@Deprecated. This API raises the first parameter to the power of the second parameter and returns the result.*/
        pow: function(num1, num2) {
            num1 -= 0;
            num2 -= 0;
            if (isNaN(num1) || isNaN(num2)) {
                throw new Error("Invalid argument(s) to math.pow");
            }
            return Math.pow(num1, num2);
        },
        findExtreme: function(extreme, args) {
            if (args.length < 2) {
                throw new Error((extreme ? "math.max" : "math.min") + " needs atleast two arguments");
            }
            var result = args[0] - 0;
            if (isNaN(result)) {
                throw new Error("Invalid argument to " + (extreme ? "math.max" : "math.min"));
            }
            for (var i = 1; i < args.length; i++) {
                args[i] -= 0;
                if (isNaN(args[i])) {
                    throw new Error("Invalid argument to " + (extreme ? "math.max" : "math.min"));
                }
                if (extreme) {
                    if (result < args[i]) {
                        result = args[i];
                    }
                } else {
                    if (result > args[i]) {
                        result = args[i];
                    }
                }
            }
            return result;
        },
        /**@Deprecated. This API returns the minimum value among the arguments.*/
        min: function() {
            return kony.math.findExtreme(false, arguments);
        },
        /**@Deprecated. This API returns the maximum value among the arguments.*/
        max: function() {
            return kony.math.findExtreme(true, arguments);
        },
        /**@Deprecated. This API returns the square root of the given number.*/
        sqrt: function(num) {
            num -= 0;
            if (isNaN(num)) {
                throw new Error("Invalid argument to math.sqrt");
            }
            var result = Math.sqrt(num);
            return isNaN(result) ? "nan" : result;
        }
    }
    /**The string Library has APIs that you can use to manipulate strings. The kony.string name space provides static string APIs. These static APIs augment the APIs in the Global string object which is available by default. For more information refer, https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/string.*/
kony.string = {
        /**@Deprecated This API finds the first occurrence of the search string in the source string. */
        find: function() {
            if (arguments.length < 2) {
                throw new Error("string.find needs atleast two arguments");
            }
            for (var i = 0; i < 2; i++) {
                if (typeof(arguments[i]) === "number") {
                    arguments[i] = arguments[i].toString();
                } else if (typeof(arguments[i]) !== "string") {
                    throw new Error("Invalid argument(s) to string.find");
                }
            }
            var beginIndex = 0;
            if (arguments.length > 2) {
                beginIndex = arguments[2] - 0;
                if (!isNaN(beginIndex)) {
                    if (beginIndex < 0) {
                        beginIndex += arguments[0].length;
                        if (beginIndex < 0) beginIndex = 0;
                    }
                } else {
                    beginIndex = 0;
                }
            }
            var result = arguments[0].indexOf(arguments[1], beginIndex - 1);
            if (-1 === result) {
                return null;
            } else {
                ////result++;
                //return result, result + arguments[1].length - 1;
                return result;
            }
        },
        /**@Deprecated This API returns the length of the source string. */
        len: function(s) {
            if (0 === arguments.length) {
                throw new Error("string.len needs atleast one argument");
            }
            if (typeof(s) === "number") {
                s = s.toString();
            } else if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.len");
            }
            return arguments[0].length;
        },
        /**@Deprecated This API compares the contents of two strings numerically. For example, "Adam" is smaller than "adam" as per the ASCII table because A(65) is smaller than a(97). */
        compare: function(s1, s2) {
            if (arguments.length < 2) {
                throw new Error("string.compare needs atleast two arguemnts");
            }
            if (typeof(s1) == "string" && typeof(s2) == "string") {
                if (s1 < s2) {
                    return -1;
                } else if (s1 == s2) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                throw new Error("Invalid argument(s) to string.compare");
            }
        },
        /**@Deprecated This API returns a string which contains a single character from the source string at the specified index. */
        charat: function(s1, index) {
            if (arguments.length < 2) {
                throw new Error("string.charat needs atleast two arguments");
            }
            if (typeof(s1) === "number") {
                s1 = s1.toString();
            } else if (typeof(s1) !== "string") {
                throw new Error("Invalid argument to string.charat");
            }
            index -= 0;
            if (isNaN(index)) {
                throw new Error("Invalid argument to string.charat");
            }
            ////index--;
            if (index < 0 || index >= s1.length) {
                return null;
            }
            return s1.charAt(index);
        },
        flipCase: function(args, flag) {
            if (0 === args.length) {
                throw new Error(flag ? "string.upper" : "string.lower" + " needs atleast one argument");
            }
            if (typeof(args[0]) !== "string") {
                throw new Error("Invalid argment to " + flag ? "string.upper" : "string.lower");
            }
            if (flag) {
                return args[0].toUpperCase();
            } else {
                return args[0].toLowerCase();
            }
        },
        /**@Deprecated This API changes the upper case characters of the source string to lower case characters. */
        lower: function() {
            return kony.string.flipCase(arguments, false);
        },
        /**@Deprecated This API changes the lower case characters of the source string to upper case characters.*/
        upper: function() {
            return kony.string.flipCase(arguments, true);
        },
        /**This API generates a string which is equivalent to "n copies of the source string concatenated together".*/
        rep: function(s, n) {
            if (arguments.length < 2) {
                throw new Error("Insufficient arguments to string.rep");
            }
            if (typeof(s) === "number") {
                s = s.toString();
            } else if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.rep");
            }
            n -= 0;
            if (isNaN(n)) {
                throw new Error("Invalid argument to string.rep");
            }
            var resultStr = "";
            for (var i = 0; i < n; i++) {
                resultStr += s;
            }
            return resultStr;
        },
        /**This API reverses the characters in the source string.*/
        reverse: function(s) {
            if (0 === arguments.length) {
                throw new Error("string.reverse needs atleast one argument");
            }
            if (typeof(s) === "number") {
                s = s.toString();
            } else if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.reverse");
            }
            var resultStr = "";
            for (var i = s.length - 1; i >= 0; i--) {
                resultStr += s.charAt(i);
            }
            return resultStr;
        },
        /**This API removes the leading and ending spaces from the source string.*/
        trim: function(s) {
            if (0 === arguments.length) {
                throw new Error("string.trim needs atleast one argument");
            }
            if (s === undefined) {
                return s;
            } else if (typeof(s) !== "string") {
                return s.toString();
                //throw new Error("Invalid argument to string.trim");
            }
            return s.replace(/^\s*/, "").replace(/\s*$/, "");
        },
        /**Determines whether two strings contain the same data, ignoring the case of the letters in the String. */
        equalsIgnoreCase: function(s1, s2) {
            if (arguments.length < 2) {
                throw new Error("string.equalsIgnoreCase needs atleast two arguments");
            }
            if (typeof(s1) !== "string" || typeof(s2) !== "string") {
                throw new Error("Invalid argument(s) to string.equalsIgnoreCase");
            }
            return (s1.toLowerCase() === s2.toLowerCase());
        },
        equals: function(s1, s2) {
            if (arguments.length < 2) {
                throw new Error("string.equals needs atleast two arguments");
            }
            if (typeof(s1) !== "string" || typeof(s2) !== "string") {
                throw new Error("Invalid argument(s) to string.equals");
            }
            return (s1 === s2);
        },
        matchEnds: function(args, end) {
            if (args.length < 2) {
                throw new Error(end ? "string.endsWith" : "string.startsWith" + " needs atleast two arguments");
            }
            if (typeof(args[0]) !== "string" || typeof(args[1]) !== "string") {
                throw new Error("Invalid argument(s) to " + end ? "string.endsWith" : "string.startsWith");
            }
            if (!(args.length > 2 && (args[2] === false || args[2] === null))) {
                args[0] = args[0].toLowerCase();
                args[1] = args[1].toLowerCase();
            }
            if (end) {
                var ll = args[0].lastIndexOf(args[1]);
                if (ll < 0) {
                    return false;
                } else {
                    return (args[0].lastIndexOf(args[1]) === args[0].length - args[1].length);
                }
            } else {
                return (args[0].indexOf(args[1]) === 0);
            }
        },
        /**This API returns a boolean value indicating if the source string begins with the specified string. */
        startsWith: function(sourcestring, comparestring, ignorecase) {
            return kony.string.matchEnds(arguments, false);
        },
        /**This API returns a boolean value indicating if the source string ends with the specified string. */
        endsWith: function(sourcestring, comparestring, ignorecase) {
            return kony.string.matchEnds(arguments, true);
        },
        /**@Deprecated This API splits the source string based on the separator (default is comma) and returns a table containing the string. */
        split: function(s, sep) {
            if (0 === arguments.length) {
                throw new Error("string.split needs atleast one argument");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.split");
            }
            var delim;
            if (arguments.length > 1) {
                if (typeof(sep) !== "string") {
                    throw new Error("The optional delimitor for string.split must be a string");
                }
                delim = sep;
            } else {
                delim = ",";
            }
            var splitstr = new Array();
            if (delim == "") {
                splitstr[1] = s;
            } else {
                splitstr = s.split(delim);
                splitstr.unshift(null); //To match lua Array indexing.
            }
            return splitstr;
        },
        /**@Deprecated This API returns the substring of the source string. */
        sub: function() {
            function getIndex(i, len) {
                if (typeof(i) === "string") {
                    i -= 0;
                } else if (typeof(i) !== "number") {
                    throw new Error("Invalid argument to string.sub");
                }
                if (i < 0) {
                    ////return (i + len + 1);
                    return (i + len - 1);
                } else if (i > len) {
                    return len;
                }
                return i;
            }

            function adjustIndex(i) {
                if (i > 0) {
                    return i - 1;
                } else {
                    return 0;
                }
            }
            if (arguments.length < 2) {
                throw new Error("string.sub needs atleast two arguments");
            }
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
                args[i] = arguments[i];
            }
            if (typeof(args[0]) === "number") {
                args[0] = args[0].toString();
            } else if (typeof(args[0]) !== "string") {
                throw new Error("Invalid argument to string.sub");
            }
            var startIndex = getIndex(args[1], args[0].length);
            var endIndex = args[0].length;
            if (args.length > 2) {
                endIndex = getIndex(args[2], args[0].length);
            }
            if (endIndex < startIndex || (0 === startIndex && endIndex === startIndex)) {
                return "";
            } else {
                ////startIndex = adjustIndex(startIndex); endIndex = adjustIndex(endIndex);
                return args[0].slice(startIndex, endIndex + 1);
            }
        },
        /**@Deprecated This API finds and replaces the occurrences of a string in the source string with a string you specify. */
        replace: function(s, f, rep) {
            if (arguments.length < 3) {
                throw new Error("string.replace needs atleast three arguments");
            }
            if (typeof(s) !== "string" || typeof(f) !== "string" || typeof(rep) !== "string") {
                throw new Error("Invalid argument(s) to string.replace");
            }
            //return [s.replace(f, rep)];
            // Replace all occurrences
            //var exp1 = new RegExp(f, "g");
            var exp1 = new RegExp(kony.string.escapeRegExp(f), "g");
            return (s != "" && f == "") ? s : s.replace(exp1, rep);
        },
        /*
        format: function (args) {
        	if (0 === args.length) {
        		throw new Error("string.format needs atleast one argument");
        	}
	
        	if (typeof(args[0]) === "number") {
        		return args[0].toString();
        	} else if (typeof(args[0]) === "string") {
        		var toks = args[0].split(/(%[f,s,b])/);
	
        		var flag = false;
        		var result = "";
        		for (var i = 0, j = 1; i < toks.length; i++) {
        			if ("%f" === toks[i] || "%s" === toks[i] || "%b" === toks[i]) {
        				if (j === args.length) {
        					throw new Error("Insufficient number of arguments to string.format");
        				}
	
        				if ("%f" === toks[i]) {
        					var num = args[j] - 0;
	
        					if (isNaN(num)) {
        						throw new Error("Invalid argument to string.format");
        					}
	
        					result += num;
        				} else if ("%s" === toks[i]) {
        					result += args[j].toString();
        				} else if ("%b" === toks[i]) {
        					if (args[j] === false || args[j] === null) {
        						result += "false";
        					} else {
        						result += "true";
        					}
        				}
	
        				j++;
        			} else {
        				result += toks[i];
        			}
        		}
	
        		return result;
        	} else {
        		throw new Error("Invalid first argument to string.format");
        	}
        }, */
        /** This API verifies if the input string contains only ASCII alphabet characters and returns a boolean value. */
        isAsciiAlpha: function(s) {
            if (arguments.length === 0) {
                throw new Error("string.isAsciiAlpha needs atleast 1 argument");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.isAsciiAlpha");
            }
            var regexp = new RegExp("[^a-zA-Z]", "g");
            return (s == "") ? false : !(regexp.test(s));
        },
        /** This API verifies if the input string contains only ASCII alphabet characters and numbers, and returns a boolean value.*/
        isAsciiAlphaNumeric: function(str) {
            if (arguments.length === 0) {
                throw new Error("string.isAsciiAlphaNumeric needs atleast 1 argument");
            }
            var p1 = /[^a-zA-Z0-9]/i; // Elimimate non alpha numeric chars //Added cap letters also 
            var p2 = /^[a-zA-Z0-9]*$/i; /* Wrong regex   /([a-z]+[0-9])|([0-9]+[a-z])/i; */
            var r1 = str.match(p1);
            var r2 = str.match(p2);
            return (!r1 && r2 && str) ? true : false;
        },
        /** This API verifies if the input string contains only numeric characters, and returns a boolean value.*/
        isNumeric: function(s) {
            if (arguments.length === 0) {
                throw new Error("string.isNumeric needs atleast 1 argument");
            }
            /*if (typeof(args[0]) !== "string") {
            	throw new Error("Invalid argument(s) to string.isNumeric");
            }*/
            return (s == "" || (typeof(s) == "string" && s.replace(/\s/g, '').length == 0)) ? false : !(isNaN(s));
        },
        /** This API verifies if any one of the specified set of characters is available in the given string and returns a boolean value.*/
        containsChars: function(s, a) {
            if (arguments.length === 0) {
                throw new Error("string.containsChars needs 2 arguments");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.containsChars");
            }
            if (a instanceof Array === false) {
                throw new Error("Invalid argument to table.containsChars");
            }
            var charset = [];
            var charstr = "";
            var chararray = a;
            var len = chararray.length;
            var result = false;
            for (var i = 0; i < len; i++) {
                charset[i] = chararray[i];
                if (s == "" || charset[i] == "") return true;
            }
            charstr = charset.join("");
            charstr = "[" + kony.string.escapeRegExp(charstr) + "]";
            var regexp = new RegExp(charstr, "g");
            result = regexp.test(s);
            return result;
        },
        /** This API verifies if only (and only) the specified set of characters is available in the given string and returns a boolean value.*/
        containsOnlyGivenChars: function(s, a) {
            if (arguments.length === 0) {
                throw new Error("string.containsOnlyGivenChars needs atleast 1 argument");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.containsOnlyGivenChars");
            }
            var charset = [];
            var charstr = "";
            var chararray = a;
            var len = chararray.length;
            var result = false;
            for (var i = 0; i < len; i++) {
                charset[i] = chararray[i];
            }
            charstr = charset.join("");
            //charstr = charstr.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            charstr = "[^" + kony.string.escapeRegExp(charstr) + "]";
            var regexp = new RegExp(charstr, "g");
            result = regexp.test(s);
            if (result === false) {
                return true;
            } else {
                return false;
            }
        },
        /** This API verifies that the input string does not contain any of the specified characters and returns a boolean value.*/
        containsNoGivenChars: function(s, a) {
            if (arguments.length === 0) {
                throw new Error("string.containsNoGivenChars needs 2 arguments");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.containsNoGivenChars");
            }
            if (a instanceof Array === false) {
                throw new Error("Invalid argument to table.containsNoGivenChars");
            }
            var charset = [];
            var charstr = "";
            var chararray = a;
            var len = chararray.length;
            var result = false;
            for (var i = 0; i < len; i++) {
                charset[i] = chararray[i];
                if (charset[i] == "") return false;
            }
            charstr = charset.join("");
            charstr = "[" + kony.string.escapeRegExp(charstr) + "]";
            var regexp = new RegExp(charstr, "g");
            result = regexp.test(s);
            if (result === false) {
                return true;
            } else {
                return false;
            }
        },
        /** This API verifies if the input string is a valid email address and returns a boolean value.*/
        isValidEmail: function(s) {
            if (arguments.length === 0) throw new Error("string.isValidEmail needs atleast 1 argument");
            var value = s;
            if (typeof(value) !== "string") return false;
            //(99.9% syntactic accuracy)
            var emailPattern = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
            if ((value.length - value.lastIndexOf('.')) < 3) {
                return false;
            }
            return emailPattern.test(value);
        },
        escapeRegExp: function(text) {
            return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
    }
    /**@Deprecated This library provides generic functions for table manipulation. It provides all its functions inside the table.

    Most functions in the Table library assume that the table represents an array or a list. For these functions, when we talk about the "length" of a table we mean the result of the length operator.

    Note: This library is also available in JavaScript under the namespace kony.table. This is only for maintaining the backward compatibility for the application converted from Lua to JavaScript.*/
kony.table = {
        /**@Deprecated This API extracts all the elements of a table and concatenates the elements to form a string. A separator can be specified which can be placed between concatenated elements.*/
        concat: function(inputtable, separator, startposition, endposition) {
            var isArgsError = false;
            var isInternalError = false;
            var result = null;
            if (!arguments[0] instanceof Object) isArgsError = true;
            if (!isArgsError) {
                var len = arguments[0].length;
                var begin = 0,
                    end = len,
                    sep = ""; //4901
                var numArgs = arguments.length > 4 ? 4 : (arguments.length - 1);
                switch (arguments.length) {
                    case 4:
                        arguments[3] -= 0;
                        if (isNaN(arguments[3])) {
                            isArgsError = true;
                        }
                        end = arguments[3];
                    case 3:
                        arguments[2] -= 0;
                        if (isNaN(arguments[2]) || arguments[2] < 0) {
                            isArgsError = true;
                        }
                        begin = arguments[2];
                    case 2:
                        sep = arguments[1];
                    default:
                        break;
                }
                if (len == 0) return kony.table.returnResult("", isArgsError, isInternalError);
                if (isArgsError) return kony.table.returnResult(result, isArgsError, isInternalError);
                if (begin > end) {
                    //isArgsError = true; // return empty string -- lua std
                    return kony.table.returnResult("", isArgsError, isInternalError);
                } else
                if (end > len) {
                    isArgsError = true;
                } else
                if (!isArgsError) {
                    result = "";
                    try {
                        for (var i = begin; i < end; i++) {
                            if (arguments[0][i] == null || arguments[0][i] instanceof Object) return kony.table.returnResult(null, true, isInternalError);
                            result += arguments[0][i].toString() + sep;
                        }
                        result += arguments[0][i].toString();
                    } catch (e) {
                        isInternalError = true;
                    }
                }
            }
            return kony.table.returnResult(result, isArgsError, isInternalError);
        },
        /*maxn: function(args) {
            if (0 === arguments.length) {
                throw new Error("table.maxn needs atleast one argument");
            }
            
            if (args[0] instanceof LuaTable === false) {
                throw new Error("Invalid argument to table.maxn");
            }
            
            var maxIndex = args[0].arrayContainer.length - 1;
            for (var obj in args[0].hashContainer) {
                var key = args[0].hashContainer[obj].key;
                if (args[0].hashContainer[obj].value !== null &&
                typeof(key) === "number" &&
                maxIndex < key) {
                    maxIndex = key;
                }
            }	    
            return maxIndex;
        },*/
        /**@Deprecated This API inserts a specified value into the given table in the list part. If a position is specified, the value is inserted before the element currently at that position. If no position is specified, the value is appended to the end of the table. If the specified position is not within the range of the list part of the table, the new element is added to the hash part of the table.*/
        insert: function(inputtable, position, value) {
            var isArgsError = false;
            var isInternalError = false;
            var result = null;
            if (arguments.length < 2 || !(arguments[0] instanceof Object)) {
                isArgsError = true;
            }
            if (!isArgsError) {
                var pos, newItem;
                // var arr = arguments[0];	
                if (arguments.length > 2) {
                    pos = arguments[1];
                    if (typeof pos == "string" || isNaN(pos)) {
                        return kony.table.returnResult(true, isInternalError);
                    }
                    newItem = arguments[2];
                } else {
                    pos = arguments[0].length;
                    newItem = arguments[1];
                    /*if(args[1] == null) // don't insert nil at the end of table -- lua std 
                    	return kony.table.returnResult(args[0], isArgsError, isInternalError);*/
                }
                try {
                    if (typeof pos == "string" || pos >= arguments[0].length || pos <= 0) {
                        if (pos == 0) {
                            //DEF 3809
                            arguments[0].splice(pos, 0, newItem);
                            //arguments[0][pos] = newItem;
                        } else {
                            arguments[0][pos] = newItem;
                        }
                    } else {
                        /*   var pre = arguments[0].slice(0, pos);
                           var post = arguments[0].slice(pos);
                           pre.push(newItem);
                           arguments[0] = pre.concat(post);*/
                        arguments[0].splice(pos, 0, newItem);
                    }
                    //arguments[0] = arr;		
                } catch (e) {
                    isInternalError = true;
                }
            }
            return kony.table.returnResult(isArgsError, isInternalError);
        },
        /**@Deprecated This API removes an element from the list part of the table. If a position is specified, the element at the position is removed. If no position is specified, the last element in the table is removed. The removed element is returned. This API operates only on the list part of the table.*/
        remove: function(inputtable, position) {
            var isArgsError = false;
            var result = null;
            if (0 === arguments.length || !(arguments[0] instanceof Array)) {
                isArgsError = true;
            }
            if (!isArgsError) {
                var pos = arguments[0].length - 1;
                if (pos >= 0) {
                    if (arguments.length > 1 && arguments[1] != null) {
                        arguments[1] -= 0;
                        if (isNaN(arguments[1]) || arguments[1] > pos || arguments[1] < 0) {
                            isArgsError = true;
                            return kony.table.returnResult(result, isArgsError, false);
                        }
                        if (arguments[1] < pos && arguments[1] >= 0) {
                            pos = arguments[1] //-1;//5.0 Decremented
                        }
                    }
                    result = arguments[0].splice(pos, 1);
                    result = result[0];
                    /*for(var i=pos;i > 0;i--){
                    	result = args[0].arrayContainer.splice(i, 1);
                    	if(result[0] == null && i == args[0].length()+1)
                    		continue;
                    	else
                    		break;				
                    }*/
                } else return kony.table.returnResult(null, isArgsError, false);
            }
            return kony.table.returnResult(result, isArgsError, false);
        },
        /**@Deprecated This API sorts the elements of the input table and returns the modified table. This API sorts only the list part of the table and the hash part of the table is ignored.*/
        sort: function(inputtable, sortkey, comparisonfunction) {
            var isArgsError = false;
            var isInternalError = false;
            var result = null;
            var comparator = null;
            if (0 === arguments.length || !(arguments[0] instanceof Array)) {
                isArgsError = true;
            }
            if (typeof(arguments[1]) == "function") {
                comparator = arguments[1];
            } else
            if (typeof(arguments[2]) == "function") {
                comparator = arguments[2];
            }
            if (!isArgsError) {
                var len = arguments[0].length;
                var pre = arguments[0];
                if (arguments[0].length < 2) {
                    //Can't do aything. Need more than one element to sort
                    return kony.table.returnResult(inputtable, false, false);
                }
                try {
                    for (var i = 0; i < len; i++) { //5.0 Decremented i
                        var elemType = typeof(arguments[0][1]);
                        if (arguments[0][i] == null || typeof(arguments[0][i]) != elemType) {
                            return kony.table.returnResult(true, isInternalError);
                        }
                    }
                    // pre = arguments[0].slice(1);
                    //var zeroth = arguments[0].shift();
                    //This is to splice the array to the length to which it has to be sorted
                    if (arguments[1] !== null && !isNaN(arguments[1])) pre.splice(arguments[1], pre.slice(arguments[1], pre.length).length);
                    if (comparator) {
                        pre.sort(function(a, b) {
                            var retVals = comparator(a, b);
                            return (retVals ? -1 : 1);
                        });
                    } else
                    if (typeof arguments[1] == "string") {
                        comparator = arguments[1];
                        pre.sort(function(a, b) {
                            if (a[comparator] != null && typeof a[comparator] == typeof b[comparator] && typeof a[comparator] == "string") {
                                var nameA = a[comparator].toLowerCase(),
                                    nameB = b[comparator].toLowerCase()
                                if (nameA < nameB) //sort string ascending
                                    return -1
                                if (nameA > nameB) return 1
                                return 0 //default return value (no sorting)				
                            } else {
                                return a[comparator] - b[comparator];
                            }
                        });
                    } else {
                        pre.sort(function(a, b) {
                            if (typeof a == "string") {
                                var A = a.toLowerCase();
                                var B = b.toLowerCase();
                                if (A < B) {
                                    return -1;
                                } else
                                if (A > B) {
                                    return 1;
                                } else {
                                    return 0;
                                }
                            } else return a - b;
                        });
                    }
                    // pre.unshift(zeroth);
                    // pre = pre.concat(arguments[0]);
                } catch (e) {
                    isInternalError = true;
                    pre = null;
                }
            }
            if (!isArgsError && !isInternalError) return kony.table.returnResult(pre, isArgsError, isInternalError);
            else return kony.table.returnResult(true, isInternalError);
        },
        /**@Deprecated This API filters the given table based on the provided criteria and returns a set of values that match the given criteria.*/
        filter: function(srctable, mapfunc) {
            var isArgsError = false;
            var isInternalError = false;
            var tgttable;
            if (arguments.length < 2 || !(srctable instanceof Object) || !(typeof(mapfunc) == "function")) {
                isArgsError = true;
            }
            if (!isArgsError) {
                var key, value, retVals;
                if ((srctable instanceof Array) && mapfunc) {
                    try {
                        tgttable = [];
                        for (var i = 0; i < srctable.length; i++) { //5.0 Decremented i
                            value = srctable[i];
                            if (value instanceof Object) {
                                /*var innerLen = value.length();
                                 var innerValue;
                                 var count = 0;
                                 for (var k = 0; k < innerLen; k++) {
                                 innerValue = value.arrayContainer[k + 1];
                                 retVals = executeClosure(mapfunc, [k + 1, innerValue]);
                                 if (retVals[0] == true)
                                 count++;
                                 }
                                 if (count == innerLen)
                                 tgttable.arrayContainer.push(value);*/
                                return kony.table.returnResult(null, true, isInternalError);
                            } else {
                                if (value != null) retVals = mapfunc(i, value);
                                if (retVals === true) tgttable.push(value);
                                retVals = false;
                            }
                        }
                    } catch (e) {
                        isArgsError = true;
                    }
                } else
                if (srctable && mapfunc) {
                    tgttable = new Object();
                    try {
                        for (var j in srctable) {
                            key = j
                            value = srctable[j];
                            if (value != null) retVals = mapfunc(j, value);
                            if (retVals === true) {
                                tgttable[key] = value;
                            }
                            retVals = false;
                        }
                    } catch (e) {
                        isArgsError = true;
                    }
                }
            }
            if (isArgsError || isInternalError) tgttable = null;
            return kony.table.returnResult(tgttable, isArgsError, isInternalError);
        },
        /**@Deprecated This API performs the given action on the input table and returns the modified table.*/
        map: function(srctable, mapfunc) {
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length < 2 || (srctable instanceof Object === false) || !(typeof(mapfunc) == "function")) {
                isArgsError = true;
            }
            if (!isArgsError) {
                try {
                    var key, value, retVals;
                    if (srctable instanceof Array && mapfunc) {
                        var len = srctable.length;
                        for (var i = 0; i < len; i++) { //5.0 Decremented i
                            if (srctable[i] instanceof Array || srctable[i] == null) {
                                return kony.table.returnResult(true, isInternalError);
                            }
                        }
                        try {
                            for (var i = 0; i < len; i++) { //5.0 Decremented i
                                value = srctable[i];
                                retVals = mapfunc(i, value);
                                if (retVals !== false) {
                                    key = retVals[0];
                                    value = retVals[1];
                                    srctable[key] = value;
                                    retVals = false;
                                } else return kony.table.returnResult(true, isInternalError);
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    } else
                    if (srctable && mapfunc) {
                        try {
                            for (var j in srctable) {
                                key = j;
                                value = srctable[key];
                                retVals = mapfunc(key, value);
                                if (retVals !== false) {
                                    key = retVals[0];
                                    value = retVals[1];
                                    srctable[key] = value;
                                    retVals = false;
                                } else return kony.table.returnResult(true, isInternalError);
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    }
                } catch (e) {
                    isInternalError = true;
                }
            }
            //srctable added for JSPFQA5653
            return kony.table.returnResult(srctable, isArgsError, isInternalError);
        },
        /**@Deprecated This API performs the given action on the input table and returns a new table.*/
        mapNew: function(srctable, mapfunc) {
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length < 2 || (srctable instanceof Object === false) || !(typeof(mapfunc) == "function")) {
                isArgsError = true;
            }
            if (srctable == null) return kony.table.returnResult(null, isArgsError, isInternalError);
            try {
                var tgttable = null;
                var key, value, retVals;
                if (!isArgsError) {
                    if (srctable instanceof Array && mapfunc) {
                        var len = srctable.length;
                        for (var i = 0; i < len; i++) { //5.0 Decremented i
                            if (srctable[i] instanceof Object || srctable[i] == null) {
                                return kony.table.returnResult(null, true, isInternalError);
                            }
                        }
                        try {
                            tgttable = [];
                            for (var i = 0; i < len; i++) { //5.0 Decremented i
                                value = srctable[i];
                                retVals = mapfunc(i, value);
                                key = retVals[0];
                                value = retVals[1];
                                tgttable[key] = value;
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    } else
                    if (srctable && mapfunc) {
                        try {
                            tgttable = new Object();
                            for (var j in srctable) {
                                key = j;
                                value = srctable[key];
                                retVals = mapfunc(key, value);
                                if (retVals !== false) {
                                    key = retVals[0];
                                    value = retVals[1];
                                    tgttable[key] = value;
                                    retVals = false;
                                } else return kony.table.returnResult(true, isInternalError);
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    }
                }
            } catch (e) {
                isInternalError = true;
            }
            if (isArgsError || isInternalError) tgttable = null;
            return kony.table.returnResult(tgttable, isArgsError, isInternalError);
        },
        /**@Deprecated This API searches the given input table and returns the value at the specified key; if the key is a number, this API returns the value at the index.*/
        get: function(srctable, key) {
            var isArgsError = false;
            var isInternalError = false;
            var invalidKey = false;
            var result = null;
            //TODO:Error Check
            if (arguments.length < 2 || srctable instanceof Object === false || key == null) {
                isArgsError = true;
                return kony.table.returnResult(result, isArgsError, isInternalError);
            }
            try {
                if (key in srctable) {
                    result = srctable[key];
                } else invalidKey = true;
            } catch (e) {
                isInternalError = true;
            }
            return kony.table.returnResult(result, isArgsError, isInternalError, invalidKey);
        },
        /**@Deprecated Tests if the specified key is part of the table.*/
        contains: function(srctable, key) {
            var isArgsError = false;
            var isInternalError = false;
            var result = false;
            if (arguments.length < 2 || srctable instanceof Object === false || key == null) {
                return kony.table.returnResult(result, true, isInternalError);
            }
            try {
                if (key in srctable) result = true;
            } catch (e) {
                isInternalError = true;
            }
            return kony.table.returnResult(result, isArgsError, isInternalError);
        },
        /**@Deprecated This API appends the content of the source table to the target table and returns the modified target table.*/
        append: function(tgttable, srctable) {
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length != 2 || !(tgttable instanceof Object) || !(srctable instanceof Object)) {
                isArgsError = true;
                return kony.table.returnResult(null, isArgsError, isInternalError);
            }
            try {
                if (tgttable.length && srctable.length) {
                    ////  var srcarray = srctable.slice(1);   //4906
                    for (var i = 0; i < srctable.length; i++) {
                        tgttable.push(srctable[i]);
                    }
                } else {
                    for (var j in srctable) {
                        tgttable[j] = srctable[j];
                    }
                }
            } catch (e) {
                isInternalError = true;
            }
            return kony.table.returnResult(tgttable, isArgsError, isInternalError);
        },
        /**@Deprecated This API removes data from the table represented by the table id.*/
        removeAll: function(srctable) {
            if (arguments.length < 1) {
                throw new Error("table.removeAll needs atleast 1 argument");
            }
            //TODO:Proper error function to distinguish between table (object) & other types
            if (typeof(srctable) != "object") {
                throw new Error("Invalid  arguments to table.removeAll");
            }
            if (srctable.length) srctable.length = 0;
            else {
                for (var key in srctable) {
                    delete srctable[key];
                }
            }
            return;
        },
        /**@Deprecated unpack

This API returns the elements from the given table. This function is equivalent to

return list[i], list[i+1], .... list[j].*/
        unpack: function(t1) {
            if (0 === arguments.length) {
                throw new Error("unpack needs atleast one argument");
            }
            if (t1 instanceof Object === false) {
                throw new Error("Invalid first argument to unpack");
            }
            var numArgs = arguments.length > 3 ? 3 : arguments.length;
            var maxIndex = arguments[0].length;
            var beginIndex = 0 /*5.0 Decremented beginIndex*/ ,
                endIndex = maxIndex;
            switch (numArgs) {
                case 3:
                    arguments[2] -= 0;
                    if (isNaN(arguments[2])) {
                        throw new Error("Invalid argument to unpack");
                    }
                    endIndex = arguments[2];
                case 2:
                    arguments[1] -= 0;
                    if (isNaN(arguments[1])) {
                        throw new Error("Invalid argument to unpack");
                    }
                    beginIndex = arguments[1];
                default:
                    break;
            }
            if (beginIndex > endIndex) {
                return [""];
            } else {
                var retVals = ""; //[];		//4907		
                for (var i = beginIndex; i < endIndex; i++) {
                    //retVals.push(arguments[0][i]);
                    if (i == 0) {
                        retVals = arguments[0][i];
                    } else {
                        retVals = retVals + " " + arguments[0][i];
                    }
                }
                return retVals;
            }
        },
        // local myjson = '{ "name": "Shasank", "id": "417" }'
        // table.parsejson(myjson)
        /*parsejson: function(args){
	
            if (arguments.length < 1) {
                throw new Error("table.parsejson needs atleast 1 argument");
            }
            
            var jsObj = args[0].evalJSON();
            
            try {
                var tgttable = kony.utils.json2LuaTable(jsObj);
            } 
            catch (e) {
                throw new Error("table.parsejson - SyntaxError: Badly formed JSON string");
            }
            
            return tgttable;
        },*/
        /*keys: function(args){
	
            if (arguments.length < 1) {
                throw new Error("table.keys needs atleast 1 argument");
            }
            
            if (args[0] instanceof LuaTable === false) {
                throw new Error("Invalid  arguments to table.keys");
            }
            
            var srctable = args[0];
            
            if (srctable.hashKeys.length) {
            
                var innerlen = srctable.hashKeys.length;
                var key;
                var keysarray = [];
                for (var j = 0; j < innerlen; j++) {
                    key = srctable.hashKeys[j];
                    keysarray.push(key);
                }
                
                return keysarray;
            }
        },*/
        returnResult: function() {
            var errorNo = null;
            var errorMsg = null;
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length >= 3) {
                var retArray = arguments[0];
                isArgsError = arguments[1];
                isInternalError = arguments[2];
                var invalidKey = arguments[3];
            } else {
                isArgsError = arguments[0];
                isInternalError = arguments[1];
            }
            if (isArgsError) {
                errorNo = 100;
                errorMsg = "INVALID ARGUMENTS";
            } else if (isInternalError) {
                errorNo = 101;
                errorMsg = "INTERNAL ERROR";
            } else if (invalidKey) {
                errorNo = 0;
                errorMsg = "INVALID KEY";
            }
            if (arguments.length >= 3)
            //return ([retArray, errorNo, errorMsg]);
                return retArray;
            else if (arguments.length == 2 && (isArgsError || isInternalError)) return ([errorNo, errorMsg]);
            else return;
        }
    }
    /**@Deprecated This API returns the current time as a string in hh:mm:ss format. The time is represented in 12 hour format.*/
kony.os.time = function() {
    var timeStr = (new Date()).toTimeString();
    return timeStr.slice(0, timeStr.indexOf(" "));
};
/**@Deprecated This API returns the number of seconds between the first input parameter (t1) to the second input parameter (t2).*/
kony.os.diffDateTime = function(time1, time2) {
    if (typeof(time1) !== "string" || typeof(time2) !== "string") {
        throw new Error("Invalid argument(s) to os.diffDateTime");
    }
    var t1 = time1.split(":");
    t1[2] = t1[2] - 0;
    var t2 = time2.split(":");
    t2[2] = t2[2] - 0;
    var one_day = 86400;
    var t1sec = t1[0] * 3600 + t1[1] * 60 + t1[2];
    var t2sec = t2[0] * 3600 + t2[1] * 60 + t2[2];
    return (t1sec > one_day || t2sec > one_day) ? null : t1sec - t2sec;
};
/**@Deprecated This API formats the current date to the given format.*/
kony.os.date = function() {
    var result;
    var currentDate = new Date();
    if (0 === arguments.length) {
        var timeStr = currentDate.toTimeString();
        result = kony.os.padZero(currentDate.getMonth() + 1) + "/" + kony.os.padZero(currentDate.getDate()) + "/" + kony.os.padZero(currentDate.getFullYear() % 100) + " " + timeStr.slice(0, timeStr.indexOf(" "));
        return result;
    } else if (typeof(arguments[0]) == "string") {
        if (arguments[0].toLowerCase().indexOf("dd") != -1) {
            return kony.os.formatdate(arguments[0], currentDate);
        } else {
            var utc = arguments[0].charAt(0) === '!';
            var index = utc ? 1 : 0;
            if ('*' === arguments[0].charAt(index) && 't' === arguments[0].charAt(index + 1)) {
                var day = utc ? currentDate.getUTCDate() : currentDate.getDate();
                var mon = (utc ? currentDate.getUTCMonth() : currentDate.getMonth()) + 1;
                var year = utc ? currentDate.getUTCFullYear() : currentDate.getFullYear();
                result = new Object();
                result["year"] = year;
                result["month"] = mon;
                result["day"] = day;
                result["hour"] = utc ? currentDate.getUTCHours() : currentDate.getHours();
                result["min"] = utc ? currentDate.getUTCMinutes() : currentDate.getMinutes();
                result["sec"] = utc ? currentDate.getUTCSeconds() : currentDate.getSeconds();
                result["wday"] = utc ? currentDate.getUTCDay() : currentDate.getDay() + 1;
                result["yday"] = kony.os.getDayOfYear(day, mon, year);
                result["isdst"] = utc ? false : kony.os.checkForDst();
                return result;
            } else return null;
        }
    } else return null;
};
/**This API allows you to convert the given number to represent currency. At present, only USA currency is supported.*/
kony.os.toCurrency = function(arg) {
    arg -= 0;
    if (isNaN(arg)) {
        throw new Error("Invalid argument to os.toCurrency");
    }
    if (arg < 0) arg *= -1;
    var str = arg.toFixed(3);
    str = str.substr(0, str.length - 1);
    var outStr = "";
    for (var i = 0; i < str.length - 4; i++) {
        outStr += str.charAt(i);
        if ((str.length - i - 1) % 3 === 0) outStr += ",";
    }
    for (; i < str.length; i++) {
        outStr += str.charAt(i);
    }
    return "$" + outStr;
};
/**This API converts the argument to a number. If the argument is already a number or a string convertible to a number, then the API returns this number; otherwise, it returns null for JavaScript and nil for Lua.*/
kony.os.toNumber = function(arg) {
    if (arguments.length != 1) {
        throw new Error("Invalid argument to os.toNumber");
    }
    if (typeof(arg) === "number") {
        return arg;
    } else if (typeof(arg) === "string") {
        var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
        if (str === '') {
            return null;
        } else {
            var num = str - 0;
            return (isNaN(num) ? null : num);
        }
    } else {
        return null;
    }
};
/**@Deprecated This API returns the difference in dates or compares two dates for equality.*/
//os.compareDates(date1,date2,"format") - dd,mm,yyyy,yy 
kony.os.compareDates = function(d1, d2, frmt) {
    if (d1 == null || d2 == null || frmt == null || !kony.os.isvaliddate(d1, frmt) || !kony.os.isvaliddate(d2, frmt)) return null
    var date1 = kony.os.getDate(d1, frmt);
    var date2 = kony.os.getDate(d2, frmt);
    var oneday = 24 * 60 * 60 * 1000;
    return parseInt((date1.getTime() - date2.getTime()) / oneday);
};
/**@Deprecated This API adds or subtracts units (days, hours, minutes, month, or years) to the given date.*/
//os.addToDate(date1,format,units,count) - units : days,hours,minutes,month,years
// Format"dd/mm/yyyy" or "mm/dd/yyyy" or mm/dd/yy
kony.os.addToDate = function(d1, frmt, unt, cnt) {
    if (d1 == null || frmt == null || unt == null || cnt == null) {
        return null;
    }
    var inputDate = d1;
    var fmt = frmt;
    var unit = unt;
    var count = cnt;
    var dateParts = inputDate.split("/");
    if (!kony.os.isvaliddate(inputDate, fmt)) return null;
    var dateObj = kony.os.getDate(inputDate, fmt);
    if (dateObj) {
        switch (unit) {
            case "years":
                dateObj.setFullYear(dateObj.getFullYear() + count);
                break;
            case "months":
                dateObj.setMonth(dateObj.getMonth() + count);
                break;
            case "days":
                dateObj.setDate(dateObj.getDate() + count);
                break;
            case "hours":
                dateObj.setHours(dateObj.getHours() + count);
                break;
            case "minutes":
                dateObj.setMinutes(dateObj.getMinutes() + count);
                break;
            default:
                break;
        }
        if (kony.os.isLeapYear([d1, fmt]) && dateObj.getMonth() >= 1 && (unit == "years" || (unit == "months" && (count == -12 || count == 12)))) dateObj.setDate(dateObj.getDate() - 1);
        return kony.os.formatdate(fmt, dateObj);
    }
    return null;
};
/**@Deprecated This API checks if the input year is a leap year.*/
//os.isLeapYear(yyyy) 
kony.os.isLeapYear = function(d1, frmt) {
    var year;
    var date = new Date(); //Take the current year;
    year = date.getFullYear();
    if (typeof(d1) == "string" && typeof(frmt) == "string") {
        if (!kony.os.isvaliddate(d1, frmt)) return false;
        var yearPart = d1.split("/")[2];
        year = (yearPart.length == 2) ? parseInt(date.getFullYear().toString().substr(0, 2) + yearPart) : parseInt(yearPart);
    }
    if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
        return true;
    } else {
        return false;
    }
};
/**@Deprecated This API converts a given date string to the target format and returns the formatted date. Format will use the tokens dd,mm,yyyy to indicate day, month, and year respectively. The delimiter used between the tokens can be any character. For example, dd/mm/yyyy and (dd)(mm)(yyyy) are valid inputs.*/
//os.formatdate(inputdate[string],sourceformat[string],targetformat[string])
kony.os.formatDate = function(d1, sfrmt, tgtfrmt) {
    var year;
    if (d1 == null || sfrmt == null || tgtfrmt == null) {
        return null;
    } else if (typeof(d1) === "string" && typeof(sfrmt) === "string" && typeof(tgtfrmt) === "string") {
        var inputDate = d1
        var srcfmt = sfrmt;
        var targetfmt = tgtfrmt;
        var datePos = srcfmt.indexOf("dd");
        var monthPos = srcfmt.indexOf("mm");
        var yearPos = (srcfmt.indexOf("yyyy") != -1) ? srcfmt.indexOf("yyyy") : srcfmt.indexOf("yy");
        if ((srcfmt == "dd/mm/yyyy" && !kony.os.isvaliddate(inputDate, srcfmt)) || datePos == -1 || monthPos == -1 || yearPos == -1 || srcfmt.indexOf("ddd") != -1 || srcfmt.indexOf("mmm") != -1) {
            return null;
        }
        var dateStrSep = srcfmt.charAt(datePos - 1);
        var dateEndSep = srcfmt.charAt(datePos + 2);
        dateEndSep = (dateEndSep == "(") ? "" : dateEndSep;
        var monthStrSep = srcfmt.charAt(monthPos - 1);
        var monthEndSep = srcfmt.charAt(monthPos + 2);
        var yearStrSep = srcfmt.charAt(yearPos - 1);
        var yearEndSep = srcfmt.charAt(yearPos + 4);
        var startDateIndex = (dateStrSep == "") ? inputDate.indexOf(dateStrSep, datePos - 1) : inputDate.indexOf(dateStrSep, datePos - 2) + 1;
        var startMonthIndex = (monthStrSep == "") ? inputDate.indexOf(monthStrSep, monthPos - 1) : inputDate.indexOf(monthStrSep, monthPos - 2) + 1;
        var startYearIndex = (yearStrSep == "") ? inputDate.indexOf(yearStrSep, yearPos - 1) : ((inputDate.indexOf(yearStrSep, yearPos - 2) != -1) ? inputDate.indexOf(yearStrSep, yearPos - 2) + 1 : inputDate.indexOf(yearStrSep, yearPos - 4) + 1);
        var endDateIndex = (dateEndSep != "") ? inputDate.indexOf(dateEndSep, datePos) : inputDate.indexOf(dateEndSep, datePos + 2);
        var endMonthIndex = (monthEndSep != "") ? inputDate.indexOf(monthEndSep, monthPos) : inputDate.indexOf(monthEndSep, monthPos + 2);
        var endYearIndex = (yearEndSep != "") ? inputDate.indexOf(yearEndSep, yearPos) : inputDate.indexOf(yearEndSep, yearPos + 4);
        var dateVal = inputDate.substring(startDateIndex, endDateIndex);
        var monthVal = inputDate.substring(startMonthIndex, endMonthIndex);
        var yearVal = inputDate.substring(startYearIndex, endYearIndex);
        if ((yearVal.length == 2 && targetfmt.indexOf("yyyy") != -1)) var fullyr = new Date().getFullYear().toString().substr(0, 2) + yearVal;
        targetfmt = targetfmt.replace(/dd/, kony.os.padZero(parseInt(dateVal, 10)));
        targetfmt = targetfmt.replace(/mm/, kony.os.padZero(parseInt(monthVal, 10)));
        targetfmt = targetfmt.replace(/(yyyy|yy)/, fullyr ? fullyr : ((targetfmt.indexOf("yyyy") == -1 && yearVal.length == 4) ? yearVal.substr(2, 2) : yearVal));
        return targetfmt;
    }
    return null;
};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
//os.isvaliddate(date,format) 
kony.os.isValidDate = function(date, frmt) {
    return (arguments.length != 2 || date == null || frmt == null) ? false : kony.os.isvaliddate(date, frmt);
};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
//os.dateComponents(date, format);
//Formats supported:  (dd/mm/yyyy , mm/dd/yyyy, dd/mm/yy , mm/dd/yy) 
kony.os.dateComponents = function(date, frmt) {
    var result;
    var dateObject;
    if (arguments.length == 0) {
        dateObject = new Date();
    } else if (date != null && frmt != null) {
        if (!kony.os.isvaliddate(date, frmt)) return null;
        dateObject = kony.os.getDate(date, frmt);
        var yearfmt = frmt.split("/")[2];
    }
    if (dateObject) {
        var day = dateObject.getDate();
        var mon = dateObject.getMonth() + 1;
        var year = (yearfmt && yearfmt.length == 2) ? parseInt(dateObject.getFullYear().toString().substr(2, 2)) : dateObject.getFullYear();
        result = new Object();
        result["year"] = year;
        result["month"] = mon;
        result["day"] = day;
        result["hour"] = dateObject.getHours();
        result["min"] = dateObject.getMinutes();
        result["sec"] = dateObject.getSeconds();
        result["wday"] = dateObject.getDay() + 1;
        result["yday"] = kony.os.getDayOfYear(day, mon, year);
        result["isdst"] = kony.os.checkForDst();
        return result;
    } else return null;
};
kony.os.padZero = function(num) {
    return num < 10 ? ("0" + num) : num;
};
/**@Deprecated This API converts a given date string to the target format and returns the formatted date. Format will use the tokens dd,mm,yyyy to indicate day, month, and year respectively. The delimiter used between the tokens can be any character. For example, dd/mm/yyyy and (dd)(mm)(yyyy) are valid inputs.*/
kony.os.formatdate = function(fmt, dateObj) {
    fmt = fmt.toLowerCase();
    fmt = fmt.replace(/dd/, kony.os.padZero(dateObj.getDate()));
    fmt = fmt.replace(/mm/, kony.os.padZero(dateObj.getMonth() + 1));
    return fmt.replace(/(yyyy|yy)/, fmt.indexOf("yyyy") == -1 ? dateObj.getFullYear().toString().substr(2, 2) : dateObj.getFullYear());
};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
//Valid formats mm/dd/yy and mm/dd/yyyy and dd/mm/yyyy		
kony.os.isvaliddate = function(dtStr, format) {
    var minYear = 1900;
    var maxYear = 2100;
    var dtCh = "/";
    var daysInMonth = kony.os.daysArray(12);
    var pos1 = dtStr.indexOf(dtCh)
    var pos2 = dtStr.indexOf(dtCh, pos1 + 1)
    var dateFormat = format || "dd/mm/yyyy";
    if (dateFormat == "dd/mm/yyyy" || dateFormat == "dd/mm/yy") {
        var strDay = dtStr.substring(0, pos1)
        var strMonth = dtStr.substring(pos1 + 1, pos2)
    } else
    if (dateFormat == "mm/dd/yy" || dateFormat == "mm/dd/yyyy") {
        var strDay = dtStr.substring(pos1 + 1, pos2);
        var strMonth = dtStr.substring(0, pos1);
    } else return false;
    var strYear = dtStr.substring(pos2 + 1);
    /*if(strYear.length == 2 && dateFormat.indexOf("yyyy") != -1)				
     return false;*/
    var today = new Date();
    strYr = strYear
    if (strDay.charAt(0) == "0" && strDay.length > 1) strDay = strDay.substring(1)
    if (strMonth.charAt(0) == "0" && strMonth.length > 1) strMonth = strMonth.substring(1)
    if (strYr.length == 2) {
        strYr = (today.getFullYear() + "").substr(0, 2) + strYr;
    }
    for (var i = 1; i <= 3; i++) {
        if (strYr.charAt(0) == "0" && strYr.length > 1) strYr = strYr.substring(1)
    }
    month = parseInt(strMonth)
    day = parseInt(strDay)
    year = parseInt(strYr)
    if (!kony.os.isInteger(strMonth) || !kony.os.isInteger(strDay) || !kony.os.isInteger(strYear) || strMonth.length < 1 || month < 1 || month > 12 || strDay.length < 1 || day < 1 || day > 31 || (month == 2 && day > kony.os.daysInFebruary(year)) || day > daysInMonth[month] || strYr.length != 4 || year == 0 || year < minYear || year > maxYear) {
        //alert("invalid date");
        return false
    }
    return true
};
kony.os.daysArray = function(n) {
    for (var i = 1; i <= n; i++) {
        this[i] = 31
        if (i == 4 || i == 6 || i == 9 || i == 11) {
            this[i] = 30
        }
        if (i == 2) {
            this[i] = 29
        }
    }
    return this
};
kony.os.daysInFebruary = function(year) {
    // February has 29 days in any year evenly divisible by four,
    // EXCEPT for centurial years which are not also divisible by 400.
    return (((year % 4 == 0) && ((!(year % 100 == 0)) || (year % 400 == 0))) ? 29 : 28);
};
kony.os.isInteger = function(s) {
    var i;
    for (i = 0; i < s.length; i++) {
        // Check that current character is number.
        var c = s.charAt(i);
        if (((c < "0") || (c > "9"))) return false;
    }
    // All characters are numbers.
    return true;
};
kony.os.getDate = function(date, format) {
    var dateObj;
    if (typeof date === "string" && typeof format === "string") {
        var dateParts = date.split("/");
        var yr = new Date().getFullYear().toString().substr(0, 2);
        if (format.indexOf("yyyy") == -1 || dateParts[2].length == 2) dateParts[2] = yr + dateParts[2];
        if (format == "mm/dd/yyyy" || format == "mm/dd/yy") dateObj = new Date(dateParts[0] + "/" + dateParts[1] + "/" + dateParts[2]);
        else dateObj = new Date(dateParts[1] + "/" + dateParts[0] + "/" + dateParts[2]);
        return dateObj;
    }
};
kony.os.getDayOfYear = function(day, month, year) {
    var i, j;
    var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    if (0 === year % 4) {
        days[1]++;
    }
    for (i = 1, j = 0; i < month; j += days[i - 1], i++);
    return j + day;
};
kony.os.checkForDst = function() {
    var rightNow = new Date();
    var jan1 = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
    var temp = jan1.toGMTString();
    var jan2 = new Date(temp.substring(0, temp.lastIndexOf(" ") - 1));
    var std_time_offset = (jan1 - jan2) / (1000 * 60 * 60);
    var june1 = new Date(rightNow.getFullYear(), 6, 1, 0, 0, 0, 0);
    temp = june1.toGMTString();
    var june2 = new Date(temp.substring(0, temp.lastIndexOf(" ") - 1));
    var daylight_time_offset = (june1 - june2) / (1000 * 60 * 60);
    var dst;
    if (std_time_offset == daylight_time_offset) {
        //dst = "0"; // daylight savings time is NOT observed
        return false;
    } else {
        //dst = "1"; // daylight savings time is observed
        return true;
    }
};
//release/tool
//ver 1.6.2
;
(function() {
    var BusinessController_Command, BusinessController_CommandResponse, BusinessController_CommandHandler, commonUtils_ExtensibilityApi, BusinessController_CommandExecutionEngine, BusinessController_BusinessController, BusinessController_BusinessDelegator, DataModel_QueryBuilder, DataModel_constants, DataModel_Error, DataModel_DBAssembler, DataModel_DataSource, DataModel_BaseRepository, DataModel_RepositoryManager, PresentationController_MDABasePresenter, BaseNavigator_MDABaseNavigator, ModuleManager_MDAModule, ModuleManager_MDAModuleManager, UIBinder_UIBinder, UIBinder_PropertyDataMapper_GenericProperties, UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom, UIBinder_PropertyDataMapper_ImageProperties, UIBinder_WidgetDataMapper_ImageWidgetDataMapper, UIBinder_PropertyDataMapper_TextboxProperties, UIBinder_WidgetDataMapper_TextboxWidgetDataMapper, UIBinder_PropertyDataMapper_LabelProperties, UIBinder_WidgetDataMapper_LabelWidgetDataMapper, UIBinder_PropertyDataMapper_TextAreaProperties, UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper, UIBinder_PropertyDataMapper_SwitchProperties, UIBinder_WidgetDataMapper_SwitchWidgetDataMapper, UIBinder_PropertyDataMapper_SliderProperties, UIBinder_WidgetDataMapper_SliderWidgetDataMapper, UIBinder_PropertyDataMapper_RichTextProperties, UIBinder_WidgetDataMapper_RichTextWidgetDataMapper, UIBinder_PropertyDataMapper_ButtonProperties, UIBinder_WidgetDataMapper_ButtonWidgetDataMapper, UIBinder_WidgetDataMapper_SegmentWidgetDataMapper, UIBinder_PropertyDataMapper_ListboxProperties, UIBinder_WidgetDataMapper_ListboxWidgetDataMapper, UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper, UIBinder_PropertyDataMapper_CalendarProperties, UIBinder_WidgetDataMapper_CalendarWidgetDataMapper, UIBinder_UIBinderBuilder, commonUtils_MDAApplication, commonUtils_Logger, commonUtils_InitializeForms, commonUtils_ProcessorUtils, ParallelCommandExecuter_ParallelCommandExecuter, DataModel_ModelRelation, DataModel_BaseModel, DataModel_ORMSession, DataModel_Expression, FormController_MDAFormController, commonUtils_ControllerGetterAPI, main, konymvcMDAFormController, kony_mvc_MDAFormController, MDAFormController;
    BusinessController_Command = function() {
        function Command(id, context, completionCallback, alias) {
            //kony.print("In Command: " + id + "  callback is: " + completionCallback);
            this.id = id;
            this.headers = context.headers;
            delete context.headers;
            this.context = context;
            this.completionCallback = completionCallback;
            this.alias = alias ? alias : id;
        }
        Command.prototype.execute = function() {};
        Command.prototype.getCompletionCallback = function() {
            return this.completionCallback;
        };
        Command.prototype.setCompletionCallback = function(completionCallback) {
            this.completionCallback = completionCallback;
        };
        Command.prototype.getContext = function() {
            return this.context;
        };
        Command.prototype.setContext = function(context) {
            this.context = context;
        };
        Command.prototype.getId = function() {
            return this.id;
        };
        Command.prototype.setId = function(id) {
            this.id = id;
        };
        Command.prototype.getAlias = function() {
            return this.alias;
        };
        Command.prototype.setAlias = function(alias) {
            this.alias = alias;
        };
        return Command;
    }();
    BusinessController_CommandResponse = function() {
        function CommandResponse(commandId, status, data, alias) {
            this.commandId = commandId;
            this.status = status;
            this.data = data;
            this.alias = alias ? alias : commandId;
        }
        return CommandResponse;
    }();
    BusinessController_CommandHandler = function(Command, CommandResponse) {
        function CommandHandler(commandId) {
            this.commandId = commandId;
            this.commandHandlerExtension = null;
            this.businessController = null;
        }
        CommandHandler.prototype.execute = function(command) {};
        CommandHandler.prototype.validate = function() {};
        CommandHandler.prototype.sendResponse = function(command, responseCode, responseData) {
            var response = new CommandResponse(command.id, responseCode, responseData, command.alias);
            command.completionCallback.call(this, response);
        };
        return CommandHandler;
    }(BusinessController_Command, BusinessController_CommandResponse);
    commonUtils_ExtensibilityApi = function() {
        function ClassExtensionUtility() {
            //This json Object is used for deregister purpose by holding the key as function name and value as JSONObject
            jsonForFunction = {};
            /**
             * This Api is the skeleton for addAfter logic
             *
             * @param {function} invoke  - The existing original function.
             * @param {function} newMeth - The new function which has to be executed later in the sequence.
             * @return           retX    - The result after execution of the latest method.
             */
            addAfterWrapper = function(invoke, newMeth) {
                    return {
                        diy: function() {
                            return function() {
                                var retX = invoke.apply(this, arguments);
                                retX = newMeth.apply(this, arguments);
                                return retX;
                            };
                        }
                    };
                },
                /**
                 * This Api is the skeleton for addBefore logic
                 *
                 * @param {function} invoke  - The existing original function.
                 * @param {function} newMeth - The new function which has to be executed prior to the sequence.
                 * @return           retX    - The result after execution of the latest method.
                 */
                addBeforeWrapper = function(invoke, newMeth) {
                    return {
                        diy: function() {
                            return function() {
                                var retX = newMeth.apply(this, arguments);
                                if (retX !== false) {
                                    retX = invoke.apply(this, arguments);
                                }
                                return retX;
                            };
                        }
                    };
                },
                /**
                 * This Api calls the function  which constructs the body for anonymous functions either addAfter or addBefore
                 *
                 * @param {String} key                 - The name of the anonymous function
                 * @param {boolean}flag                - Used to decide addAfter or addBefore
                 */
                makeAnonymousFuncBody = function(key, flag) {
                    if (flag === 1) {
                        makeAnonyAddAfterBody(key);
                    } else {
                        makeAnonyAddBeforeBody(key);
                    }
                },
                /**
                 * This function constructs the body for anonymous function in the scenario  of addAfter
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddAfterBody = function(key) {
                    var obj = jsonForFunction[key];
                    if (obj[key]['after']) {
                        var afterArray = obj[key]['after'];
                        for (var index = 0; index < afterArray.length; index++) {
                            var invoker = eval(key);
                            meth = eval(afterArray[index]);
                            methObj = addAfterWrapper(invoker, meth);
                        }
                        eval(key + '=methObj.diy();');
                    }
                },
                /**
                 * This function constructs the body for anonymous function in the scenario  of addBefore
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddBeforeBody = function(key) {
                    var obj = jsonForFunction[key];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        var invoker = eval(key);
                        meth = eval(beforeArray[index]);
                        methObj = addBeforeWrapper(invoker, meth);
                    }
                    eval(key + '=methObj.diy();');
                },
                /**
                 * This Api calls the method which constructs the body for anonymous function in the scenario  of deRegistering a method
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonymousFuncDeRegisterBody = function(key) {
                    makeAnonyAddAfterDeRegister(key);
                    makeAnonyAddBeforeDeRegister(key);
                },
                /**
                 * This function reconstructs the body after deregistering a particular method
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddBeforeDeRegister = function(key) {
                    var obj = jsonForFunction[key];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        var invoker = eval(key);
                        meth = eval(beforeArray[index]);
                        var methObj = addBeforeWrapper(invoker, meth);
                        eval(key + '=methObj.diy();');
                    }
                },
                /**
                 * This function reconstructs the body after deRegistering a particular method
                 *
                 * @param {string} key                 - The existing original function.
                 */
                makeAnonyAddAfterDeRegister = function(key) {
                    var obj = jsonForFunction[key];
                    var afterArray = obj[key]['after'];
                    for (var index = 0; index < afterArray.length; index++) {
                        var invoker = eval(key);
                        meth = eval(afterArray[index]);
                        var methObj = addAfterWrapper(invoker, meth);
                        eval(key + '=methObj.diy();');
                    }
                },
                /**
                 * This Api calls the method which constructs the body for class in the scenario  of addAfter or addBefore of a member		
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 * @param {boolean} flag               - factor to call addAfter or addBefore.
                 */
                makeClassFunctionBody = function(refClass, key, flag) {
                    if (flag === 1) {
                        makeClassAddAfterFunctionBody(refClass, key);
                    } else {
                        makeClassAddBeforeFunctionBody(refClass, key);
                    }
                },
                /**
                 * This function constructs the body for Class in the scenario  of addAfter
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddAfterFunctionBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var afterArray = obj[key]['after'];
                    for (var index = 0; index < afterArray.length; index++) {
                        for (var keyValue in afterArray[index]) {
                            var invoker = refClass[key];
                            meth = afterArray[index][keyValue];
                            var methObj = addAfterWrapper(invoker, meth);
                        }
                    }
                    refClass[key] = methObj.diy();
                },
                /**
                 * This function constructs the body for Class in the scenario  of addBefore
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddBeforeFunctionBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        for (var keyValue in beforeArray[index]) {
                            var invoker = refClass[key];
                            meth = beforeArray[index][keyValue];
                            var methObj = addBeforeWrapper(invoker, meth);
                        }
                    }
                    refClass[key] = methObj.diy();
                },
                /**
                 * This Api calls the method which constructs the body for class in the scenario  of deRegistering a method	
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassDeRegisterFunctionBody = function(refClass, key) {
                    makeClassAddAfterBody(refClass, key);
                    makeClassAddBeforeBody(refClass, key);
                },
                /**
                 * This function reconstructs the body after deRegistering a particular method
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddAfterBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var afterArray = obj[key]['after'];
                    for (var index = 0; index < afterArray.length; index++) {
                        for (var keyValue in afterArray[index]) {
                            var invoker = refClass[key];
                            meth = afterArray[index][keyValue];
                            var methObj = addAfterWrapper(invoker, meth);
                        }
                        refClass[key] = methObj.diy();
                    }
                },
                /**
                 * This function reconstructs the body after deRegistering a particular method
                 *
                 * @param {class} refClass             - The copy of the original class
                 * @param {string} key                 - The existing original function.
                 */
                makeClassAddBeforeBody = function(refClass, key) {
                    var obj = refClass[key + '_orig' + 1];
                    var beforeArray = obj[key]['before'];
                    for (var index = 0; index < beforeArray.length; index++) {
                        for (var keyValue in beforeArray[index]) {
                            var invoker = refClass[key];
                            meth = beforeArray[index][keyValue];
                            var methObj = addBeforeWrapper(invoker, meth);
                        }
                        refClass[key] = methObj.diy();
                    }
                },
                /**
                 * This method is used to set the required assets for calling addAfter method to construct the body for anonymous function
                 *
                 * @param {class}    refClass - The prototype of the original class
                 * @param {JSON}     method   - The existing original function and new function as value.
                 * @param {boolean}  flag     - deciding factor to construct JSON Object for before or after methods
                 */
                anonymousFuncAdd = function(claz, method, flag) {
                    var method = claz;
                    for (var key in method) {
                        if (!jsonForFunction[key]) {
                            jsonForFunction[key] = {};
                        }
                        var dummyObject = jsonForFunction[key];
                        var meth = method[key];
                        if (dummyObject[key] === undefined) {
                            makeJsonObject(flag, meth, key);
                        } else {
                            makeJsonObjectComplete(flag, meth, key);
                        }
                        if (flag == 1) {
                            makeAnonymousFuncBody(key, 1);
                        } else {
                            makeAnonymousFuncBody(key, 0);
                        }
                    }
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {string} key       - original function
                 */
                makeJsonObject = function(flag, meth, key) {
                    var innerLevelObject = {};
                    innerLevelObject['after'] = [];
                    innerLevelObject['before'] = [];
                    if (flag === 1) {
                        innerLevelObject['after'].push(meth.name);
                    } else {
                        innerLevelObject['before'].push(meth.name);
                    }
                    var dummyObject = jsonForFunction[key];
                    dummyObject[key] = innerLevelObject;
                    jsonForFunction[key + 1] = eval(key);
                    jsonForFunction[key] = dummyObject;
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {string} key       - original function
                 */
                makeJsonObjectComplete = function(flag, meth, key) {
                    var dummyObject = jsonForFunction[key];
                    if (dummyObject[key]['after'] == undefined || dummyObject[key]['before'] == undefined) {
                        var innerLevelObject = {};
                        innerLevelObject['after'] = [];
                        innerLevelObject['before'] = [];
                        if (flag === 1) {
                            innerLevelObject['after'].push(meth.name);
                        } else {
                            innerLevelObject['before'].push(meth.name);
                        }
                        dummyObject[key] = innerLevelObject;
                        jsonForFunction[key + 1] = eval(key);
                    } else {
                        if (flag === 1) {
                            dummyObject[key]['after'].push(meth.name);
                        } else {
                            dummyObject[key]['before'].push(meth.name);
                        }
                    }
                    jsonForFunction[key] = dummyObject;
                },
                /**
                 * This method is used to set the required assets for calling addAfter method to construct the body for class
                 *
                 * @param {class}      claz - The prototype of the original class
                 * @param {function} meth    - new method
                 * @param {boolean}  flag     - deciding factor to construct JSON Object for before or after methods
                 */
                classMemberAdd = function(claz, method, flag) {
                    var innerLevelObject = {};
                    var refClass = claz;
                    var methodsList = [];
                    for (var key in method) {
                        if (!refClass[key + '_orig' + 1]) {
                            refClass[key + '_orig' + 1] = {};
                        }
                        var dummyObject = refClass[key + '_orig' + 1];
                        var meth = method[key];
                        if (refClass[key]) {
                            if (dummyObject[key] == undefined) {
                                makeClassJson(key, flag, method, refClass);
                            } else {
                                makeClassJsonComplete(key, flag, method, refClass);
                            }
                            if (flag == 1) {
                                makeClassFunctionBody(refClass, key, 1);
                            } else {
                                makeClassFunctionBody(refClass, key, 0);
                            }
                        }
                    }
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {string} key       - original function
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 */
                makeClassJson = function(key, flag, method, refClass) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var innerLevelObject = {};
                    innerLevelObject['after'] = [];
                    innerLevelObject['before'] = [];
                    innerinnerObject = {};
                    innerinnerObject[method[key].name] = method[key];
                    if (flag == 1) {
                        innerLevelObject['after'].push(innerinnerObject);
                    } else {
                        innerLevelObject['before'].push(innerinnerObject);
                    }
                    dummyObject[key] = innerLevelObject;
                    refClass[key + '_orig'] = refClass[key];
                    refClass[key + '_orig' + 1] = dummyObject;
                },
                /**
                 * This Api is used to construct the json for addAfter and addBefore scenarios
                 *
                 * @param {string} key       - original function
                 * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
                 * @param {function} meth    - new method
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 */
                makeClassJsonComplete = function(key, flag, method, refClass) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    if (dummyObject[key]['after'] == undefined || dummyObject[key]['before'] == undefined) {
                        innerLevelObject = {};
                        innerLevelObject['after'] = [];
                        innerLevelObject['before'] = [];
                        innerinnerObject = {};
                        innerinnerObject[method[key].name] = method[key];
                        if (flag == 1) {
                            innerLevelObject['after'].push(innerinnerObject);
                        } else {
                            innerLevelObject['before'].push(innerinnerObject);
                        }
                        dummyObject[key] = innerLevelObject;
                        refClass[key + '_orig'] = refClass[key];
                    } else {
                        innerinnerObject = {};
                        innerinnerObject[method[key].name] = method[key];
                        if (flag == 1) {
                            dummyObject[key]['after'].push(innerinnerObject);
                        } else {
                            dummyObject[key]['before'].push(innerinnerObject);
                        }
                    }
                    refClass[key + '_orig' + 1] = dummyObject;
                },
                /**
                 * This Api is used to call the methods for deRegistering purpose
                 *
                 * @param {class}    claz    - The class which contains various methods
                 * @param {function} meth    - new method
                 */
                deRegisterAnonyFunc = function(claz, method) {
                    method = claz;
                    for (var key in method) {
                        var meth = method[key];
                        var dummyObject = jsonForFunction[key];
                        afterArrayProcessing(key, meth);
                        beforeArrayProcessing(key, meth);
                        eval(key + '=jsonForFunction[key+1]');
                        makeAnonymousFuncDeRegisterBody(key);
                    }
                },
                /**
                 * This Api is used to process the addAfter methods and deregister them accordingly
                 *
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                afterArrayProcessing = function(key, meth) {
                    var dummyObject = jsonForFunction[key];
                    var afterArray = dummyObject[key]['after'];
                    for (var j = 0; j < afterArray.length; j++) {
                        if (afterArray[j] == meth.name) {
                            afterArray.splice(j, 1);
                            dummyObject[key]['after'] = afterArray;
                            jsonForFunction[key] = dummyObject;
                        }
                    }
                },
                /**
                 * This Api is used to process the addBefore methods and deregister them accordingly
                 *
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                beforeArrayProcessing = function(key, meth) {
                    var dummyObject = jsonForFunction[key];
                    var beforeArray = dummyObject[key]['before'];
                    for (var k = 0; k < beforeArray.length; k++) {
                        if (beforeArray[k] == meth.name) {
                            beforeArray.splice(k, 1);
                            dummyObject[key]['before'] = beforeArray;
                            jsonForFunction[key] = dummyObject;
                        }
                    }
                },
                /**
                 * This Api is used to call the methods for deRegistering purpose
                 *
                 * @param {class}    claz    - The class which contains various methods
                 * @param {function} method    - new method
                 */
                deRegisterClassMember = function(claz, method) {
                    var refClass = claz;
                    for (var key in method) {
                        var meth = method[key];
                        var dummyObject = refClass[key + '_orig' + 1];
                        classAfterArrayProcessing(refClass, key, meth);
                        classBeforeArrayProcessing(refClass, key, meth);
                        refClass[key] = refClass[key + '_orig'];
                        makeClassDeRegisterFunctionBody(claz, key);
                    }
                },
                /**
                 * This Api is used to process the addAfter methods and deregister them accordingly
                 *
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                classAfterArrayProcessing = function(refClass, key, meth) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var afterArray = dummyObject[key]['after'];
                    for (var j = 0; j < afterArray.length; j++) {
                        for (var keyValue in afterArray[j]) {
                            if (keyValue == meth.name) {
                                afterArray.splice(j, 1);
                                dummyObject[key]['after'] = afterArray;
                                refClass[key + '_orig' + 1] = dummyObject;
                            }
                        }
                    }
                },
                /**
                 * This Api is used to process the addBefore methods and deregister them accordingly
                 *
                 * @param {class}   refClass- The class which contains prototype of the original class.
                 * @param {string}  key         - The original initial method
                 * @param {function} meth       - new method
                 */
                classBeforeArrayProcessing = function(refClass, key, meth) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var beforeArray = dummyObject[key]['before'];
                    for (var k = 0; k < beforeArray.length; k++) {
                        for (var keyValue in beforeArray[k]) {
                            if (keyValue == meth.name) {
                                beforeArray.splice(k, 1);
                                dummyObject[key]['before'] = beforeArray;
                                refClass[key + '_orig' + 1] = dummyObject;
                            }
                        }
                    }
                };
            /**
             * This Api is used to construct the json for addAfter and addBefore scenarios
             *
             * @param {string} key       - original function
             * @param {boolean} flag     - deciding factor to construct JSON Object for before or after methods
             * @param {function} meth    - new method
             * @param {class}   refClass- The class which contains prototype of the original class.
             */
            makeClassJson = function(key, flag, method, refClass) {
                    var dummyObject = refClass[key + '_orig' + 1];
                    var innerLevelObject = {};
                    innerLevelObject['after'] = [];
                    innerLevelObject['before'] = [];
                    innerinnerObject = {};
                    innerinnerObject[method[key].name] = method[key];
                    if (flag == 1) {
                        innerLevelObject['after'].push(innerinnerObject);
                    } else {
                        innerLevelObject['before'].push(innerinnerObject);
                    }
                    dummyObject[key] = innerLevelObject;
                    refClass[key + '_orig'] = refClass[key];
                    refClass[key + '_orig' + 1] = dummyObject;
                }, this.constructor = function(arg) {},
                /**
                 * This function adds a new member function to an existing class definition
                 *
                 * @param {class} claz   - The class for which a new member has to be added.
                 * @param {JSON}  method - The member which has to be added to the class.
                 */
                this.addMethod = function(claz, method) {
                    if (claz) {
                        var refClass = claz;
                    }
                    for (var key in method) {
                        if (!refClass[key]) {
                            refClass[key] = method[key];
                        }
                    }
                },
                /**
                 * This function adds a new sequence to an existing member function of a class definition. 
                 * The new sequence of code is executed after executing the default behaviour
                 *
                 * @param {class} claz   - The class for which addAfter functionality has to be extended.
                 * @param {JSON}  method - The member which has to be extended after to existing member of the class.
                 */
                this.addAfter = function(claz, method) {
                    if (method === undefined) {
                        anonymousFuncAdd(claz, method, 1);
                    } else {
                        classMemberAdd(claz, method, 1);
                    }
                },
                /**
                 * This function adds a new sequence to an existing member function of a class definition. 
                 * The new sequence of code is executed before executing the default behaviour
                 *
                 * @param {class} claz   - The class for which addBefore functionality has to be extended.
                 * @param {JSON}  method - The member which has to be extended before to existing member of the class.
                 */
                this.addBefore = function(claz, method) {
                    if (method === undefined) {
                        anonymousFuncAdd(claz, method, 0);
                    } else {
                        classMemberAdd(claz, method, 0);
                    }
                },
                /**
                 * This function removes an existing member function
                 *
                 * @param {class} claz       - The class for which a member has to be removed.
                 * @param {JSON}  method - The member which has to be removed from the class.
                 */
                this.removeMethod = function(claz, method) {
                    if (claz) {
                        var refClass = claz;
                    }
                    for (var key in methodName) {
                        delete refClass[key];
                    }
                },
                /**
                 * This function overrides an existing member behaviour with a new behaviour.
                 *
                 * @param {class} claz   - The class for which a member has to be updated.
                 * @param {JSON}  method - The member which has to be updated in the class.
                 */
                this.updateMethod = function(claz, method) {
                    if (method === undefined) {
                        method = claz;
                        for (var key in method) {
                            if (method[key] !== undefined) {
                                eval(key + '=method[key];');
                            }
                        }
                    } else {
                        for (var key in method) {
                            if (claz) {
                                var refClass = claz;
                            }
                            if (refClass[key]) {
                                refClass[key] = method[key];
                            }
                        }
                    }
                },
                /**
                 * This function deregisters an existing member function of a class definition. 
                 *
                 * @param {class} claz   - The class for which a member has to be deregistered.
                 * @param {JSON}  method - The member which has to be deRegistered from the sequence of member in the class.
                 */
                this.deRegister = function(claz, method) {
                    if (method === undefined) {
                        deRegisterAnonyFunc(claz, method);
                    } else {
                        deRegisterClassMember(claz, method);
                    }
                };
        }
        return ClassExtensionUtility;
    }();
    BusinessController_CommandExecutionEngine = function(Command, CommandHandler, ClassExtensionUtility) {
        function CommandExecutionEngine() {
            this.commandHandlers = [];
        }
        CommandExecutionEngine.prototype.registerCommandHandler = function(commandHandler) {
            var commandHandlerArray = [
                commandHandler.commandId,
                commandHandler,
                commandHandler.commandHandlerExtension
            ];
            if (commandHandlerArray[2]) {
                if (commandHandlerArray[2].execute) {
                    var extensionInstance = new ClassExtensionUtility();
                    extensionInstance.addBefore(commandHandlerArray[2], {
                        execute: commandHandlerArray[2].addBefore
                    });
                    extensionInstance.addBefore(commandHandlerArray[2], {
                        sendResponse: commandHandlerArray[2].addAfter
                    });
                } else {
                    var extensionInstance = new ClassExtensionUtility();
                    extensionInstance.addBefore(commandHandlerArray[1], {
                        execute: commandHandlerArray[2].addBefore
                    });
                    extensionInstance.addBefore(commandHandlerArray[1], {
                        sendResponse: commandHandlerArray[2].addAfter
                    });
                }
            }
            this.commandHandlers.push(commandHandlerArray); //kony.print("MDA2*** commandHandlers is :" + this.commandHandlers);
        };
        CommandExecutionEngine.prototype.unRegisterHandler = function(commandId) {
            for (var i = 0; i < this.commandHandlers.length; i++) {
                var commandHandlerArray = this.commandHandlers[i];
                if (commandHandlerArray[0] === commandId) {
                    this.commandHandlers.splice(i, 1);
                    break;
                }
            }
        };
        CommandExecutionEngine.prototype._executeCommand = function(command, params) {
            kony.print('MDA2*** CommandExecutionEngine execute : ' + command);
            if (this.isCommandRegistered(command.id) === true) {
                for (var i = 0; i < this.commandHandlers.length; i++) {
                    var commandHandlerArray = this.commandHandlers[i];
                    if (commandHandlerArray[0] === command.id) {
                        commandHandler = commandHandlerArray[1];
                        commandHandler.validate(params);
                        commandHandler.execute(command);
                        break;
                    }
                }
            } else {
                kony.print('Not registered ');
                throw new Exception('ERROR_CODE_300', 'Error at Command Execution Engine, Missing or Wrong CommandID');
            }
        };
        CommandExecutionEngine.prototype.execute = function(command) {
            kony.print('MDA2*** CommandExecutionEngine execute : ' + command);
            if (this.isCommandRegistered(command.id) === true) {
                for (var i = 0; i < this.commandHandlers.length; i++) {
                    var commandHandlerArray = this.commandHandlers[i];
                    if (commandHandlerArray[0] === command.id) {
                        commandHandler = commandHandlerArray[1];
                        commandHandlerExtension = commandHandlerArray[2];
                        if (commandHandlerExtension != null && commandHandlerExtension.execute) {
                            commandHandlerExtension.super = commandHandler.execute;
                            var returnVal = commandHandlerExtension.execute(command);
                            if (returnVal === false) {
                                commandHandler.sendResponse(command, kony.mvc.constants.STATUS_ABORT, null);
                            }
                        } else {
                            commandHandler.execute(command);
                        }
                        break;
                    }
                }
            } else {
                kony.print('Not registered ');
                throw new Exception('ERROR_CODE_300', 'Error at Command Execution Engine, Missing or Wrong CommandID ');
            }
        };
        CommandExecutionEngine.prototype.isCommandRegistered = function(commandId) {
            for (var i = 0; i < this.commandHandlers.length; i++) {
                var commandHandlerArray = this.commandHandlers[i];
                if (commandHandlerArray[0] === commandId) {
                    return true;
                }
            }
            return false;
        };
        return CommandExecutionEngine;
    }(BusinessController_Command, BusinessController_CommandHandler, commonUtils_ExtensibilityApi);
    BusinessController_BusinessController = function(CommandExecutionEngine, CommandHandler, Command) {
        function BusinessController() {
            //this.context = context;
            this.cmdEngine = new CommandExecutionEngine();
            this.initializeBusinessController();
        }
        BusinessController.prototype.initializeBusinessController = function() {};
        BusinessController.prototype.executeCommand = function(command, params) {
            this.cmdEngine._executeCommand(command, params);
        };
        BusinessController.prototype.execute = function(command) {
            //kony.print ("In BC executing :" + command.id);
            this.cmdEngine.execute(command);
        };
        BusinessController.prototype.registerCommandHandlers = function(commandHandlers, callback) {
            if (callback == '' || callback == undefined) {
                for (var i = 0; i < commandHandlers.length; i++) {
                    var commandId = commandHandlers[i].CommandId;
                    var commandHandler = require(commandHandlers[i].CommandHandler);
                    if (commandHandlers[i].CommandHandlerExtension && commandHandlers[i].CommandHandlerExtension != null) {
                        var commandHandlerExtn = commandHandlers[i].CommandHandlerExtension;
                        try {
                            var commandExtension = require(commandHandlerExtn);
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Missing Command Handler Extension : ' + err);
                        }
                    } else {
                        var commandExtension = null;
                    }
                    var handler = new commandHandler(commandId);
                    handler.commandHandlerExtension = commandExtension;
                    if (commandExtension && commandExtension.execute) commandExtension.sendResponse = handler.sendResponse;
                    handler.businessController = this;
                    this.cmdEngine.registerCommandHandler(handler);
                } //var handler = eval('new '+commandHandler+'("'+commandId+'");');
            } else {
                var self = this;
                var handlersarray = [],
                    commandId = [],
                    commandHandlerExtn = [];
                for (var i = 0; i < commandHandlers.length; i++) {
                    commandId[i] = commandHandlers[i].CommandId;
                    commandHandlerExtn[i] = commandHandlers[i].CommandHandlerExtension;
                    handlersarray[i] = commandHandlers[i].CommandHandler;
                }
                var handlerinstances;
                var commandHandler = require(handlersarray, function() {
                    for (var i = 0; i < arguments.length; i++) {
                        try {
                            handlerinstances = arguments;
                            var HandlerExtn = commandHandlerExtn[i];
                            var instanceCommandHandler = handlerinstances[i];
                            var handler = new instanceCommandHandler(commandId[i]);
                            if (commandHandlerExtn[i] != null || commandHandlerExtn[i] != undefined) {
                                var commandExtension = require([HandlerExtn], function(instanceCommandHandlerExtn) {
                                    handler.commandHandlerExtension = instanceCommandHandlerExtn;
                                    if (instanceCommandHandlerExtn && instanceCommandHandlerExtn.execute) instanceCommandHandlerExtn.sendResponse = handler.sendResponse;
                                });
                            } else {
                                var commandExtension = null;
                            }
                            handler.businessController = self;
                            self.cmdEngine.registerCommandHandler(handler); //callback();
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Missing Command Handler Extension : ' + err);
                        }
                    }
                });
            }
        };
        return BusinessController;
    }(BusinessController_CommandExecutionEngine, BusinessController_CommandHandler, BusinessController_Command);
    BusinessController_BusinessDelegator = function() {
        function BusinessDelegator() {
            this.superParams = {
                counter: 0,
                level: null,
                refStack: []
            };
        }
        BusinessDelegator.prototype.super = function(methodName, argList) {
            var scope = this;
            var returnValue = null;
            if (this.superParams.level === null) {
                this.superParams.level = 0;
                while (scope['extensionLevel' + this.superParams.level.toString()]) {
                    this.superParams.level++;
                }
            }
            if (this.superParams.counter === 0) {
                for (var i = 0; i < this.superParams.level; i++) {
                    if (scope['extensionLevel' + i.toString()][methodName]) {
                        this.superParams.refStack.push(i);
                    }
                }
            }
            this.superParams.refStack.pop();
            if (this.superParams.refStack.length !== 0) {
                var callLvl = this.superParams.refStack[this.superParams.refStack.length - 1];
                this.superParams.counter++;
                returnValue = scope['extensionLevel' + callLvl.toString()][methodName].apply(this, argList);
                this.superParams.counter--;
            } else {
                kony.print('#MDA2 : Can\'t find any super for the ' + methodName + ' Method.');
            }
            if (this.superParams.counter === 0) {
                this.superParams.refStack = [];
                this.superParams.level = null;
            }
            return returnValue;
        };
        return BusinessDelegator;
    }();
    DataModel_QueryBuilder = function() {
        function QueryBuilder() {}
        /**
         * @function buildSelectList creates a list of fields for given model
         * @param  {BaseModel} baseModel model defination
         * @param  {Json} config    config for corresponding model
         * @return {String} select list
         */
        QueryBuilder.prototype.buildSelectList = function(baseModel, config) {
            var selectList = '';
            for (var key in baseModel.relations) {
                var relationship = baseModel.relations[key];
                var modelstr = relationship.targetObject;
                var modeldefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(modelstr);
                var configdefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(modelstr);
                selectList = selectList + QueryBuilder.prototype.buildSelectList(modeldefination, configdefination);
            }
            for (var column in config.mappings) {
                selectList = selectList + '`' + config.tableName + '`.`' + config.mappings[column] + '` as ' + config.tableName + '_' + config.mappings[column] + ',';
            }
            return selectList;
        };
        /**
         * @function buildTableName creates list of table names for given model including inner join with related models if any
         * @param  {BaseModel} baseModel model defination
         * @param  {Json} config    config for corresponding model
         * @param  {String} parent   parent table name
         * @param  {Json} parentRelation json describing model relation with parent
         * @return {String} list of table names including inner join with related models if any
         */
        QueryBuilder.prototype.buildTableName = function(baseModel, config, parent, parentRelation) {
            var fromList = '`' + config.tableName + '`';
            if (parentRelation !== undefined) {
                var relations = parentRelation.relationFields;
                var relation = relations[0];
                fromList = fromList + ' ON `' + parent + '`.`' + relation.sourceField + '`=`' + parentRelation.targetObject + '`.`' + relation.targetField + '`';
                for (var i = 1; i < relations.length; i++) {
                    relation = relations[i];
                    fromList = fromList + ' AND `' + parent + '`.`' + relation.sourceField + '`=`' + parentRelation.targetObject + '`.`' + relation.targetField + '`';
                }
            }
            for (var key in baseModel.relations) {
                var relationship = baseModel.relations[key];
                var modelstr = relationship.targetObject;
                var modeldefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(modelstr);
                var configdefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(modelstr);
                fromList = fromList + ' LEFT OUTER JOIN ' + QueryBuilder.prototype.buildTableName(modeldefination, configdefination, config.tableName, relationship);
            }
            return fromList;
        };
        /**
         * @function buildConditions create a where condition based on criteria
         * @param  {Json} criteria Json object describing criteria
         * @param  {Json} config   config object
         * @return {String} where condition
         */
        QueryBuilder.prototype.buildConditions = function(criteria, config) {
            var finalCriteria = '';
            var leftcondition = '';
            var rightcondition = '';
            if (criteria !== undefined) {
                if (criteria.hasOwnProperty('expr')) {
                    if (!(criteria['lhs'].constructor == {}.constructor) && !(criteria['rhs'].constructor == {}.constructor)) {
                        finalCriteria = criteria['lhs'] + '' + criteria['expr'] + '' + criteria['rhs'];
                    } else {
                        if (criteria.hasOwnProperty('lhs') && criteria['lhs'].constructor == {}.constructor) {
                            leftcondition = leftcondition + QueryBuilder.prototype.buildConditions(criteria['lhs'], config);
                        } else {
                            leftcondition = criteria['lhs'];
                        }
                        if (criteria.hasOwnProperty('rhs') && criteria['rhs'].constructor == {}.constructor) {
                            rightcondition = rightcondition + QueryBuilder.prototype.buildConditions(criteria['rhs'], config);
                        } else {
                            rightcondition = criteria['rhs'];
                        }
                        finalCriteria = leftcondition + ' ' + criteria['expr'] + ' ' + rightcondition;
                    }
                }
            }
            return finalCriteria;
        };
        QueryBuilder.prototype.constructPrimaryKeyODataQuery = function(primaryKeyObj) {
            var filterQuery = '$filter=';
            var primaryKeys = Object.keys(primaryKeyObj);
            var length = primaryKeys.length;
            var query = '';
            for (var index in primaryKeys) {
                query = query + primaryKeys[index] + ' eq ' + primaryKeyObj[primaryKeys[index]];
                if (index < length - 1) query = query + ' and ';
            }
            if (query == '') {
                return null;
            } else {
                return filterQuery + query;
            }
            return query;
        };
        return QueryBuilder;
    }();
    DataModel_constants = {
        SESSIONTOKEN: 'session_token',
        DATA_OBJECT: 'dataObject',
        HEADERS_STRING: 'headers',
        QUERY_PARAMS: 'queryParams',
        LHS_STRING: 'lhs',
        RHS_STRING: 'rhs',
        ACCESS: 'access',
        ONLINE: 'online',
        OFFLINE: 'offline',
        SELECT_STRING: 'select ',
        FROM_STRING: ' from ',
        WHERE_STRING: ' where ',
        EXPR: 'expr',
        MESSAGE_FOR_RECORDCREATED: 'record created',
        MESSAGE_FOR_RECORDPARIALUPDATE: 'record partial update',
        MESSAGE_FOR_RECORDUPDATED: 'record updated',
        MESSAGE_FOR_RECORDDELETED: 'Record deleted',
        ERROR_IN_RECORD_DELETION: 'Error in record deletion',
        MODEL_STRING: 'Model',
        SYMBOL_UNDERSCORE: '_',
        MF_CONFIG_STRING: '_MF_Config',
        FORM_CONTROLLER_TYPE: 'kony.mvc.MDAFormController',
        HTTP_REQUEST_OPTIONS: 'httpRequestOptions',
        XML_REQUEST_OPTIONS: 'xmlHttpRequestOptions'
    };
    DataModel_Error = function() {
        //error object
        var Error = function() {
            this.errcode = null;
            this.errmsg = null;
            this.opstatus = null;
        };
        return Error;
    }();
    DataModel_DBAssembler = function(Error) {
        var assembler = {};
        /**
         * @function {function toDBJson}
         * @param  {BaseModel} BaseModelInstance {instance obj of BaseModel subType}
         * @param  {json object} config {config Json Mapping property names in BaseModel to db column names}
         * @return {json object} {Json object with instance values mapped to db column names}
         */
        assembler.toDBJson = function(BaseModelInstance, config) {
            /*if BaseModelInstance is an instance of model then object to json conversion is performed using toJsonInternal utility to ensure
             **getters are not invoked for this operation.
             **else if BaseModelInstance is an instance of BaseRepository not model instance, standard js methods could be used for conversion.
             */
            if (BaseModelInstance.toJsonInternal) {
                return BaseModelInstance.toJsonInternal();
            } else {
                var dbJson = {};
                Object.keys(config.mappings).forEach(function(key) {
                    dbJson[config.mappings[key]] = BaseModelInstance[key];
                });
                return dbJson;
            }
        };
        //create Error Object
        assembler.createError = function(BaseModelInstance, config, error) {
            var err = new Error();
            if (error.opstatus == 0) {
                if (config.mappings.text == undefined) {
                    err.errcode = 300;
                    err.errmsg = 'Invalid Params';
                    err.opstatus = error.opstatus;
                } else {
                    for (key in error) {
                        err[key] = error[key];
                    }
                }
            } else {
                for (key in error) {
                    err[key] = error[key];
                }
            }
            return err;
        };
        /**
         * @function {function fromDBJson}
         * @param  {BaseModelClass} BaseModelClass {Class of BaseModel subType for object creation}
         * @param  {json object} config         {config Json Mapping property names in BaseModel to db column names}
         * @param  {json object} dbJson         {Json object with instance values mapped to db column names}
         * @return {BaseModel} {BaseModel subType instance object}
         */
        assembler.fromDBJson = function(BaseModelClass, config, dbJson) {
            var modelJson = {};
            Object.keys(config.mappings).forEach(function(key) {
                modelJson[key] = dbJson[config.mappings[key]];
            });
            /*According to the new requirement internal layers shouldn't invoke getters and setters for object instantiation, below statements could be used
             **to instantiate object without invoking getters and setters.
             */
            var retModel = new BaseModelClass();
            if (retModel.fromJsonInternal) retModel.fromJsonInternal(modelJson);
            else retModel = new BaseModelClass(modelJson);
            var baseMap = BaseModelClass.prototype.attributeMap;
            var attributeMap = JSON.parse(JSON.stringify(baseMap));
            for (var attribute in attributeMap) {
                var model = attributeMap[attribute].model;
                var attributeDBValue = dbJson[attribute];
                if (model) {
                    var modelDefinition = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(model);
                    var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                    if (Array.isArray(attributeDBValue)) {
                        var modelArray = [];
                        for (var record in attributeDBValue) {
                            var modelAttributeJson = {};
                            Object.keys(modelConfig.mappings).forEach(function(key) {
                                modelAttributeJson[key] = attributeDBValue[record][modelConfig.mappings[key]];
                            });
                            var attributeModel = new modelDefinition();
                            if (attributeModel.fromJsonInternal) attributeModel.fromJsonInternal(modelAttributeJson);
                            else attributeModel = new modelDefinition(modelAttributeJson);
                            modelArray.push(attributeModel);
                        }
                        retModel[attribute] = modelArray;
                    } else {
                        var modelAttributeJson = {};
                        Object.keys(modelConfig.mappings).forEach(function(key) {
                            modelAttributeJson[key] = attributeDBValue[modelConfig.mappings[key]];
                        });
                        var attributeModel = new modelDefinition();
                        if (attributeModel.fromJsonInternal) attributeModel.fromJsonInternal(modelAttributeJson);
                        else attributeModel = new modelDefinition(modelAttributeJson);
                        retModel[attribute] = attributeModel;
                    }
                } else {
                    retModel[attribute] = attributeDBValue;
                }
            }
            return retModel;
        };
        return assembler;
    }(DataModel_Error);
    DataModel_DataSource = function(QueryBuilder, constants, DBAssembler) {
        DataSource = function() {};
        /**
         * @function getByPrimaryKey  fetches data for the specified model based on the primary keys
         * @param  {BaseModel} BaseModel model defination
         * @param  {Json} config      config of corresponding model
         * @param  {String/JSON} primaryKey   primitive in case of one primary key and json in case of composite primary key
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.getByPrimaryKey = function(BaseModel, config, primaryKey, onCompletion, accessMode, headerParams, dtoOptions) {
            var modelobject;
            var primaykeyobj = {};
            var primarykey;
            if (primaryKey == null || primaryKey == '' || primaryKey == undefined) {
                throw new Exception('ERROR_CODE_500', 'Invalid Primary Key');
            }
            for (var key in config.primaryKeys) {
                if (!(config.primaryKeys[key] in primaryKey)) {
                    var errPk = new Error();
                    errPk.opstatus = 0;
                    var errorobject = DBAssembler.createError(null, config, errPk);
                    errorobject.errmsg = 'Primary Key ' + config.primaryKeys[key] + ' is missing in the the input record.';
                    //User defines attributes with model object in attributeMap. Each API takes care of deleting the attributes defined
                    //for its usage. With each new invocation of the API, old attributes might be retained if not deleted which might
                    //cause inconsistency, if used.
                    for (var attribute in BaseModel.prototype.attributeMap) {
                        delete BaseModel.prototype.attributeMap[attribute];
                    }
                    onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorobject);
                    return;
                }
            }
            if (primaryKey.constructor == {}.constructor) {
                primaykeyobj = primaryKey;
            } else {
                for (var key in config.primaryKeys) {
                    primarykey = config.primaryKeys[key];
                    primaykeyobj[primarykey] = primaryKey;
                }
            }
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var odataQueryFlag = kony.mvc.MDAApplication.getSharedInstance().getODataStatus();
            var options = {};
            if (odataQueryFlag) {
                var queryBuilder = new QueryBuilder();
                var odataQuery = queryBuilder.constructPrimaryKeyODataQuery(primaykeyobj);
                if (odataQuery) dataObject.setOdataUrl(odataQuery);
            } else {
                options[constants.QUERY_PARAMS] = primaykeyobj;
            }
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.fetch(options, function(response) {
                if (response && response.records && response.records.length == 1) {
                    modelobject = DBAssembler.fromDBJson(BaseModel, config, response.records[0]);
                }
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                //callback sends status, data, error
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, modelobject, null);
            }, function(err) {
                //callback sends status, data, error
                errorobject = DBAssembler.createError(BaseModel, config, err);
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorobject);
            });
        };
        /**
         * @function checkObj   forms the valid JSON to be passed as criteria to fetch data for ONLINE calls
         * @param  {JSON} criteria      JSON including "EXPR","lhs" and "rhs" as criteria object for ONLINE calls
         * @param  {JSON} finalCriteria  JSON including pairs as value["lhs"] : value["rhs"] 
         * @return {JSON} finalCriteria
         */
        DataSource.prototype.checkObj = function(criteria, finalCriteria) {
            if (criteria.hasOwnProperty(constants.LHS_STRING) && criteria[constants.LHS_STRING].constructor == kony.mvc.Expression) {
                DataSource.prototype.checkObj(criteria[constants.LHS_STRING], finalCriteria);
            } else {
                finalCriteria[criteria[constants.LHS_STRING]] = criteria[constants.RHS_STRING];
            }
            if (criteria.hasOwnProperty(constants.RHS_STRING) && criteria[constants.RHS_STRING].constructor == kony.mvc.Expression) {
                DataSource.prototype.checkObj(criteria[constants.RHS_STRING], finalCriteria);
            } else {
                finalCriteria[criteria[constants.LHS_STRING]] = criteria[constants.RHS_STRING];
            }
            return finalCriteria;
        };
        /**
         * @function customVerb fetches data for the specified model using specified customVerb
         * @param  {BaseModel} BaseModel    model defination
         * @param  {Json}      config      config of corresponding model
         * @param  {String} customVerb   name of the custom verb to be executed
         * @param  {Json} params       parameters in the form of key value pairs
         * @param  {function} onCompletion success callback
         * @return 
         */
        DataSource.prototype.customVerb = function(BaseModel, config, customVerb, params, onCompletion, headerParams, dtoOptions) {
            var modelobject;
            var basemodel = new BaseModel();
            var models = [];
            var access = {};
            access[constants.ACCESS] = constants.ONLINE;
            var objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, access);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            for (var key in params) {
                dataObject.addField(key, params[key]);
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.customVerb(customVerb, options, function(response) {
                if (response[config.tableName]) {
                    for (var key in response[config.tableName]) {
                        modelobject = DBAssembler.fromDBJson(BaseModel, config, response[config.tableName][key]);
                        models.push(modelobject);
                    }
                    for (var attribute in BaseModel.prototype.attributeMap) {
                        delete BaseModel.prototype.attributeMap[attribute];
                    }
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, models, null);
                } else {
                    for (var attribute in BaseModel.prototype.attributeMap) {
                        delete BaseModel.prototype.attributeMap[attribute];
                    }
                    if (response.text === null) {
                        errorObject = DBAssembler.createError(BaseModel, config, response);
                        if (errorObject.code == 300) {
                            onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
                        } else {
                            onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                        }
                    }
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, response, null);
                }
            }, function(err) {
                //callback sends status, data, error
                errorObject = DBAssembler.createError(BaseModel, config, err);
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
            });
        };
        /**
         * @function createModelResponse  converts the backend response into required models
         * @param  {Json} response  response from backend
         * @param  {BaseModel} baseModel model defination
         * @param  {Json} config    config of corresponding model
         * @return {Json} backend responde in the form of models
         */
        DataSource.prototype.createModelResponse = function(response, baseModel, config) {
            var modelresponse = {};
            for (var key in baseModel.relations) {
                var relationship = baseModel.relations[key];
                var modelstr = relationship.targetObject;
                var modeldefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getModelDefinition(modelstr);
                var configdefination = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(modelstr);
                for (var relations in relationship.relationFields) {
                    var relation = relationship.relationFields[relations];
                    var res = DataSource.prototype.createModelResponse(response, modeldefination, configdefination);
                    response[config.tableName + constants.SYMBOL_UNDERSCORE + relation.sourceField] = res;
                }
            }
            for (var column in config.mappings) {
                try {
                    modelresponse[config.mappings[column]] = response[config.tableName + constants.SYMBOL_UNDERSCORE + config.mappings[column]];
                } catch (err) {}
            }
            var modelObject = DBAssembler.fromDBJson(baseModel, config, modelresponse);
            return modelObject;
        };
        /**
         * @function getByCriteria  fetches data for the specified model based on the criteria passed
         * @param  {BaseModel} modelDefination   model defination
         * @param  {Json} config          config of corresponding model
         * @param  {Json} criteria        criteria object based on which query is build in case of ONLINE and OFFLINE
         * @param  {function} onCompletion    success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.getByCriteria = function(modelDefination, config, criteria, onCompletion, accessMode, headerParams, dtoOptions) {
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            var modelobject;
            var models = [];
            var objSvc;
            var finalCriteria = {};
            var access = {};
            if (accessMode[constants.ACCESS] == constants.OFFLINE) {
                var queryString;
                var query = new QueryBuilder();
                var selectList = query.buildSelectList(modelDefination, config);
                var fromList = query.buildTableName(modelDefination, config);
                selectList = selectList.slice(0, -1);
                queryString = constants.SELECT_STRING + selectList + constants.FROM_STRING + fromList + constants.WHERE_STRING + query.buildConditions(criteria, config);
                var tables = [config.tableName];
                for (var key in modelDefination.relations) {
                    var relationship = modelDefination.relations[key];
                    tables.push(relationship.targetObject);
                }
                access[constants.ACCESS] = constants.OFFLINE;
                objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, access);
                objSvc.executeSelectQuery(queryString, function(response) {
                    kony.print(JSON.stringify(response));
                    var modelresponse = [];
                    for (var key in response) {
                        modelobject = DataSource.prototype.createModelResponse(response[key], modelDefination, config);
                        modelresponse.push(modelobject);
                    }
                    onCompletion(modelresponse);
                }, function(err) {
                    errorObject = DBAssembler.createError(modelDefination, config, err);
                    onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
                });
            } else {
                if (criteria !== undefined) {
                    if (criteria.hasOwnProperty(constants.EXPR)) {
                        if (criteria.hasOwnProperty(constants.LHS_STRING) && criteria[constants.LHS_STRING].constructor == kony.mvc.Expression) {
                            finalCriteria = DataSource.prototype.checkObj(criteria[constants.LHS_STRING], finalCriteria);
                        }
                        if (criteria.hasOwnProperty(constants.RHS_STRING) && criteria[constants.RHS_STRING].constructor == kony.mvc.Expression) {
                            finalCriteria = DataSource.prototype.checkObj(criteria[constants.RHS_STRING], finalCriteria);
                        }
                        if (!(criteria[constants.LHS_STRING].constructor == kony.mvc.Expression && criteria[constants.RHS_STRING].constructor == kony.mvc.Expression)) {
                            finalCriteria[criteria[constants.LHS_STRING]] = criteria[constants.RHS_STRING];
                        }
                    }
                }
                access[constants.ACCESS] = constants.ONLINE;
                objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, access);
                var headers = {};
                headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
                for (var headKey in headerParams) {
                    headers[headKey] = headerParams[headKey];
                }
                var dataObject = new kony.sdk.dto.DataObject(config.tableName);
                DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
                var options = {};
                options[constants.DATA_OBJECT] = dataObject;
                options[constants.HEADERS_STRING] = headers;
                options[constants.QUERY_PARAMS] = finalCriteria;
                var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
                var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
                if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
                if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
                objSvc.fetch(options, function(response) {
                    for (var key in response.records) {
                        modelobject = DBAssembler.fromDBJson(modelDefination, config, response.records[key]);
                        models.push(modelobject);
                    }
                    for (var attribute in modelDefination.prototype.attributeMap) {
                        delete modelDefination.prototype.attributeMap[attribute];
                    }
                    //callback sends status, data, error
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, models, null);
                }, function(err) {
                    //callback sends status, data, error
                    errorObject = DBAssembler.createError(modelDefination, config, err);
                    for (var attribute in modelDefination.prototype.attributeMap) {
                        delete modelDefination.prototype.attributeMap[attribute];
                    }
                    onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject);
                });
            }
        };
        /**
         * @function save saves the given model data in the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.save = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var baseMap = BaseModel.attributeMap;
            if (baseMap) {
                /*Removing JSON.parse(JSON.stringify(baseMap) since it calls getters which in turn calls post processor.Internal layer should not call getters and setters.
                 **Instead of cloning, pushing all the keys in baseMap to attributeMap and then iterating over attributeMap fixes our requirement.
                 */
                var attributeMap = [];
                for (var i in baseMap) {
                    attributeMap.push(i);
                }
                for (var attribute in attributeMap) {
                    var model = baseMap[attributeMap[attribute]].model;
                    var attributeValue = baseMap[attributeMap[attribute]].value;
                    if (model) {
                        var modelArray = [];
                        var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                        if (Array.isArray(attributeValue)) {
                            for (var eachRecord in attributeValue) {
                                var dbobject = DBAssembler.toDBJson(attributeValue[eachRecord], modelConfig);
                                modelArray.push(dbobject);
                            }
                        } else {
                            var dbobject = DBAssembler.toDBJson(attributeValue, modelConfig);
                            modelArray.push(dbobject);
                        }
                        dataObject.addField(attributeMap[attribute], modelArray);
                    } else {
                        dataObject.addField(attributeMap[attribute], attributeValue);
                    }
                    delete BaseModel.attributeMap[attributeMap[attribute]];
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.create(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDCREATED + JSON.stringify(res));
                kony.print(constants.MESSAGE_FOR_RECORDCREATED);
                //callback sends status, data, error
                if (res.text === null) {
                    errorObject = DBAssembler.createError(BaseModel, config, response);
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                }
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //callback sends status, data, error
                //onCompletion(kony.mvc.constants.STATUS_FAILURE,undefined,err);
            });
        };
        /**
         * @function partialUpdate partially update the model data to the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.partialUpdate = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var baseMap = BaseModel.attributeMap;
            if (baseMap) {
                /*Removing JSON.parse(JSON.stringify(baseMap) since it calls getters which in turn calls post processor.Internal layer should not call getters and setters.
                 **Instead of cloning, pushing all the keys in baseMap to attributeMap and then iterating over attributeMap fixes our requirement.
                 */
                var attributeMap = [];
                for (var i in baseMap) {
                    attributeMap.push(i);
                }
                for (var attribute in attributeMap) {
                    var model = baseMap[attributeMap[attribute]].model;
                    var attributeValue = baseMap[attributeMap[attribute]].value;
                    if (model) {
                        var modelArray = [];
                        var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                        if (Array.isArray(attributeValue)) {
                            for (var eachRecord in attributeValue) {
                                var dbobject = DBAssembler.toDBJson(attributeValue[eachRecord], modelConfig);
                                modelArray.push(dbobject);
                            }
                        } else {
                            var dbobject = DBAssembler.toDBJson(attributeValue, modelConfig);
                            modelArray.push(dbobject);
                        }
                        dataObject.addField(attributeMap[attribute], modelArray);
                    } else {
                        dataObject.addField(attributeMap[attribute], attributeValue);
                    }
                    delete BaseModel.attributeMap[attributeMap[attribute]];
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.partialUpdate(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDPARIALUPDATE + JSON.stringify(res));
                kony.print(constants.MESSAGE_FOR_RECORDPARIALUPDATE);
                //callback sends status, data, error
                if (res.text === null) {
                    errorObject = DBAssembler.createError(BaseModel, config, response);
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                }
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //callback sends status, data, error
            });
        };
        /**
         * @function getAll fetches  all the records for the specified model
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.getAll = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var modelobject;
            var models = [];
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.fetch(options, function(response) {
                for (var key in response.records) {
                    modelobject = DBAssembler.fromDBJson(BaseModel, config, response.records[key]);
                    models.push(modelobject);
                }
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                //callback sends status, data, error
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, models, null);
            }, function(err) {
                //callback sends status, data, error
                errorObject = DBAssembler.createError(BaseModel, config, err);
                for (var attribute in BaseModel.prototype.attributeMap) {
                    delete BaseModel.prototype.attributeMap[attribute];
                }
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); // onCompletion(kony.mvc.constants.STATUS_FAILURE,undefined,err);
            });
        };
        /**
         * @function update updates the specified model into the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {JSON} config       config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        DataSource.prototype.update = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var baseMap = BaseModel.attributeMap;
            if (baseMap) {
                /*Removing JSON.parse(JSON.stringify(baseMap) since it calls getters which in turn calls post processor.Internal layer should not call getters and setters.
                 **Instead of cloning, pushing all the keys in baseMap to attributeMap and then iterating over attributeMap fixes our requirement.
                 */
                var attributeMap = [];
                for (var i in baseMap) {
                    attributeMap.push(i);
                }
                for (var attribute in attributeMap) {
                    var model = baseMap[attributeMap[attribute]].model;
                    var attributeValue = baseMap[attributeMap[attribute]].value;
                    if (model) {
                        var modelArray = [];
                        var modelConfig = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(model);
                        if (Array.isArray(attributeValue)) {
                            for (var eachRecord in attributeValue) {
                                var dbobject = DBAssembler.toDBJson(attributeValue[eachRecord], modelConfig);
                                modelArray.push(dbobject);
                            }
                        } else {
                            var dbobject = DBAssembler.toDBJson(attributeValue, modelConfig);
                            modelArray.push(dbobject);
                        }
                        dataObject.addField(attributeMap[attribute], modelArray);
                    } else {
                        dataObject.addField(attributeMap[attribute], attributeValue);
                    }
                    delete BaseModel.attributeMap[attributeMap[attribute]];
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.update(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDUPDATED + JSON.stringify(res));
                kony.print(constants.MESSAGE_FOR_RECORDUPDATED);
                //callback sends status, data, error
                if (res.text === null) {
                    errorObject = DBAssembler.createError(BaseModel, config, response);
                    onCompletion(kony.mvc.constants.STATUS_SUCCESS, errorObject, null);
                }
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(JSON.stringify(err));
                //callback sends status, data, error
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //onCompletion(kony.mvc.constants.STATUS_FAILURE,undefined,err);
            });
        };
        /**
         * @function remove deletes the specified model from the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {Json} config      config of corresponding model
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        DataSource.prototype.remove = function(BaseModel, config, onCompletion, accessMode, headerParams, dtoOptions) {
            var dbobject = DBAssembler.toDBJson(BaseModel, config);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            for (var key in dbobject) {
                if (dbobject[key] !== null) {
                    dataObject.addField(key, dbobject[key]);
                }
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.deleteRecord(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDDELETED);
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(constants.ERROR_IN_RECORD_DELETION + JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); //onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, err);
            });
        };
        /**
         * @function removeById deletes the specified model from the backend
         * @param  {BaseModel} BaseModel    model defination
         * @param  {Json} config      config of corresponding model
         * @param  {function} onCompletion success callback
         * @param {JSON/STRING} primaryKey primary key value or json representing the key and value
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        DataSource.prototype.removeById = function(BaseModel, config, primaryKey, onCompletion, accessMode, headerParams, dtoOptions) {
            var modelobject;
            var primaykeyobj = {};
            var primarykey;
            if (primaryKey == null || primaryKey == '' || primaryKey == undefined) {
                throw new Exception('ERROR_CODE_500', 'Invalid  Primary Key');
            }
            if (primaryKey.constructor == {}.constructor) {
                primaykeyobj = primaryKey;
            } else {
                for (var key in config.primaryKeys) {
                    primarykey = config.primaryKeys[key];
                    primaykeyobj[primarykey] = primaryKey;
                }
            }
            var objSvc;
            if (accessMode === undefined) {
                accessMode = kony.mvc.MDAApplication.getSharedInstance().getAppMode();
            }
            objSvc = kony.sdk.getCurrentInstance().getObjectService(config.serviceName, accessMode);
            var headers = {};
            headers[constants.SESSIONTOKEN] = kony.mvc.MDAApplication.getSharedInstance().appContext.session_token;
            for (var headKey in headerParams) {
                headers[headKey] = headerParams[headKey];
            }
            var dataObject = new kony.sdk.dto.DataObject(config.tableName);
            DataSource.prototype.addOptionsToDTO(dataObject, dtoOptions);
            var keys = Object.keys(primaykeyobj);
            for (var records in keys) {
                dataObject.addField(keys[records], primaykeyobj[keys[records]]);
            }
            var options = {};
            options[constants.DATA_OBJECT] = dataObject;
            options[constants.HEADERS_STRING] = headers;
            //options[constants.QUERY_PARAMS]= primaykeyobj;
            var httpOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.httpRequestOptions;
            var xmlOptions = kony.mvc.MDAApplication.getSharedInstance().appContext.xmlRequestOptions;
            if (httpOptions) options[constants.HTTP_REQUEST_OPTIONS] = httpOptions;
            if (xmlOptions) options[constants.XML_REQUEST_OPTIONS] = xmlOptions;
            objSvc.deleteRecord(options, function(res) {
                kony.print(constants.MESSAGE_FOR_RECORDDELETED);
                onCompletion(kony.mvc.constants.STATUS_SUCCESS, res, null);
            }, function(err) {
                kony.print(constants.ERROR_IN_RECORD_DELETION + JSON.stringify(err));
                errorObject = DBAssembler.createError(BaseModel, config, err);
                onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, errorObject); // onCompletion(kony.mvc.constants.STATUS_FAILURE, undefined, err);
            });
        };
        DataSource.prototype.addOptionsToDTO = function(dataObject, dtoOptions) {
            for (var key in dtoOptions) {
                dataObject[key] = dtoOptions[key];
            }
        };
        return DataSource;
    }(DataModel_QueryBuilder, DataModel_constants, DataModel_DBAssembler);
    DataModel_BaseRepository = function(DataSource) {
        function BaseRepository(modelDefinition, config, injectedDataSource) {
            this.modelDefinition = modelDefinition;
            this.config = config;
            this.datasource = injectedDataSource || new DataSource();
            this.headerParams = null;
        }
        /**
         * @function initialize initalize the base repository
         * @param  {JSON} context 
         * @return 
         */
        BaseRepository.prototype.initialize = function(context) {};
        /**
         * @function save saves the given model data in the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.save = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.save(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function update updates the specified model into the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.update = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.update(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function partialUpdate partially update the model data to the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseRepository.prototype.partialUpdate = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.partialUpdate(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function remove deletes the specified model from the backend
         * @param  {BaseModel} modelInstance model object
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.remove = function(modelInstance, onCompletion, accessMode, options) {
            this.datasource.remove(modelInstance, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function removeById deletes the specified model from the backend
         * @param  {BaseModel} modelInstance model object
         * @param {JSON/STRING} primaryKey primary key value or json representing the key and value
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.removeById = function(modelInstance, primaryKey, onCompletion, accessMode, options) {
            this.datasource.removeById(modelInstance, this.config, primaryKey, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function getByPrimaryKey  fetches data for the specified model based on the primary keys
         * @param  {String/JSON} primaryKey   primitive in case of one primary key and json in case of composite primary key
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseRepository.prototype.getByPrimaryKey = function(PrimaryKey, onCompletion, accessMode, options) {
            this.datasource.getByPrimaryKey(this.modelDefinition, this.config, PrimaryKey, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function getAll fetches  all the records for the specified model
         * @param  {type} onCompletion success callback
         * @param  {type} accessMode   json specifing access mode
         * @return 
         */
        BaseRepository.prototype.getAll = function(onCompletion, accessMode, options) {
            this.datasource.getAll(this.modelDefinition, this.config, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function customVerb fetches data for the specified model using specified customVerb
         * @param  {String} customVerb   name of the custom verb to be executed
         * @param  {JSON} params       parameters in the form of key value pairs
         * @param  {function} onCompletion success callback
         * @return 
         */
        BaseRepository.prototype.customVerb = function(customVerb, params, onCompletion, options) {
            this.datasource.customVerb(this.modelDefinition, this.config, customVerb, params, onCompletion, this.headerParams, options);
            this.clearHeaderParams();
        };
        /**
         * @function getByCriteria  fetches data for the specified model based on the criteria passed
         * @param  {Json} criteria        criteria object based on which query is build in case of online and offline
         * @param  {function} onCompletion    success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseRepository.prototype.getByCriteria = function(criteria, onCompletion, accessMode, options) {
            this.datasource.getByCriteria(this.modelDefinition, this.config, criteria, onCompletion, accessMode, this.headerParams, options);
            this.clearHeaderParams();
        };
        BaseRepository.prototype.setHeaderParams = function(headers) {
            this.headerParams = headers;
        };
        BaseRepository.prototype.clearHeaderParams = function() {
            this.headerParams = null;
        };
        return BaseRepository;
    }(DataModel_DataSource);
    DataModel_RepositoryManager = function(BaseRepository) {
        RepositoryManager = function() {
            this.repoMap = {};
            this.repo = undefined;
            this.repoConfig = undefined;
            this.initializeRepoConfig('RepoManagerConfig');
        };
        RepositoryManager.prototype.initialize = function(context) {};
        /**
         * @function initializeRepoConfig intializes repoManagerConfig which is generated 
         * @param  {String} repoconfig repoManagerConfig file name
         * @return 
         */
        RepositoryManager.prototype.initializeRepoConfig = function(repoconfig) {
            this.repoConfig = require(repoconfig);
        };
        /**
         * @function getRepository
         * @param  {String} model model name as per repoManagerConfig file
         * @return {BaseRepository} repository for given model
         */
        RepositoryManager.prototype.getRepository = function(model) {
            var repo = this.repoMap[model];
            if (repo === undefined) {
                var modelConfig = this.repoConfig[model];
                var modelPath = modelConfig['model'];
                var configPath = modelConfig['config'];
                var repoPath = modelConfig['repository'];
                var repository;
                if (repoPath == '') {
                    repository = BaseRepository;
                } else {
                    repository = require(repoPath);
                }
                this.setRepository(model, modelPath, configPath, repository);
            }
            return this.repoMap[model];
        };
        /**
         * @function getAllRepository gives all the repositories which are set in repository manager
         * @return {Array} list of repositories
         */
        RepositoryManager.prototype.getAllRepository = function() {
            var repositories = [];
            for (var model in this.repoMap) {
                repositories.push(this.repoMap[model]);
            }
            return repositories;
        };
        /**
         * @function setRepository sets repository in repository manager
         * @param  {String} modelName       name of model as per repoManagerConfig file
         * @param  {String} modelPath       Path of model which used to require the corresponding model 
         * @param  {String} configPath      Path of config which used to require the corresponding config
         * @param  {function} ModelRepository repository defination
         * @return 
         */
        RepositoryManager.prototype.setRepository = function(modelName, modelPath, configPath, ModelRepository) {
            var model = require(modelPath);
            var config = require(configPath);
            var repository = new ModelRepository(model, config);
            this.repoMap[modelName] = repository;
        };
        return RepositoryManager; //}();
    }(DataModel_BaseRepository);
    PresentationController_MDABasePresenter = function() {
        function MDABasePresenter() {
            this.navigator = null;
            this.businessController = null;
            this.superParams = {
                counter: 0,
                level: null,
                refStack: []
            };
            this.initialize();
        }
        MDABasePresenter.prototype.initialize = function() {};
        MDABasePresenter.prototype.asyncUpdateUI = function(uiTag, context) {
            var formInStack = false;
            for (var i = 0; i < this._presentationStack.length; i++) {
                if (this._presentationStack[i].formName == uiTag) {
                    formInStack = true;
                    break;
                }
            }
            if (formInStack) {
                var controller = _kony.mvc.GetController(uiTag, true);
                controller.updateUI(context);
            } else {
                kony.print('## MDA: Trying to asyncUpdateUI. Can\'t find the FORM: ' + uiTag + ' as Loaded.');
            }
        };
        MDABasePresenter.prototype.presentUserInterface = function(uiTag, context, isBack) {
            isBack = isBack ? isBack : false;
            if (!isBack) {
                this._pushToPresentationStack(this, uiTag, context);
            }
            //TO DO: Will move to individial Derived class
            this.navigator.presentUserInterface(uiTag, context);
        };
        MDABasePresenter.prototype._onEventRaised = function(sender, eventId, eventContext) {
            if ('on' + eventId in this) {
                this['on' + eventId].call(this, sender, eventContext);
            } else {
                this.onEventRaised(sender, eventId, eventContext);
            }
        };
        MDABasePresenter.prototype.onEventRaised = function(sender, eventId, eventContext) {};
        MDABasePresenter.prototype._presentationStack = [];
        MDABasePresenter.prototype._createPresentationStackObject = function(presenter, formName, context) {
            var stackObj = {};
            stackObj.presenter = presenter;
            stackObj.formName = formName;
            stackObj.context = context;
            return stackObj;
        };
        MDABasePresenter.prototype._pushToPresentationStack = function(presenter, formName, context) {
            if (this._presentationStack.length != 0) {
                var top = this._presentationStack.length - 1;
                var topStackObj = this._presentationStack[top];
                if (topStackObj.formName == formName) {
                    topStackObj.context = context;
                } else {
                    this._presentationStack.push(this._createPresentationStackObject(presenter, formName, context));
                }
            } else {
                this._presentationStack.push(this._createPresentationStackObject(presenter, formName, context));
            }
        };
        MDABasePresenter.prototype._popFromPresentationStack = function() {
            var poppedStackObject = this._presentationStack.pop();
            var stackLength = this._presentationStack.length;
            if (stackLength != 0) return this._presentationStack[stackLength - 1];
            else return null;
        };
        MDABasePresenter.prototype.clearPresentationStackUntil = function(formName) {
            if (formName) {
                var top = this._presentationStack.length - 1;
                while (this._presentationStack[top].formName != formName) {
                    this._presentationStack.pop();
                    top -= 1;
                }
            } else {
                kony.print('mention form name parameter to clear until that object in stack');
            }
        };
        MDABasePresenter.prototype.presentPreviousScreen = function(context) {
            var previousStackContext = this._popFromPresentationStack();
            if (previousStackContext) {
                var presenter = previousStackContext.presenter;
                var formName = previousStackContext.formName;
                var context = context ? context : previousStackContext.context;
                presenter.presentUserInterface(formName, context, true);
            } else {
                kony.print('No previous forms available');
            }
        };
        MDABasePresenter.prototype.attachBackPresentationFlow = function(formName, context) {
            this._pushToPresentationStack(this, formName, context);
        };
        MDABasePresenter.prototype.detachFromPresentationFlow = function(formName) {
            var poppedArray = [];
            var top = this._presentationStack.length - 1;
            while (this._presentationStack[top].formName != formName) {
                var poppedObject = this._presentationStack.pop();
                poppedArray.push(poppedObject);
                top -= 1;
            }
            //Removing the from
            this._presentationStack.pop();
            Array.prototype.push.apply(this._presentationStack, poppedArray);
        };
        MDABasePresenter.prototype.getCurrentForm = function() {
            var top = this._presentationStack.length - 1;
            var topStackObj = this._presentationStack[top];
            return topStackObj.formName;
        };
        MDABasePresenter.prototype.super = function(methodName, argList) {
            var scope = this;
            var returnValue = null;
            if (this.superParams.level === null) {
                this.superParams.level = 0;
                while (scope['extensionLevel' + this.superParams.level.toString()]) {
                    this.superParams.level++;
                }
            }
            if (this.superParams.counter === 0) {
                for (var i = 0; i < this.superParams.level; i++) {
                    if (scope['extensionLevel' + i.toString()][methodName]) {
                        this.superParams.refStack.push(i);
                    }
                }
            }
            this.superParams.refStack.pop();
            if (this.superParams.refStack.length !== 0) {
                var callLvl = this.superParams.refStack[this.superParams.refStack.length - 1];
                this.superParams.counter++;
                returnValue = scope['extensionLevel' + callLvl.toString()][methodName].apply(this, argList);
                this.superParams.counter--;
            } else {
                kony.print('#MDA2 : Can\'t find any super for the ' + methodName + ' Method.');
            }
            if (this.superParams.counter === 0) {
                this.superParams.refStack = [];
                this.superParams.level = null;
            }
            return returnValue;
        };
        return MDABasePresenter;
    }();
    BaseNavigator_MDABaseNavigator = function() {
        function MDABaseNavigator() {
            this.presentationController = null;
            this.config = null;
            this.initialize();
        }
        MDABaseNavigator.prototype.initialize = function() {};
        MDABaseNavigator.prototype.presentUserInterface = function(uiTag, context) {
            var formToPresent = uiTag;
            this.presentForm(formToPresent, uiTag, context);
        };
        MDABaseNavigator.prototype.presentForm = function(form, uiTag, viewModel) {
            var context = {};
            context['viewModel'] = viewModel;
            context._presenter = this.presentationController;
            var config = this.getConfig(form);
            context._formConfig = config;
            var _currentForm = kony.application.getCurrentForm();
            if (_currentForm && form == _currentForm.id) {
                var controller = _kony.mvc.GetController(form, true);
                controller.updateUI(context['viewModel']);
            } else {
                try {
                    var frmNavObject = new kony.mvc.Navigation(form);
                    frmNavObject.navigate(context);
                } catch (err) {
                    throw new Exception('ERROR_CODE_300', 'Error at Navigator, Missing or Wrong UITag : ' + err);
                }
            }
        };
        MDABaseNavigator.prototype.getConfig = function(form) {
            var name;
            try {
                this.name = eval(form + 'Config');
            } catch (err) {
                return null;
            }
            return this.name;
        };
        return MDABaseNavigator;
    }();
    ModuleManager_MDAModule = function(MDABasePresenter, MDABaseNavigator, BusinessController, constants, BusinessDelegator) {
        function MDAModule(moduleName, moduleMode, channel, callback, isStartup) {
            this.businessController = null;
            this.presentationController = null;
            this.navigator = null;
            this.moduleName = moduleName;
            this.channel = channel;
            try {
                this.moduleConfig = eval(this.moduleName + 'Config');
                if (this.moduleConfig[moduleMode]) {
                    this.moduleConfig = this.moduleConfig[moduleMode];
                    this.moduleMode = moduleMode;
                } else {
                    this.moduleMode = 'Default';
                    kony.print('MDA2***..module: ' + moduleName + '- Default Mode');
                }
            } catch (e) {
                throw new Exception('ERROR_CODE_600', 'Module Config expected ' + e);
            }
            if (isStartup == 1) {
                this.setStartupModule(callback);
            } else {
                this.setupModule(callback);
            }
        }
        MDAModule.prototype.setStartupModule = function(callback) {
            kony.print('MDA2*** Setup Startup module');
            if (callback !== undefined) {
                this.setUpBusinessPresentationController(callback);
                this.setUpNavigator();
            } else {
                this.setUpBusinessController();
                this.setUpPresentationController();
                this.setUpNavigator();
                this.presentationController.navigator = this.navigator;
                this.presentationController.businessController = this.businessController;
                this.navigator.presentationController = this.presentationController;
            }
        };
        MDAModule.prototype.setupModule = function(callback) {
            kony.print('MDA2*** Setup module');
            if (callback !== undefined) {
                this.setUpForms();
                this.setUpBusinessPresentationController(callback);
                this.setUpNavigator();
            } else {
                this.setUpForms();
                this.setUpBusinessController();
                this.setUpPresentationController();
                this.setUpNavigator();
                this.presentationController.navigator = this.navigator;
                this.presentationController.businessController = this.businessController;
                this.navigator.presentationController = this.presentationController;
            }
        };
        MDAModule.prototype.setUpBusinessPresentationController = function(callback) {
            if (this.moduleConfig === undefined) {
                this.businessController = this.createBusinessController();
                this.presentationController = this.createPresentationController();
                if (this.businessController === null && this.presentationController === null) {
                    kony.print('MDA2*** Derived module does not provide a Business controller');
                    this.businessController = this.createDefaultBusinessController();
                }
            } else {
                var businessControllerClass, presentationControllerClass, businessExtensions, presentationExtensions;
                if (this.moduleConfig.BusinessControllerConfig) {
                    businessControllerClass = this.moduleConfig.BusinessControllerConfig.BusinessControllerClass;
                    if (this.moduleConfig.BusinessControllerConfig.CommandHandler) {
                        var commandHandlers = this.moduleConfig.BusinessControllerConfig.CommandHandler;
                        var handlersarray = [],
                            commandId = [],
                            commandHandlerExtn = [];
                        for (var i = 0; i < commandHandlers.length; i++) {
                            commandId[i] = commandHandlers[i].CommandId;
                            commandHandlerExtn[i] = commandHandlers[i].CommandHandlerExtension;
                            handlersarray[i] = commandHandlers[i].CommandHandler;
                        }
                    }
                }
                if (this.moduleConfig.BusinessControllerConfig.BusinessExtensions) businessExtensions = this.moduleConfig.BusinessControllerConfig.BusinessExtensions;
                //If buisnessController class is not supplied in config file, 
                //create from derived module else default Buisness controller
                var currentChannel = kony.sdk.getChannelType();
                //TO DO: Platform team to generate channel correctly
                currentChannel = currentChannel.charAt(0).toUpperCase() + currentChannel.slice(1);
                if (this.channel === undefined) {
                    if (this.moduleConfig.PresentationControllerConfig) {
                        var defaultPresentation = this.moduleConfig.PresentationControllerConfig['Default'];
                        var channelPresentation = this.moduleConfig.PresentationControllerConfig[currentChannel];
                        this.channel = channelPresentation ? currentChannel : 'Default';
                        presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                        presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                    } else presentationControllerClass = undefined;
                } else {
                    if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) {
                        presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                        presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                    } else presentationControllerClass = undefined;
                }
                if (businessControllerClass === undefined || businessControllerClass === '' || presentationControllerClass === undefined || presentationControllerClass === '') {
                    kony.print(' MDA2*** Config does not provide a Business controller');
                    kony.print('MDA2*** Config does not provide a Presentation controller');
                    this.businessController = this.createBusinessController();
                    this.presentationController = this.createPresentationController();
                    if (this.businessController === null && this.presentationController === null) {
                        kony.print('MDA2*** Derived module does not provide a Business controller');
                        this.businessController = this.createDefaultBusinessController();
                        kony.print('MDA2*** Derived module does not provide a Presentation controller');
                        this.presentationController = this.createDefaultPresentationController();
                    }
                } else {
                    kony.print('MDA2*** Config  provides a Presentation controller');
                    try {
                        var pController, bController;
                        var self = this;
                        var params = [
                            presentationControllerClass,
                            businessControllerClass
                        ];
                        params = params.concat(businessExtensions);
                        params = params.concat(presentationExtensions);
                        if (handlersarray) params = params.concat(handlersarray);
                        if (commandHandlerExtn) params = params.concat(commandHandlerExtn);
                        var DerivedController = require(params, function() {
                            presentationControllerClass = arguments[0];
                            businessControllerClass = arguments[1];
                            pController = new presentationControllerClass();
                            bController = new businessControllerClass();
                            self.presentationController = pController;
                            self.businessController = bController;
                            self.navigator.presentationController = self.presentationController;
                            self.presentationController.businessController = self.businessController;
                            self.presentationController.navigator = self.navigator;

                            function Callback() {
                                callback(self);
                            }
                            self.createPresentationExtensionsAsync(function() {
                                if (BusinessController.prototype.isPrototypeOf(bController)) {
                                    self.createCommandHandlers(Callback);
                                } else {
                                    self.createBusinessExtensionsAsync(businessExtensions, Callback);
                                } //callback(self);
                            });
                            kony.print('MDA2*** Config  provides a Business controller');
                        });
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', ' Invalid Presentation Controller Class ' + err);
                    }
                }
            }
        };
        MDAModule.prototype.createBusinessExtensionsAsync = function(businessExtensions, callback) {
            var self = this;
            if (businessExtensions !== undefined) {
                var extNModule;
                try {
                    (function() {
                        return this;
                    }()['require'](businessExtensions, function() {
                        extNModule = [self.businessController].concat(Array.prototype.slice.call(arguments));
                        kony.print('MDA2**** extNModule : ' + extNModule);
                        _kony.mvc.assignFunctions2Controller(self.businessController, extNModule);
                        callback(self);
                    }));
                } catch (err) {
                    throw new Exception('ERROR_CODE_300', 'Business Controller Extension invalid ' + err);
                }
                kony.print('MDA2**** extNModule : ' + extNModule);
            } else {
                callback(self);
                kony.print('MDA2**** invalid businessExtensions: ' + businessExtensions);
            }
        };
        MDAModule.prototype.createPresentationExtensionsAsync = function(callback) {
            var self = this;
            if (this.moduleConfig !== undefined) {
                var presentationExtensions;
                if (this.channel === undefined) {
                    extChannel = 'Default';
                }
                if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                if (presentationExtensions !== undefined) {
                    var extNModule;
                    try {
                        (function() {
                            return this;
                        }()['require'](presentationExtensions, function() {
                            extNModule = [self.presentationController].concat(Array.prototype.slice.call(arguments));
                            kony.print('MDA2**** extNModule : ' + extNModule);
                            _kony.mvc.assignFunctions2Controller(self.presentationController, extNModule);
                            callback();
                        }));
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', 'Presentation Controller Extension invalid ' + err);
                    }
                }
            }
        };
        MDAModule.prototype.setUpBusinessController = function() {
            if (this.moduleConfig === undefined) {
                this.businessController = this.createBusinessController();
                if (this.businessController === null) {
                    kony.print('MDA2*** Derived module does not provide a Business controller');
                    this.businessController = this.createDefaultBusinessController();
                }
            } else {
                var businessControllerClass;
                if (this.moduleConfig.BusinessControllerConfig) businessControllerClass = this.moduleConfig.BusinessControllerConfig.BusinessControllerClass;
                //If buisnessController class is not supplied in config file, 
                //create from derived module else default Buisness controller
                if (businessControllerClass === undefined || businessControllerClass === '') {
                    kony.print(' MDA2*** Config does not provide a Business controller');
                    this.businessController = this.createBusinessController();
                    if (this.businessController === null) {
                        kony.print('MDA2*** Derived module does not provide a Business controller');
                        this.businessController = this.createDefaultBusinessController();
                    }
                } else {
                    kony.print('MDA2*** Config  provides a Business controller');
                    try {
                        var DerivedBusinessController = require(businessControllerClass);
                        this.businessController = new DerivedBusinessController();
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', 'Invalid Business Controller Class ' + err);
                    }
                }
            }
            if (BusinessController.prototype.isPrototypeOf(this.businessController)) {
                this.createCommandHandlers();
            } else {
                this.createBusinessExtensions();
            }
        };
        MDAModule.prototype.setUpPresentationController = function() {
            if (this.moduleConfig === undefined) {
                this.presentationController = this.createPresentationController();
                if (this.presentationController === null) {
                    kony.print('MDA2*** Derived module does not provide a Presentation controller');
                    this.presentationController = this.createDefaultPresentationController();
                }
            } else {
                var presentationControllerClass;
                var currentChannel = kony.sdk.getChannelType();
                //TO DO: Platform team to generate channel correctly
                currentChannel = currentChannel.charAt(0).toUpperCase() + currentChannel.slice(1);
                if (this.channel === undefined) {
                    if (this.moduleConfig.PresentationControllerConfig) {
                        var defaultPresentation = this.moduleConfig.PresentationControllerConfig['Default'];
                        var channelPresentation = this.moduleConfig.PresentationControllerConfig[currentChannel];
                        this.channel = channelPresentation ? currentChannel : 'Default';
                        presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                    } else presentationControllerClass = undefined;
                } else {
                    if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) presentationControllerClass = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationControllerClass;
                    else presentationControllerClass = undefined;
                }
                if (presentationControllerClass === undefined || presentationControllerClass === '') {
                    kony.print('MDA2*** Config does not provide a Presentation controller');
                    this.presentationController = this.createPresentationController();
                    if (this.presentationController === null) {
                        kony.print('MDA2*** Derived module does not provide a Presentation controller');
                        this.presentationController = this.createDefaultPresentationController();
                    }
                } else {
                    kony.print('MDA2*** Config  provides a Presentation controller');
                    try {
                        var DerivedPresentationController = require(presentationControllerClass);
                        this.presentationController = new DerivedPresentationController();
                    } catch (err) {
                        throw new Exception('ERROR_CODE_300', ' Invalid Presentation Controller Class ' + err);
                    }
                }
            }
            this.createPresentationExtensions();
        };
        MDAModule.prototype.setUpNavigator = function() {
            this.navigator = this.createNavigator();
            if (this.navigator === null) {
                this.navigator = this.createDefaultNavigator();
            }
        };
        MDAModule.prototype.setUpForms = function() {
            if (this.moduleConfig !== undefined) {
                var forms = this.moduleConfig.Forms;
                var channel = kony.sdk.getChannelType();
                //Call some API here
                if (forms && channel && forms[channel]) {
                    var formsList = Object.keys(forms[channel]);
                    for (var eachForm in formsList) {
                        if (kony.mvc.registry.getControllerType(eachForm) != constants.FORM_CONTROLLER_TYPE) {
                            var formNameKey = formsList[eachForm];
                            var formPath = forms[channel][formNameKey].FormName;
                            var friendlyName = forms[channel][formNameKey].friendlyName || formPath;
                            var controller = forms[channel][formNameKey].Controller;
                            var formController = forms[channel][formNameKey].FormController;
                            var controllerExtensions = forms[channel][formNameKey].ControllerExtensions;
                            var controllerExtName = [];
                            Array.prototype.push.apply(controllerExtName, controllerExtensions);
                            kony.mvc.registry.remove(friendlyName);
                            kony.mvc.registry.add(friendlyName, formPath, {
                                'controllerName': controller,
                                'controllerType': formController,
                                'controllerExtName': controllerExtName
                            });
                        }
                    }
                }
            }
        };
        MDAModule.prototype.createBusinessController = function() {
            return null;
        };
        MDAModule.prototype.createPresentationController = function() {
            return null;
        };
        MDAModule.prototype.createNavigator = function() {
            return null;
        };
        MDAModule.prototype.createDefaultNavigator = function() {
            return new MDABaseNavigator();
        };
        MDAModule.prototype.createDefaultBusinessController = function() {
            var businessController = new BusinessController();
            return businessController;
        };
        MDAModule.prototype.createDefaultPresentationController = function() {
            var presentationController = new MDABasePresenter();
            return presentationController;
        };
        MDAModule.prototype.createCommandHandlers = function(callback) {
            if (this.moduleConfig !== undefined && this.moduleConfig.BusinessControllerConfig) {
                var commandHandlers = this.moduleConfig.BusinessControllerConfig.CommandHandler;
                kony.print(commandHandlers);
                this.businessController.registerCommandHandlers(commandHandlers, callback);
                if (callback) {
                    callback();
                }
            }
        };
        MDAModule.prototype.createPresentationExtensions = function() {
            if (this.moduleConfig !== undefined) {
                var presentationExtensions;
                if (this.channel === undefined) {
                    extChannel = 'Default';
                }
                if (this.moduleConfig.PresentationControllerConfig && this.moduleConfig.PresentationControllerConfig[this.channel]) presentationExtensions = this.moduleConfig.PresentationControllerConfig[this.channel].PresentationExtensions;
                if (presentationExtensions !== undefined) {
                    var extNModule = [];
                    extNModule.push(this.presentationController);
                    for (var i = 0; i < presentationExtensions.length; i++) {
                        try {
                            extNModule.push(require(presentationExtensions[i]));
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Presentation Controller Extension invalid ' + err);
                        }
                        kony.print('MDA2**** extNModule : ' + extNModule);
                    }
                    _kony.mvc.assignFunctions2Controller(this.presentationController, extNModule);
                } else {
                    kony.print('MDA2**** invalid presentationExtensions: ' + presentationExtensions);
                }
            }
        };
        MDAModule.prototype.createBusinessExtensions = function() {
            if (this.moduleConfig !== undefined) {
                var businessExtensions;
                if (this.moduleConfig.BusinessControllerConfig.BusinessExtensions) businessExtensions = this.moduleConfig.BusinessControllerConfig.BusinessExtensions;
                if (businessExtensions !== undefined) {
                    var extNModule = [];
                    extNModule.push(this.businessController);
                    for (var i = 0; i < businessExtensions.length; i++) {
                        try {
                            extNModule.push(require(businessExtensions[i]));
                        } catch (err) {
                            throw new Exception('ERROR_CODE_300', 'Business Controller Extension invalid ' + err);
                        }
                        kony.print('MDA2**** extNModule : ' + extNModule);
                    }
                    _kony.mvc.assignFunctions2Controller(this.businessController, extNModule);
                } else {
                    kony.print('MDA2**** invalid businessExtensions: ' + businessExtensions);
                }
            }
        };
        return MDAModule;
    }(PresentationController_MDABasePresenter, BaseNavigator_MDABaseNavigator, BusinessController_BusinessController, DataModel_constants, BusinessController_BusinessDelegator);
    ModuleManager_MDAModuleManager = function(MDAModule) {
        function MDAModuleManager() {
            this.moduleMap = {};
            this.initialize();
        }
        MDAModuleManager.prototype.initialize = function() {};
        MDAModuleManager.prototype.loadModule = function(moduleName, moduleMode, channel, callback) {
            if (moduleMode == null) moduleMode = 'Default';
            kony.print('MDA2***..loadModule: ' + moduleName + '-' + moduleMode + 'Mode');
            var self = this;
            if (!this.moduleMap[moduleName]) {
                var module = null;
                var moduleConfig;
                try {
                    moduleConfig = eval(this.moduleName + 'Config');
                } catch (e) {}
                if (moduleConfig !== undefined) {
                    var moduleClass = moduleConfig.ModuleClass;
                    if (moduleClass !== undefined || moduleClass !== '') {
                        var Module = require(moduleClass);
                        module = new Module(moduleName, moduleMode, channel, callback);
                        this.moduleMap[moduleName] = module;
                    } else {
                        if (callback !== undefined) {
                            new MDAModule(moduleName, moduleMode, channel, function(module) {
                                self.moduleMap[moduleName] = module;
                                callback(module);
                            });
                        } else {
                            module = new MDAModule(moduleName, moduleMode, channel, callback);
                            this.moduleMap[moduleName] = module;
                        }
                    }
                } else {
                    var self = this;
                    if (callback !== undefined) {
                        new MDAModule(moduleName, moduleMode, channel, function(module) {
                            self.moduleMap[moduleName] = module;
                            callback(module);
                        });
                    } else {
                        module = new MDAModule(moduleName, moduleMode, channel, callback);
                        this.moduleMap[moduleName] = module;
                    }
                }
            }
        };
        MDAModuleManager.prototype.getModule = function(moduleName, moduleMode, channel, callback) {
            // kony.print('Returned MDA2*** Module: ' + moduleName + '-' + this.moduleMap[moduleName].moduleMode + ' Mode Instance');
            if (!this.moduleMap[moduleName]) {
                this.loadModule(moduleName, moduleMode, channel, callback);
                return this.moduleMap[moduleName];
            } else {
                if (callback === undefined) {
                    return this.moduleMap[moduleName];
                } else {
                    callback(this.moduleMap[moduleName]);
                }
            }
        };
        MDAModuleManager.prototype.loadStartupModule = function(moduleName, moduleMode, channel, callback) {
            if (moduleMode == null) moduleMode = 'Default';
            kony.print('MDA2***..loadStartupModule: ' + moduleName + '-' + moduleMode + 'Mode');
            var self = this;
            var isStartup = 1;
            if (!this.moduleMap[moduleName]) {
                var module = null;
                var moduleConfig;
                try {
                    moduleConfig = eval(this.moduleName + 'Config');
                } catch (e) {}
                if (moduleConfig !== undefined) {
                    var moduleClass = moduleConfig.ModuleClass;
                    if (moduleClass !== undefined || moduleClass !== '') {
                        var Module = require(moduleClass);
                        module = new Module(moduleName, moduleMode, channel, callback, isStartup);
                        this.moduleMap[moduleName] = module;
                    } else {
                        if (callback !== undefined) {
                            new MDAModule(moduleName, moduleMode, channel, function(module) {
                                self.moduleMap[moduleName] = module;
                                callback(module);
                            }, isStartup);
                        } else {
                            module = new MDAModule(moduleName, moduleMode, channel, callback, isStartup);
                            this.moduleMap[moduleName] = module;
                        }
                    }
                } else {
                    var self = this;
                    if (callback !== undefined) {
                        new MDAModule(moduleName, moduleMode, channel, function(module) {
                            self.moduleMap[moduleName] = module;
                            callback(module);
                        }, isStartup);
                    } else {
                        module = new MDAModule(moduleName, moduleMode, channel, callback, isStartup);
                        this.moduleMap[moduleName] = module;
                    }
                }
            }
        };
        MDAModuleManager.prototype.getStartupModule = function(moduleName, moduleMode, channel, callback) {
            if (!this.moduleMap[moduleName]) {
                this.loadModule(moduleName, moduleMode, channel, callback);
                return this.moduleMap[moduleName];
            } else {
                if (callback === undefined) {
                    return this.moduleMap[moduleName];
                } else {
                    callback(this.moduleMap[moduleName]);
                }
            }
        };
        return MDAModuleManager;
    }(ModuleManager_MDAModule);
    UIBinder_UIBinder = function() {
        var includesInArray = function(array, obj) {
            if (Array.isArray(array)) {
                for (var ele in array) {
                    if (obj == array[ele]) {
                        return true;
                    }
                }
            }
            return false;
        };

        function UIBinder() {
            this.map = {};
        }
        UIBinder.prototype.registerWidgetMapper = function(widgetType, widgetDataMapper) {
            //Mapping widget with its mapper
            this.map[widgetType.toLowerCase()] = widgetDataMapper;
        };
        UIBinder.prototype.mapWidgetData = function(config, data, form, widgetId) {
            var dataModelKeys = Object.keys(data);
            var widgetDataModel = config[widgetId].entityId;
            for (var eachDataModel in dataModelKeys) {
                if (widgetDataModel == dataModelKeys[eachDataModel]) {
                    screenRefreshFlag = true;
                    var componentTag = config[widgetId].componentId;
                    var widget;
                    if (componentTag) widget = form[componentTag][widgetId];
                    else widget = form[widgetId];
                    var widgetConfig = config[widgetId];
                    widgetConfig['widgetId'] = widgetId;
                    var widgetType = widgetConfig.widgetType.toLowerCase();
                    if (widgetType in this.map) {
                        var mapper = this.map[widgetType];
                        try {
                            mapper.mapData(widgetConfig, data, widget);
                        } catch (err) {
                            kony.print('Widget Data Mapper error while mapping: ' + err);
                        }
                    } else {
                        kony.print('Widget doesn\'t exist with UIBinder ' + widgetType);
                    }
                } else {
                    kony.print('View Model ' + dataModelKeys[eachDataModel] + ' is not for widget:' + widgetId + ' with View Model:' + widgetDataModel);
                }
            }
        };
        UIBinder.prototype.mapData = function(config, data, form, groupSelect) {
            if (config && data) {
                if (config.groups) {
                    for (var groupId in config.groups) {
                        if (groupSelect) {
                            if (includesInArray(groupSelect, groupId) || groupId === groupSelect) {
                                for (var widgetid in config.groups[groupId]) {
                                    this.mapWidgetData(config.groups[groupId], data, form, widgetid);
                                }
                            }
                        } else {
                            for (var widgetid in config.groups[groupId]) {
                                this.mapWidgetData(config.groups[groupId], data, form, widgetid);
                            }
                        }
                    }
                    if (config.widgets === null || config.widgets === undefined) {
                        config.widgets = {};
                    }
                }
                if (config.widgets) {
                    for (var widgetId in config.widgets) {
                        this.mapWidgetData(config.widgets, data, form, widgetId);
                    }
                } else {
                    //Config Format Old
                    var newConfig = {};
                    //Setting the formid to formId
                    newConfig['formId'] = config['formid'];
                    delete config.formid;
                    //Getting Object Service name, online/offline, entity details
                    newConfig['objectServiceName'] = config[newConfig.formId]['objectServiceName'];
                    newConfig['objectServiceOptions'] = config[newConfig.formId]['objectServiceOptions'];
                    newConfig['entityId'] = config[newConfig.formId]['entity'];
                    delete config[newConfig.formId];
                    //Add widgets object
                    newConfig['widgets'] = {};
                    //Adding widgets to config
                    for (var widget in config) {
                        newConfig.widgets[widget] = {};
                        newConfig.widgets[widget]['widgetType'] = config[widget].fieldprops.widgettype.toLowerCase();
                        newConfig.widgets[widget]['entityId'] = config[widget].fieldprops.entity;
                        if (config[widget].fieldprops.widgettype.toLowerCase() == 'segment') {
                            newConfig.widgets[widget]['objectServiceName'] = newConfig.objectServiceName;
                            newConfig.widgets[widget]['fields'] = {};
                            for (var eachField in config[widget].fieldprops.field) {
                                newConfig.widgets[widget].fields[eachField] = {};
                                newConfig.widgets[widget].fields[eachField]['widgetType'] = config[widget].fieldprops.field[eachField].widgettype.toLowerCase();
                                newConfig.widgets[widget].fields[eachField]['fieldId'] = config[widget].fieldprops.field[eachField].field;
                            }
                        } else {
                            newConfig.widgets[widget]['fieldId'] = config[widget].fieldprops.field;
                        }
                    }
                    //Recursively calling map data
                    this.mapData(newConfig, data, form);
                }
                form.forceLayout();
            }
        };
        UIBinder.prototype.getWidgetData = function(config, formId, widgetId, dataMap) {
            var widget = formId[widgetId];
            var widgetConfig = config[widgetId];
            if (dataMap[widgetConfig.entityId] == null) dataMap[widgetConfig.entityId] = {};
            var widgetType = widgetConfig.widgetType.toLowerCase();
            if (widgetType in this.map) {
                if (widgetType !== 'segment') {
                    var mapper = this.map[widgetType];
                    dataMap[widgetConfig.entityId][widgetConfig.fieldId] = mapper.getPropertyData(widget);
                } else {
                    var mapper = this.map[widgetType];
                    dataMap[widgetConfig.entityId] = mapper.getPropertyData(widget);
                }
            }
        };
        //Get Data
        UIBinder.prototype.getData = function(config, formId, groupSelect) {
            if (config) {
                var dataMap = {};
                if (config.groups) {
                    for (var groupId in config.groups) {
                        if (groupSelect) {
                            if (includesInArray(groupSelect, groupId) || groupId === groupSelect) {
                                for (var widgetid in config.groups[groupId]) {
                                    this.getWidgetData(config.groups[groupId], formId, widgetid, dataMap);
                                }
                            }
                        } else {
                            for (var widgetid in config.groups[groupId]) {
                                this.getWidgetData(config.groups[groupId], formId, widgetid, dataMap);
                            }
                        }
                    }
                }
                if (config.widgets) {
                    for (var widgetId in config.widgets) {
                        this.getWidgetData(config.widgets, formId, widgetId, dataMap);
                    }
                }
                return dataMap;
            }
        };
        return UIBinder;
    }();

    function GenericPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    GenericPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    //Bottom Property
    function BottomPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    BottomPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    BottomPropertyMapper.prototype.propertyHandler = function() {};
    //CenterX Property
    function CenterXPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    CenterXPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    CenterXPropertyMapper.prototype.propertyHandler = function() {};
    //CenterY Property
    function CenterYPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    CenterYPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    CenterYPropertyMapper.prototype.propertyHandler = function() {};
    //Height Property
    function HeightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    HeightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    HeightPropertyMapper.prototype.propertyHandler = function() {};
    //Is Visible Property
    function IsVisiblePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    IsVisiblePropertyMapper.prototype.mapProperty = function(data, widget) {
        if (data == 'true') data = true;
        else if (data == 'false') data = false;
        var property = this.map.propName;
        widget[property] = data;
    };
    IsVisiblePropertyMapper.prototype.propertyHandler = function() {};
    //Skin Property
    function SkinPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SkinPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    SkinPropertyMapper.prototype.propertyHandler = function() {};
    //Top Property
    function TopPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TopPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TopPropertyMapper.prototype.propertyHandler = function() {};
    //Width Property
    function WidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    WidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    WidthPropertyMapper.prototype.propertyHandler = function() {};
    //Left Property
    function LeftPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    LeftPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    LeftPropertyMapper.prototype.propertyHandler = function() {};
    //Background Color
    function BackgroundColorPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    BackgroundColorPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    BackgroundColorPropertyMapper.prototype.propertyHandler = function() {};
    //Right Property
    function RightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    RightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    RightPropertyMapper.prototype.propertyHandler = function() {};
    //MaxWidth Property
    function MaxWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MaxWidthPropertyMapper.prototype.propertyHandler = function() {};
    //MinWidth Property
    function MinWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MinWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MinWidthPropertyMapper.prototype.propertyHandler = function() {};
    //MaxHeight Property
    function MaxHeightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxHeightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MaxHeightPropertyMapper.prototype.propertyHandler = function() {};
    //MinHeight Property
    function MinHeightPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MinHeightPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    MinHeightPropertyMapper.prototype.propertyHandler = function() {};
    //ZIndex Property
    function ZIndexPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ZIndexPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ZIndexPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_GenericProperties = undefined;
    UIBinder_WidgetDataMapper_WidgetDataMapper = function() {
        function WidgetDataMapper(widgetType) {
            this.propertyMap = {
                'width': new WidthPropertyMapper('width'),
                'height': new HeightPropertyMapper('height'),
                'isvisible': new IsVisiblePropertyMapper('isVisible'),
                'top': new TopPropertyMapper('top'),
                'bottom': new BottomPropertyMapper('bottom'),
                'centerx': new CenterXPropertyMapper('centerX'),
                'centery': new CenterYPropertyMapper('centerY'),
                'skin': new SkinPropertyMapper('skin'),
                'left': new LeftPropertyMapper('left'),
                'backgroundcolor': new BackgroundColorPropertyMapper('backgroundColor'),
                'right': new RightPropertyMapper('right'),
                'maxwidth': new MaxWidthPropertyMapper('maxWidth'),
                'minwidth': new MinWidthPropertyMapper('minWidth'),
                'maxheight': new MaxHeightPropertyMapper('maxHeiht'),
                'minheight': new MinHeightPropertyMapper('minHeight'),
                'zindex': new ZIndexPropertyMapper('zIndex')
            };
            this.widgetType = widgetType;
        }
        //Register property mapper or base property mapper
        WidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            this.propertyMap[propertyType.toLowerCase()] = propertyMapper;
        };
        WidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            if (widgetConfig.propertyMapper) {
                kony.print('Mapping properties with widgets');
                var properties = Object.keys(widgetConfig.propertyMapper);
                for (var property in properties) {
                    //alert(properties[property].toLowerCase());
                    var mapper = this.propertyMap[properties[property].toLowerCase()];
                    try {
                        if (widgetConfig.scope.toLowerCase() == 'context') {} else {
                            var dataKey = data[widgetConfig.entityId][widgetConfig.fieldId];
                            var keyVal = widgetConfig.propertyMapper[properties[property]].split('.');
                            var key = keyVal[keyVal.length - 1];
                            var dataVal = dataKey[key];
                            try {
                                mapper.mapProperty(dataVal, widget);
                            } catch (err) {
                                kony.print('MapData function error while mapping property ' + err);
                            }
                        }
                    } catch (err) {
                        kony.print('Error in data format : MapData WidgetDataMapper ' + err);
                    }
                }
            } else {
                //If no property map exists
                //Backward compatibility
                kony.print('Mapping default properties with widgets');
                var defaultMapper = this.propertyMap['default'];
                if (typeof data[widgetConfig.entityId][widgetConfig.fieldId] == 'object') {
                    type = defaultMapper.map.propName;
                    try {
                        defaultMapper.mapProperty(data[widgetConfig.entityId][widgetConfig.fieldId][type], widget);
                    } catch (err) {
                        kony.print('Error while Mapping default property with widget ' + err);
                    }
                } else {
                    try {
                        defaultMapper.mapProperty(data[widgetConfig.entityId][widgetConfig.fieldId], widget);
                    } catch (err) {
                        kony.print('Error while Mapping default property with widget ' + err);
                    }
                }
            }
        };
        WidgetDataMapper.prototype.getPropertyData = function(widget) {
            var txtMapper = this.propertyMap['text'];
            var data = txtMapper.getPropertyValue(widget);
            return data;
        };
        return WidgetDataMapper;
    }();
    commonUtils_inheritsFrom = function() {
        var inheritsFrom = function(child, parent) {
            child.prototype = Object.create(parent.prototype);
            child.prototype.constructor = child;
        };
        return inheritsFrom;
    }();

    function SourcePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SourcePropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    SourcePropertyMapper.prototype.propertyHandler = function() {};
    SourcePropertyMapper.prototype.getPropertyValue = function(widget) {
        var srcVal = widget[this.map['propName']];
        return srcVal;
    };
    //BASE64 PROPERTY
    function Base64PropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    Base64PropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    Base64PropertyMapper.prototype.propertyHandler = function() {};
    //IMAGE WHEN FAIL PROPERTY
    function ImageWhenFailedPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ImageWhenFailedPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ImageWhenFailedPropertyMapper.prototype.propertyHandler = function() {};
    //IMAGE WHILE DOWNLOAD PROPERTY
    function ImageWhileDownloadPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ImageWhileDownloadPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ImageWhileDownloadPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_ImageProperties = undefined;
    UIBinder_WidgetDataMapper_ImageWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Image
        function ImageWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType);
            this.registerPropertyMapper('default', new SourcePropertyMapper('src'));
        }
        inheritsFrom(ImageWidgetDataMapper, WidgetDataMapper);
        ImageWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        ImageWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        ImageWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var srcMapper = this.propertyMap['source'];
            var data = srcMapper.getPropertyValue(widget);
            return data;
        };
        return ImageWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function PlaceholderPropertyMappper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    PlaceholderPropertyMappper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    PlaceholderPropertyMappper.prototype.propertyHandler = function() {};

    function PlaceholderSkinPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    PlaceholderSkinPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    PlaceholderSkinPropertyMapper.prototype.propertyHandler = function() {};

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };

    function MaxTextLengthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxTextLengthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    MaxTextLengthPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_TextboxProperties = undefined;
    UIBinder_WidgetDataMapper_TextboxWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //TextBox
        function TextboxWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(TextboxWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        TextboxWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        TextboxWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        TextboxWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return TextboxWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };

    function TextStylePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextStylePropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextStylePropertyMapper.prototype.propertyHandler = function() {};

    function TextCopyablePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextCopyablePropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        if (data == 'true') widget[property] = true;
        else if (data == 'false') widget[property] = false;
    };
    TextCopyablePropertyMapper.prototype.propertyHandler = function() {};

    function WrappingPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    WrappingPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    WrappingPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_LabelProperties = undefined;
    UIBinder_WidgetDataMapper_LabelWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Label
        function LabelWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType);
            inheritsFrom(LabelWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        LabelWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        LabelWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        LabelWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return LabelWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    //shadowtype, showclosebutton, showprogressindicator, textInputMode, toolTip, wrapText
    function ShadowTypePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShadowTypePropertyMapper.prototype.propertyHandler = function() {};
    ShadowTypePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function ShowCloseButtonPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShowCloseButtonPropertyMapper.prototype.propertyHandler = function() {};
    ShowCloseButtonPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function ShowProgressIndicatorPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShowProgressIndicatorPropertyMapper.prototype.propertyHandler = function() {};
    ShowProgressIndicatorPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function TextInputModePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextInputModePropertyMapper.prototype.propertyHandler = function() {};
    TextInputModePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function ToolTipPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ToolTipPropertyMapper.prototype.propertyHandler = function() {};
    ToolTipPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function WrapTextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    WrapTextPropertyMapper.prototype.propertyHandler = function() {};
    WrapTextPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function PlaceholderPropertyMappper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    PlaceholderPropertyMappper.prototype.propertyHandler = function() {};
    PlaceholderPropertyMappper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };
    UIBinder_PropertyDataMapper_TextAreaProperties = undefined;
    UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Textarea
        function TextAreaWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(TextAreaWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        TextAreaWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        TextAreaWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        TextAreaWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return TextAreaWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function SelectedIndexPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedIndexPropertyMapper.prototype.mapProperty = function(data, widget) {
        data = parseInt(data);
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedIndexPropertyMapper.prototype.propertyHandler = function() {};
    SelectedIndexPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue.toString();
    };

    function OpacityPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    OpacityPropertyMapper.prototype.propertyHandler = function() {};
    OpacityPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    UIBinder_PropertyDataMapper_SwitchProperties = undefined;
    UIBinder_WidgetDataMapper_SwitchWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Switch
        function SwitchWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(SwitchWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', SelectedIndexPropertyMapper('selectedIndex'));
        }
        SwitchWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        SwitchWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        SwitchWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var switchMapper = this.propertyMap['selectedindex'];
            var data = switchMapper.getPropertyValue(widget);
            return data;
        };
        return SwitchWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function SelectedValuePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedValuePropertyMapper.prototype.mapProperty = function(data, widget) {
        data = parseInt(data);
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedValuePropertyMapper.prototype.propertyHandler = function() {};
    SelectedValuePropertyMapper.prototype.getPropertyValue = function(widget) {
        var value = widget[this.map['propName']];
        return value.toString();
    };

    function ThicknessPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ThicknessPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    ThicknessPropertyMapper.prototype.propertyHandler = function() {};

    function MinWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MinWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    MinWidthPropertyMapper.prototype.propertyHandler = function() {};

    function MaxWidthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MaxWidthPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    MaxWidthPropertyMapper.prototype.propertyHandler = function() {};
    UIBinder_PropertyDataMapper_SliderProperties = undefined;
    UIBinder_WidgetDataMapper_SliderWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Slider
        function SliderWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(SliderWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', SelectedValuePropertyMapper('selectedValue'));
        }
        SliderWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        SliderWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        SliderWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var sliderMapper = this.propertyMap['selectedvalue'];
            var data = sliderMapper.getPropertyValue(widget);
            return data;
        };
        return SliderWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };

    function OpacityPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    OpacityPropertyMapper.prototype.propertyHandler = function() {};
    OpacityPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };
    UIBinder_PropertyDataMapper_RichTextProperties = undefined;
    UIBinder_WidgetDataMapper_RichTextWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //RichText
        function RichTextWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(RichTextWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        RichTextWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        RichTextWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        RichTextWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return RichTextWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    //TEXT PROPERTY MAPPER
    function TextPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TextPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    TextPropertyMapper.prototype.propertyHandler = function() {};
    TextPropertyMapper.prototype.getPropertyValue = function(widget) {
        var textValue = widget[this.map['propName']];
        return textValue;
    };
    UIBinder_PropertyDataMapper_ButtonProperties = undefined;
    UIBinder_WidgetDataMapper_ButtonWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Button
        function ButtonWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(ButtonWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new TextPropertyMapper('text'));
        }
        ButtonWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        ButtonWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        ButtonWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return ButtonWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    UIBinder_WidgetDataMapper_SegmentWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //SEGMENT
        function SegmentWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType);
            inheritsFrom(SegmentWidgetDataMapper, WidgetDataMapper);
        }
        SegmentWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        SegmentWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            //CONSTRUCT SEGMENT WIDGET DATA MAP
            var widgetDataMap = {};
            var segmentFields = [];
            var entity = widgetConfig.entityId;
            var field = widgetConfig.fieldId;
            for (var fieldWidget in widgetConfig.fields) {
                var widgetField = widgetConfig.fields[fieldWidget].fieldId;
                widgetDataMap[fieldWidget] = widgetField;
                segmentFields.push(widgetField);
            }
            widget.widgetDataMap = widgetDataMap;
            //construct array of json to pass to segment.addAll();
            // var dataArr=[];
            // for(var eachRecord in data[entity][field] ){
            //     var recordMap={};
            //     for(var eachField in segmentFields){
            //         if(data[entity][field][eachRecord][segmentFields[eachField]] !== null){
            //             if(typeof data[entity][field][eachRecord][segmentFields[eachField]]==="object"){
            //                 //data in field->JSON format
            //                 recordMap[segmentFields[eachField]]=data[entity][field][eachRecord][segmentFields[eachField]].text;
            //             }
            //             else{
            //                 //normal data format
            //                 recordMap[segmentFields[eachField]]=data[entity][field][eachRecord][segmentFields[eachField]];
            //             }
            //         }
            //         //SET other properties for the widget fields
            //     }
            //     dataArr.push(recordMap);
            // }
            widget.removeAll();
            widget.addAll(data[entity][field]);
        };
        SegmentWidgetDataMapper.prototype.getPropertyData = function(widget) {
            return widget.data;
        };
        return SegmentWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);

    function ShadowTypePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShadowTypePropertyMapper.prototype.propertyHandler = function() {};
    ShadowTypePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function ShadowDepthPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    ShadowDepthPropertyMapper.prototype.propertyHandler = function() {};
    ShadowDepthPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = parseInt(data);
    };

    function TickedImagePropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    TickedImagePropertyMapper.prototype.propertyHandler = function() {};
    TickedImagePropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function HoverSkinPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    HoverSkinPropertyMapper.prototype.propertyHandler = function() {};
    HoverSkinPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };

    function MasterDataPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    MasterDataPropertyMapper.prototype.propertyHandler = function() {};
    MasterDataPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    MasterDataPropertyMapper.prototype.getPropertyValue = function(widget) {
        var data = [];
        for (var item in widget[this.map['propName']]) {
            data.push(item);
        }
        return data;
    };

    function SelectedKeyPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedKeyPropertyMapper.prototype.propertyHandler = function() {};
    SelectedKeyPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedKeyPropertyMapper.prototype.getPropertyValue = function(widget) {
        return widget[this.map['propName']];
    };

    function SelectedKeysPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    SelectedKeysPropertyMapper.prototype.propertyHandler = function() {};
    SelectedKeysPropertyMapper.prototype.mapProperty = function(data, widget) {
        //sets string as data
        var property = this.map.propName;
        widget[property] = data;
    };
    SelectedKeysPropertyMapper.prototype.getPropertyValue = function(widget) {
        return widget[this.map['propName']];
    };
    UIBinder_PropertyDataMapper_ListboxProperties = undefined;
    UIBinder_WidgetDataMapper_ListboxWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Listbox
        function ListboxWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(ListboxWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', SelectedKeyPropertyMapper('selectedKey'));
        }
        ListboxWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        ListboxWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        ListboxWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var listboxMapper = this.propertyMap['selectedkey'];
            var data = listboxMapper.getPropertyValue(widget);
            return data;
        };
        return ListboxWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //Button
        function FlexContainerWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(FlexContainerWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', null);
        }
        FlexContainerWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        FlexContainerWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        FlexContainerWidgetDataMapper.prototype.getPropertyData = function(widget) {
            WidgetDataMapper.prototype.getPropertyData.call(this, widget);
        };
        return FlexContainerWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    //DATE COMPONENT PROPERTY
    function DateComponentsPropertyMapper(property) {
        this.map = {};
        this.map['propName'] = property;
    }
    DateComponentsPropertyMapper.prototype.mapProperty = function(data, widget) {
        var property = this.map.propName;
        widget[property] = data;
    };
    DateComponentsPropertyMapper.prototype.propertyHandler = function() {};
    DateComponentsPropertyMapper.prototype.getPropertyValue = function(widget) {
        var datecompValue = widget[this.map['propName']];
        return datecompValue;
    };
    UIBinder_PropertyDataMapper_CalendarProperties = undefined;
    UIBinder_WidgetDataMapper_CalendarWidgetDataMapper = function(WidgetDataMapper, inheritsFrom) {
        //CALENDAR
        function CalendarWidgetDataMapper(widgetType) {
            WidgetDataMapper.call(this, widgetType.toLowerCase());
            inheritsFrom(CalendarWidgetDataMapper, WidgetDataMapper);
            this.registerPropertyMapper('default', new DateComponentsPropertyMapper('dateComponents'));
        }
        CalendarWidgetDataMapper.prototype.registerPropertyMapper = function(propertyType, propertyMapper) {
            WidgetDataMapper.prototype.registerPropertyMapper.call(this, propertyType, propertyMapper);
        };
        CalendarWidgetDataMapper.prototype.mapData = function(widgetConfig, data, widget) {
            WidgetDataMapper.prototype.mapData.call(this, widgetConfig, data, widget);
        };
        CalendarWidgetDataMapper.prototype.getPropertyData = function(widget) {
            var datecompMapper = this.propertyMap['dateComponents'];
            var data = datecompMapper.getPropertyValue(widget);
            return data;
        };
        return CalendarWidgetDataMapper;
    }(UIBinder_WidgetDataMapper_WidgetDataMapper, commonUtils_inheritsFrom);
    UIBinder_UIBinderBuilder = function(UIBinder, WidgetDataMapper, ImageWidgetDataMapper, TextboxWidgetDataMapper, LabelWidgetDataMapper, TextAreaWidgetDataMapper, SwitchWidgetDataMapper, SliderWidgetDataMapper, RichTextWidgetDataMapper, ButtonWidgetDataMapper, SegmentWidgetDataMapper, ListboxWidgetDataMapper, FlexContainerWidgetDataMapper, CalendarWidgetDataMapper) {
        var binderInstance = null;
        UIBinderBuilder = function() {
            this.initialize();
        };
        UIBinderBuilder.prototype.initialize = function() {
            if (binderInstance === null) {
                binderInstance = new UIBinder();
            }
            this.register();
        };
        UIBinderBuilder.prototype.register = function() {
            var imageMapper = new ImageWidgetDataMapper('image');
            var textBoxMapper = new TextboxWidgetDataMapper('textbox');
            var labelMapper = new LabelWidgetDataMapper('label');
            var textAreaMapper = new TextAreaWidgetDataMapper('textarea');
            var switchMapper = new SwitchWidgetDataMapper('switch');
            var sliderMapper = new SliderWidgetDataMapper('slider');
            var richTextMapper = new RichTextWidgetDataMapper('richtext');
            var buttonMapper = new ButtonWidgetDataMapper('button');
            var segmentMapper = new SegmentWidgetDataMapper('segment');
            var listBoxMapper = new ListboxWidgetDataMapper('listbox');
            var flexContainerMapper = new FlexContainerWidgetDataMapper('flexcontainer');
            var calendarMapper = new CalendarWidgetDataMapper('calendar');
            //Registering properties
            imageMapper.registerPropertyMapper('src', new SourcePropertyMapper('src'));
            imageMapper.registerPropertyMapper('base64', new Base64PropertyMapper('base64'));
            textBoxMapper.registerPropertyMapper('placeholder', new PlaceholderPropertyMappper('placeholder'));
            textBoxMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            textBoxMapper.registerPropertyMapper('maxtextlength', new MaxTextLengthPropertyMapper('maxTextLength'));
            labelMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            labelMapper.registerPropertyMapper('textstyle', new TextStylePropertyMapper('textStyle'));
            labelMapper.registerPropertyMapper('textcopyable', new TextCopyablePropertyMapper('textCopyable'));
            textAreaMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            textAreaMapper.registerPropertyMapper('shadowtype', new ShadowTypePropertyMapper('shadowType'));
            textAreaMapper.registerPropertyMapper('textinputmode', new TextInputModePropertyMapper('textInputMode'));
            textAreaMapper.registerPropertyMapper('tooltip', new ToolTipPropertyMapper('toolTip'));
            textAreaMapper.registerPropertyMapper('placeholder', new PlaceholderPropertyMappper('placeholder'));
            switchMapper.registerPropertyMapper('selectedindex', new SelectedIndexPropertyMapper('selectedIndex'));
            sliderMapper.registerPropertyMapper('selectedvalue', new SelectedValuePropertyMapper('selectedValue'));
            sliderMapper.registerPropertyMapper('minwidth', new MinWidthPropertyMapper('minWidth'));
            sliderMapper.registerPropertyMapper('maxWidth', new MaxWidthPropertyMapper('maxWidth'));
            richTextMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            richTextMapper.registerPropertyMapper('opacity', new OpacityPropertyMapper('opacity'));
            buttonMapper.registerPropertyMapper('text', new TextPropertyMapper('text'));
            listBoxMapper.registerPropertyMapper('shadowtype', new ShadowTypePropertyMapper('shadowType'));
            listBoxMapper.registerPropertyMapper('shadowdepth', new ShadowDepthPropertyMapper('shadowDepth'));
            listBoxMapper.registerPropertyMapper('hoverskin', new HoverSkinPropertyMapper('hoverSkin'));
            listBoxMapper.registerPropertyMapper('masterdata', new MasterDataPropertyMapper('masterData'));
            listBoxMapper.registerPropertyMapper('selectedkey', new SelectedKeyPropertyMapper('selectedKey'));
            listBoxMapper.registerPropertyMapper('selectedkeys', new SelectedKeysPropertyMapper('selectedKeys'));
            calendarMapper.registerPropertyMapper('datecomponents', new DateComponentsPropertyMapper('dateComponents'));
            //Registering Widgets
            binderInstance.registerWidgetMapper('image', imageMapper);
            binderInstance.registerWidgetMapper('textbox', textBoxMapper);
            binderInstance.registerWidgetMapper('label', labelMapper);
            binderInstance.registerWidgetMapper('textarea', textAreaMapper);
            binderInstance.registerWidgetMapper('switch', switchMapper);
            binderInstance.registerWidgetMapper('slider', sliderMapper);
            binderInstance.registerWidgetMapper('richtext', richTextMapper);
            binderInstance.registerWidgetMapper('button', buttonMapper);
            binderInstance.registerWidgetMapper('segment', segmentMapper);
            binderInstance.registerWidgetMapper('listbox', listBoxMapper);
            binderInstance.registerWidgetMapper('flexcontainer', flexContainerMapper);
            binderInstance.registerWidgetMapper('calendar', calendarMapper);
        };
        UIBinderBuilder.prototype.getBinder = function() {
            return binderInstance;
        };
        return UIBinderBuilder;
    }(UIBinder_UIBinder, UIBinder_WidgetDataMapper_WidgetDataMapper, UIBinder_WidgetDataMapper_ImageWidgetDataMapper, UIBinder_WidgetDataMapper_TextboxWidgetDataMapper, UIBinder_WidgetDataMapper_LabelWidgetDataMapper, UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper, UIBinder_WidgetDataMapper_SwitchWidgetDataMapper, UIBinder_WidgetDataMapper_SliderWidgetDataMapper, UIBinder_WidgetDataMapper_RichTextWidgetDataMapper, UIBinder_WidgetDataMapper_ButtonWidgetDataMapper, UIBinder_WidgetDataMapper_SegmentWidgetDataMapper, UIBinder_WidgetDataMapper_ListboxWidgetDataMapper, UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper, UIBinder_WidgetDataMapper_CalendarWidgetDataMapper);
    commonUtils_MDAApplication = function(RepositoryManager, MDAModuleManager, UIBinderBuilder) {
        var appInstance = null;

        function MDAApplication() {
            if (appInstance !== null) {
                throw new Error(' Cannot instantiate more than one MDAApplication, use MDAApplication.getSharedInstance()');
            }
            this.initialize();
        }
        MDAApplication.prototype = {
            initialize: function() {
                this.repositoryManager = new RepositoryManager();
                this.moduleManager = new MDAModuleManager();
                this.UIBinder = new UIBinderBuilder().getBinder();
                this.appContext = {};
                this.accessMode = {
                    'access': 'online'
                };
                this.oDataQueryFlag = false;
                var scope = this;
                this.modelStore = {
                    getModelDefinition: function(modelName) {
                        var modelConfig = scope.repositoryManager.repoConfig[modelName];
                        var modelPath = modelConfig['model'];
                        var model = require(modelPath);
                        return model;
                    },
                    getConfig: function(modelName) {
                        var modelConfig = scope.repositoryManager.repoConfig[modelName];
                        var configPath = modelConfig['config'];
                        var config = require(configPath);
                        return config;
                    }
                };
            }
        };
        MDAApplication.getSharedInstance = function() {
            if (appInstance === null) {
                appInstance = new MDAApplication();
            }
            return appInstance;
        };
        MDAApplication.prototype.getRepoManager = function() {
            return this.repositoryManager;
        };
        MDAApplication.prototype.setRepoManager = function(repoManagerInstance) {
            this.repositoryManager = repoManagerInstance;
        };
        MDAApplication.prototype.getModuleManager = function() {
            return this.moduleManager;
        };
        MDAApplication.prototype.setModuleManager = function(moduleManagerInstance) {
            this.moduleManager = moduleManagerInstance;
        };
        MDAApplication.prototype.getUIBinder = function() {
            return this.UIBinder;
        };
        MDAApplication.prototype.setUIBinder = function(uiBinderInstance) {
            this.UIBinder = uiBinderInstance;
        };
        MDAApplication.prototype.setAppMode = function(appMode) {
            this.accessMode['access'] = appMode;
        };
        MDAApplication.prototype.getAppMode = function() {
            return this.accessMode;
        };
        MDAApplication.prototype.getODataStatus = function() {
            return this.oDataQueryFlag;
        };
        MDAApplication.prototype.setOdataStatus = function(flag) {
            this.oDataQueryFlag = flag;
        };
        return MDAApplication;
    }(DataModel_RepositoryManager, ModuleManager_MDAModuleManager, UIBinder_UIBinderBuilder);
    commonUtils_Logger = function() {
        function Logger() {}
        Logger.logExecutionTimes = function(targetObject, targetMethod, args) {
            function callbackTimeStamping(callback) {
                return function() {
                    var startTime = Date.now();
                    kony.print('MDA PERF :: Start Time executing callback ' + callback.name + '() : ' + startTime);
                    callback.apply(null, arguments);
                    var endTime = Date.now();
                    kony.print('MDA PERF :: End Time executing callback ' + callback.name + '() : ' + endTime);
                    kony.print('MDA PERF :: Total time executing callback ' + callback.name + '() : ' + (endTime - startTime) + 'ms');
                };
            }
            var argArr = [];
            for (var i = 0; i < args.length; i++) {
                if (typeof args[i] === 'function') {
                    argArr.push(callbackTimeStamping(args[i]));
                } else if (args[i] instanceof kony.mvc.Business.Command) {
                    var target = {};
                    for (var key in args[i]) {
                        if (args[i].hasOwnProperty(key)) {
                            target[key] = args[i][key];
                        }
                    }
                    target.completionCallback = callbackTimeStamping(args[i].completionCallback);
                    argArr.push(target);
                } else {
                    argArr.push(args[i]);
                }
            }
            var targetFunction = null;
            var _targetObject = targetObject == null ? this : targetObject;
            var targetFunctionName = '';
            if (typeof targetMethod === 'function') {
                targetFunction = targetMethod;
                targetFunctionName = targetFunction.name;
            } else if (typeof targetMethod === 'string') {
                targetFunction = _targetObject[targetMethod];
                targetFunctionName = targetMethod;
            }
            if (targetFunctionName == null || targetFunctionName.trim() === '') {
                targetFunctionName = '<anonymous>';
            }
            var startTimeLogPrefix = 'MDA PERF :: Start Time executing ' + _targetObject.constructor.name + '.' + targetFunctionName + '() : ';
            var endTimeLogPrefix = 'MDA PERF :: End Time executing ' + _targetObject.constructor.name + '.' + targetFunctionName + '() : ';
            var totalTimeLogPrefix = 'MDA PERF :: Total Time executing ' + _targetObject.constructor.name + '.' + targetFunctionName + '() : ';
            var startTime = Date.now();
            kony.print(startTimeLogPrefix + startTime);
            var returnVal = targetFunction.apply(_targetObject, argArr);
            var endTime = Date.now();
            kony.print(endTimeLogPrefix + endTime);
            kony.print(totalTimeLogPrefix + (endTime - startTime) + 'ms');
            return returnVal;
        };
        return Logger;
    }();
    commonUtils_InitializeForms = function(constants) {
        function InitializeForms(moduleName) {
            this.moduleConfig = eval(moduleName + 'Config');
            if (this.moduleConfig !== undefined) {
                var forms = this.moduleConfig.Forms;
                var channel = kony.sdk.getChannelType();
                //Call some API here
                if (forms && channel && forms[channel]) {
                    var formsList = Object.keys(forms[channel]);
                    for (var eachForm in formsList) {
                        if (kony.mvc.registry.getControllerType(eachForm) != constants.FORM_CONTROLLER_TYPE) {
                            var formNameKey = formsList[eachForm];
                            var formPath = forms[channel][formNameKey].FormName;
                            var friendlyName = forms[channel][formNameKey].friendlyName || formPath;
                            var controller = forms[channel][formNameKey].Controller;
                            var formController = forms[channel][formNameKey].FormController;
                            var controllerExtensions = forms[channel][formNameKey].ControllerExtensions;
                            var controllerExtName = [];
                            Array.prototype.push.apply(controllerExtName, controllerExtensions);
                            kony.mvc.registry.remove(friendlyName);
                            kony.mvc.registry.add(friendlyName, formPath, {
                                'controllerName': controller,
                                'controllerType': formController,
                                'controllerExtName': controllerExtName
                            });
                        }
                    }
                }
            }
        }
        return InitializeForms;
    }(DataModel_constants);
    commonUtils_ProcessorUtils = function() {
        function ProcessorUtils() {}
        ProcessorUtils.applyFunction = function(fnToApply, val, context) {
            //Context fetch from sdk metadata
            if (fnToApply && context['metadata']) {
                var config = kony.mvc.MDAApplication.getSharedInstance().modelStore.getConfig(context['object']);
                context['datatype'] = config.typings[context['field']];
                val = fnToApply(val, context);
            }
            return val;
        };
        ProcessorUtils.getMetadataForObject = function(serviceName, objectName, options, successCallback, failureCallback) {
            kony.sdk.getCurrentInstance().getObjectService(serviceName, {
                'access': 'online'
            }).getMetadataOfObject(objectName, options, successCallback, failureCallback);
        };
        ProcessorUtils.convertObjectMetadataToFieldMetadataMap = function(objectMetadata) {
            var metadataMap = {};
            if (objectMetadata) {
                var columns = objectMetadata.columns;
                for (var colIndex in columns) {
                    if (columns[colIndex].metadata) {
                        metadataMap[columns[colIndex].displayName] = columns[colIndex].metadata;
                    }
                }
            }
            return metadataMap;
        };
        return ProcessorUtils;
    }();
    ParallelCommandExecuter_ParallelCommandExecuter = function() {
        function ParallelCommandExecuter() {}
        ParallelCommandExecuter.executeCommands = function(businessController, commands, callback) {
            var responseList = [];

            function successCallback(response) {
                if (response !== undefined) {
                    responseList.push(response);
                }
                if (responseList.length === commands.length) {
                    var responseListInOrder = [];
                    for (var i = 0; i < commands.length; i++) {
                        var alias = commands[i].getAlias();
                        for (var j = 0; j < responseList.length; j++) {
                            if (alias === responseList[j].alias) {
                                responseListInOrder.push(responseList[j]);
                            }
                        }
                    }
                    callback(responseListInOrder);
                }
            }
            for (var i = 0; i < commands.length; i++) {
                commands[i].setCompletionCallback(successCallback);
                businessController.execute(commands[i]);
            }
        };
        return ParallelCommandExecuter;
    }();
    DataModel_ModelRelation = function() {
        var Relation = function(name, targetObject) {
            this.name = name;
            this.targetObject = targetObject;
            this.relationFields = [];
            this.addRelationField = function(source, target) {
                this.relationFields.push({
                    sourceField: source,
                    targetField: target
                });
            };
            this.isValid = function() {
                if (this.relationFields.length === 0) {
                    throw Error('atleast one relationfield should be added use addRelationField(sourceProperty,targetProperty)');
                } else {
                    return true;
                }
            };
            this.type = 'OneToMany';
            this.cascade = 'false';
        };
        return Relation;
    }();
    DataModel_BaseModel = function(ModelRelation) {
        var BaseModel = function() {};
        //BaseModel.prototype.attributeMap={};
        BaseModel.prototype.getId = function() {
            if (this.config.primaryKeys.length === 1) {
                return this[this.config.primaryKeys[0]];
            } else {
                throw Error('getId() for Composite keys is not implemented yet.');
            }
        };
        BaseModel.isParentOf = function(child) {
            var _this = this;
            child.prototype = Object.create(this.prototype);
            child.prototype.constructor = child;
            child.prototype.attributeMap = {};
            Object.keys(this).forEach(function(key) {
                child[key] = _this[key];
            });
        };
        BaseModel.prototype.toDBJson = function(config) {
            var _this2 = this;
            var dbMapObj = {};
            Object.keys(config.mappings).forEach(function(e) {
                dbMapObj[config.mappings[e]] = _this2[e];
            });
            return dbMapObj;
        };
        /**
         * @function addRelation adds new relation to existing model
         * @param  {relation} relation object
         * @return
         */
        BaseModel.addRelation = function(relationObject) {
            var existingrelation;
            var relationexists = false;
            var modelrelations = this.relations;
            for (var i = 0; i < modelrelations.length; i++) {
                existingrelation = modelrelations[i];
                if (relationObject['targetObject'] == existingrelation['targetObject']) {
                    relationexists = true;
                }
            }
            if (!relationexists) {
                if (relationObject instanceof ModelRelation && relationObject.isValid()) {
                    this.relations.push(relationObject);
                }
            }
        };
        //Making attribute map part of Child model so depricating this
        //BaseModel.prototype.attributeMap={};
        /**
         * @function prototype function add Attribute adds new attribute and value to existing model instance
         * @param  {attributeKey} attribute key
         * @param  {modelDef} model defination
         * @return
         */
        BaseModel.prototype.addAttribute = function(attributeKey, attributeValue, modelName) {
            this.attributeMap[attributeKey] = {
                'model': modelName,
                'value': attributeValue
            };
        };
        /**
         * @function function add Attribute adds new attribute and value to existing model
         * @param  {attributeKey} attribute key
         * @param  {modelDef} model defination
         * @return
         */
        BaseModel.addAttribute = function(attributeKey, attributeValue, modelName) {
            this.prototype.attributeMap[attributeKey] = {
                'model': modelName,
                'value': null
            };
        };
        /**
         * @function save saves the given model data in the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.prototype.save = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).save(this, onCompletion, accessMode, options);
        };
        /**
         * @function getByPrimaryKey  fetches data for the specified model based on the primary keys
         * @param  {String/JSON} primaryKey   primitive in case of one primary key and json in case of composite primary key
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseModel.getByPrimaryKey = function(PrimaryKey, onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).getByPrimaryKey(PrimaryKey, onCompletion, accessMode, options);
        };
        /**
         * @function update  updates the record into the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.prototype.update = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).update(this, onCompletion, accessMode, options);
        };
        /**
         * @function partialUpdate partially update the model data to the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return 
         */
        BaseModel.prototype.partialUpdate = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).partialUpdate(this, onCompletion, accessMode, options);
        };
        /**
         * @function remove deletes the specified model from the backend
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.prototype.remove = function(onCompletion, accessMode, options) {
            var model = this.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).remove(this, onCompletion, accessMode, options);
        };
        /**
         * @function removeById deletes the specified model from the backend with a specific id
         * @param {JSON/STRING} primaryKey primary key value or json representing the key and value
         * @param  {function} onCompletion success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.removeById = function(primaryKey, onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).removeById(this, primaryKey, onCompletion, accessMode, options);
        };
        /**
         * @function getAll  fetches  all the data for the specified model
         * @param  {type} onCompletion success callback
         * @param  {type} accessMode   json specifing access mode
         * @return 
         */
        BaseModel.getAll = function(onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).getAll(onCompletion, accessMode, options);
        };
        /**
         * @function customVerb fetches data for the specified model using specified customVerb
         * @param  {String} customVerb   name of the custom verb to be executed
         * @param  {JSON} params       parameters in the form of key value pairs
         * @param  {function} onCompletion success callback
         * @return 
         */
        BaseModel.customVerb = function(customVerb, params, onCompletion, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).customVerb(customVerb, params, onCompletion, options);
        };
        /**
         * @function getByCriteria  fetches data for the specified model based on the criteria passed
         * @param  {Json} criteria        criteria object based on which query is build in case of online and offline
         * @param  {function} onCompletion    success callback
         * @param  {JSON} accessMode   json specifing access mode
         * @return
         */
        BaseModel.getByCriteria = function(criteria, onCompletion, accessMode, options) {
            var model = this.prototype.objModelName;
            options = options ? options : null;
            kony.mvc.MDAApplication.getSharedInstance().getRepoManager().getRepository(model).getByCriteria(criteria, onCompletion, accessMode, options);
        };
        /**
         * @function {function name}
         * @param  {type} injectedNamedValMap    {description}
         * @param  {type} injectedPropertyValMap {description}
         * @return {type} {description}
         */
        BaseModel.Validator = function(injectedNamedValMap, injectedPropertyValMap) {
            var NamedValidatorMap = injectedNamedValMap ? injectedNamedValMap : {};
            var PropertyToValidatorMap = injectedPropertyValMap ? injectedPropertyValMap : {};
            var getValidations = function(propName) {
                if (PropertyToValidatorMap[propName]) {
                    return PropertyToValidatorMap[propName];
                } else {
                    return [];
                }
            };
            this.isValid = function(obj, propName, value) {
                if (propName) {
                    return getValidations(propName).every(function(fn) {
                        return fn(value, propName, obj);
                    });
                } else {
                    return Object.keys(PropertyToValidatorMap).filter(function(prop) {
                        return PropertyToValidatorMap[prop];
                    }).every(function(prop) {
                        return PropertyToValidatorMap[prop].every(function(fn) {
                            return fn(obj[prop], prop, obj);
                        });
                    });
                }
            };
            this.registerValidator = function(propName, validationFn, validationName) {
                var errMsg = 'Unable to register Validator ';
                if (!propName) {
                    throw Error(errMsg + '-> Property Name should be specified');
                }
                if (!validationFn) {
                    throw Error(errMsg + '-> Validation Function should be specified');
                }
                var validationFnToStore = validationFn;
                if (validationName) {
                    if (NamedValidatorMap[validationName] && NamedValidatorMap[validationName] != null) {
                        throw Error(errMsg + '-> Validation Function named "' + validationName + '" already exists.');
                    } else {
                        validationFnToStore = function validationFnToStore() {
                            if (validationFn.apply(undefined, arguments)) {
                                return true;
                            } else {
                                throw Error('Validation "' + validationName + '" failed for property : ' + propName);
                            }
                        };
                        validationFnToStore.name = validationName;
                        validationFnToStore.onProperty = propName;
                        NamedValidatorMap[validationName] = validationFnToStore;
                    }
                }
                if (!PropertyToValidatorMap[propName]) {
                    PropertyToValidatorMap[propName] = [];
                }
                PropertyToValidatorMap[propName].push(validationFnToStore);
            };
            this.deRegisterValidator = function(validationName) {
                if (NamedValidatorMap[validationName]) {
                    var fnToRemove = NamedValidatorMap[validationName];
                    PropertyToValidatorMap[fnToRemove.onProperty] = PropertyToValidatorMap[fnToRemove.onProperty].filter(function(e) {
                        return e != fnToRemove;
                    });
                    NamedValidatorMap[validationName] = null;
                } //else{throw 'No such validator was registered';}
            };
            this.clearAllValidators = function(forPropName) {
                if (forPropName) {
                    if (PropertyToValidatorMap[forPropName]) {
                        //clear named validations for the property
                        Object.keys(NamedValidatorMap).filter(function(key) {
                            return NamedValidatorMap[key] != null;
                        }).filter(function(key) {
                            return NamedValidatorMap[key].onProperty === forPropName;
                        }).forEach(function(key) {
                            NamedValidatorMap[key] = null;
                        });
                        //reset all the validataions for property
                        PropertyToValidatorMap[forPropName] = [];
                    }
                } else {
                    //clear all named validations
                    Object.keys(NamedValidatorMap).forEach(function(key) {
                        NamedValidatorMap[key] = null;
                    });
                    //reset all validations for all properties
                    Object.keys(PropertyToValidatorMap).forEach(function(key) {
                        PropertyToValidatorMap[key] = [];
                    });
                }
            };
            this.getNamedValidations = function() {
                return Object.keys(NamedValidatorMap).filter(function(key) {
                    return NamedValidatorMap[key];
                });
            };
        };
        return BaseModel;
    }(DataModel_ModelRelation);
    DataModel_ORMSession = function() {
        ORMSession = function(appContext) {
            this.appContext = appContext;
        };
        ORMSession.prototype.intialize = function() {};
        ORMSession.prototype.save = function(QueryBuilder) {};
        ORMSession.prototype.remove = function(QueryBuilder) {};
        ORMSession.prototype.get = function(QueryBuilder) {
            //Put Validation Logic
            //Put Execution Logic  
            //get query from QueryBuilder 
            //execute and return result
            console.log('in ormsession get method');
            var query = QueryBuilder.getQuery();
            console.log('execute ' + query);
        };
        return ORMSession;
    }();
    DataModel_Expression = function() {
        Expression = function() {
            this.expr = null;
            this.lhs = null;
            this.rhs = null;
        };
        Expression.and = function() {
            var rootExpression = Expression.eq(null, null);
            for (var expression in arguments) {
                if (rootExpression.lhs == null) {
                    rootExpression.lhs = arguments[expression];
                    continue;
                } else if (rootExpression.rhs == null) {
                    rootExpression.rhs = arguments[expression];
                    continue;
                } else {
                    var temp = rootExpression;
                    rootExpression = Expression.eq(null, null);
                    rootExpression.lhs = temp;
                    rootExpression.rhs = arguments[expression];
                }
            }
            return rootExpression;
        };
        Expression.eq = function(lexpr, rexpr) {
            var expr = new Expression();
            expr.expr = 'eq';
            expr.lhs = lexpr;
            expr.rhs = rexpr;
            return expr;
        };
        return Expression;
    }();
    FormController_MDAFormController = function(inheritsFrom) {
        function MDAFormController(viewId1) {
            this.eventDelegate = null;
            this.presenter = null;
            this.config = null;
            this.superParams = {
                counter: 0,
                level: null,
                refStack: []
            };
            kony.mvc.FormController.call(this, viewId1);
        }
        inheritsFrom(MDAFormController, kony.mvc.FormController);
        MDAFormController.prototype.show = function(context, isBackNavigation) {
            kony.mvc.FormController.prototype.show.call(this, context, isBackNavigation);
        };
        MDAFormController.prototype.raiseEvent = function(eventId, eventContext) {
            if (this.eventDelegate !== null) {
                this.eventDelegate._onEventRaised(this, eventId, eventContext);
            }
        };
        MDAFormController.prototype.setStartupContext = function() {};
        MDAFormController.prototype.onNavigate = function(context, isBackNavigation) {
            this.setStartupContext();
            if (context) {
                this.eventDelegate = context._presenter;
                this.presenter = context._presenter;
                this.config = context._formConfig;
                if ('viewModel' in context) {
                    this.updateUI(context.viewModel);
                }
            }
        };
        MDAFormController.prototype.updateUI = function(viewModel) {
            var uiInstance = kony.mvc.MDAApplication.getSharedInstance().getUIBinder();
            if (this.shouldUpdateUI(viewModel)) {
                this.willUpdateUI(viewModel);
                uiInstance.mapData(this.config, viewModel, this.view);
                this.didUpdateUI(viewModel);
            }
        };
        MDAFormController.prototype.shouldUpdateUI = function(context) {
            //code
            return true;
        };
        MDAFormController.prototype.willUpdateUI = function(context) {};
        MDAFormController.prototype.didUpdateUI = function(context) {};
        MDAFormController.prototype.attachToModule = function(module) {
            this.presenter = module.presentationController;
            this.presenter._pushToPresentationStack(this.presenter, this.view.id, null);
        };
        MDAFormController.prototype.super = function(methodName, argList) {
            var scope = this;
            var returnValue = null;
            if (this.superParams.level === null) {
                this.superParams.level = 0;
                while (scope['extensionLevel' + this.superParams.level.toString()]) {
                    this.superParams.level++;
                }
            }
            if (this.superParams.counter === 0) {
                for (var i = 0; i < this.superParams.level; i++) {
                    if (scope['extensionLevel' + i.toString()][methodName]) {
                        this.superParams.refStack.push(i);
                    }
                }
            }
            this.superParams.refStack.pop();
            if (this.superParams.refStack.length !== 0) {
                var callLvl = this.superParams.refStack[this.superParams.refStack.length - 1];
                this.superParams.counter++;
                returnValue = scope['extensionLevel' + callLvl.toString()][methodName].apply(this, argList);
                this.superParams.counter--;
            } else {
                kony.print('#MDA2 : Can\'t find any super for the ' + methodName + ' Method.');
            }
            if (this.superParams.counter === 0) {
                this.superParams.refStack = [];
                this.superParams.level = null;
            }
            return returnValue;
        };
        return MDAFormController;
    }(commonUtils_inheritsFrom);
    commonUtils_ControllerGetterAPI = function() {
        function getController(formId) {
            var tempController = kony.mvc.registry.get(formId);
            var controllerType = 'kony.mvc.MDAFormController';
            var isForm = true;
            if (tempController != null) {
                var tempControllerType = kony.mvc.registry.getControllerType(formId);
                if (tempControllerType == controllerType) {
                    return _kony.mvc.GetController(formId, isForm);
                } else {
                    var friendlyName = kony.mvc.registry.getFriendlyName(formId);
                    var controllerName = kony.mvc.registry.getControllerName(formId);
                    var controllerExtName = kony.mvc.registry.getControllerExtName(formId);
                    kony.mvc.registry.remove(formId);
                    kony.mvc.registry.add(formId, formId, {
                        'controllerName': controllerType,
                        'controllerType': controllerType,
                        'controllerExtName': controllerExtName
                    });
                    return _kony.mvc.GetController(formId, isForm);
                }
            } else {
                return null;
            }
        }
        return getController;
    }();
    main = function(require) {
        if (typeof kony === 'undefined') {
            kony = {};
        }
        kony.mvc = kony.mvc ? kony.mvc : {};
        const mda = kony.mvc;
        mda.Business = {};
        mda.Business.Controller = BusinessController_BusinessController;
        mda.Business.Command = BusinessController_Command;
        mda.Business.CommandExecutionEngine = BusinessController_CommandExecutionEngine;
        mda.Business.CommandHandler = BusinessController_CommandHandler;
        mda.Business.CommandResponse = BusinessController_CommandResponse;
        mda.Business.Delegator = BusinessController_BusinessDelegator;
        mda.util = mda.util ? mda.util : {};
        mda.MDAApplication = commonUtils_MDAApplication;
        mda.util.ClassExtensionUtility = commonUtils_ExtensibilityApi;
        mda.util.Logger = commonUtils_Logger;
        mda.util.InitializeForms = commonUtils_InitializeForms;
        mda.util.ProcessorUtils = commonUtils_ProcessorUtils;
        //mda.util.sync = mda.util.sync ? mda.util.sync : {};
        //mda.util.sync.Sync_Initialize_CommandHandler = require('commonUtils/syncController/Sync_Initialize_CommandHandler');
        //mda.util.sync.Sync_PresentationController = require('commonUtils/syncController/Sync_PresentationController');
        //mda.util.sync.SyncModuleConfig = require('commonUtils/syncController/SyncModuleConfig');
        mda.util.ParallelCommandExecuter = ParallelCommandExecuter_ParallelCommandExecuter;
        mda.Data = mda.Data ? mda.Data : {};
        mda.Data.BaseModel = DataModel_BaseModel;
        mda.Data.BaseRepository = DataModel_BaseRepository;
        mda.Data.DataSource = DataModel_DataSource;
        mda.Data.ORMSession = DataModel_ORMSession;
        mda.Data.QueryBuilder = DataModel_QueryBuilder;
        mda.Data.RepositoryManager = DataModel_RepositoryManager;
        mda.Data.ModelRelation = DataModel_ModelRelation;
        mda.Expression = DataModel_Expression;
        mda.MDAFormController = FormController_MDAFormController;
        mda.MDAModule = ModuleManager_MDAModule;
        mda.MDAModuleManager = ModuleManager_MDAModuleManager;
        mda.Presentation = mda.Presentation ? mda.Presentation : {};
        mda.Presentation.BasePresenter = PresentationController_MDABasePresenter;
        mda.Presentation.BaseNavigator = BaseNavigator_MDABaseNavigator;
        mda.UIBinder = mda.UIBinder ? mda.UIBinder : {};
        mda.UIBinder.UIBinder = UIBinder_UIBinder;
        mda.UIBinder.UIBinderBuilder = UIBinder_UIBinderBuilder;
        mda.UIBinder.WidgetDataMapper = UIBinder_WidgetDataMapper_WidgetDataMapper;
        mda.UIBinder.PropertyDataMapper = mda.UIBinder.PropertyDataMapper ? mda.UIBinder.PropertyDataMapper : {};
        mda.UIBinder.PropertyDataMapper.ButtonProperties = UIBinder_PropertyDataMapper_ButtonProperties;
        mda.UIBinder.PropertyDataMapper.CalendarProperties = UIBinder_PropertyDataMapper_CalendarProperties;
        mda.UIBinder.PropertyDataMapper.GenericProperties = UIBinder_PropertyDataMapper_GenericProperties;
        mda.UIBinder.PropertyDataMapper.ImageProperties = UIBinder_PropertyDataMapper_ImageProperties;
        mda.UIBinder.PropertyDataMapper.LabelProperties = UIBinder_PropertyDataMapper_LabelProperties;
        mda.UIBinder.PropertyDataMapper.ListboxProperties = UIBinder_PropertyDataMapper_ListboxProperties;
        mda.UIBinder.PropertyDataMapper.RichTextProperties = UIBinder_PropertyDataMapper_RichTextProperties;
        mda.UIBinder.PropertyDataMapper.SliderProperties = UIBinder_PropertyDataMapper_SliderProperties;
        mda.UIBinder.PropertyDataMapper.SwitchProperties = UIBinder_PropertyDataMapper_SwitchProperties;
        mda.UIBinder.PropertyDataMapper.TextAreaProperties = UIBinder_PropertyDataMapper_TextAreaProperties;
        mda.UIBinder.PropertyDataMapper.TextboxProperties = UIBinder_PropertyDataMapper_TextboxProperties;
        mda.UIBinder.WidgetDataMapper = mda.UIBinder.WidgetDataMapper ? mda.UIBinder.WidgetDataMapper : {};
        mda.UIBinder.WidgetDataMapper.ButtonWidgetDataMapper = UIBinder_WidgetDataMapper_ButtonWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.CalendarWidgetDataMapper = UIBinder_WidgetDataMapper_CalendarWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.ImageWidgetDataMapper = UIBinder_WidgetDataMapper_ImageWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.LabelWidgetDataMapper = UIBinder_WidgetDataMapper_LabelWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.ListboxWidgetDataMapper = UIBinder_WidgetDataMapper_ListboxWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.RichTextWidgetDataMapper = UIBinder_WidgetDataMapper_RichTextWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.SegmentWidgetDataMapper = UIBinder_WidgetDataMapper_SegmentWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.SliderWidgetDataMapper = UIBinder_WidgetDataMapper_SliderWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.SwitchWidgetDataMapper = UIBinder_WidgetDataMapper_SwitchWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.TextAreaWidgetDataMapper = UIBinder_WidgetDataMapper_TextAreaWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.TextboxWidgetDataMapper = UIBinder_WidgetDataMapper_TextboxWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.FlexContainerWidgetDataMapper = UIBinder_WidgetDataMapper_FlexContainerWidgetDataMapper;
        mda.UIBinder.WidgetDataMapper.WidgetDataMapper = UIBinder_WidgetDataMapper_WidgetDataMapper;
        mda.getController = commonUtils_ControllerGetterAPI;
        //constants
        mda.constants = mda.constants ? mda.constants : {};
        mda.constants.STATUS_SUCCESS = 100;
        mda.constants.STATUS_FAILURE = 200;
        mda.constants.STATUS_ABORT = 99;
        define('kony.mvc.MDAFormController', kony.mvc.MDAFormController);
        define('kony/mvc/MDAFormController', kony.mvc.MDAFormController);
        define('MDAFormController', kony.mvc.MDAFormController);
        return mda;
    }({});
}());
function getKonyMBAASAppKey() {
    return $appKey;
}

function getKonyMBAASAppSecret() {
    return $appSecret;
}
function initializesegNewsTemplate() {
    segNewsFlxContainer = new kony.ui.FlexContainer({
        "autogrowMode": kony.flex.AUTOGROW_NONE,
        "clipBounds": true,
        "height": "25%",
        "id": "segNewsFlxContainer",
        "isVisible": true,
        "layoutType": kony.flex.FREE_FORM,
        "left": "0dp",
        "isModalContainer": false,
        "skin": "slFbox",
        "top": "0dp",
        "width": "100%"
    }, {
        "retainFlowHorizontalAlignment": false
    }, {});
    segNewsFlxContainer.setDefaultUnit(kony.flex.DP);
    var lblTitle = new kony.ui.Label({
        "height": "50%",
        "id": "lblTitle",
        "isVisible": true,
        "left": "0%",
        "skin": "defLabel",
        "text": "Label",
        "top": "0%",
        "width": "80%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var lblDescription = new kony.ui.Label({
        "height": "50%",
        "id": "lblDescription",
        "isVisible": true,
        "left": "0%",
        "skin": "defLabel",
        "text": "Label",
        "top": "50%",
        "width": "80%",
        "zIndex": 1
    }, {
        "contentAlignment": constants.CONTENT_ALIGN_MIDDLE_LEFT,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    var imgNews = new kony.ui.Image2({
        "height": "100%",
        "id": "imgNews",
        "isVisible": true,
        "left": "80%",
        "skin": "slImage",
        "src": "imagedrag.png",
        "top": "0%",
        "width": "20%",
        "zIndex": 1
    }, {
        "imageScaleMode": constants.IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO,
        "padding": [0, 0, 0, 0],
        "paddingInPixel": false
    }, {});
    segNewsFlxContainer.add(lblTitle, lblDescription, imgNews);
}
kony.globals["appid"] = "breakingNews";
kony.globals["build"] = "debug";
kony.globals["locales"] = [];
kony.globals["i18nArray"] = [];
//startup.js
var appConfig = {
    appId: "breakingNews",
    appName: "breakingNews",
    appVersion: "1.0.0",
    isturlbase: "http://KH2321.kitspl.com:8443/services",
    isDebug: true,
    isMFApp: true,
    appKey: "276cd5d9697082c509240e05ced84e8d",
    appSecret: "5bb54d20c2afe4b8c23b7bea1af656dd",
    serviceUrl: "http://KH2321.kitspl.com:8443/authService/100000002/appconfig",
    svcDoc: {
        "identity_meta": {},
        "app_version": "1.0",
        "baseId": "e9ce3f15-7439-4ed5-b6f6-c67b27fdf591",
        "app_default_version": "1.0",
        "login": [{
            "alias": "userstore",
            "type": "basic",
            "prov": "userstore",
            "url": "http://KH2321.kitspl.com:8443/authService/100000002"
        }],
        "services_meta": {
            "breakingNewsService": {
                "offline": true,
                "metadata_url": "http://KH2321.kitspl.com:8443/services/metadata/v1/breakingNewsService",
                "type": "objectsvc",
                "version": "1.0",
                "url": "http://KH2321.kitspl.com:8443/services/data/v1/breakingNewsService"
            }
        },
        "selflink": "http://KH2321.kitspl.com:8443/authService/100000002/appconfig",
        "integsvc": {
            "_internal_logout": "http://KH2321.kitspl.com:8443/services/IST"
        },
        "service_doc_etag": "0000016B4BE48948",
        "appId": "4e56d061-5399-4fb3-8391-b8049647c1a3",
        "identity_features": {
            "reporting_params_header_allowed": true
        },
        "name": "BreakingNews",
        "reportingsvc": {
            "session": "http://KH2321.kitspl.com:8443/services/IST",
            "custom": "http://KH2321.kitspl.com:8443/services/CMS"
        },
        "Webapp": {
            "url": "http://KH2321.kitspl.com:8443/apps/breakingNews"
        }
    },
    runtimeAppVersion: "1.0",
    eventTypes: ["FormEntry", "Error", "Crash"],
};
sessionID = "";

function appInit(params) {
    skinsInit();
    initializeMVCTemplates();
    initializeUserWidgets();
    initializeSampleRowTemplate();
    initializeSampleSectionHeaderTemplate();
    initializesegNewsTemplate();
    Form1Globals();
    FormSubNewsCreateGlobals();
    frmNewsGlobals();
    frmWelcomeGlobals();
    //to generate adherePercentageStrictly, retainSpace, marginPaddingConsistency flags as true if the project is created in 5.5
    setAppBehaviors();
};
//This is a hack for postAppInit and NotesPopup.
kony.visualizer.actions.postAppInitCallBack = function(eventObj) {};

function setAppBehaviors() {
    kony.application.setApplicationBehaviors({
        applyMarginPaddingInBCGMode: false,
        adherePercentageStrictly: true,
        retainSpaceOnHide: true,
        responsive: true,
        APILevel: 8400
    })
};

function themeCallBack() {
    initializeGlobalVariables();
    requirejs.config({
        baseUrl: kony.appinit.getStaticContentPath() + 'desktopweb/appjs'
    });
    require(['kvmodules'], function() {
        kony.application.setApplicationInitializationEvents({
            init: appInit,
            postappinit: kony.visualizer.actions.postAppInitCallBack,
            showstartupform: function() {
                frmWelcome.show();
            }
        });
    });
};

function loadResources() {
    kony.theme.packagedthemes(["defaultTheme"]);
    globalhttpheaders = {};
    sdkInitConfig = {
        "appConfig": appConfig,
        "isMFApp": appConfig.isMFApp,
        "appKey": appConfig.appKey,
        "appSecret": appConfig.appSecret,
        "eventTypes": appConfig.eventTypes,
        "serviceUrl": appConfig.serviceUrl
    }
    kony.setupsdks(sdkInitConfig, onSuccessSDKCallBack, onSuccessSDKCallBack);
};

function onSuccessSDKCallBack() {
    spaAPM && spaAPM.startTracking();
    kony.theme.setCurrentTheme("default", themeCallBack, themeCallBack);
}

function initializeApp() {
    kony.application.setApplicationMode(constants.APPLICATION_MODE_NATIVE);
    //This is the entry point for the application.When Locale comes,Local API call will be the entry point.
    loadResources();
};
									function getSPARequireModulesList(){ return ['kvmodules']; }
								
/* File to handle CRUD operations on technology table*/
//sample create function
function techCreate() {
    var obj = new kony.sdk.KNYObj("technolgy_news");
    var record = {};
    record.techid = 1;
    record.stateId = 1;
    record.Date = "2019-06-12";
    record.image1 = base64String;
    obj.create(record, {}, successCallback, failureCallback);
}
function initializeUserWidgets() {}
kony.decrement = function(num) {
    if (typeof(num) === "number") {
        return num - 1;
    } else {
        return num;
    }
};
kony.increment = function(num) {
    if (typeof(num) === "number") {
        return num + 1;
    } else {
        return num;
    }
};
kony.decrementIndices = function(arr) {
    var tArr = [];
    for (var i = 0; i < arr.length; i++) {
        tArr[i] = arr[i] - 1;
    }
    return tArr;
};
kony.incrementIndices = function(arr) {
    var tArr = [];
    for (var i = 0; i < arr.length; i++) {
        tArr[i] = arr[i] + 1;
    }
    return tArr;
};
/**The Math Library has APIs that you can use to perform mathematical operations.*/
kony.math = {
        /**@Deprecated. This API returns the value of pi. Note: math.pi is not a function, but a property in math namespace.*/
        pi: Math.PI,
        /**@Deprecated. This API generates pseudo-random numbers which are uniformly distributed. This API generates a real number between 0 and 1.*/
        random: function() {
            return (Math.random());
            /*var result = Math.random();
	
		if (0 === args.length) {
			return result;
		} else if (1 === args.length) {
			args[0] -= 0;
			if (isNaN(args[0])) {
				throw new Error("Invalid argument to math.random");
			}
	
			result = Math.floor(result * args[0]) + 1;
		} else if (2 === args.length) {
			args[0] -= 0; args[1] -= 0;
			if (isNaN(args[0]) || isNaN(args[1])) {
				throw new Error("Invalid argument(s) to math.random");
			}
	
			result = Math.floor(result * (args[1] - args[0] + 1)) + args[0];
		} else {
			throw new Error("Invalid number of arguments to math.random");
		}
	
		return result;*/
        },
        /*
        randomseed: function (args) {
        	return null;
        },
        */
        /**@Deprecated. This API sets the input parameter as the "seed" for the pseudo-random generator.
        Note: Equal seeds produce equal sequences of numbers.*/
        randomSeed: function(num) {
            pseudoRandomArray = [];
            if (isNaN(num)) throw new Error("Invalid argument to math.randomseed");
            if (!pseudoRandomArray[num]) {
                pseudoRandomArray[num] = Math.random();
            }
            return pseudoRandomArray[num];
        },
        /**@Deprecated. This API converts the float value to an integer. The converted integer value is always the integer part of the specified float number (number before the decimal).*/
        toInteger: function(num) {
            num -= 0;
            if (isNaN(num)) {
                throw new Error("Invalid argument to math.tointeger");
            }
            return Math.floor(num);
        },
        /**@Deprecated. This API raises the first parameter to the power of the second parameter and returns the result.*/
        pow: function(num1, num2) {
            num1 -= 0;
            num2 -= 0;
            if (isNaN(num1) || isNaN(num2)) {
                throw new Error("Invalid argument(s) to math.pow");
            }
            return Math.pow(num1, num2);
        },
        findExtreme: function(extreme, args) {
            if (args.length < 2) {
                throw new Error((extreme ? "math.max" : "math.min") + " needs atleast two arguments");
            }
            var result = args[0] - 0;
            if (isNaN(result)) {
                throw new Error("Invalid argument to " + (extreme ? "math.max" : "math.min"));
            }
            for (var i = 1; i < args.length; i++) {
                args[i] -= 0;
                if (isNaN(args[i])) {
                    throw new Error("Invalid argument to " + (extreme ? "math.max" : "math.min"));
                }
                if (extreme) {
                    if (result < args[i]) {
                        result = args[i];
                    }
                } else {
                    if (result > args[i]) {
                        result = args[i];
                    }
                }
            }
            return result;
        },
        /**@Deprecated. This API returns the minimum value among the arguments.*/
        min: function() {
            return kony.math.findExtreme(false, arguments);
        },
        /**@Deprecated. This API returns the maximum value among the arguments.*/
        max: function() {
            return kony.math.findExtreme(true, arguments);
        },
        /**@Deprecated. This API returns the square root of the given number.*/
        sqrt: function(num) {
            num -= 0;
            if (isNaN(num)) {
                throw new Error("Invalid argument to math.sqrt");
            }
            var result = Math.sqrt(num);
            return isNaN(result) ? "nan" : result;
        }
    }
    /**The string Library has APIs that you can use to manipulate strings. The kony.string name space provides static string APIs. These static APIs augment the APIs in the Global string object which is available by default. For more information refer, https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/string.*/
kony.string = {
        /**@Deprecated This API finds the first occurrence of the search string in the source string. */
        find: function() {
            if (arguments.length < 2) {
                throw new Error("string.find needs atleast two arguments");
            }
            for (var i = 0; i < 2; i++) {
                if (typeof(arguments[i]) === "number") {
                    arguments[i] = arguments[i].toString();
                } else if (typeof(arguments[i]) !== "string") {
                    throw new Error("Invalid argument(s) to string.find");
                }
            }
            var beginIndex = 0;
            if (arguments.length > 2) {
                beginIndex = arguments[2] - 0;
                if (!isNaN(beginIndex)) {
                    if (beginIndex < 0) {
                        beginIndex += arguments[0].length;
                        if (beginIndex < 0) beginIndex = 0;
                    }
                } else {
                    beginIndex = 0;
                }
            }
            var result = arguments[0].indexOf(arguments[1], beginIndex - 1);
            if (-1 === result) {
                return null;
            } else {
                ////result++;
                //return result, result + arguments[1].length - 1;
                return result;
            }
        },
        /**@Deprecated This API returns the length of the source string. */
        len: function(s) {
            if (0 === arguments.length) {
                throw new Error("string.len needs atleast one argument");
            }
            if (typeof(s) === "number") {
                s = s.toString();
            } else if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.len");
            }
            return arguments[0].length;
        },
        /**@Deprecated This API compares the contents of two strings numerically. For example, "Adam" is smaller than "adam" as per the ASCII table because A(65) is smaller than a(97). */
        compare: function(s1, s2) {
            if (arguments.length < 2) {
                throw new Error("string.compare needs atleast two arguemnts");
            }
            if (typeof(s1) == "string" && typeof(s2) == "string") {
                if (s1 < s2) {
                    return -1;
                } else if (s1 == s2) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                throw new Error("Invalid argument(s) to string.compare");
            }
        },
        /**@Deprecated This API returns a string which contains a single character from the source string at the specified index. */
        charat: function(s1, index) {
            if (arguments.length < 2) {
                throw new Error("string.charat needs atleast two arguments");
            }
            if (typeof(s1) === "number") {
                s1 = s1.toString();
            } else if (typeof(s1) !== "string") {
                throw new Error("Invalid argument to string.charat");
            }
            index -= 0;
            if (isNaN(index)) {
                throw new Error("Invalid argument to string.charat");
            }
            ////index--;
            if (index < 0 || index >= s1.length) {
                return null;
            }
            return s1.charAt(index);
        },
        flipCase: function(args, flag) {
            if (0 === args.length) {
                throw new Error(flag ? "string.upper" : "string.lower" + " needs atleast one argument");
            }
            if (typeof(args[0]) !== "string") {
                throw new Error("Invalid argment to " + flag ? "string.upper" : "string.lower");
            }
            if (flag) {
                return args[0].toUpperCase();
            } else {
                return args[0].toLowerCase();
            }
        },
        /**@Deprecated This API changes the upper case characters of the source string to lower case characters. */
        lower: function() {
            return kony.string.flipCase(arguments, false);
        },
        /**@Deprecated This API changes the lower case characters of the source string to upper case characters.*/
        upper: function() {
            return kony.string.flipCase(arguments, true);
        },
        /**This API generates a string which is equivalent to "n copies of the source string concatenated together".*/
        rep: function(s, n) {
            if (arguments.length < 2) {
                throw new Error("Insufficient arguments to string.rep");
            }
            if (typeof(s) === "number") {
                s = s.toString();
            } else if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.rep");
            }
            n -= 0;
            if (isNaN(n)) {
                throw new Error("Invalid argument to string.rep");
            }
            var resultStr = "";
            for (var i = 0; i < n; i++) {
                resultStr += s;
            }
            return resultStr;
        },
        /**This API reverses the characters in the source string.*/
        reverse: function(s) {
            if (0 === arguments.length) {
                throw new Error("string.reverse needs atleast one argument");
            }
            if (typeof(s) === "number") {
                s = s.toString();
            } else if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.reverse");
            }
            var resultStr = "";
            for (var i = s.length - 1; i >= 0; i--) {
                resultStr += s.charAt(i);
            }
            return resultStr;
        },
        /**This API removes the leading and ending spaces from the source string.*/
        trim: function(s) {
            if (0 === arguments.length) {
                throw new Error("string.trim needs atleast one argument");
            }
            if (s === undefined) {
                return s;
            } else if (typeof(s) !== "string") {
                return s.toString();
                //throw new Error("Invalid argument to string.trim");
            }
            return s.replace(/^\s*/, "").replace(/\s*$/, "");
        },
        /**Determines whether two strings contain the same data, ignoring the case of the letters in the String. */
        equalsIgnoreCase: function(s1, s2) {
            if (arguments.length < 2) {
                throw new Error("string.equalsIgnoreCase needs atleast two arguments");
            }
            if (typeof(s1) !== "string" || typeof(s2) !== "string") {
                throw new Error("Invalid argument(s) to string.equalsIgnoreCase");
            }
            return (s1.toLowerCase() === s2.toLowerCase());
        },
        equals: function(s1, s2) {
            if (arguments.length < 2) {
                throw new Error("string.equals needs atleast two arguments");
            }
            if (typeof(s1) !== "string" || typeof(s2) !== "string") {
                throw new Error("Invalid argument(s) to string.equals");
            }
            return (s1 === s2);
        },
        matchEnds: function(args, end) {
            if (args.length < 2) {
                throw new Error(end ? "string.endsWith" : "string.startsWith" + " needs atleast two arguments");
            }
            if (typeof(args[0]) !== "string" || typeof(args[1]) !== "string") {
                throw new Error("Invalid argument(s) to " + end ? "string.endsWith" : "string.startsWith");
            }
            if (!(args.length > 2 && (args[2] === false || args[2] === null))) {
                args[0] = args[0].toLowerCase();
                args[1] = args[1].toLowerCase();
            }
            if (end) {
                var ll = args[0].lastIndexOf(args[1]);
                if (ll < 0) {
                    return false;
                } else {
                    return (args[0].lastIndexOf(args[1]) === args[0].length - args[1].length);
                }
            } else {
                return (args[0].indexOf(args[1]) === 0);
            }
        },
        /**This API returns a boolean value indicating if the source string begins with the specified string. */
        startsWith: function(sourcestring, comparestring, ignorecase) {
            return kony.string.matchEnds(arguments, false);
        },
        /**This API returns a boolean value indicating if the source string ends with the specified string. */
        endsWith: function(sourcestring, comparestring, ignorecase) {
            return kony.string.matchEnds(arguments, true);
        },
        /**@Deprecated This API splits the source string based on the separator (default is comma) and returns a table containing the string. */
        split: function(s, sep) {
            if (0 === arguments.length) {
                throw new Error("string.split needs atleast one argument");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument to string.split");
            }
            var delim;
            if (arguments.length > 1) {
                if (typeof(sep) !== "string") {
                    throw new Error("The optional delimitor for string.split must be a string");
                }
                delim = sep;
            } else {
                delim = ",";
            }
            var splitstr = new Array();
            if (delim == "") {
                splitstr[1] = s;
            } else {
                splitstr = s.split(delim);
                splitstr.unshift(null); //To match lua Array indexing.
            }
            return splitstr;
        },
        /**@Deprecated This API returns the substring of the source string. */
        sub: function() {
            function getIndex(i, len) {
                if (typeof(i) === "string") {
                    i -= 0;
                } else if (typeof(i) !== "number") {
                    throw new Error("Invalid argument to string.sub");
                }
                if (i < 0) {
                    ////return (i + len + 1);
                    return (i + len - 1);
                } else if (i > len) {
                    return len;
                }
                return i;
            }

            function adjustIndex(i) {
                if (i > 0) {
                    return i - 1;
                } else {
                    return 0;
                }
            }
            if (arguments.length < 2) {
                throw new Error("string.sub needs atleast two arguments");
            }
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
                args[i] = arguments[i];
            }
            if (typeof(args[0]) === "number") {
                args[0] = args[0].toString();
            } else if (typeof(args[0]) !== "string") {
                throw new Error("Invalid argument to string.sub");
            }
            var startIndex = getIndex(args[1], args[0].length);
            var endIndex = args[0].length;
            if (args.length > 2) {
                endIndex = getIndex(args[2], args[0].length);
            }
            if (endIndex < startIndex || (0 === startIndex && endIndex === startIndex)) {
                return "";
            } else {
                ////startIndex = adjustIndex(startIndex); endIndex = adjustIndex(endIndex);
                return args[0].slice(startIndex, endIndex + 1);
            }
        },
        /**@Deprecated This API finds and replaces the occurrences of a string in the source string with a string you specify. */
        replace: function(s, f, rep) {
            if (arguments.length < 3) {
                throw new Error("string.replace needs atleast three arguments");
            }
            if (typeof(s) !== "string" || typeof(f) !== "string" || typeof(rep) !== "string") {
                throw new Error("Invalid argument(s) to string.replace");
            }
            //return [s.replace(f, rep)];
            // Replace all occurrences
            //var exp1 = new RegExp(f, "g");
            var exp1 = new RegExp(kony.string.escapeRegExp(f), "g");
            return (s != "" && f == "") ? s : s.replace(exp1, rep);
        },
        /*
        format: function (args) {
        	if (0 === args.length) {
        		throw new Error("string.format needs atleast one argument");
        	}
	
        	if (typeof(args[0]) === "number") {
        		return args[0].toString();
        	} else if (typeof(args[0]) === "string") {
        		var toks = args[0].split(/(%[f,s,b])/);
	
        		var flag = false;
        		var result = "";
        		for (var i = 0, j = 1; i < toks.length; i++) {
        			if ("%f" === toks[i] || "%s" === toks[i] || "%b" === toks[i]) {
        				if (j === args.length) {
        					throw new Error("Insufficient number of arguments to string.format");
        				}
	
        				if ("%f" === toks[i]) {
        					var num = args[j] - 0;
	
        					if (isNaN(num)) {
        						throw new Error("Invalid argument to string.format");
        					}
	
        					result += num;
        				} else if ("%s" === toks[i]) {
        					result += args[j].toString();
        				} else if ("%b" === toks[i]) {
        					if (args[j] === false || args[j] === null) {
        						result += "false";
        					} else {
        						result += "true";
        					}
        				}
	
        				j++;
        			} else {
        				result += toks[i];
        			}
        		}
	
        		return result;
        	} else {
        		throw new Error("Invalid first argument to string.format");
        	}
        }, */
        /** This API verifies if the input string contains only ASCII alphabet characters and returns a boolean value. */
        isAsciiAlpha: function(s) {
            if (arguments.length === 0) {
                throw new Error("string.isAsciiAlpha needs atleast 1 argument");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.isAsciiAlpha");
            }
            var regexp = new RegExp("[^a-zA-Z]", "g");
            return (s == "") ? false : !(regexp.test(s));
        },
        /** This API verifies if the input string contains only ASCII alphabet characters and numbers, and returns a boolean value.*/
        isAsciiAlphaNumeric: function(str) {
            if (arguments.length === 0) {
                throw new Error("string.isAsciiAlphaNumeric needs atleast 1 argument");
            }
            var p1 = /[^a-zA-Z0-9]/i; // Elimimate non alpha numeric chars //Added cap letters also 
            var p2 = /^[a-zA-Z0-9]*$/i; /* Wrong regex   /([a-z]+[0-9])|([0-9]+[a-z])/i; */
            var r1 = str.match(p1);
            var r2 = str.match(p2);
            return (!r1 && r2 && str) ? true : false;
        },
        /** This API verifies if the input string contains only numeric characters, and returns a boolean value.*/
        isNumeric: function(s) {
            if (arguments.length === 0) {
                throw new Error("string.isNumeric needs atleast 1 argument");
            }
            /*if (typeof(args[0]) !== "string") {
            	throw new Error("Invalid argument(s) to string.isNumeric");
            }*/
            return (s == "" || (typeof(s) == "string" && s.replace(/\s/g, '').length == 0)) ? false : !(isNaN(s));
        },
        /** This API verifies if any one of the specified set of characters is available in the given string and returns a boolean value.*/
        containsChars: function(s, a) {
            if (arguments.length === 0) {
                throw new Error("string.containsChars needs 2 arguments");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.containsChars");
            }
            if (a instanceof Array === false) {
                throw new Error("Invalid argument to table.containsChars");
            }
            var charset = [];
            var charstr = "";
            var chararray = a;
            var len = chararray.length;
            var result = false;
            for (var i = 0; i < len; i++) {
                charset[i] = chararray[i];
                if (s == "" || charset[i] == "") return true;
            }
            charstr = charset.join("");
            charstr = "[" + kony.string.escapeRegExp(charstr) + "]";
            var regexp = new RegExp(charstr, "g");
            result = regexp.test(s);
            return result;
        },
        /** This API verifies if only (and only) the specified set of characters is available in the given string and returns a boolean value.*/
        containsOnlyGivenChars: function(s, a) {
            if (arguments.length === 0) {
                throw new Error("string.containsOnlyGivenChars needs atleast 1 argument");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.containsOnlyGivenChars");
            }
            var charset = [];
            var charstr = "";
            var chararray = a;
            var len = chararray.length;
            var result = false;
            for (var i = 0; i < len; i++) {
                charset[i] = chararray[i];
            }
            charstr = charset.join("");
            //charstr = charstr.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            charstr = "[^" + kony.string.escapeRegExp(charstr) + "]";
            var regexp = new RegExp(charstr, "g");
            result = regexp.test(s);
            if (result === false) {
                return true;
            } else {
                return false;
            }
        },
        /** This API verifies that the input string does not contain any of the specified characters and returns a boolean value.*/
        containsNoGivenChars: function(s, a) {
            if (arguments.length === 0) {
                throw new Error("string.containsNoGivenChars needs 2 arguments");
            }
            if (typeof(s) !== "string") {
                throw new Error("Invalid argument(s) to string.containsNoGivenChars");
            }
            if (a instanceof Array === false) {
                throw new Error("Invalid argument to table.containsNoGivenChars");
            }
            var charset = [];
            var charstr = "";
            var chararray = a;
            var len = chararray.length;
            var result = false;
            for (var i = 0; i < len; i++) {
                charset[i] = chararray[i];
                if (charset[i] == "") return false;
            }
            charstr = charset.join("");
            charstr = "[" + kony.string.escapeRegExp(charstr) + "]";
            var regexp = new RegExp(charstr, "g");
            result = regexp.test(s);
            if (result === false) {
                return true;
            } else {
                return false;
            }
        },
        /** This API verifies if the input string is a valid email address and returns a boolean value.*/
        isValidEmail: function(s) {
            if (arguments.length === 0) throw new Error("string.isValidEmail needs atleast 1 argument");
            var value = s;
            if (typeof(value) !== "string") return false;
            //(99.9% syntactic accuracy)
            var emailPattern = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
            if ((value.length - value.lastIndexOf('.')) < 3) {
                return false;
            }
            return emailPattern.test(value);
        },
        escapeRegExp: function(text) {
            return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
    }
    /**@Deprecated This library provides generic functions for table manipulation. It provides all its functions inside the table.

    Most functions in the Table library assume that the table represents an array or a list. For these functions, when we talk about the "length" of a table we mean the result of the length operator.

    Note: This library is also available in JavaScript under the namespace kony.table. This is only for maintaining the backward compatibility for the application converted from Lua to JavaScript.*/
kony.table = {
        /**@Deprecated This API extracts all the elements of a table and concatenates the elements to form a string. A separator can be specified which can be placed between concatenated elements.*/
        concat: function(inputtable, separator, startposition, endposition) {
            var isArgsError = false;
            var isInternalError = false;
            var result = null;
            if (!arguments[0] instanceof Object) isArgsError = true;
            if (!isArgsError) {
                var len = arguments[0].length;
                var begin = 0,
                    end = len,
                    sep = ""; //4901
                var numArgs = arguments.length > 4 ? 4 : (arguments.length - 1);
                switch (arguments.length) {
                    case 4:
                        arguments[3] -= 0;
                        if (isNaN(arguments[3])) {
                            isArgsError = true;
                        }
                        end = arguments[3];
                    case 3:
                        arguments[2] -= 0;
                        if (isNaN(arguments[2]) || arguments[2] < 0) {
                            isArgsError = true;
                        }
                        begin = arguments[2];
                    case 2:
                        sep = arguments[1];
                    default:
                        break;
                }
                if (len == 0) return kony.table.returnResult("", isArgsError, isInternalError);
                if (isArgsError) return kony.table.returnResult(result, isArgsError, isInternalError);
                if (begin > end) {
                    //isArgsError = true; // return empty string -- lua std
                    return kony.table.returnResult("", isArgsError, isInternalError);
                } else
                if (end > len) {
                    isArgsError = true;
                } else
                if (!isArgsError) {
                    result = "";
                    try {
                        for (var i = begin; i < end; i++) {
                            if (arguments[0][i] == null || arguments[0][i] instanceof Object) return kony.table.returnResult(null, true, isInternalError);
                            result += arguments[0][i].toString() + sep;
                        }
                        result += arguments[0][i].toString();
                    } catch (e) {
                        isInternalError = true;
                    }
                }
            }
            return kony.table.returnResult(result, isArgsError, isInternalError);
        },
        /*maxn: function(args) {
            if (0 === arguments.length) {
                throw new Error("table.maxn needs atleast one argument");
            }
            
            if (args[0] instanceof LuaTable === false) {
                throw new Error("Invalid argument to table.maxn");
            }
            
            var maxIndex = args[0].arrayContainer.length - 1;
            for (var obj in args[0].hashContainer) {
                var key = args[0].hashContainer[obj].key;
                if (args[0].hashContainer[obj].value !== null &&
                typeof(key) === "number" &&
                maxIndex < key) {
                    maxIndex = key;
                }
            }	    
            return maxIndex;
        },*/
        /**@Deprecated This API inserts a specified value into the given table in the list part. If a position is specified, the value is inserted before the element currently at that position. If no position is specified, the value is appended to the end of the table. If the specified position is not within the range of the list part of the table, the new element is added to the hash part of the table.*/
        insert: function(inputtable, position, value) {
            var isArgsError = false;
            var isInternalError = false;
            var result = null;
            if (arguments.length < 2 || !(arguments[0] instanceof Object)) {
                isArgsError = true;
            }
            if (!isArgsError) {
                var pos, newItem;
                // var arr = arguments[0];	
                if (arguments.length > 2) {
                    pos = arguments[1];
                    if (typeof pos == "string" || isNaN(pos)) {
                        return kony.table.returnResult(true, isInternalError);
                    }
                    newItem = arguments[2];
                } else {
                    pos = arguments[0].length;
                    newItem = arguments[1];
                    /*if(args[1] == null) // don't insert nil at the end of table -- lua std 
                    	return kony.table.returnResult(args[0], isArgsError, isInternalError);*/
                }
                try {
                    if (typeof pos == "string" || pos >= arguments[0].length || pos <= 0) {
                        if (pos == 0) {
                            //DEF 3809
                            arguments[0].splice(pos, 0, newItem);
                            //arguments[0][pos] = newItem;
                        } else {
                            arguments[0][pos] = newItem;
                        }
                    } else {
                        /*   var pre = arguments[0].slice(0, pos);
                           var post = arguments[0].slice(pos);
                           pre.push(newItem);
                           arguments[0] = pre.concat(post);*/
                        arguments[0].splice(pos, 0, newItem);
                    }
                    //arguments[0] = arr;		
                } catch (e) {
                    isInternalError = true;
                }
            }
            return kony.table.returnResult(isArgsError, isInternalError);
        },
        /**@Deprecated This API removes an element from the list part of the table. If a position is specified, the element at the position is removed. If no position is specified, the last element in the table is removed. The removed element is returned. This API operates only on the list part of the table.*/
        remove: function(inputtable, position) {
            var isArgsError = false;
            var result = null;
            if (0 === arguments.length || !(arguments[0] instanceof Array)) {
                isArgsError = true;
            }
            if (!isArgsError) {
                var pos = arguments[0].length - 1;
                if (pos >= 0) {
                    if (arguments.length > 1 && arguments[1] != null) {
                        arguments[1] -= 0;
                        if (isNaN(arguments[1]) || arguments[1] > pos || arguments[1] < 0) {
                            isArgsError = true;
                            return kony.table.returnResult(result, isArgsError, false);
                        }
                        if (arguments[1] < pos && arguments[1] >= 0) {
                            pos = arguments[1] //-1;//5.0 Decremented
                        }
                    }
                    result = arguments[0].splice(pos, 1);
                    result = result[0];
                    /*for(var i=pos;i > 0;i--){
                    	result = args[0].arrayContainer.splice(i, 1);
                    	if(result[0] == null && i == args[0].length()+1)
                    		continue;
                    	else
                    		break;				
                    }*/
                } else return kony.table.returnResult(null, isArgsError, false);
            }
            return kony.table.returnResult(result, isArgsError, false);
        },
        /**@Deprecated This API sorts the elements of the input table and returns the modified table. This API sorts only the list part of the table and the hash part of the table is ignored.*/
        sort: function(inputtable, sortkey, comparisonfunction) {
            var isArgsError = false;
            var isInternalError = false;
            var result = null;
            var comparator = null;
            if (0 === arguments.length || !(arguments[0] instanceof Array)) {
                isArgsError = true;
            }
            if (typeof(arguments[1]) == "function") {
                comparator = arguments[1];
            } else
            if (typeof(arguments[2]) == "function") {
                comparator = arguments[2];
            }
            if (!isArgsError) {
                var len = arguments[0].length;
                var pre = arguments[0];
                if (arguments[0].length < 2) {
                    //Can't do aything. Need more than one element to sort
                    return kony.table.returnResult(inputtable, false, false);
                }
                try {
                    for (var i = 0; i < len; i++) { //5.0 Decremented i
                        var elemType = typeof(arguments[0][1]);
                        if (arguments[0][i] == null || typeof(arguments[0][i]) != elemType) {
                            return kony.table.returnResult(true, isInternalError);
                        }
                    }
                    // pre = arguments[0].slice(1);
                    //var zeroth = arguments[0].shift();
                    //This is to splice the array to the length to which it has to be sorted
                    if (arguments[1] !== null && !isNaN(arguments[1])) pre.splice(arguments[1], pre.slice(arguments[1], pre.length).length);
                    if (comparator) {
                        pre.sort(function(a, b) {
                            var retVals = comparator(a, b);
                            return (retVals ? -1 : 1);
                        });
                    } else
                    if (typeof arguments[1] == "string") {
                        comparator = arguments[1];
                        pre.sort(function(a, b) {
                            if (a[comparator] != null && typeof a[comparator] == typeof b[comparator] && typeof a[comparator] == "string") {
                                var nameA = a[comparator].toLowerCase(),
                                    nameB = b[comparator].toLowerCase()
                                if (nameA < nameB) //sort string ascending
                                    return -1
                                if (nameA > nameB) return 1
                                return 0 //default return value (no sorting)				
                            } else {
                                return a[comparator] - b[comparator];
                            }
                        });
                    } else {
                        pre.sort(function(a, b) {
                            if (typeof a == "string") {
                                var A = a.toLowerCase();
                                var B = b.toLowerCase();
                                if (A < B) {
                                    return -1;
                                } else
                                if (A > B) {
                                    return 1;
                                } else {
                                    return 0;
                                }
                            } else return a - b;
                        });
                    }
                    // pre.unshift(zeroth);
                    // pre = pre.concat(arguments[0]);
                } catch (e) {
                    isInternalError = true;
                    pre = null;
                }
            }
            if (!isArgsError && !isInternalError) return kony.table.returnResult(pre, isArgsError, isInternalError);
            else return kony.table.returnResult(true, isInternalError);
        },
        /**@Deprecated This API filters the given table based on the provided criteria and returns a set of values that match the given criteria.*/
        filter: function(srctable, mapfunc) {
            var isArgsError = false;
            var isInternalError = false;
            var tgttable;
            if (arguments.length < 2 || !(srctable instanceof Object) || !(typeof(mapfunc) == "function")) {
                isArgsError = true;
            }
            if (!isArgsError) {
                var key, value, retVals;
                if ((srctable instanceof Array) && mapfunc) {
                    try {
                        tgttable = [];
                        for (var i = 0; i < srctable.length; i++) { //5.0 Decremented i
                            value = srctable[i];
                            if (value instanceof Object) {
                                /*var innerLen = value.length();
                                 var innerValue;
                                 var count = 0;
                                 for (var k = 0; k < innerLen; k++) {
                                 innerValue = value.arrayContainer[k + 1];
                                 retVals = executeClosure(mapfunc, [k + 1, innerValue]);
                                 if (retVals[0] == true)
                                 count++;
                                 }
                                 if (count == innerLen)
                                 tgttable.arrayContainer.push(value);*/
                                return kony.table.returnResult(null, true, isInternalError);
                            } else {
                                if (value != null) retVals = mapfunc(i, value);
                                if (retVals === true) tgttable.push(value);
                                retVals = false;
                            }
                        }
                    } catch (e) {
                        isArgsError = true;
                    }
                } else
                if (srctable && mapfunc) {
                    tgttable = new Object();
                    try {
                        for (var j in srctable) {
                            key = j
                            value = srctable[j];
                            if (value != null) retVals = mapfunc(j, value);
                            if (retVals === true) {
                                tgttable[key] = value;
                            }
                            retVals = false;
                        }
                    } catch (e) {
                        isArgsError = true;
                    }
                }
            }
            if (isArgsError || isInternalError) tgttable = null;
            return kony.table.returnResult(tgttable, isArgsError, isInternalError);
        },
        /**@Deprecated This API performs the given action on the input table and returns the modified table.*/
        map: function(srctable, mapfunc) {
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length < 2 || (srctable instanceof Object === false) || !(typeof(mapfunc) == "function")) {
                isArgsError = true;
            }
            if (!isArgsError) {
                try {
                    var key, value, retVals;
                    if (srctable instanceof Array && mapfunc) {
                        var len = srctable.length;
                        for (var i = 0; i < len; i++) { //5.0 Decremented i
                            if (srctable[i] instanceof Array || srctable[i] == null) {
                                return kony.table.returnResult(true, isInternalError);
                            }
                        }
                        try {
                            for (var i = 0; i < len; i++) { //5.0 Decremented i
                                value = srctable[i];
                                retVals = mapfunc(i, value);
                                if (retVals !== false) {
                                    key = retVals[0];
                                    value = retVals[1];
                                    srctable[key] = value;
                                    retVals = false;
                                } else return kony.table.returnResult(true, isInternalError);
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    } else
                    if (srctable && mapfunc) {
                        try {
                            for (var j in srctable) {
                                key = j;
                                value = srctable[key];
                                retVals = mapfunc(key, value);
                                if (retVals !== false) {
                                    key = retVals[0];
                                    value = retVals[1];
                                    srctable[key] = value;
                                    retVals = false;
                                } else return kony.table.returnResult(true, isInternalError);
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    }
                } catch (e) {
                    isInternalError = true;
                }
            }
            //srctable added for JSPFQA5653
            return kony.table.returnResult(srctable, isArgsError, isInternalError);
        },
        /**@Deprecated This API performs the given action on the input table and returns a new table.*/
        mapNew: function(srctable, mapfunc) {
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length < 2 || (srctable instanceof Object === false) || !(typeof(mapfunc) == "function")) {
                isArgsError = true;
            }
            if (srctable == null) return kony.table.returnResult(null, isArgsError, isInternalError);
            try {
                var tgttable = null;
                var key, value, retVals;
                if (!isArgsError) {
                    if (srctable instanceof Array && mapfunc) {
                        var len = srctable.length;
                        for (var i = 0; i < len; i++) { //5.0 Decremented i
                            if (srctable[i] instanceof Object || srctable[i] == null) {
                                return kony.table.returnResult(null, true, isInternalError);
                            }
                        }
                        try {
                            tgttable = [];
                            for (var i = 0; i < len; i++) { //5.0 Decremented i
                                value = srctable[i];
                                retVals = mapfunc(i, value);
                                key = retVals[0];
                                value = retVals[1];
                                tgttable[key] = value;
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    } else
                    if (srctable && mapfunc) {
                        try {
                            tgttable = new Object();
                            for (var j in srctable) {
                                key = j;
                                value = srctable[key];
                                retVals = mapfunc(key, value);
                                if (retVals !== false) {
                                    key = retVals[0];
                                    value = retVals[1];
                                    tgttable[key] = value;
                                    retVals = false;
                                } else return kony.table.returnResult(true, isInternalError);
                            }
                        } catch (e) {
                            isArgsError = true;
                        }
                    }
                }
            } catch (e) {
                isInternalError = true;
            }
            if (isArgsError || isInternalError) tgttable = null;
            return kony.table.returnResult(tgttable, isArgsError, isInternalError);
        },
        /**@Deprecated This API searches the given input table and returns the value at the specified key; if the key is a number, this API returns the value at the index.*/
        get: function(srctable, key) {
            var isArgsError = false;
            var isInternalError = false;
            var invalidKey = false;
            var result = null;
            //TODO:Error Check
            if (arguments.length < 2 || srctable instanceof Object === false || key == null) {
                isArgsError = true;
                return kony.table.returnResult(result, isArgsError, isInternalError);
            }
            try {
                if (key in srctable) {
                    result = srctable[key];
                } else invalidKey = true;
            } catch (e) {
                isInternalError = true;
            }
            return kony.table.returnResult(result, isArgsError, isInternalError, invalidKey);
        },
        /**@Deprecated Tests if the specified key is part of the table.*/
        contains: function(srctable, key) {
            var isArgsError = false;
            var isInternalError = false;
            var result = false;
            if (arguments.length < 2 || srctable instanceof Object === false || key == null) {
                return kony.table.returnResult(result, true, isInternalError);
            }
            try {
                if (key in srctable) result = true;
            } catch (e) {
                isInternalError = true;
            }
            return kony.table.returnResult(result, isArgsError, isInternalError);
        },
        /**@Deprecated This API appends the content of the source table to the target table and returns the modified target table.*/
        append: function(tgttable, srctable) {
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length != 2 || !(tgttable instanceof Object) || !(srctable instanceof Object)) {
                isArgsError = true;
                return kony.table.returnResult(null, isArgsError, isInternalError);
            }
            try {
                if (tgttable.length && srctable.length) {
                    ////  var srcarray = srctable.slice(1);   //4906
                    for (var i = 0; i < srctable.length; i++) {
                        tgttable.push(srctable[i]);
                    }
                } else {
                    for (var j in srctable) {
                        tgttable[j] = srctable[j];
                    }
                }
            } catch (e) {
                isInternalError = true;
            }
            return kony.table.returnResult(tgttable, isArgsError, isInternalError);
        },
        /**@Deprecated This API removes data from the table represented by the table id.*/
        removeAll: function(srctable) {
            if (arguments.length < 1) {
                throw new Error("table.removeAll needs atleast 1 argument");
            }
            //TODO:Proper error function to distinguish between table (object) & other types
            if (typeof(srctable) != "object") {
                throw new Error("Invalid  arguments to table.removeAll");
            }
            if (srctable.length) srctable.length = 0;
            else {
                for (var key in srctable) {
                    delete srctable[key];
                }
            }
            return;
        },
        /**@Deprecated unpack

This API returns the elements from the given table. This function is equivalent to

return list[i], list[i+1], .... list[j].*/
        unpack: function(t1) {
            if (0 === arguments.length) {
                throw new Error("unpack needs atleast one argument");
            }
            if (t1 instanceof Object === false) {
                throw new Error("Invalid first argument to unpack");
            }
            var numArgs = arguments.length > 3 ? 3 : arguments.length;
            var maxIndex = arguments[0].length;
            var beginIndex = 0 /*5.0 Decremented beginIndex*/ ,
                endIndex = maxIndex;
            switch (numArgs) {
                case 3:
                    arguments[2] -= 0;
                    if (isNaN(arguments[2])) {
                        throw new Error("Invalid argument to unpack");
                    }
                    endIndex = arguments[2];
                case 2:
                    arguments[1] -= 0;
                    if (isNaN(arguments[1])) {
                        throw new Error("Invalid argument to unpack");
                    }
                    beginIndex = arguments[1];
                default:
                    break;
            }
            if (beginIndex > endIndex) {
                return [""];
            } else {
                var retVals = ""; //[];		//4907		
                for (var i = beginIndex; i < endIndex; i++) {
                    //retVals.push(arguments[0][i]);
                    if (i == 0) {
                        retVals = arguments[0][i];
                    } else {
                        retVals = retVals + " " + arguments[0][i];
                    }
                }
                return retVals;
            }
        },
        // local myjson = '{ "name": "Shasank", "id": "417" }'
        // table.parsejson(myjson)
        /*parsejson: function(args){
	
            if (arguments.length < 1) {
                throw new Error("table.parsejson needs atleast 1 argument");
            }
            
            var jsObj = args[0].evalJSON();
            
            try {
                var tgttable = kony.utils.json2LuaTable(jsObj);
            } 
            catch (e) {
                throw new Error("table.parsejson - SyntaxError: Badly formed JSON string");
            }
            
            return tgttable;
        },*/
        /*keys: function(args){
	
            if (arguments.length < 1) {
                throw new Error("table.keys needs atleast 1 argument");
            }
            
            if (args[0] instanceof LuaTable === false) {
                throw new Error("Invalid  arguments to table.keys");
            }
            
            var srctable = args[0];
            
            if (srctable.hashKeys.length) {
            
                var innerlen = srctable.hashKeys.length;
                var key;
                var keysarray = [];
                for (var j = 0; j < innerlen; j++) {
                    key = srctable.hashKeys[j];
                    keysarray.push(key);
                }
                
                return keysarray;
            }
        },*/
        returnResult: function() {
            var errorNo = null;
            var errorMsg = null;
            var isArgsError = false;
            var isInternalError = false;
            if (arguments.length >= 3) {
                var retArray = arguments[0];
                isArgsError = arguments[1];
                isInternalError = arguments[2];
                var invalidKey = arguments[3];
            } else {
                isArgsError = arguments[0];
                isInternalError = arguments[1];
            }
            if (isArgsError) {
                errorNo = 100;
                errorMsg = "INVALID ARGUMENTS";
            } else if (isInternalError) {
                errorNo = 101;
                errorMsg = "INTERNAL ERROR";
            } else if (invalidKey) {
                errorNo = 0;
                errorMsg = "INVALID KEY";
            }
            if (arguments.length >= 3)
            //return ([retArray, errorNo, errorMsg]);
                return retArray;
            else if (arguments.length == 2 && (isArgsError || isInternalError)) return ([errorNo, errorMsg]);
            else return;
        }
    }
    /**@Deprecated This API returns the current time as a string in hh:mm:ss format. The time is represented in 12 hour format.*/
kony.os.time = function() {
    var timeStr = (new Date()).toTimeString();
    return timeStr.slice(0, timeStr.indexOf(" "));
};
/**@Deprecated This API returns the number of seconds between the first input parameter (t1) to the second input parameter (t2).*/
kony.os.diffDateTime = function(time1, time2) {
    if (typeof(time1) !== "string" || typeof(time2) !== "string") {
        throw new Error("Invalid argument(s) to os.diffDateTime");
    }
    var t1 = time1.split(":");
    t1[2] = t1[2] - 0;
    var t2 = time2.split(":");
    t2[2] = t2[2] - 0;
    var one_day = 86400;
    var t1sec = t1[0] * 3600 + t1[1] * 60 + t1[2];
    var t2sec = t2[0] * 3600 + t2[1] * 60 + t2[2];
    return (t1sec > one_day || t2sec > one_day) ? null : t1sec - t2sec;
};
/**@Deprecated This API formats the current date to the given format.*/
kony.os.date = function() {
    var result;
    var currentDate = new Date();
    if (0 === arguments.length) {
        var timeStr = currentDate.toTimeString();
        result = kony.os.padZero(currentDate.getMonth() + 1) + "/" + kony.os.padZero(currentDate.getDate()) + "/" + kony.os.padZero(currentDate.getFullYear() % 100) + " " + timeStr.slice(0, timeStr.indexOf(" "));
        return result;
    } else if (typeof(arguments[0]) == "string") {
        if (arguments[0].toLowerCase().indexOf("dd") != -1) {
            return kony.os.formatdate(arguments[0], currentDate);
        } else {
            var utc = arguments[0].charAt(0) === '!';
            var index = utc ? 1 : 0;
            if ('*' === arguments[0].charAt(index) && 't' === arguments[0].charAt(index + 1)) {
                var day = utc ? currentDate.getUTCDate() : currentDate.getDate();
                var mon = (utc ? currentDate.getUTCMonth() : currentDate.getMonth()) + 1;
                var year = utc ? currentDate.getUTCFullYear() : currentDate.getFullYear();
                result = new Object();
                result["year"] = year;
                result["month"] = mon;
                result["day"] = day;
                result["hour"] = utc ? currentDate.getUTCHours() : currentDate.getHours();
                result["min"] = utc ? currentDate.getUTCMinutes() : currentDate.getMinutes();
                result["sec"] = utc ? currentDate.getUTCSeconds() : currentDate.getSeconds();
                result["wday"] = utc ? currentDate.getUTCDay() : currentDate.getDay() + 1;
                result["yday"] = kony.os.getDayOfYear(day, mon, year);
                result["isdst"] = utc ? false : kony.os.checkForDst();
                return result;
            } else return null;
        }
    } else return null;
};
/**This API allows you to convert the given number to represent currency. At present, only USA currency is supported.*/
kony.os.toCurrency = function(arg) {
    arg -= 0;
    if (isNaN(arg)) {
        throw new Error("Invalid argument to os.toCurrency");
    }
    if (arg < 0) arg *= -1;
    var str = arg.toFixed(3);
    str = str.substr(0, str.length - 1);
    var outStr = "";
    for (var i = 0; i < str.length - 4; i++) {
        outStr += str.charAt(i);
        if ((str.length - i - 1) % 3 === 0) outStr += ",";
    }
    for (; i < str.length; i++) {
        outStr += str.charAt(i);
    }
    return "$" + outStr;
};
/**This API converts the argument to a number. If the argument is already a number or a string convertible to a number, then the API returns this number; otherwise, it returns null for JavaScript and nil for Lua.*/
kony.os.toNumber = function(arg) {
    if (arguments.length != 1) {
        throw new Error("Invalid argument to os.toNumber");
    }
    if (typeof(arg) === "number") {
        return arg;
    } else if (typeof(arg) === "string") {
        var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
        if (str === '') {
            return null;
        } else {
            var num = str - 0;
            return (isNaN(num) ? null : num);
        }
    } else {
        return null;
    }
};
/**@Deprecated This API returns the difference in dates or compares two dates for equality.*/
//os.compareDates(date1,date2,"format") - dd,mm,yyyy,yy 
kony.os.compareDates = function(d1, d2, frmt) {
    if (d1 == null || d2 == null || frmt == null || !kony.os.isvaliddate(d1, frmt) || !kony.os.isvaliddate(d2, frmt)) return null
    var date1 = kony.os.getDate(d1, frmt);
    var date2 = kony.os.getDate(d2, frmt);
    var oneday = 24 * 60 * 60 * 1000;
    return parseInt((date1.getTime() - date2.getTime()) / oneday);
};
/**@Deprecated This API adds or subtracts units (days, hours, minutes, month, or years) to the given date.*/
//os.addToDate(date1,format,units,count) - units : days,hours,minutes,month,years
// Format"dd/mm/yyyy" or "mm/dd/yyyy" or mm/dd/yy
kony.os.addToDate = function(d1, frmt, unt, cnt) {
    if (d1 == null || frmt == null || unt == null || cnt == null) {
        return null;
    }
    var inputDate = d1;
    var fmt = frmt;
    var unit = unt;
    var count = cnt;
    var dateParts = inputDate.split("/");
    if (!kony.os.isvaliddate(inputDate, fmt)) return null;
    var dateObj = kony.os.getDate(inputDate, fmt);
    if (dateObj) {
        switch (unit) {
            case "years":
                dateObj.setFullYear(dateObj.getFullYear() + count);
                break;
            case "months":
                dateObj.setMonth(dateObj.getMonth() + count);
                break;
            case "days":
                dateObj.setDate(dateObj.getDate() + count);
                break;
            case "hours":
                dateObj.setHours(dateObj.getHours() + count);
                break;
            case "minutes":
                dateObj.setMinutes(dateObj.getMinutes() + count);
                break;
            default:
                break;
        }
        if (kony.os.isLeapYear([d1, fmt]) && dateObj.getMonth() >= 1 && (unit == "years" || (unit == "months" && (count == -12 || count == 12)))) dateObj.setDate(dateObj.getDate() - 1);
        return kony.os.formatdate(fmt, dateObj);
    }
    return null;
};
/**@Deprecated This API checks if the input year is a leap year.*/
//os.isLeapYear(yyyy) 
kony.os.isLeapYear = function(d1, frmt) {
    var year;
    var date = new Date(); //Take the current year;
    year = date.getFullYear();
    if (typeof(d1) == "string" && typeof(frmt) == "string") {
        if (!kony.os.isvaliddate(d1, frmt)) return false;
        var yearPart = d1.split("/")[2];
        year = (yearPart.length == 2) ? parseInt(date.getFullYear().toString().substr(0, 2) + yearPart) : parseInt(yearPart);
    }
    if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
        return true;
    } else {
        return false;
    }
};
/**@Deprecated This API converts a given date string to the target format and returns the formatted date. Format will use the tokens dd,mm,yyyy to indicate day, month, and year respectively. The delimiter used between the tokens can be any character. For example, dd/mm/yyyy and (dd)(mm)(yyyy) are valid inputs.*/
//os.formatdate(inputdate[string],sourceformat[string],targetformat[string])
kony.os.formatDate = function(d1, sfrmt, tgtfrmt) {
    var year;
    if (d1 == null || sfrmt == null || tgtfrmt == null) {
        return null;
    } else if (typeof(d1) === "string" && typeof(sfrmt) === "string" && typeof(tgtfrmt) === "string") {
        var inputDate = d1
        var srcfmt = sfrmt;
        var targetfmt = tgtfrmt;
        var datePos = srcfmt.indexOf("dd");
        var monthPos = srcfmt.indexOf("mm");
        var yearPos = (srcfmt.indexOf("yyyy") != -1) ? srcfmt.indexOf("yyyy") : srcfmt.indexOf("yy");
        if ((srcfmt == "dd/mm/yyyy" && !kony.os.isvaliddate(inputDate, srcfmt)) || datePos == -1 || monthPos == -1 || yearPos == -1 || srcfmt.indexOf("ddd") != -1 || srcfmt.indexOf("mmm") != -1) {
            return null;
        }
        var dateStrSep = srcfmt.charAt(datePos - 1);
        var dateEndSep = srcfmt.charAt(datePos + 2);
        dateEndSep = (dateEndSep == "(") ? "" : dateEndSep;
        var monthStrSep = srcfmt.charAt(monthPos - 1);
        var monthEndSep = srcfmt.charAt(monthPos + 2);
        var yearStrSep = srcfmt.charAt(yearPos - 1);
        var yearEndSep = srcfmt.charAt(yearPos + 4);
        var startDateIndex = (dateStrSep == "") ? inputDate.indexOf(dateStrSep, datePos - 1) : inputDate.indexOf(dateStrSep, datePos - 2) + 1;
        var startMonthIndex = (monthStrSep == "") ? inputDate.indexOf(monthStrSep, monthPos - 1) : inputDate.indexOf(monthStrSep, monthPos - 2) + 1;
        var startYearIndex = (yearStrSep == "") ? inputDate.indexOf(yearStrSep, yearPos - 1) : ((inputDate.indexOf(yearStrSep, yearPos - 2) != -1) ? inputDate.indexOf(yearStrSep, yearPos - 2) + 1 : inputDate.indexOf(yearStrSep, yearPos - 4) + 1);
        var endDateIndex = (dateEndSep != "") ? inputDate.indexOf(dateEndSep, datePos) : inputDate.indexOf(dateEndSep, datePos + 2);
        var endMonthIndex = (monthEndSep != "") ? inputDate.indexOf(monthEndSep, monthPos) : inputDate.indexOf(monthEndSep, monthPos + 2);
        var endYearIndex = (yearEndSep != "") ? inputDate.indexOf(yearEndSep, yearPos) : inputDate.indexOf(yearEndSep, yearPos + 4);
        var dateVal = inputDate.substring(startDateIndex, endDateIndex);
        var monthVal = inputDate.substring(startMonthIndex, endMonthIndex);
        var yearVal = inputDate.substring(startYearIndex, endYearIndex);
        if ((yearVal.length == 2 && targetfmt.indexOf("yyyy") != -1)) var fullyr = new Date().getFullYear().toString().substr(0, 2) + yearVal;
        targetfmt = targetfmt.replace(/dd/, kony.os.padZero(parseInt(dateVal, 10)));
        targetfmt = targetfmt.replace(/mm/, kony.os.padZero(parseInt(monthVal, 10)));
        targetfmt = targetfmt.replace(/(yyyy|yy)/, fullyr ? fullyr : ((targetfmt.indexOf("yyyy") == -1 && yearVal.length == 4) ? yearVal.substr(2, 2) : yearVal));
        return targetfmt;
    }
    return null;
};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
//os.isvaliddate(date,format) 
kony.os.isValidDate = function(date, frmt) {
    return (arguments.length != 2 || date == null || frmt == null) ? false : kony.os.isvaliddate(date, frmt);
};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
//os.dateComponents(date, format);
//Formats supported:  (dd/mm/yyyy , mm/dd/yyyy, dd/mm/yy , mm/dd/yy) 
kony.os.dateComponents = function(date, frmt) {
    var result;
    var dateObject;
    if (arguments.length == 0) {
        dateObject = new Date();
    } else if (date != null && frmt != null) {
        if (!kony.os.isvaliddate(date, frmt)) return null;
        dateObject = kony.os.getDate(date, frmt);
        var yearfmt = frmt.split("/")[2];
    }
    if (dateObject) {
        var day = dateObject.getDate();
        var mon = dateObject.getMonth() + 1;
        var year = (yearfmt && yearfmt.length == 2) ? parseInt(dateObject.getFullYear().toString().substr(2, 2)) : dateObject.getFullYear();
        result = new Object();
        result["year"] = year;
        result["month"] = mon;
        result["day"] = day;
        result["hour"] = dateObject.getHours();
        result["min"] = dateObject.getMinutes();
        result["sec"] = dateObject.getSeconds();
        result["wday"] = dateObject.getDay() + 1;
        result["yday"] = kony.os.getDayOfYear(day, mon, year);
        result["isdst"] = kony.os.checkForDst();
        return result;
    } else return null;
};
kony.os.padZero = function(num) {
    return num < 10 ? ("0" + num) : num;
};
/**@Deprecated This API converts a given date string to the target format and returns the formatted date. Format will use the tokens dd,mm,yyyy to indicate day, month, and year respectively. The delimiter used between the tokens can be any character. For example, dd/mm/yyyy and (dd)(mm)(yyyy) are valid inputs.*/
kony.os.formatdate = function(fmt, dateObj) {
    fmt = fmt.toLowerCase();
    fmt = fmt.replace(/dd/, kony.os.padZero(dateObj.getDate()));
    fmt = fmt.replace(/mm/, kony.os.padZero(dateObj.getMonth() + 1));
    return fmt.replace(/(yyyy|yy)/, fmt.indexOf("yyyy") == -1 ? dateObj.getFullYear().toString().substr(2, 2) : dateObj.getFullYear());
};
/**@Deprecated This API returns the various date components of a specified date (in a specified format) or the current system date.*/
//Valid formats mm/dd/yy and mm/dd/yyyy and dd/mm/yyyy		
kony.os.isvaliddate = function(dtStr, format) {
    var minYear = 1900;
    var maxYear = 2100;
    var dtCh = "/";
    var daysInMonth = kony.os.daysArray(12);
    var pos1 = dtStr.indexOf(dtCh)
    var pos2 = dtStr.indexOf(dtCh, pos1 + 1)
    var dateFormat = format || "dd/mm/yyyy";
    if (dateFormat == "dd/mm/yyyy" || dateFormat == "dd/mm/yy") {
        var strDay = dtStr.substring(0, pos1)
        var strMonth = dtStr.substring(pos1 + 1, pos2)
    } else
    if (dateFormat == "mm/dd/yy" || dateFormat == "mm/dd/yyyy") {
        var strDay = dtStr.substring(pos1 + 1, pos2);
        var strMonth = dtStr.substring(0, pos1);
    } else return false;
    var strYear = dtStr.substring(pos2 + 1);
    /*if(strYear.length == 2 && dateFormat.indexOf("yyyy") != -1)				
     return false;*/
    var today = new Date();
    strYr = strYear
    if (strDay.charAt(0) == "0" && strDay.length > 1) strDay = strDay.substring(1)
    if (strMonth.charAt(0) == "0" && strMonth.length > 1) strMonth = strMonth.substring(1)
    if (strYr.length == 2) {
        strYr = (today.getFullYear() + "").substr(0, 2) + strYr;
    }
    for (var i = 1; i <= 3; i++) {
        if (strYr.charAt(0) == "0" && strYr.length > 1) strYr = strYr.substring(1)
    }
    month = parseInt(strMonth)
    day = parseInt(strDay)
    year = parseInt(strYr)
    if (!kony.os.isInteger(strMonth) || !kony.os.isInteger(strDay) || !kony.os.isInteger(strYear) || strMonth.length < 1 || month < 1 || month > 12 || strDay.length < 1 || day < 1 || day > 31 || (month == 2 && day > kony.os.daysInFebruary(year)) || day > daysInMonth[month] || strYr.length != 4 || year == 0 || year < minYear || year > maxYear) {
        //alert("invalid date");
        return false
    }
    return true
};
kony.os.daysArray = function(n) {
    for (var i = 1; i <= n; i++) {
        this[i] = 31
        if (i == 4 || i == 6 || i == 9 || i == 11) {
            this[i] = 30
        }
        if (i == 2) {
            this[i] = 29
        }
    }
    return this
};
kony.os.daysInFebruary = function(year) {
    // February has 29 days in any year evenly divisible by four,
    // EXCEPT for centurial years which are not also divisible by 400.
    return (((year % 4 == 0) && ((!(year % 100 == 0)) || (year % 400 == 0))) ? 29 : 28);
};
kony.os.isInteger = function(s) {
    var i;
    for (i = 0; i < s.length; i++) {
        // Check that current character is number.
        var c = s.charAt(i);
        if (((c < "0") || (c > "9"))) return false;
    }
    // All characters are numbers.
    return true;
};
kony.os.getDate = function(date, format) {
    var dateObj;
    if (typeof date === "string" && typeof format === "string") {
        var dateParts = date.split("/");
        var yr = new Date().getFullYear().toString().substr(0, 2);
        if (format.indexOf("yyyy") == -1 || dateParts[2].length == 2) dateParts[2] = yr + dateParts[2];
        if (format == "mm/dd/yyyy" || format == "mm/dd/yy") dateObj = new Date(dateParts[0] + "/" + dateParts[1] + "/" + dateParts[2]);
        else dateObj = new Date(dateParts[1] + "/" + dateParts[0] + "/" + dateParts[2]);
        return dateObj;
    }
};
kony.os.getDayOfYear = function(day, month, year) {
    var i, j;
    var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    if (0 === year % 4) {
        days[1]++;
    }
    for (i = 1, j = 0; i < month; j += days[i - 1], i++);
    return j + day;
};
kony.os.checkForDst = function() {
    var rightNow = new Date();
    var jan1 = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
    var temp = jan1.toGMTString();
    var jan2 = new Date(temp.substring(0, temp.lastIndexOf(" ") - 1));
    var std_time_offset = (jan1 - jan2) / (1000 * 60 * 60);
    var june1 = new Date(rightNow.getFullYear(), 6, 1, 0, 0, 0, 0);
    temp = june1.toGMTString();
    var june2 = new Date(temp.substring(0, temp.lastIndexOf(" ") - 1));
    var daylight_time_offset = (june1 - june2) / (1000 * 60 * 60);
    var dst;
    if (std_time_offset == daylight_time_offset) {
        //dst = "0"; // daylight savings time is NOT observed
        return false;
    } else {
        //dst = "1"; // daylight savings time is observed
        return true;
    }
};
